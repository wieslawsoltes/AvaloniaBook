\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Avalonia Book}
\end{center}
\vspace*{\fill}
\clearpage

\setcounter{tocdepth}{3}
\tableofcontents
\clearpage

\phantomsection
\addcontentsline{toc}{section}{Part I — Foundations you can’t skip}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part I — Foundations you can’t skip}
\end{center}
\vspace*{\fill}
\clearpage

\subsection{1. Welcome to Avalonia and
MVVM}\label{welcome-to-avalonia-and-mvvm}

Goal - Understand what Avalonia is today, how it has grown, and where it
is heading. - Learn the roles of C\#, XAML, and MVVM (with their core
building blocks) inside an Avalonia app. - Map Avalonia's layered
architecture so you can navigate the source confidently. - Compare
Avalonia with WPF, WinUI, .NET MAUI, and Uno to make an informed
platform choice. - Follow the journey from \texttt{AppBuilder.Configure}
to the first window, and know how to inspect it in the samples.

Why this matters - Picking a UI framework is a strategic decision.
Knowing Avalonia's history, roadmap, and governance helps you judge its
momentum. - Understanding the framework layers and MVVM primitives
prevents ``magic'' and makes documentation, samples, and source code
less intimidating. - Being able to contrast Avalonia with sibling
frameworks keeps expectations realistic and helps you explain the choice
to teammates.

Avalonia in simple words - Avalonia is an open-source, cross-platform UI
framework. One code base targets Windows, macOS, Linux, Android, iOS,
and the browser (WebAssembly). - It brings a modern Fluent-inspired
theme, a deep control set, rich data binding, and tooling such as
DevTools and the XAML Previewer. - If you have WPF experience, Avalonia
feels familiar; if you are new, you get gradual guidance with MVVM,
XAML, and C\#.

A short history, governance, and roadmap - Origins (2013-2018): The
project began as a community effort to bring a modern, cross-platform
take on the WPF programming model. - Maturing releases (0.9-0.10):
Stabilised control set, styling, and platform backends while adding
mobile and browser support. - Avalonia 11 (2023): The 11.x line
introduced the Fluent 2 theme refresh, compiled bindings, a new
rendering backend, and long-term support. New minor updates land roughly
every 2-3 months with patch releases in between. - Governance:
AvaloniaUI is stewarded by a core team at Avalonia Solutions Ltd.~with
an active GitHub community. Development is fully open with public issue
tracking and roadmap discussions. - Roadmap themes: continuing Fluent
updates, performance and tooling investments, deeper designer
integration, and steady platform parity across desktop, mobile, and web.

How Avalonia is layered - \textbf{Avalonia.Base}: foundational
services--dependency properties (\texttt{AvaloniaProperty}), threading,
layout primitives, and rendering contracts. Source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base}{src/Avalonia.Base}.
- \textbf{Avalonia.Controls}: the control set, templated controls,
panels, windowing, and lifetimes. Source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls}{src/Avalonia.Controls}
with the \texttt{Application} class in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Application.cs}{Application.cs}.
- \textbf{Styling and themes}: styles, selectors, control themes, and
Fluent resources. Source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Styling}{src/Avalonia.Base/Styling}
and
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent}{src/Avalonia.Themes.Fluent}.
- \textbf{Markup}: XAML parsing, compiled XAML, and the runtime loader
used at startup. Source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Markup.Xaml}{src/Avalonia.Markup.Xaml}
with
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}{AvaloniaXamlLoader.cs}.
- \textbf{Platform backends}: per-OS integrations--for example
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Windows/Avalonia.Win32}{src/Windows/Avalonia.Win32},
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Native}{src/Avalonia.Native},
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Android/Avalonia.Android}{src/Android/Avalonia.Android},
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/iOS/Avalonia.iOS}{src/iOS/Avalonia.iOS},
and
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Browser/Avalonia.Browser}{src/Browser/Avalonia.Browser}.

Create your own architecture sketch showing \texttt{Avalonia.Base} at
the foundation, \texttt{Avalonia.Controls} and
\texttt{Avalonia.Markup.Xaml} layered above it, theme assemblies such as
\texttt{Avalonia.Themes.Fluent}, and platform backends surrounding the
stack. Keep the diagram handy as you read later chapters.

C\#, XAML, and MVVM--who does what - \textbf{C\#}: application startup
(\texttt{AppBuilder}), services, models, and view models. Logic lives in
strongly typed classes. - \textbf{XAML}: declarative UI
markup--controls, layout, styles, resources, and data templates. -
\textbf{MVVM}: separates responsibilities. The View (XAML) binds to a
ViewModel (C\#) which exposes Models and services. Tests target
ViewModels and models directly.

MVVM building blocks you should recognise early -
\texttt{INotifyPropertyChanged}: standard .NET interface. When a
ViewModel property raises \texttt{PropertyChanged}, bound controls
refresh. - \texttt{AvaloniaProperty}: Avalonia's dependency property
system (see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/AvaloniaProperty.cs}{AvaloniaProperty.cs})
powers styling, animation, and templated control state. - Binding
expressions: XAML bindings are parsed and applied via the XAML loader.
The runtime loader lives in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}{AvaloniaXamlLoader.cs}.
- Commands: typically \texttt{ICommand} implementations on the ViewModel
(plain or via libraries such as CommunityToolkit.Mvvm or ReactiveUI) so
buttons and menu items can invoke logic. - Data templates: define how
ViewModels render in lists and navigation. We will use them extensively
starting in Chapter 3.

The MVVM contract inside Avalonia - \texttt{AvaloniaObject} and
\texttt{StyledElement}: every control derives from
\texttt{AvaloniaObject}, gaining access to the dependency property
system. \texttt{StyledElement} adds styling, resources, and the logical
tree. These classes live in
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base}{\texttt{Avalonia.Base}}.
- \texttt{AvaloniaLocator}: a lightweight service locator
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/AvaloniaLocator.cs}{\texttt{AvaloniaLocator.cs}})
used by the framework to resolve services (logging, platform
implementations). You can register your own singletons during startup
when integrating DI containers. - Logical vs visual tree: controls
participate in a logical tree (resources, data context inheritance) and
a visual tree (rendered elements). Explore helpers such as
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/LogicalTree/LogicalTreeExtensions.cs}{\texttt{LogicalTreeExtensions}}
and the DevTools tree viewers to see both perspectives. -
\texttt{ViewLocator}: MVVM projects often map view models to views
dynamically. Avalonia ships a default \texttt{ViewLocator} in
\texttt{Avalonia.ReactiveUI}, and you can create your own service that
resolves XAML types by naming convention. - Service registration:
register singleton services with
\texttt{AvaloniaLocator.CurrentMutable.Bind\textless{}TService\textgreater{}().ToConstant(instance)}
during \texttt{AppBuilder} configuration so both code-behind and markup
extensions can retrieve them.

Data context flow across trees - Data contexts inherit through the
logical tree (e.g., \texttt{Window} → \texttt{Grid} →
\texttt{TextBlock}). Controls outside that tree, such as popups, will
not inherit automatically; explicitly assign contexts when necessary. -
The visual tree may contain additional elements introduced by control
templates. Bindings resolve by name through the logical tree first, then
resource lookups, so understanding both structures keeps bindings
predictable. - Use DevTools' Logical/Visual tabs to inspect the tree at
runtime and trace resource lookups or data-context changes.

From \texttt{AppBuilder.Configure} to the first window (annotated flow)
1. \textbf{Program entry point} creates a builder:
\texttt{BuildAvaloniaApp()} returns
\texttt{AppBuilder.Configure\textless{}App\textgreater{}()}. 2.
\textbf{Platform detection} (\texttt{UsePlatformDetect}) selects the
right backend (Win32, macOS, X11, Android, iOS, Browser). 3.
\textbf{Rendering setup} (\texttt{UseSkia}) chooses the rendering
pipeline--Skia by default. 4. \textbf{Logging and services}
(\texttt{LogToTrace}, custom DI) configure diagnostics. 5. \textbf{Start
a lifetime}: \texttt{StartWithClassicDesktopLifetime(args)} (desktop) or
\texttt{StartWithSingleViewLifetime} (mobile/browser). Lifetimes live
under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/ApplicationLifetimes}{ApplicationLifetimes}.
6. \textbf{\texttt{Application} initialises}:
\texttt{App.OnFrameworkInitializationCompleted} is called; this is where
you typically create and show the first \texttt{Window} or set
\texttt{MainView}. 7. \textbf{XAML loads}: \texttt{AvaloniaXamlLoader}
reads \texttt{App.axaml} and your window/user control XAML. 8.
\textbf{Bindings connect}: when the window's data context is set to a
ViewModel, bindings listen for \texttt{PropertyChanged} events and keep
UI and data in sync.

Tour the ControlCatalog (your guided sample) - Clone the repo (or open
the
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples/ControlCatalog}{ControlCatalog
sample}). - \texttt{ControlCatalog.Desktop} demonstrates desktop
controls, theming, and navigation. Inspect \texttt{App.axaml},
\texttt{MainWindow.axaml}, and their code-behind to see how
\texttt{AppBuilder} and MVVM connect. - Use DevTools (press \texttt{F12}
when running the sample) to inspect bindings, the visual tree, and live
styles. - Explore the repository mapping: the \texttt{Button} page in
the catalog points to code under
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Button.cs}{src/Avalonia.Controls/Button.cs};
style resources originate from Fluent theme XAML under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent/Controls}{src/Avalonia.Themes.Fluent/Controls}.

Why Avalonia instead of\ldots{} - \textbf{WPF} (Windows only): mature
desktop tooling and huge ecosystem, but no cross-platform story.
Avalonia keeps the mental model while expanding to macOS, Linux, mobile,
and web. - \textbf{WinUI 3} (Windows 10/11): modern Windows UI with
native Win32 packaging. Great for Windows-only solutions; Avalonia wins
when you must ship beyond Windows. - \textbf{.NET MAUI}: Microsoft's
cross-platform evolution of Xamarin.Forms focused on mobile-first UI.
Avalonia emphasises desktop parity, theming flexibility, and XAML
consistency across platforms. - \textbf{Uno Platform}: reuses WinUI XAML
across platforms via WebAssembly and native controls. Avalonia offers a
single rendering pipeline (Skia) for consistent visuals when you prefer
pixel-perfect fidelity over native look-and-feel.

Repository landmarks (bookmark these) - Framework source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src}{src} -
Samples:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples}{samples}
- Docs:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/docs}{docs} -
ControlCatalog entry point:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/samples/ControlCatalog/ControlCatalog.csproj}{ControlCatalog.csproj}

Check yourself - Can you describe how Avalonia evolved to its current
release cadence and governance model? - Can you name the key Avalonia
layers (Base, Controls, Markup, Themes, Platforms) and what each
provides? - Can you explain the MVVM building blocks
(\texttt{INotifyPropertyChanged}, \texttt{AvaloniaProperty}, bindings,
commands) in your own words? - Can you sketch the \texttt{AppBuilder}
startup steps that end with a \texttt{Window} or \texttt{MainView} being
shown? - Can you list one reason you might choose Avalonia over WPF,
WinUI, .NET MAUI, or Uno?

Practice and validation - Clone the Avalonia repository, build, and run
the desktop ControlCatalog. Set a breakpoint in
\texttt{Application.OnFrameworkInitializationCompleted} inside
\texttt{App.axaml.cs} to watch the lifetime hand-off. - While
ControlCatalog runs, open DevTools (F12) and track a ViewModel property
change (for example, toggle a CheckBox) in the binding diagnostics panel
to see \texttt{PropertyChanged} events flowing. - Inspect the source
jump-offs for \texttt{Application}
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Application.cs}{Application.cs}),
\texttt{AvaloniaProperty}
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/AvaloniaProperty.cs}{AvaloniaProperty.cs}),
and the XAML loader
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}{AvaloniaXamlLoader.cs}).
Note how the pieces you just read about appear in real code. - Pick
three controls from ControlCatalog (e.g., Button, SplitView,
ColorPicker) and map each to the assembly and namespace hosting its
implementation. Sketch the relationships in the architecture diagram you
created earlier so you can orient yourself quickly when diving into
source.

What's next - Next: \href{Chapter02.md}{Chapter 2}

\newpage

\subsection{2. Set up tools and build your first
project}\label{set-up-tools-and-build-your-first-project}

Goal - Install the .NET SDK, Avalonia templates, and an IDE on your
operating system of choice. - Configure optional workloads (Android,
iOS, WebAssembly) so you are ready for multi-target development. -
Create, build, and run a new Avalonia project from the command line and
from your IDE. - Understand the generated project structure and where
startup, resources, and build targets live. - Build the Avalonia
framework from source when you need nightly features or to debug the
platform.

Why this matters - A confident setup avoids painful environment issues
later when you add mobile or browser targets. - Knowing where the
generated files live prepares you for upcoming chapters on layout,
lifetimes, and MVVM. - Building the framework from source lets you test
bug fixes, follow development, and debug into the toolkit.

\subsection{Prerequisites by operating
system}\label{prerequisites-by-operating-system}

\subsubsection{SDK matrix at a glance}\label{sdk-matrix-at-a-glance}

Avalonia 11 targets .NET 8.0. The official repository pins versions in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/global.json}{\texttt{global.json}}:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Scenario
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
SDK / Tooling
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Notes
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Desktop (Windows/macOS/Linux) & .NET SDK \texttt{8.0.x} & Use latest
LTS; \texttt{global.json} ensures consistent builds across machines. \\
Android & .NET SDK \texttt{8.0.x} + \texttt{android} workload & Requires
Android Studio or Visual Studio mobile workloads. \\
iOS/macOS Catalyst & .NET SDK \texttt{8.0.x} + \texttt{ios} workload &
Requires Xcode CLI tools and Apple certificates for device
deployment. \\
Browser (WebAssembly) & .NET SDK \texttt{8.0.x} + \texttt{wasm-tools}
workload & Installs Emscripten toolchain for WASM builds. \\
\end{longtable}

Run \texttt{dotnet\ -\/-list-sdks} to confirm the expected SDK version
is installed. When multiple SDKs coexist, keep a repo-level
\texttt{global.json} to pin builds to the Avalonia-supported version.

\subsubsection{Windows}\label{windows}

\begin{itemize}
\tightlist
\item
  Install the latest \textbf{.NET SDK} (x64) from
  \url{https://dotnet.microsoft.com/download}.
\item
  Install \textbf{Visual Studio 2022} with the ``.NET desktop
  development'' workload; add ``.NET Multi-platform App UI development''
  for mobile tooling.
\item
  Optional: \texttt{winget\ install\ -\/-id\ Microsoft.DotNet.SDK.8}
  (replace with the current LTS) and install the \textbf{Windows
  Subsystem for Linux} if you plan to test Linux packages.
\item
  Native dependencies: Avalonia bundles Skia; keep GPU drivers updated.
  When shipping self-contained builds, include ANGLE libraries
  (\texttt{libEGL}, \texttt{libGLESv2}, \texttt{d3dcompiler\_47}) for
  broader GPU compatibility (see Chapter 26).
\end{itemize}

\subsubsection{macOS}\label{macos}

\begin{itemize}
\tightlist
\item
  Install the latest \textbf{.NET SDK (Arm64 or x64)} from Microsoft.
\item
  Install \textbf{Xcode} (App Store) to satisfy iOS build prerequisites.
\item
  Recommended IDEs: \textbf{JetBrains Rider}, \textbf{Visual Studio 2022
  for Mac} (if installed), or \textbf{Visual Studio Code} with the C\#
  Dev Kit.
\item
  Optional: install \textbf{Homebrew} and use it for
  \texttt{brew\ install\ dotnet-sdk} to keep versions updated.
\item
  Native dependencies: Avalonia uses Skia via Metal/OpenGL; ensure
  Command Line Tools are installed (\texttt{xcode-select\ -\/-install}).
\end{itemize}

\subsubsection{Linux (Ubuntu/Debian
example)}\label{linux-ubuntudebian-example}

\begin{itemize}
\tightlist
\item
  Add the Microsoft package feed and install the latest \textbf{.NET
  SDK} (\texttt{sudo\ apt\ install\ dotnet-sdk-8.0}).
\item
  Install an IDE: \textbf{Rider} or \textbf{Visual Studio Code} with the
  C\# extension (OmniSharp or C\# Dev Kit).
\item
  Ensure GTK dependencies are present
  (\texttt{sudo\ apt\ install\ libgtk-3-0\ libwebkit2gtk-4.1-0}) because
  the ControlCatalog sample relies on them.
\item
  Native dependencies: install Mesa/OpenGL drivers
  (\texttt{sudo\ apt\ install\ mesa-utils}) and ICU libraries for
  globalization support.
\end{itemize}

\begin{quote}
Verify your SDK installation:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet} \AttributeTok{{-}{-}version}
\ExtensionTok{dotnet} \AttributeTok{{-}{-}list{-}sdks}
\end{Highlighting}
\end{Shaded}

Make sure the Avalonia-supported SDK (currently .NET 8.x for Avalonia
11) appears in the list before moving on.
\end{quote}

\subsection{Optional workloads for advanced
targets}\label{optional-workloads-for-advanced-targets}

Run these commands only if you plan to target additional platforms soon
(you can add them later):

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet}\NormalTok{ workload install wasm{-}tools      }\CommentTok{\# Browser (WebAssembly)}
\ExtensionTok{dotnet}\NormalTok{ workload install android         }\CommentTok{\# Android toolchain}
\ExtensionTok{dotnet}\NormalTok{ workload install ios             }\CommentTok{\# iOS/macOS Catalyst toolchain}
\ExtensionTok{dotnet}\NormalTok{ workload install maui           }\CommentTok{\# Optional: Windows tooling support}

\CommentTok{\#\# Restore workloads declared in a solution (after cloning a repo)}
\ExtensionTok{dotnet}\NormalTok{ workload restore}
\end{Highlighting}
\end{Shaded}

If a workload fails, run \texttt{dotnet\ workload\ repair} and confirm
your IDE also installed the Android/iOS dependencies (Android SDK
Managers, Xcode command-line tools).

\subsection{Recommended IDE setup}\label{recommended-ide-setup}

\subsubsection{Visual Studio 2022
(Windows)}\label{visual-studio-2022-windows}

\begin{itemize}
\tightlist
\item
  Ensure the \textbf{Avalonia for Visual Studio} extension is installed
  (Marketplace) for XAML IntelliSense and the previewer.
\item
  Enable \textbf{XAML Hot Reload} under Tools -\textgreater{} Options
  -\textgreater{} Debugging -\textgreater{} General.
\item
  For Android/iOS, open Visual Studio Installer and add the
  corresponding mobile workloads.
\end{itemize}

\subsubsection{JetBrains Rider}\label{jetbrains-rider}

\begin{itemize}
\tightlist
\item
  Install the \textbf{Avalonia plugin} (File -\textgreater{} Settings
  -\textgreater{} Plugins -\textgreater{} Marketplace -\textgreater{}
  search ``Avalonia'').
\item
  Enable the built-in XAML previewer via
  \texttt{View\ -\textgreater{}\ Tool\ Windows\ -\textgreater{}\ Avalonia\ Previewer}.
\item
  Configure Android SDKs under Preferences -\textgreater{} Build Tools
  if you plan to run Android projects.
\end{itemize}

\subsubsection{Visual Studio Code}\label{visual-studio-code}

\begin{itemize}
\tightlist
\item
  Install the \textbf{C\# Dev Kit} or \textbf{C\# (OmniSharp)} extension
  for IntelliSense and debugging.
\item
  Add the \textbf{Avalonia for VS Code} extension for XAML tooling and
  preview.
\item
  Configure \texttt{dotnet\ watch} tasks or use the Avalonia preview
  extension's Live Preview panel.
\item
  Add tasks in \texttt{.vscode/tasks.json} for \texttt{dotnet\ run} /
  \texttt{dotnet\ watch} to trigger builds with \textbf{Ctrl+Shift+B}.
\item
  Set \texttt{"avalonia.preview.host"} to \texttt{dotnet} in
  \texttt{.vscode/settings.json} so the previewer launches automatically
  when you open XAML files.
\end{itemize}

\subsection{Install Avalonia project
templates}\label{install-avalonia-project-templates}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet}\NormalTok{ new install Avalonia.Templates}
\end{Highlighting}
\end{Shaded}

This adds templates such as \texttt{avalonia.app},
\texttt{avalonia.mvvm}, \texttt{avalonia.reactiveui}, and
\texttt{avalonia.xplat}.

Verify installation:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet}\NormalTok{ new list avalonia}
\end{Highlighting}
\end{Shaded}

You should see a table of available Avalonia templates.

\subsubsection{Template quick-reference}\label{template-quick-reference}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Template
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Command
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
When to use
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Desktop (code-behind) & \texttt{dotnet\ new\ avalonia.app\ -n\ MyApp} &
Small prototypes with code-behind patterns. \\
MVVM starter & \texttt{dotnet\ new\ avalonia.mvvm\ -n\ MyApp.Mvvm} &
Includes a ViewModel base class and sample bindings. \\
ReactiveUI &
\texttt{dotnet\ new\ avalonia.reactiveui\ -n\ MyApp.ReactiveUI} & If you
standardise on ReactiveUI for MVVM. \\
Cross-platform heads &
\texttt{dotnet\ new\ avalonia.app\ -\/-multiplatform\ -n\ MyApp.Multi} &
Generates desktop, mobile, and browser heads in one project. \\
Split head projects &
\texttt{dotnet\ new\ avalonia.xplat\ -n\ MyApp.Xplat} & Separate
desktop/mobile projects (Visual Studio friendly). \\
Control library &
\texttt{dotnet\ new\ avalonia.library\ -n\ MyApp.Controls} & Create
reusable UI/control libraries. \\
\end{longtable}

Pair this with \texttt{dotnet\ workload\ list} to confirm matching
workloads are installed for the heads you create.

\subsection{Create and run your first project (CLI-first
flow)}\label{create-and-run-your-first-project-cli-first-flow}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\# Create a new solution folder}
\FunctionTok{mkdir}\NormalTok{ HelloAvalonia }\KeywordTok{\&\&} \BuiltInTok{cd}\NormalTok{ HelloAvalonia}

\CommentTok{\#\# Scaffold a desktop app template (code{-}behind pattern)}
\ExtensionTok{dotnet}\NormalTok{ new avalonia.app }\AttributeTok{{-}o}\NormalTok{ HelloAvalonia.Desktop}

\BuiltInTok{cd}\NormalTok{ HelloAvalonia.Desktop}

\CommentTok{\#\# Restore packages and build}
\ExtensionTok{dotnet}\NormalTok{ build}

\CommentTok{\#\# Run the app}
\ExtensionTok{dotnet}\NormalTok{ run}
\end{Highlighting}
\end{Shaded}

A starter window appears. Close it when done.

\subsubsection{Alternative templates}\label{alternative-templates}

\begin{itemize}
\tightlist
\item
  \texttt{dotnet\ new\ avalonia.mvvm\ -o\ HelloAvalonia.Mvvm}
  -\textgreater{} includes a ViewModel base class and data-binding
  sample.
\item
  \texttt{dotnet\ new\ avalonia.reactiveui\ -o\ HelloAvalonia.ReactiveUI}
  -\textgreater{} adds ReactiveUI integration out of the box.
\item
  \texttt{dotnet\ new\ avalonia.app\ -\/-multiplatform\ -o\ HelloAvalonia.Multi}
  -\textgreater{} single-project layout with mobile/browser heads.
\item
  \texttt{dotnet\ new\ avalonia.xplat\ -o\ HelloAvalonia.Xplat}
  -\textgreater{} generates separate head projects (desktop/mobile)
  suited to Visual Studio.
\item
  \texttt{dotnet\ new\ avalonia.library\ -o\ HelloAvalonia.Controls}
  -\textgreater{} starts a reusable control/library project.
\end{itemize}

\subsection{Open the project in your
IDE}\label{open-the-project-in-your-ide}

\subsubsection{Visual Studio}\label{visual-studio}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  File -\textgreater{} Open -\textgreater{} Project/Solution
  -\textgreater{} select \texttt{HelloAvalonia.Desktop.csproj}.
\item
  Press \textbf{F5} (or the green Run arrow) to launch with the
  debugger.
\item
  Verify XAML Hot Reload by editing \texttt{MainWindow.axaml} while the
  app runs.
\end{enumerate}

\subsubsection{Rider}\label{rider}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  File -\textgreater{} Open -\textgreater{} choose the solution folder.
\item
  Use the top-right run configuration to run/debug.
\item
  Open the Avalonia Previewer tool window to see live XAML updates.
\end{enumerate}

\subsubsection{VS Code}\label{vs-code}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{code\ .} inside the project directory.
\item
  Accept the prompt to add build/debug assets; VS Code generates
  \texttt{launch.json} and \texttt{.vscode/tasks.json}.
\item
  Use the Run and Debug panel (F5) and the Avalonia preview extension
  for live previews.
\end{enumerate}

\subsection{Generated project tour (why each file
matters)}\label{generated-project-tour-why-each-file-matters}

\begin{itemize}
\tightlist
\item
  \texttt{HelloAvalonia.Desktop.csproj}: project metadata--target
  frameworks, NuGet packages, Avalonia build tasks
  (\texttt{Avalonia.Build.Tasks} compiles XAML to BAML-like assets; see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Build.Tasks/CompileAvaloniaXamlTask.cs}{CompileAvaloniaXamlTask.cs}).
\item
  \texttt{Program.cs}: entry point returning
  \texttt{BuildAvaloniaApp()}. Calls \texttt{UsePlatformDetect},
  \texttt{UseSkia}, \texttt{LogToTrace}, and starts the classic desktop
  lifetime (definition in
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs}{AppBuilderDesktopExtensions.cs}).
\item
  \texttt{App.axaml} / \texttt{App.axaml.cs}: global resources and
  startup logic. \texttt{App.OnFrameworkInitializationCompleted} creates
  and shows \texttt{MainWindow} (implementation defined in
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Application.cs}{Application.cs}).
\item
  \texttt{MainWindow.axaml} / \texttt{.axaml.cs}: your initial view.
  XAML is loaded by
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}{AvaloniaXamlLoader}.
\item
  \texttt{Assets/} and \texttt{Styles/}: sample resource dictionaries
  you can expand later.
\end{itemize}

\subsection{Make a visible change and
rerun}\label{make-a-visible-change-and-rerun}

\begin{Shaded}
\begin{Highlighting}[]

\NormalTok{\textless{}}\KeywordTok{Window}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{        xmlns:x=}\StringTok{"http://schemas.microsoft.com/winfx/2006/xaml"}
\OtherTok{        x:Class=}\StringTok{"HelloAvalonia.MainWindow"}
\OtherTok{        Width=}\StringTok{"400"}\OtherTok{ Height=}\StringTok{"260"}
\OtherTok{        Title=}\StringTok{"Hello Avalonia!"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ Margin=}\StringTok{"16"}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"It works!"}\OtherTok{ FontSize=}\StringTok{"24"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Click me"}\OtherTok{ HorizontalAlignment=}\StringTok{"Left"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Window}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Rebuild and run (\texttt{dotnet\ run} or IDE Run) to confirm the change.

\subsection{Troubleshooting checklist}\label{troubleshooting-checklist}

\begin{itemize}
\tightlist
\item
  \textbf{\texttt{dotnet} command missing}: reinstall the .NET SDK and
  restart the terminal/IDE. Confirm environment variables
  (\texttt{PATH}) include the dotnet installation path.
\item
  \textbf{Template not found}: rerun
  \texttt{dotnet\ new\ install\ Avalonia.Templates} or remove outdated
  versions with \texttt{dotnet\ new\ uninstall\ Avalonia.Templates}.
\item
  \textbf{NuGet restore issues}: clear caches
  (\texttt{dotnet\ nuget\ locals\ all\ -\/-clear}), ensure internet
  access or configure an offline mirror, then rerun
  \texttt{dotnet\ restore}.
\item
  \textbf{Workload errors}: run \texttt{dotnet\ workload\ repair}.
  Ensure Visual Studio or Xcode installed the matching tooling.
\item
  \textbf{IDE previewer fails}: confirm the Avalonia extension/plugin is
  installed, build the project once, and check the Output window for
  loader errors.
\item
  \textbf{Runtime missing native dependencies} (Linux): install GTK,
  Skia, and OpenGL packages (\texttt{libmesa}, \texttt{libx11-dev}).
\item
  \textbf{GPU anomalies}: temporarily disable GPU
  (\texttt{SKIA\_SHARP\_GPU=0}) to isolate driver issues, then update
  GPU drivers or include ANGLE fallbacks.
\item
  \textbf{Nightly packages}: add
  \texttt{https://www.myget.org/F/avalonia-nightly/api/v3/index.json} to
  NuGet sources to test nightly builds; pin a stable package before
  release.
\end{itemize}

\subsection{Build Avalonia from source (optional but recommended
once)}\label{build-avalonia-from-source-optional-but-recommended-once}

\begin{itemize}
\tightlist
\item
  Clone the framework:
  \texttt{git\ clone\ https://github.com/AvaloniaUI/Avalonia.git}.
\item
  Initialise submodules if prompted:
  \texttt{git\ submodule\ update\ -\/-init\ -\/-recursive}.
\item
  On Windows: run \texttt{.\textbackslash{}build.ps1\ -Target\ Build}.
\item
  On macOS/Linux: run \texttt{./build.sh\ -\/-target=Build}.
\item
  Docs reference:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/docs/build.md}{docs/build.md}.
\item
  Launch the ControlCatalog from source:
  \texttt{dotnet\ run\ -\/-project\ samples/ControlCatalog.Desktop/ControlCatalog.Desktop.csproj}.
\end{itemize}

Building from source gives you binaries with the latest commits, useful
for testing fixes or contributing.

\subsection{Practice and validation}\label{practice-and-validation}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Confirm your environment with \texttt{dotnet\ -\/-list-sdks} and
  \texttt{dotnet\ workload\ list}. If workloads are missing, run
  \texttt{dotnet\ workload\ restore}.
\item
  Install the Avalonia templates and scaffold each template from the
  quick-reference table. Capture which commands require additional
  workloads.
\item
  Run one generated app from the CLI and another from your IDE,
  verifying hot reload or the previewer works in both flows.
\item
  Clone the Avalonia repo, build it
  (\texttt{./build.sh\ -\/-target=Build} or
  \texttt{.\textbackslash{}build.ps1\ -Target\ Build}), and run the
  ControlCatalog sample.
\item
  Inspect \texttt{samples/ControlCatalog/ControlCatalog.csproj} and map
  referenced Avalonia packages to their source folders. Update your
  architecture sketch with these relationships.
\item
  Set a breakpoint in \texttt{App.axaml.cs}
  (\texttt{OnFrameworkInitializationCompleted}) and step through startup
  to watch the lifetime initialise.
\item
  Document SDK versions, workloads, and template output in a team README
  so new developers can reproduce your setup.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks}

\begin{itemize}
\tightlist
\item
  Build pipeline tasks:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Build.Tasks}{src/Avalonia.Build.Tasks}.
\item
  Desktop lifetime helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs}{src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs}.
\item
  ControlCatalog project:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/samples/ControlCatalog/ControlCatalog.csproj}{samples/ControlCatalog/ControlCatalog.csproj}.
\item
  Framework application startup:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Application.cs}{src/Avalonia.Controls/Application.cs}.
\end{itemize}

\subsection{Check yourself}\label{check-yourself}

\begin{itemize}
\tightlist
\item
  Which command installs Avalonia templates and how do you verify the
  install?
\item
  How do you list installed .NET SDKs and workloads?
\item
  Where does \texttt{App.OnFrameworkInitializationCompleted} live and
  what does it do?
\item
  Which files control project startup, resources, and views in a new
  template?
\item
  What steps are required to build Avalonia from source on your OS?
\end{itemize}

What's next - Next: \href{Chapter03.md}{Chapter 3}

\newpage

\subsection{3. Your first UI: layouts, controls, and XAML
basics}\label{your-first-ui-layouts-controls-and-xaml-basics}

Goal - Build your first meaningful window with StackPanel, Grid, and
reusable user controls. - Learn how \texttt{ContentControl},
\texttt{UserControl}, and \texttt{NameScope} help you compose UIs
cleanly. - See how logical and visual trees differ so you can find
controls and debug bindings. - Use \texttt{ItemsControl} with
\texttt{DataTemplate} and a simple value converter to repeat UI for
collections. - Understand XAML namespaces (\texttt{xmlns:}) and how to
reference custom classes or Avalonia namespaces.

Why this matters - Real apps are more than a single window--you compose
views, reuse user controls, and bind lists of data. - Understanding the
logical tree versus the visual tree makes tooling (DevTools,
FindControl, bindings) predictable. - Data templates and converters are
the backbone of MVVM-friendly UIs; learning them early prevents hacks
later.

Prerequisites - Chapter 2 completed. You can run \texttt{dotnet\ new},
\texttt{dotnet\ build}, and \texttt{dotnet\ run} on your machine.

\subsection{1. Scaffold the sample
project}\label{scaffold-the-sample-project}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\# Create a new sample app for this chapter}
\ExtensionTok{dotnet}\NormalTok{ new avalonia.mvvm }\AttributeTok{{-}o}\NormalTok{ SampleUiBasics}
\BuiltInTok{cd}\NormalTok{ SampleUiBasics}

\CommentTok{\#\# Restore packages and run once to ensure the template works}
\ExtensionTok{dotnet}\NormalTok{ run}
\end{Highlighting}
\end{Shaded}

Open the project in your IDE before continuing.

\subsection{2. Quick primer on XAML
namespaces}\label{quick-primer-on-xaml-namespaces}

The root \texttt{\textless{}Window\textgreater{}} tag declares
namespaces so XAML can resolve types:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{        xmlns:x=}\StringTok{"http://schemas.microsoft.com/winfx/2006/xaml"}
\OtherTok{        xmlns:ui=}\StringTok{"clr{-}namespace:SampleUiBasics.Views"}
\OtherTok{        x:Class=}\StringTok{"SampleUiBasics.Views.MainWindow"}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  The default namespace maps to common Avalonia controls (Button, Grid,
  StackPanel).
\item
  \texttt{xmlns:x} exposes XAML keywords like \texttt{x:Name},
  \texttt{x:Key}, and \texttt{x:DataType}.
\item
  Custom prefixes (e.g., \texttt{xmlns:ui}) point to CLR namespaces in
  your project or other assemblies so you can reference your own classes
  or controls (\texttt{ui:OrderRow}).
\item
  To import controls from other assemblies, add the prefix defined by
  their \texttt{{[}XmlnsDefinition{]}} attribute (for example,
  \texttt{xmlns:fluent="avares://Avalonia.Themes.Fluent"}).
\end{itemize}

\subsection{3. How Avalonia loads this
XAML}\label{how-avalonia-loads-this-xaml}

\begin{itemize}
\tightlist
\item
  \texttt{InitializeComponent()} in \texttt{MainWindow.axaml.cs} invokes
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}{\texttt{AvaloniaXamlLoader.Load}},
  wiring the compiled XAML into the partial class defined by
  \texttt{x:Class}.
\item
  During build, Avalonia's MSBuild tasks generate code that registers
  resources, name scopes, and compiled bindings for the loader (see
  Chapter 30 for the full pipeline).
\item
  In design-time or hot reload scenarios, the same loader can parse XAML
  streams when no compiled version exists, so runtime errors usually
  originate from this method.
\item
  Keep \texttt{x:Class} values in sync with your namespace; mismatches
  result in \texttt{XamlLoadException} messages complaining about
  missing compiled XAML.
\end{itemize}

\subsection{4. Build the main layout (StackPanel +
Grid)}\label{build-the-main-layout-stackpanel-grid}

Open \texttt{Views/MainWindow.axaml} and replace the
\texttt{\textless{}Window.Content\textgreater{}} with:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{        xmlns:x=}\StringTok{"http://schemas.microsoft.com/winfx/2006/xaml"}
\OtherTok{        xmlns:ui=}\StringTok{"clr{-}namespace:SampleUiBasics.Views"}
\OtherTok{        x:Class=}\StringTok{"SampleUiBasics.Views.MainWindow"}
\OtherTok{        Width=}\StringTok{"540"}\OtherTok{ Height=}\StringTok{"420"}
\OtherTok{        Title=}\StringTok{"Customer overview"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{DockPanel}\OtherTok{ LastChildFill=}\StringTok{"True"}\OtherTok{ Margin=}\StringTok{"16"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ DockPanel.Dock=}\StringTok{"Top"}
\OtherTok{               Classes=}\StringTok{"h1"}
\OtherTok{               Text=}\StringTok{"Customer overview"}
\OtherTok{               Margin=}\StringTok{"0,0,0,16"}\NormalTok{/\textgreater{}}

\NormalTok{    \textless{}}\KeywordTok{Grid}\OtherTok{ ColumnDefinitions=}\StringTok{"2*,3*"}
\OtherTok{          RowDefinitions=}\StringTok{"Auto,*"}
\OtherTok{          ColumnSpacing=}\StringTok{"16"}
\OtherTok{          RowSpacing=}\StringTok{"16"}\NormalTok{\textgreater{}}

\NormalTok{      \textless{}}\KeywordTok{StackPanel}\OtherTok{ Grid.Column=}\StringTok{"0"}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{TextBlock}\OtherTok{ Classes=}\StringTok{"h2"}\OtherTok{ Text=}\StringTok{"Details"}\NormalTok{/\textgreater{}}

\NormalTok{        \textless{}}\KeywordTok{Grid}\OtherTok{ ColumnDefinitions=}\StringTok{"Auto,*"}\OtherTok{ RowDefinitions=}\StringTok{"Auto,Auto,Auto"}\OtherTok{ RowSpacing=}\StringTok{"8"}\OtherTok{ ColumnSpacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Name:"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBox}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ Width=}\StringTok{"200"}\OtherTok{ Text=}\StringTok{"\{Binding Customer.Name\}"}\NormalTok{/\textgreater{}}

\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ Text=}\StringTok{"Email:"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBox}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ Text=}\StringTok{"\{Binding Customer.Email\}"}\NormalTok{/\textgreater{}}

\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ Grid.Row=}\StringTok{"2"}\OtherTok{ Text=}\StringTok{"Status:"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{ComboBox}\OtherTok{ Grid.Row=}\StringTok{"2"}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ SelectedIndex=}\StringTok{"0"}\NormalTok{\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{ComboBoxItem}\NormalTok{\textgreater{}Prospect\textless{}/}\KeywordTok{ComboBoxItem}\NormalTok{\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{ComboBoxItem}\NormalTok{\textgreater{}Active\textless{}/}\KeywordTok{ComboBoxItem}\NormalTok{\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{ComboBoxItem}\NormalTok{\textgreater{}Dormant\textless{}/}\KeywordTok{ComboBoxItem}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}/}\KeywordTok{ComboBox}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}


\NormalTok{      \textless{}}\KeywordTok{StackPanel}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{TextBlock}\OtherTok{ Classes=}\StringTok{"h2"}\OtherTok{ Text=}\StringTok{"Recent orders"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{ItemsControl}\OtherTok{ Items=}\StringTok{"\{Binding RecentOrders\}"}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{ItemsControl.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{              \textless{}}\KeywordTok{ui:OrderRow}\NormalTok{ /\textgreater{}}
\NormalTok{            \textless{}/}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}/}\KeywordTok{ItemsControl.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{ItemsControl}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{DockPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Window}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

What you just used: - \texttt{DockPanel} places a title bar on top and
fills the rest. - \texttt{Grid} split into two columns for the form
(left) and list (right). - \texttt{ItemsControl} repeats a data template
for each item in \texttt{RecentOrders}.

\subsection{\texorpdfstring{5. Create a reusable user control
(\texttt{OrderRow})}{5. Create a reusable user control (OrderRow)}}\label{create-a-reusable-user-control-orderrow}

Add a new file \texttt{Views/OrderRow.axaml}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{UserControl}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{             xmlns:x=}\StringTok{"http://schemas.microsoft.com/winfx/2006/xaml"}
\OtherTok{             x:Class=}\StringTok{"SampleUiBasics.Views.OrderRow"}
\OtherTok{             Padding=}\StringTok{"8"}
\OtherTok{             Classes=}\StringTok{"card"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Border}\OtherTok{ Background=}\StringTok{"\{DynamicResource ThemeBackgroundBrush\}"}
\OtherTok{          CornerRadius=}\StringTok{"6"}
\OtherTok{          Padding=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Grid}\OtherTok{ ColumnDefinitions=}\StringTok{"*,Auto"}\OtherTok{ RowDefinitions=}\StringTok{"Auto,Auto"}\OtherTok{ ColumnSpacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{TextBlock}\OtherTok{ Classes=}\StringTok{"h3"}\OtherTok{ Text=}\StringTok{"\{Binding Title\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{TextBlock}\OtherTok{ Grid.Column=}\StringTok{"1"}
\OtherTok{                 Foreground=}\StringTok{"\{DynamicResource ThemeAccentBrush\}"}
\OtherTok{                 Text=}\StringTok{"\{Binding Total, Converter=\{StaticResource CurrencyConverter\}\}"}\NormalTok{/\textgreater{}}

\NormalTok{      \textless{}}\KeywordTok{TextBlock}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ Grid.ColumnSpan=}\StringTok{"2"}\OtherTok{ Text=}\StringTok{"\{Binding PlacedOn, StringFormat=\textquotesingle{}Ordered on \{0:d\}\textquotesingle{}\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{UserControl}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{UserControl} encapsulates UI so you can reuse it via
  \texttt{\textless{}ui:OrderRow\ /\textgreater{}}.
\item
  It relies on bindings (\texttt{Title}, \texttt{Total},
  \texttt{PlacedOn}) which come from the current item in the data
  template.
\item
  Using a user control keeps the item template readable and testable.
\end{itemize}

\subsection{6. Add a value converter}\label{add-a-value-converter}

Converters adapt data for display. Create
\texttt{Converters/CurrencyConverter.cs}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ System}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Globalization}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Data}\OperatorTok{.}\FunctionTok{Converters}\OperatorTok{;}

\KeywordTok{namespace}\NormalTok{ SampleUiBasics}\OperatorTok{.}\FunctionTok{Converters}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ CurrencyConverter }\OperatorTok{:}\NormalTok{ IValueConverter}
\OperatorTok{\{}
    \KeywordTok{public} \DataTypeTok{object}\OperatorTok{?} \FunctionTok{Convert}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ value}\OperatorTok{,}\NormalTok{ Type targetType}\OperatorTok{,} \DataTypeTok{object}\OperatorTok{?}\NormalTok{ parameter}\OperatorTok{,}\NormalTok{ CultureInfo culture}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{value }\KeywordTok{is} \DataTypeTok{decimal}\NormalTok{ amount}\OperatorTok{)}
            \KeywordTok{return} \DataTypeTok{string}\OperatorTok{.}\FunctionTok{Format}\OperatorTok{(}\NormalTok{culture}\OperatorTok{,} \StringTok{"\{0:C\}"}\OperatorTok{,}\NormalTok{ amount}\OperatorTok{);}

        \KeywordTok{return}\NormalTok{ value}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{object}\OperatorTok{?} \FunctionTok{ConvertBack}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ value}\OperatorTok{,}\NormalTok{ Type targetType}\OperatorTok{,} \DataTypeTok{object}\OperatorTok{?}\NormalTok{ parameter}\OperatorTok{,}\NormalTok{ CultureInfo culture}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ value}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Register the converter in \texttt{App.axaml} so XAML can reference it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Application}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{             xmlns:x=}\StringTok{"http://schemas.microsoft.com/winfx/2006/xaml"}
\OtherTok{             xmlns:converters=}\StringTok{"clr{-}namespace:SampleUiBasics.Converters"}
\OtherTok{             x:Class=}\StringTok{"SampleUiBasics.App"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Application.Resources}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{converters:CurrencyConverter}\OtherTok{ x:Key=}\StringTok{"CurrencyConverter"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Application.Resources}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{Application.Styles}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{FluentTheme}\NormalTok{ /\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Application.Styles}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Application}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsection{7. Populate the ViewModel with nested
data}\label{populate-the-viewmodel-with-nested-data}

Open \texttt{ViewModels/MainWindowViewModel.cs} and replace its contents
with:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ System}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Collections}\OperatorTok{.}\FunctionTok{ObjectModel}\OperatorTok{;}

\KeywordTok{namespace}\NormalTok{ SampleUiBasics}\OperatorTok{.}\FunctionTok{ViewModels}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ MainWindowViewModel}
\OperatorTok{\{}
    \KeywordTok{public}\NormalTok{ CustomerViewModel Customer }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\OperatorTok{(}\StringTok{"Avery Diaz"}\OperatorTok{,} \StringTok{"avery@example.com"}\OperatorTok{);}

    \KeywordTok{public}\NormalTok{ ObservableCollection}\OperatorTok{\textless{}}\NormalTok{OrderViewModel}\OperatorTok{\textgreater{}}\NormalTok{ RecentOrders }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{new} \FunctionTok{OrderViewModel}\OperatorTok{(}\StringTok{"Starter subscription"}\OperatorTok{,} \FloatTok{49.00m}\OperatorTok{,}\NormalTok{ DateTime}\OperatorTok{.}\FunctionTok{Today}\OperatorTok{.}\FunctionTok{AddDays}\OperatorTok{({-}}\DecValTok{2}\OperatorTok{)),}
        \KeywordTok{new} \FunctionTok{OrderViewModel}\OperatorTok{(}\StringTok{"Design add{-}on"}\OperatorTok{,} \FloatTok{129.00m}\OperatorTok{,}\NormalTok{ DateTime}\OperatorTok{.}\FunctionTok{Today}\OperatorTok{.}\FunctionTok{AddDays}\OperatorTok{({-}}\DecValTok{12}\OperatorTok{)),}
        \KeywordTok{new} \FunctionTok{OrderViewModel}\OperatorTok{(}\StringTok{"Consulting"}\OperatorTok{,} \FloatTok{900.00m}\OperatorTok{,}\NormalTok{ DateTime}\OperatorTok{.}\FunctionTok{Today}\OperatorTok{.}\FunctionTok{AddDays}\OperatorTok{({-}}\DecValTok{20}\OperatorTok{))}
    \OperatorTok{\};}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed}\NormalTok{ record }\FunctionTok{CustomerViewModel}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ Name}\OperatorTok{,} \DataTypeTok{string}\NormalTok{ Email}\OperatorTok{);}

\KeywordTok{public} \KeywordTok{sealed}\NormalTok{ record }\FunctionTok{OrderViewModel}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ Title}\OperatorTok{,} \DataTypeTok{decimal}\NormalTok{ Total}\OperatorTok{,}\NormalTok{ DateTime PlacedOn}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Now bindings like \texttt{\{Binding\ Customer.Name\}} and
\texttt{\{Binding\ RecentOrders\}} have backing data.

\subsection{\texorpdfstring{8. Understand \texttt{ContentControl},
\texttt{UserControl}, and
\texttt{NameScope}}{8. Understand ContentControl, UserControl, and NameScope}}\label{understand-contentcontrol-usercontrol-and-namescope}

\begin{itemize}
\tightlist
\item
  \textbf{\texttt{ContentControl}} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ContentControl.cs}{ContentControl.cs})
  holds a single content object. Windows, Buttons, and many controls
  inherit from it. Setting \texttt{Content} or placing child XAML
  elements populates that content.
\item
  \textbf{\texttt{UserControl}} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/UserControl.cs}{UserControl.cs})
  packages a reusable view with its own XAML and code-behind. Each
  \texttt{UserControl} creates its own \texttt{NameScope} so
  \texttt{x:Name} values remain local.
\item
  \textbf{\texttt{NameScope}} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/NameScope.cs}{NameScope.cs})
  governs how \texttt{x:Name} lookups work. Use
  \texttt{this.FindControl\textless{}T\textgreater{}("OrdersList")} or
  \texttt{NameScope.GetNameScope(this)} to resolve names inside the
  nearest scope.
\end{itemize}

Example: add \texttt{x:Name="OrdersList"} to the \texttt{ItemsControl}
in \texttt{MainWindow.axaml} and access it from code-behind:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{partial} \KeywordTok{class}\NormalTok{ MainWindow }\OperatorTok{:}\NormalTok{ Window}
\OperatorTok{\{}
    \KeywordTok{public} \FunctionTok{MainWindow}\OperatorTok{()}
    \OperatorTok{\{}
        \FunctionTok{InitializeComponent}\OperatorTok{();}

        \DataTypeTok{var}\NormalTok{ ordersList }\OperatorTok{=} \KeywordTok{this}\OperatorTok{.}\FunctionTok{FindControl}\OperatorTok{\textless{}}\NormalTok{ItemsControl}\OperatorTok{\textgreater{}(}\StringTok{"OrdersList"}\OperatorTok{);}
        \CommentTok{// Inspect or manipulate generated visuals here if needed.}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

When you nest user controls, remember: a name defined in
\texttt{OrderRow} is not visible in \texttt{MainWindow} because each
\texttt{UserControl} has its own scope. This avoids name collisions in
templated scenarios.

\subsection{9. Logical tree vs visual tree (why it
matters)}\label{logical-tree-vs-visual-tree-why-it-matters}

\begin{itemize}
\tightlist
\item
  The \textbf{logical tree} tracks content relationships: windows
  -\textgreater{} user controls -\textgreater{} ItemsControl items.
  Bindings and resource lookups walk the logical tree. Inspect with
  \texttt{this.GetLogicalChildren()} or DevTools -\textgreater{} Logical
  tree.
\item
  The \textbf{visual tree} includes the actual visuals created by
  templates (Borders, TextBlocks, Panels). DevTools -\textgreater{}
  Visual tree shows the rendered hierarchy.
\item
  Some controls (e.g., \texttt{ContentPresenter}) exist in the visual
  tree but not in the logical tree. When \texttt{FindControl} fails,
  confirm whether the element is in the logical tree.
\item
  Reference implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/LogicalTree/LogicalTreeExtensions.cs}{LogicalTreeExtensions.cs}
  and
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Visual.cs}{Visual.cs}.
\end{itemize}

\subsection{10. Data templates
explained}\label{data-templates-explained}

\begin{itemize}
\tightlist
\item
  \texttt{ItemsControl.ItemTemplate} applies a \texttt{DataTemplate} for
  each item. Inside a data template, the \texttt{DataContext} is the
  individual item (an \texttt{OrderViewModel}).
\item
  You can inline XAML or reference a key:
  \texttt{\textless{}DataTemplate\ x:Key="OrderTemplate"\textgreater{}\ ...}
  and then \texttt{ItemTemplate="\{StaticResource\ OrderTemplate\}"}.
\item
  Data templates can contain user controls, panels, or inline elements.
  They are the foundation for list virtualization later.
\item
  Template source:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/Templates/DataTemplate.cs}{DataTemplate.cs}.
\end{itemize}

\subsection{\texorpdfstring{11. Work with resources
(\texttt{FindResource})}{11. Work with resources (FindResource)}}\label{work-with-resources-findresource}

\begin{itemize}
\tightlist
\item
  Declare brushes, converters, or styles in \texttt{Window.Resources} or
  \texttt{Application.Resources}.
\item
  Retrieve them at runtime with \texttt{FindResource} or
  \texttt{TryFindResource}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window.Resources}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{SolidColorBrush}\OtherTok{ x:Key=}\StringTok{"HighlightBrush"}\OtherTok{ Color=}\StringTok{"\#FFE57F"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Window.Resources}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private} \DataTypeTok{void} \FunctionTok{OnHighlight}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ RoutedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\FunctionTok{FindResource}\OperatorTok{(}\StringTok{"HighlightBrush"}\OperatorTok{)} \KeywordTok{is}\NormalTok{ IBrush brush}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        Background }\OperatorTok{=}\NormalTok{ brush}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{FindResource} walks the logical tree first, then escalates to
  application resources, mirroring how the XAML parser resolves
  \texttt{StaticResource}.
\item
  Resources defined inside a \texttt{UserControl} or
  \texttt{DataTemplate} are scoped; use \texttt{this.Resources} to
  override per-view resources without affecting the rest of the app.
\end{itemize}

\subsection{12. Run, inspect, and
iterate}\label{run-inspect-and-iterate}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet}\NormalTok{ run}
\end{Highlighting}
\end{Shaded}

While the app runs: - Press \textbf{F12} (DevTools). Explore both
logical and visual trees for \texttt{OrderRow} entries. - Select an
\texttt{OrderRow} TextBlock and confirm the binding path
(\texttt{Total}) resolves to the right data. - Try editing
\texttt{OrderViewModel} values in code and rerun to see updates.

\subsection{Troubleshooting}\label{troubleshooting}

\begin{itemize}
\tightlist
\item
  \textbf{Binding path errors}: DevTools -\textgreater{} Diagnostics
  -\textgreater{} Binding Errors shows typos. Ensure properties exist or
  set \texttt{x:DataType="vm:OrderViewModel"} in templates for
  compile-time checks (once you add namespaces for view models).
\item
  \textbf{Converter not found}: ensure the namespace prefix in
  \texttt{App.axaml} matches the converter's CLR namespace and the key
  matches \texttt{StaticResource\ CurrencyConverter}.
\item
  \textbf{User control not rendering}: confirm the namespace prefix
  \texttt{xmlns:ui} matches the CLR namespace of \texttt{OrderRow} and
  that the class is \texttt{partial} with matching \texttt{x:Class}.
\item
  \textbf{FindControl returns null}: check \texttt{NameScope}. If the
  element is inside a data template, use \texttt{e.Source} from events
  or bind through the ViewModel instead of searching.
\end{itemize}

\subsection{Practice and validation}\label{practice-and-validation-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a \texttt{ui:AddressCard} user control showing billing address
  details. Bind it to \texttt{Customer} using
  \texttt{ContentControl.Content="\{Binding\ Customer\}"} and define a
  data template for \texttt{CustomerViewModel}.
\item
  Add a \texttt{ValueConverter} that highlights orders above \$500 by
  returning a different brush; apply it to the Border background via
  \texttt{\{Binding\ Total,\ Converter=...\}}.
\item
  Name the \texttt{ItemsControl} (\texttt{x:Name="OrdersList"}) and call
  \texttt{this.FindControl\textless{}ItemsControl\textgreater{}("OrdersList")}
  in code-behind to verify name scoping.
\item
  Override \texttt{HighlightBrush} in \texttt{MainWindow.Resources} and
  use \texttt{FindResource} to swap the window background at runtime
  (e.g., from a button click).
\item
  Add a \texttt{ListBox} instead of \texttt{ItemsControl} and observe
  how selection adds visual states in the visual tree.
\item
  Use DevTools to inspect both logical and visual trees for
  \texttt{OrderRow}. Toggle the Namescope overlay to see how scopes
  nest.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-1}

\begin{itemize}
\tightlist
\item
  XAML loader:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}{src/Markup/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}
\item
  Content control composition:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ContentControl.cs}{src/Avalonia.Controls/ContentControl.cs}
\item
  User controls and name scopes:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/UserControl.cs}{src/Avalonia.Controls/UserControl.cs}
\item
  \texttt{NameScope} implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/NameScope.cs}{src/Avalonia.Base/Styling/NameScope.cs}
\item
  Logical tree helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/LogicalTree/LogicalTreeExtensions.cs}{src/Avalonia.Base/LogicalTree/LogicalTreeExtensions.cs}
\item
  Data template implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/Templates/DataTemplate.cs}{src/Markup/Avalonia.Markup.Xaml/Templates/DataTemplate.cs}
\item
  Value converters:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Data/Converters}{src/Avalonia.Base/Data/Converters}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-1}

\begin{itemize}
\tightlist
\item
  How do XAML namespaces (\texttt{xmlns}) relate to CLR namespaces and
  assemblies?
\item
  What is the difference between the logical and visual tree, and why
  does it matter for bindings?
\item
  How do \texttt{ContentControl} and \texttt{UserControl} differ and
  when would you choose each?
\item
  Where do you register value converters so they can be referenced in
  XAML?
\item
  Inside a \texttt{DataTemplate}, what object provides the
  \texttt{DataContext}?
\end{itemize}

What's next - Next: \href{Chapter04.md}{Chapter 4}

\newpage

\subsection{4. Application startup: AppBuilder and
lifetimes}\label{application-startup-appbuilder-and-lifetimes}

Goal - Trace the full AppBuilder pipeline from \texttt{Program.Main} to
the first window or view. - Understand how each lifetime
(\texttt{ClassicDesktopStyleApplicationLifetime},
\texttt{SingleViewApplicationLifetime},
\texttt{BrowserSingleViewLifetime},
\texttt{HeadlessApplicationLifetime}) boots and shuts down your app. -
Learn where to register services, logging, and global configuration
before the UI appears. - Handle startup exceptions gracefully and log
early so failures are diagnosable. - Prepare a project that can swap
between desktop, mobile/browser, and headless test lifetimes.

Why this matters - The startup path decides which platforms you can
target and where dependency injection, logging, and configuration
happen. - Knowing the lifetime contracts keeps your code organised when
you add secondary windows, mobile navigation, or browser shells later. -
Understanding the AppBuilder steps helps you debug platform issues
(e.g., missing native dependencies or misconfigured rendering).

Prerequisites - You have completed Chapter 2 and can build/run a
template project. - You are comfortable editing \texttt{Program.cs},
\texttt{App.axaml}, and \texttt{App.axaml.cs}.

\subsection{1. Follow the AppBuilder pipeline step by
step}\label{follow-the-appbuilder-pipeline-step-by-step}

\texttt{Program.cs} (or \texttt{Program.fs} in F\#) is the entry point.
A typical template looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{ReactiveUI}\OperatorTok{;} \CommentTok{// optional in ReactiveUI template}

\KeywordTok{internal} \KeywordTok{static} \KeywordTok{class}\NormalTok{ Program}
\OperatorTok{\{}
    \OperatorTok{[}\NormalTok{STAThread}\OperatorTok{]}
    \KeywordTok{public} \KeywordTok{static} \DataTypeTok{void} \FunctionTok{Main}\OperatorTok{(}\DataTypeTok{string}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)} \OperatorTok{=\textgreater{}} \FunctionTok{BuildAvaloniaApp}\OperatorTok{()}
        \OperatorTok{.}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}

    \KeywordTok{public} \KeywordTok{static}\NormalTok{ AppBuilder }\FunctionTok{BuildAvaloniaApp}\OperatorTok{()}
        \OperatorTok{=\textgreater{}}\NormalTok{ AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}       \CommentTok{// 1. Choose your Application subclass}
            \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}             \CommentTok{// 2. Detect the right native backend (Win32, macOS, X11, Android, iOS, Browser)}
            \OperatorTok{.}\FunctionTok{UseSkia}\OperatorTok{()}                      \CommentTok{// 3. Configure the rendering pipeline (Skia GPU/CPU renderer)}
            \OperatorTok{.}\FunctionTok{With}\OperatorTok{(}\KeywordTok{new}\NormalTok{ SkiaOptions }\OperatorTok{\{}         \CommentTok{// 4. (Optional) tweak renderer settings}
\NormalTok{                MaxGpuResourceSizeBytes }\OperatorTok{=} \DecValTok{96} \OperatorTok{*} \DecValTok{1024} \OperatorTok{*} \DecValTok{1024}
            \OperatorTok{\})}
            \OperatorTok{.}\FunctionTok{LogToTrace}\OperatorTok{()}                   \CommentTok{// 5. Hook logging before startup completes}
            \OperatorTok{.}\FunctionTok{UseReactiveUI}\OperatorTok{();}               \CommentTok{// 6. (Optional) enable ReactiveUI integration}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Each call returns the builder so you can chain configuration. Relevant
source: - \texttt{AppBuilder} implementation:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/AppBuilder.cs}{\texttt{src/Avalonia.Controls/AppBuilder.cs}}
- Skia configuration:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Skia/Avalonia.Skia/SkiaOptions.cs}{\texttt{src/Skia/Avalonia.Skia/SkiaOptions.cs}}
- Desktop helpers (\texttt{StartWithClassicDesktopLifetime}):
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs}{\texttt{src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs}}

\subsubsection{Builder pipeline diagram (mental
map)}\label{builder-pipeline-diagram-mental-map}

\begin{verbatim}
Program.Main
  `--- BuildAvaloniaApp()
        |-- Configure<App>()        (create Application instance)
        |-- UsePlatformDetect()     (choose backend)
        |-- UseSkia()/UseReactiveUI (features)
        |-- LogToTrace()/With(...)  (diagnostics/options)
        `-- StartWith...Lifetime()  (select lifetime and enter main loop)
\end{verbatim}

If anything in the pipeline throws, the process exits before UI renders.
Log early to catch those cases.

\subsection{2. Lifetimes in detail}\label{lifetimes-in-detail}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Lifetime type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Typical targets
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Key members
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{ClassicDesktopStyleApplicationLifetime} & Windowed desktop apps
with startup/shutdown events and main window & Windows, macOS, Linux &
\texttt{MainWindow}, \texttt{ShutdownMode}, \texttt{Exit},
\texttt{ShutdownRequested}, \texttt{OnExit} \\
\texttt{SingleViewApplicationLifetime} & Hosts a single root control
(\texttt{MainView}) & Android, iOS, Embedded & \texttt{MainView},
\texttt{MainViewClosing}, \texttt{OnMainViewClosed} \\
\texttt{BrowserSingleViewLifetime} (implements
\texttt{ISingleViewApplicationLifetime}) & Same contract as single view,
tuned for WebAssembly & Browser (WASM) & \texttt{MainView}, async app
init \\
\texttt{HeadlessApplicationLifetime} & No visible UI; runs for tests or
background services & Unit/UI tests & \texttt{TryGetTopLevel()}, manual
pumping \\
\end{longtable}

Key interfaces and classes to read: - Desktop lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs}{\texttt{ClassicDesktopStyleApplicationLifetime.cs}}
- Single view lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/SingleViewApplicationLifetime.cs}{\texttt{SingleViewApplicationLifetime.cs}}
- Browser lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserSingleViewLifetime.cs}{\texttt{BrowserSingleViewLifetime.cs}}
- Headless lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Headless/Avalonia.Headless/AvaloniaHeadlessApplicationLifetime.cs}{\texttt{AvaloniaHeadlessApplicationLifetime.cs}}

\subsubsection{Desktop lifetime flow}\label{desktop-lifetime-flow}

\begin{itemize}
\tightlist
\item
  \texttt{MainWindow} must be assigned before
  \texttt{base.OnFrameworkInitializationCompleted()} or no window will
  appear.
\item
  \texttt{ShutdownMode} controls when the app exits
  (\texttt{OnLastWindowClose}, \texttt{OnMainWindowClose}, or
  \texttt{OnExplicitShutdown}).
\item
  Subscribe to \texttt{ShutdownRequested} to cancel shutdown (e.g.,
  unsaved document prompt). Call \texttt{e.Cancel\ =\ true} to keep the
  app running.
\item
  Additional windows can be opened by tracking them in a collection and
  calling \texttt{Show()} / \texttt{Close()}.
\end{itemize}

\subsubsection{Single view and browser
lifetimes}\label{single-view-and-browser-lifetimes}

\begin{itemize}
\tightlist
\item
  Provide a root \texttt{Control} via \texttt{MainView}. Navigation
  stacks switch the child content instead of opening new windows.
\item
  For Android/iOS, the host platform handles navigation/back events;
  forward them to view models via commands.
\item
  Browser lifetime initialises asynchronously---await long-running
  startup logic before assigning \texttt{MainView}.
\end{itemize}

\subsubsection{Headless lifetime notes}\label{headless-lifetime-notes}

\begin{itemize}
\tightlist
\item
  \texttt{StartWithHeadless} disables rendering but still runs the
  dispatcher. Use it for integration tests.
\item
  Combine with \texttt{Avalonia.Headless.XUnit} or
  \texttt{Avalonia.Headless.NUnit} to drive UI interactions
  programmatically.
\end{itemize}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Typical targets
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Key members
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{ClassicDesktopStyleApplicationLifetime} & Windowed desktop apps
with startup/shutdown events and main window & Windows, macOS, Linux &
\texttt{MainWindow}, \texttt{ShutdownMode}, \texttt{Exit},
\texttt{OnExit} \\
\texttt{SingleViewApplicationLifetime} & Hosts a single root control
(\texttt{MainView}) & Android, iOS, Embedded & \texttt{MainView},
\texttt{MainViewClosing}, \texttt{OnMainViewClosed} \\
\texttt{BrowserSingleViewLifetime} (implements
\texttt{ISingleViewApplicationLifetime}) & Same contract as single view,
tuned for WebAssembly & Browser (WASM) & \texttt{MainView}, async app
init \\
\texttt{HeadlessApplicationLifetime} & No visible UI; runs for tests or
background services & Unit/UI tests & \texttt{TryGetTopLevel()}, manual
pumping \\
\end{longtable}

Key interfaces and classes to read: - Desktop lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs}{\texttt{ClassicDesktopStyleApplicationLifetime.cs}}
- Single view lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/SingleViewApplicationLifetime.cs}{\texttt{SingleViewApplicationLifetime.cs}}
- Browser lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserSingleViewLifetime.cs}{\texttt{BrowserSingleViewLifetime.cs}}
- Headless lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Headless/Avalonia.Headless/AvaloniaHeadlessApplicationLifetime.cs}{\texttt{src/Headless/Avalonia.Headless/AvaloniaHeadlessApplicationLifetime.cs}}

\subsection{\texorpdfstring{3. Wiring lifetimes in
\texttt{App.OnFrameworkInitializationCompleted}}{3. Wiring lifetimes in App.OnFrameworkInitializationCompleted}}\label{wiring-lifetimes-in-app.onframeworkinitializationcompleted}

\texttt{App.axaml.cs} is the right place to react once the framework is
ready:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Controls}\OperatorTok{.}\FunctionTok{ApplicationLifetimes}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Microsoft}\OperatorTok{.}\FunctionTok{Extensions}\OperatorTok{.}\FunctionTok{DependencyInjection}\OperatorTok{;} \CommentTok{// if using DI}

\KeywordTok{namespace}\NormalTok{ MultiLifetimeSample}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{partial} \KeywordTok{class}\NormalTok{ App }\OperatorTok{:}\NormalTok{ Application}
\OperatorTok{\{}
    \KeywordTok{private}\NormalTok{ IServiceProvider}\OperatorTok{?}\NormalTok{ \_services}\OperatorTok{;}

    \KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{Initialize}\OperatorTok{()}
        \OperatorTok{=\textgreater{}}\NormalTok{ AvaloniaXamlLoader}\OperatorTok{.}\FunctionTok{Load}\OperatorTok{(}\KeywordTok{this}\OperatorTok{);}

    \KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{()}
    \OperatorTok{\{}
        \CommentTok{// Create/register services only once}
\NormalTok{        \_services }\OperatorTok{??=} \FunctionTok{ConfigureServices}\OperatorTok{();}

        \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ IClassicDesktopStyleApplicationLifetime desktop}\OperatorTok{)}
        \OperatorTok{\{}
            \DataTypeTok{var}\NormalTok{ shell }\OperatorTok{=}\NormalTok{ \_services}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{MainWindow}\OperatorTok{\textgreater{}();}
\NormalTok{            desktop}\OperatorTok{.}\FunctionTok{MainWindow} \OperatorTok{=}\NormalTok{ shell}\OperatorTok{;}
\NormalTok{            desktop}\OperatorTok{.}\FunctionTok{Exit} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_services}\OperatorTok{.}\FunctionTok{Dispose}\OperatorTok{();}
        \OperatorTok{\}}
        \KeywordTok{else} \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ ISingleViewApplicationLifetime singleView}\OperatorTok{)}
        \OperatorTok{\{}
\NormalTok{            singleView}\OperatorTok{.}\FunctionTok{MainView} \OperatorTok{=}\NormalTok{ \_services}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{MainView}\OperatorTok{\textgreater{}();}
        \OperatorTok{\}}
        \KeywordTok{else} \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ IControlledApplicationLifetime controlled}\OperatorTok{)}
        \OperatorTok{\{}
\NormalTok{            controlled}\OperatorTok{.}\FunctionTok{Exit} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ Console}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\StringTok{"Application exited"}\OperatorTok{);}
        \OperatorTok{\}}

        \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{();}
    \OperatorTok{\}}

    \KeywordTok{private}\NormalTok{ IServiceProvider }\FunctionTok{ConfigureServices}\OperatorTok{()}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ services }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ServiceCollection}\OperatorTok{();}
\NormalTok{        services}\OperatorTok{.}\FunctionTok{AddSingleton}\OperatorTok{\textless{}}\NormalTok{MainWindow}\OperatorTok{\textgreater{}();}
\NormalTok{        services}\OperatorTok{.}\FunctionTok{AddSingleton}\OperatorTok{\textless{}}\NormalTok{MainView}\OperatorTok{\textgreater{}();}
\NormalTok{        services}\OperatorTok{.}\FunctionTok{AddSingleton}\OperatorTok{\textless{}}\NormalTok{DashboardViewModel}\OperatorTok{\textgreater{}();}
\NormalTok{        services}\OperatorTok{.}\FunctionTok{AddLogging}\OperatorTok{(}\NormalTok{builder }\OperatorTok{=\textgreater{}}\NormalTok{ builder}\OperatorTok{.}\FunctionTok{AddDebug}\OperatorTok{());}
        \KeywordTok{return}\NormalTok{ services}\OperatorTok{.}\FunctionTok{BuildServiceProvider}\OperatorTok{();}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Notes: - \texttt{ApplicationLifetime} always implements
\texttt{IControlledApplicationLifetime}, so you can subscribe to
\texttt{Exit} for cleanup even if you do not know the exact subtype. -
Use dependency injection (any container) to share views/view models.
Avalonia does not ship a DI container, so you control the lifetime. -
For headless tests, your \texttt{App} still runs but you typically
return \texttt{SingleView} or host view models manually.

\subsection{4. Handling exceptions and
logging}\label{handling-exceptions-and-logging}

Important logging points: - \texttt{AppBuilder.LogToTrace()} uses
Avalonia's logging infrastructure (see
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Logging}{\texttt{src/Avalonia.Base/Logging}}).
For production apps, plug in \texttt{Serilog},
\texttt{Microsoft.Extensions.Logging}, or your preferred provider. -
Subscribe to \texttt{AppDomain.CurrentDomain.UnhandledException},
\texttt{TaskScheduler.UnobservedTaskException}, and
\texttt{Dispatcher.UIThread.UnhandledException} to capture failures
before they tear down the dispatcher. -
\texttt{IControlledApplicationLifetime} (\texttt{ApplicationLifetime})
exposes \texttt{Exit} and \texttt{Shutdown()} so you can close
gracefully after logging or prompting the user.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\NormalTok{STAThread}\OperatorTok{]}
\KeywordTok{public} \KeywordTok{static} \DataTypeTok{void} \FunctionTok{Main}\OperatorTok{(}\DataTypeTok{string}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    AppDomain}\OperatorTok{.}\FunctionTok{CurrentDomain}\OperatorTok{.}\FunctionTok{UnhandledException} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}} \FunctionTok{LogFatal}\OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{ExceptionObject}\OperatorTok{);}
\NormalTok{    TaskScheduler}\OperatorTok{.}\FunctionTok{UnobservedTaskException} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}} \FunctionTok{LogFatal}\OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{Exception}\OperatorTok{);}

\NormalTok{    Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{UnhandledException} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}}
    \OperatorTok{\{}
        \FunctionTok{LogFatal}\OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{Exception}\OperatorTok{);}
\NormalTok{        e}\OperatorTok{.}\FunctionTok{Handled} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;} \CommentTok{// optionally keep the app alive after logging}
    \OperatorTok{\};}

    \KeywordTok{try}
    \OperatorTok{\{}
        \FunctionTok{BuildAvaloniaApp}\OperatorTok{().}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
    \OperatorTok{\}}
    \KeywordTok{catch} \OperatorTok{(}\NormalTok{Exception ex}\OperatorTok{)}
    \OperatorTok{\{}
        \FunctionTok{LogFatal}\OperatorTok{(}\NormalTok{ex}\OperatorTok{);}
        \KeywordTok{throw}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{ClassicDesktopStyleApplicationLifetime} exposes
\texttt{ShutdownMode}, \texttt{ShutdownRequested}, and
\texttt{Shutdown()} so you can decide whether to exit on last window
close, on main window close, or only when you call \texttt{Shutdown()}
explicitly.

\subsection{5. Switching lifetimes inside one
project}\label{switching-lifetimes-inside-one-project}

You can provide different entry points or compile-time switches:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \DataTypeTok{void} \FunctionTok{Main}\OperatorTok{(}\DataTypeTok{string}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)}
\OperatorTok{\{}
\KeywordTok{\#if}\NormalTok{ HEADLESS}
    \FunctionTok{BuildAvaloniaApp}\OperatorTok{().}\FunctionTok{Start}\OperatorTok{(}\NormalTok{AppMain}\OperatorTok{);}
\KeywordTok{\#elif}\NormalTok{ BROWSER}
    \FunctionTok{BuildAvaloniaApp}\OperatorTok{().}\FunctionTok{SetupBrowserApp}\OperatorTok{(}\StringTok{"app"}\OperatorTok{);}
\KeywordTok{\#else}
    \FunctionTok{BuildAvaloniaApp}\OperatorTok{().}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
\KeywordTok{\#endif}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{SetupBrowserApp} is defined in
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserAppBuilder.cs}{\texttt{BrowserAppBuilder.cs}}
  and attaches the app to a DOM element.
\item
  \texttt{Start} (with \texttt{AppMain}) lets you provide your own
  lifetime, often used in headless/integration tests.
\end{itemize}

\subsection{6. Headless/testing
scenarios}\label{headlesstesting-scenarios}

Avalonia's headless assemblies let you boot an app without rendering:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Headless}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ Program}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static} \DataTypeTok{void} \FunctionTok{Main}\OperatorTok{(}\DataTypeTok{string}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)}
        \OperatorTok{=\textgreater{}} \FunctionTok{BuildAvaloniaApp}\OperatorTok{().}\FunctionTok{StartWithHeadless}\OperatorTok{(}\KeywordTok{new}\NormalTok{ HeadlessApplicationOptions}
        \OperatorTok{\{}
\NormalTok{            RenderingMode }\OperatorTok{=}\NormalTok{ HeadlessRenderingMode}\OperatorTok{.}\FunctionTok{None}\OperatorTok{,}
\NormalTok{            UseHeadlessDrawingContext }\OperatorTok{=} \KeywordTok{true}
        \OperatorTok{\});}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{Avalonia.Headless} lives under
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Headless}{\texttt{src/Headless}}
  and powers automated UI tests (\texttt{Avalonia.Headless.XUnit},
  \texttt{Avalonia.Headless.NUnit}).
\item
  You can pump the dispatcher manually to run asynchronous UI logic in
  tests (\texttt{HeadlessUnitTestSession.Run} displays an example).
\end{itemize}

\subsection{7. Putting it together: desktop + single-view
sample}\label{putting-it-together-desktop-single-view-sample}

\texttt{Program.cs}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static}\NormalTok{ AppBuilder }\FunctionTok{BuildAvaloniaApp}\OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{UseSkia}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{LogToTrace}\OperatorTok{();}

\OperatorTok{[}\NormalTok{STAThread}\OperatorTok{]}
\KeywordTok{public} \KeywordTok{static} \DataTypeTok{void} \FunctionTok{Main}\OperatorTok{(}\DataTypeTok{string}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{args}\OperatorTok{.}\FunctionTok{Contains}\OperatorTok{(}\StringTok{"{-}{-}single{-}view"}\OperatorTok{))}
    \OperatorTok{\{}
        \FunctionTok{BuildAvaloniaApp}\OperatorTok{().}\FunctionTok{StartWithSingleViewLifetime}\OperatorTok{(}\KeywordTok{new} \FunctionTok{MainView}\OperatorTok{());}
    \OperatorTok{\}}
    \KeywordTok{else}
    \OperatorTok{\{}
        \FunctionTok{BuildAvaloniaApp}\OperatorTok{().}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{App.axaml.cs} sets up both \texttt{MainWindow} and
\texttt{MainView} (as shown earlier). At runtime, you can switch
lifetimes via command-line or compile condition.

\subsection{Troubleshooting}\label{troubleshooting-1}

\begin{itemize}
\tightlist
\item
  \textbf{Black screen on startup}: check \texttt{UsePlatformDetect()};
  on Linux you might need extra packages (mesa, libwebkit) or use
  \texttt{UseSkia} explicitly.
\item
  \textbf{No window appearing}: ensure \texttt{desktop.MainWindow} is
  assigned before calling
  \texttt{base.OnFrameworkInitializationCompleted()}.
\item
  \textbf{Single view renders but inputs fail}: confirm you used the
  right lifetime (\texttt{StartWithSingleViewLifetime}) and that your
  root view is a \texttt{Control} with focusable children.
\item
  \textbf{DI container disposed too early}: if you \texttt{using} the
  provider, keep it alive for the app lifetime and dispose in
  \texttt{Exit}.
\item
  \textbf{Unhandled exception after closing last window}: check
  \texttt{ShutdownMode}. Default is \texttt{OnLastWindowClose}; switch
  to \texttt{OnMainWindowClose} or call \texttt{Shutdown()} to exit on
  demand.
\end{itemize}

\subsection{Practice and validation}\label{practice-and-validation-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Modify your project so the same \texttt{App} supports both desktop and
  single-view lifetimes. Use a command-line switch (\texttt{-\/-mobile})
  to select \texttt{StartWithSingleViewLifetime} and verify your
  \texttt{MainView} renders inside a mobile head (Android emulator or
  \texttt{dotnet\ run\ -\/-\ -\/-mobile} + \texttt{SingleView} desktop
  simulation).
\item
  Register a logging provider using
  \texttt{Microsoft.Extensions.Logging}. Log the current lifetime type
  inside \texttt{OnFrameworkInitializationCompleted}, subscribe to
  \texttt{ShutdownRequested}, and record when the app exits.
\item
  Add a simple DI container (as shown) and resolve
  \texttt{MainWindow}/\texttt{MainView} through it. Confirm disposal
  happens when the app exits.
\item
  Create a headless console entry point
  (\texttt{BuildAvaloniaApp().Start(AppMain)}) and run a unit test that
  constructs a view, invokes bindings, and pumps the dispatcher.
\item
  Wire \texttt{Dispatcher.UIThread.UnhandledException} and verify that
  handled exceptions keep the app alive while unhandled ones terminate.
\item
  Intentionally throw inside \texttt{OnFrameworkInitializationCompleted}
  and observe how logging captures the stack. Then add a
  \texttt{try/catch} to show a fallback dialog or log and exit
  gracefully.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-2}

\begin{itemize}
\tightlist
\item
  \texttt{AppBuilder} internals:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/AppBuilder.cs}{\texttt{src/Avalonia.Controls/AppBuilder.cs}}
\item
  Desktop startup helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs}{\texttt{src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs}}
\item
  Desktop lifetime implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs}{\texttt{src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs}}
\item
  Single-view lifetime:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/SingleViewApplicationLifetime.cs}{\texttt{src/Avalonia.Controls/ApplicationLifetimes/SingleViewApplicationLifetime.cs}}
\item
  Browser lifetime:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserSingleViewLifetime.cs}{\texttt{src/Browser/Avalonia.Browser/BrowserSingleViewLifetime.cs}}
\item
  Headless lifetime and tests:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Headless}{\texttt{src/Headless}}
\item
  Controlled lifetime interface
  (\texttt{IControlledApplicationLifetime}):
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/IControlledApplicationLifetime.cs}{\texttt{src/Avalonia.Controls/ApplicationLifetimes/IControlledApplicationLifetime.cs}}
\item
  Dispatcher unhandled exception hook:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Threading/Dispatcher.cs}{\texttt{src/Avalonia.Base/Threading/Dispatcher.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-2}

\begin{itemize}
\tightlist
\item
  What steps does \texttt{BuildAvaloniaApp()} perform before choosing a
  lifetime?
\item
  Which lifetime would you use for Windows/macOS, Android/iOS, browser,
  and automated tests?
\item
  Where should you place dependency injection setup and where should you
  dispose the container?
\item
  How can you capture and log unhandled exceptions thrown during
  startup?
\item
  How would you attach the app to a DOM element in a WebAssembly host?
\end{itemize}

What's next - Next: \href{Chapter05.md}{Chapter 5}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part II — Building beautiful and useful UIs}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part II — Building beautiful and useful UIs}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{5. Layout system without
mystery}\label{layout-system-without-mystery}

Goal - Understand Avalonia's layout pass (\texttt{Measure} then
\texttt{Arrange}) and how \texttt{Layoutable} and \texttt{LayoutManager}
orchestrate it. - Master the core panels (StackPanel, Grid, DockPanel,
WrapPanel) plus advanced tools (\texttt{GridSplitter}, \texttt{Viewbox},
\texttt{LayoutTransformControl}, \texttt{SharedSizeGroup}). - Learn when
to create custom panels by overriding
\texttt{MeasureOverride}/\texttt{ArrangeOverride}. - Know how scrolling,
virtualization, and \texttt{Panel.ZIndex} interact with layout. -
Practice diagnosing layout issues with DevTools overlays and logging.

Why this matters - Layout defines the user experience: predictable
resizing, adaptive forms, responsive dashboards. - Panels are reusable
building blocks. Understanding the underlying contract helps you read
control templates and write your own. - Troubleshooting layout without a
plan wastes time; with DevTools and knowledge of the pass order, you
debug confidently.

Prerequisites - You can run a basic Avalonia app and edit XAML (Chapters
2-4). - You have DevTools (F12) available to inspect layout rectangles.

\subsection{1. Mental model: measure and
arrange}\label{mental-model-measure-and-arrange}

Every control inherits from \texttt{Layoutable}
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/Layoutable.cs}{Layoutable.cs}).
The layout pass runs in two stages:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Measure}: Parent asks each child ``How big would you like to
  be?'' providing an available size. The child can respond with any size
  up to that constraint. Override \texttt{MeasureOverride} in panels to
  lay out children.
\item
  \textbf{Arrange}: Parent decides where to place each child within its
  final bounds. Override \texttt{ArrangeOverride} to position children
  based on the measured sizes.
\end{enumerate}

The \texttt{LayoutManager}
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/LayoutManager.cs}{LayoutManager.cs})
schedules layout passes when controls invalidate measure or arrange
(\texttt{InvalidateMeasure}, \texttt{InvalidateArrange}).

\subsection{2. Layout invalidation and
diagnostics}\label{layout-invalidation-and-diagnostics}

\begin{itemize}
\tightlist
\item
  Call \texttt{InvalidateMeasure()} when a control's desired size
  changes (for example, text content updates).
\item
  Call \texttt{InvalidateArrange()} when position changes but desired
  size remains the same. Panels do this when children move without
  resizing.
\item
  \texttt{LayoutManager} batches these requests; inspect timings via
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/LayoutPassTiming.cs}{\texttt{LayoutPassTiming}}
  or DevTools -\textgreater{} Layout tab.
\item
  Enable DevTools layout overlays (F12 -\textgreater{} Layout) to
  visualise measure/arrange bounds. Combine with
  \texttt{RendererDebugOverlays.LayoutTimeGraph} to profile layout
  costs.
\item
  For custom panels, avoid calling \texttt{InvalidateMeasure} from
  inside \texttt{MeasureOverride}; schedule work via \texttt{Dispatcher}
  if you must recalc asynchronously.
\end{itemize}

\subsection{3. Start a layout playground
project}\label{start-a-layout-playground-project}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet}\NormalTok{ new avalonia.app }\AttributeTok{{-}o}\NormalTok{ LayoutPlayground}
\BuiltInTok{cd}\NormalTok{ LayoutPlayground}
\end{Highlighting}
\end{Shaded}

Replace \texttt{MainWindow.axaml} with an experiment playground that
demonstrates the core panels and alignment tools:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{        xmlns:x=}\StringTok{"http://schemas.microsoft.com/winfx/2006/xaml"}
\OtherTok{        x:Class=}\StringTok{"LayoutPlayground.MainWindow"}
\OtherTok{        Width=}\StringTok{"880"}\OtherTok{ Height=}\StringTok{"560"}
\OtherTok{        Title=}\StringTok{"Layout Playground"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Grid}\OtherTok{ ColumnDefinitions=}\StringTok{"*,*"}\OtherTok{ RowDefinitions=}\StringTok{"Auto,*"}\OtherTok{ Padding=}\StringTok{"16"}\OtherTok{ RowSpacing=}\StringTok{"16"}\OtherTok{ ColumnSpacing=}\StringTok{"16"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Grid.ColumnSpan=}\StringTok{"2"}\OtherTok{ Classes=}\StringTok{"h1"}\OtherTok{ Text=}\StringTok{"Layout system without mystery"}\NormalTok{/\textgreater{}}

\NormalTok{    \textless{}}\KeywordTok{StackPanel}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{TextBlock}\OtherTok{ Classes=}\StringTok{"h2"}\OtherTok{ Text=}\StringTok{"StackPanel"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Border}\OtherTok{ BorderBrush=}\StringTok{"\#CCC"}\OtherTok{ BorderThickness=}\StringTok{"1"}\OtherTok{ Padding=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{StackPanel}\OtherTok{ Spacing=}\StringTok{"6"}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Top"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Middle"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Bottom"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Stretch me"}\OtherTok{ HorizontalAlignment=}\StringTok{"Stretch"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}

\NormalTok{      \textless{}}\KeywordTok{TextBlock}\OtherTok{ Classes=}\StringTok{"h2"}\OtherTok{ Text=}\StringTok{"DockPanel"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Border}\OtherTok{ BorderBrush=}\StringTok{"\#CCC"}\OtherTok{ BorderThickness=}\StringTok{"1"}\OtherTok{ Padding=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{DockPanel}\OtherTok{ LastChildFill=}\StringTok{"True"}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ DockPanel.Dock=}\StringTok{"Top"}\OtherTok{ Text=}\StringTok{"Top bar"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ DockPanel.Dock=}\StringTok{"Left"}\OtherTok{ Text=}\StringTok{"Left"}\OtherTok{ Margin=}\StringTok{"0,4,8,0"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Border}\OtherTok{ Background=}\StringTok{"\#F0F6FF"}\OtherTok{ CornerRadius=}\StringTok{"4"}\OtherTok{ Padding=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Last child fills remaining space"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{DockPanel}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}

\NormalTok{    \textless{}}\KeywordTok{StackPanel}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{TextBlock}\OtherTok{ Classes=}\StringTok{"h2"}\OtherTok{ Text=}\StringTok{"Grid + WrapPanel"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Border}\OtherTok{ BorderBrush=}\StringTok{"\#CCC"}\OtherTok{ BorderThickness=}\StringTok{"1"}\OtherTok{ Padding=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{Grid}\OtherTok{ ColumnDefinitions=}\StringTok{"Auto,*"}\OtherTok{ RowDefinitions=}\StringTok{"Auto,Auto,Auto"}\OtherTok{ ColumnSpacing=}\StringTok{"8"}\OtherTok{ RowSpacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Name:"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBox}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ MinWidth=}\StringTok{"200"}\NormalTok{/\textgreater{}}

\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ Text=}\StringTok{"Email:"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBox}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ Grid.Column=}\StringTok{"1"}\NormalTok{/\textgreater{}}

\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ Grid.Row=}\StringTok{"2"}\OtherTok{ Text=}\StringTok{"Notes:"}\OtherTok{ VerticalAlignment=}\StringTok{"Top"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBox}\OtherTok{ Grid.Row=}\StringTok{"2"}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ Height=}\StringTok{"80"}\OtherTok{ AcceptsReturn=}\StringTok{"True"}\OtherTok{ TextWrapping=}\StringTok{"Wrap"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}

\NormalTok{      \textless{}}\KeywordTok{Border}\OtherTok{ BorderBrush=}\StringTok{"\#CCC"}\OtherTok{ BorderThickness=}\StringTok{"1"}\OtherTok{ Padding=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{WrapPanel}\OtherTok{ ItemHeight=}\StringTok{"32"}\OtherTok{ MinWidth=}\StringTok{"200"}\OtherTok{ ItemWidth=}\StringTok{"100"}\OtherTok{ HorizontalAlignment=}\StringTok{"Left"}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"One"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Two"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Three"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Four"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Five"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Six"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{WrapPanel}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Window}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Run the app and resize the window. Observe how StackPanel, DockPanel,
Grid, and WrapPanel distribute space.

\subsection{4. Alignment and sizing toolkit
recap}\label{alignment-and-sizing-toolkit-recap}

\begin{itemize}
\tightlist
\item
  \texttt{Margin} vs \texttt{Padding}: Margin adds space around a
  control; Padding adds space inside a container.
\item
  \texttt{HorizontalAlignment}/\texttt{VerticalAlignment}:
  \texttt{Stretch} makes controls fill available space; \texttt{Center},
  \texttt{Start}, \texttt{End} align within the assigned slot.
\item
  \texttt{Width}/\texttt{Height}: fixed sizes; use sparingly. Prefer
  \texttt{MinWidth}, \texttt{MaxWidth}, \texttt{MinHeight},
  \texttt{MaxHeight} for adaptive layouts.
\item
  Grid sizing: \texttt{Auto} (size to content), \texttt{*} (take
  remaining space), \texttt{2*} (take twice the share). Column/row
  definitions can mix Auto, star, and pixel values.
\end{itemize}

\subsection{5. Advanced layout tools}\label{advanced-layout-tools}

\subsubsection{\texorpdfstring{Grid with
\texttt{SharedSizeGroup}}{Grid with SharedSizeGroup}}\label{grid-with-sharedsizegroup}

\texttt{SharedSizeGroup} lets multiple grids share sizes within a scope.
Mark the parent with \texttt{Grid.IsSharedSizeScope="True"}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Grid}\OtherTok{ ColumnDefinitions=}\StringTok{"Auto,*"}\OtherTok{ RowDefinitions=}\StringTok{"Auto,Auto"}\OtherTok{ Grid.IsSharedSizeScope=}\StringTok{"True"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Grid.ColumnDefinitions}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ColumnDefinition}\OtherTok{ SharedSizeGroup=}\StringTok{"Label"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ColumnDefinition}\OtherTok{ Width=}\StringTok{"*"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Grid.ColumnDefinitions}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Grid}\OtherTok{ RowDefinitions=}\StringTok{"Auto,Auto"}\OtherTok{ ColumnDefinitions=}\StringTok{"Auto,*"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"First"}\OtherTok{ Grid.Column=}\StringTok{"0"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBox}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ MinWidth=}\StringTok{"200"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Grid}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ ColumnDefinitions=}\StringTok{"Auto,*"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Second"}\OtherTok{ Grid.Column=}\StringTok{"0"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBox}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ MinWidth=}\StringTok{"200"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

All label columns share the same width. Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Grid.cs}{\texttt{Grid.cs}}
and
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/DefinitionBase.cs}{\texttt{DefinitionBase.cs}}.

\subsubsection{\texorpdfstring{\texttt{GridSplitter}}{GridSplitter}}\label{gridsplitter}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Grid}\OtherTok{ ColumnDefinitions=}\StringTok{"3*,Auto,2*"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ Grid.Column=}\StringTok{"0"}\NormalTok{\textgreater{}...\textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{GridSplitter}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ Width=}\StringTok{"6"}\OtherTok{ ShowsPreview=}\StringTok{"True"}\OtherTok{ Background=}\StringTok{"\#DDD"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ Grid.Column=}\StringTok{"2"}\NormalTok{\textgreater{}...\textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{GridSplitter} lets users resize star-sized columns/rows.
Implementation:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/GridSplitter.cs}{\texttt{GridSplitter.cs}}.

\subsubsection{\texorpdfstring{\texttt{Viewbox} and
\texttt{LayoutTransformControl}}{Viewbox and LayoutTransformControl}}\label{viewbox-and-layouttransformcontrol}

\begin{itemize}
\tightlist
\item
  \texttt{Viewbox} scales its child proportionally to fit the available
  space.
\item
  \texttt{LayoutTransformControl} applies transforms (rotate, scale,
  skew) while preserving layout.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Viewbox}\OtherTok{ Stretch=}\StringTok{"Uniform"}\OtherTok{ Width=}\StringTok{"200"}\OtherTok{ Height=}\StringTok{"200"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Scaled"}\OtherTok{ FontSize=}\StringTok{"24"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Viewbox}\NormalTok{\textgreater{}}

\NormalTok{\textless{}}\KeywordTok{LayoutTransformControl}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{LayoutTransformControl.LayoutTransform}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{RotateTransform}\OtherTok{ Angle=}\StringTok{"{-}10"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{LayoutTransformControl.LayoutTransform}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Border}\OtherTok{ Padding=}\StringTok{"12"}\OtherTok{ Background=}\StringTok{"\#E7F1FF"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Rotated layout"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{LayoutTransformControl}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Sources:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Viewbox.cs}{\texttt{Viewbox.cs}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/LayoutTransformControl.cs}{\texttt{LayoutTransformControl.cs}}.

\subsubsection{\texorpdfstring{\texttt{Panel.ZIndex}}{Panel.ZIndex}}\label{panel.zindex}

Controls inside the same panel respect \texttt{Panel.ZIndex} for
stacking order. Higher ZIndex renders above lower values.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Canvas}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Rectangle}\OtherTok{ Width=}\StringTok{"100"}\OtherTok{ Height=}\StringTok{"80"}\OtherTok{ Fill=}\StringTok{"\#60FF0000"}\OtherTok{ Panel.ZIndex=}\StringTok{"1"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Rectangle}\OtherTok{ Width=}\StringTok{"120"}\OtherTok{ Height=}\StringTok{"60"}\OtherTok{ Fill=}\StringTok{"\#6000FF00"}\OtherTok{ Panel.ZIndex=}\StringTok{"2"}\OtherTok{ Margin=}\StringTok{"20,10,0,0"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Canvas}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsection{6. Scrolling and
LogicalScroll}\label{scrolling-and-logicalscroll}

\texttt{ScrollViewer} wraps content to provide scrolling. When the child
implements \texttt{ILogicalScrollable} (e.g., \texttt{ItemsPresenter}
with virtualization), the scrolling is smoother and can skip measurement
of offscreen content.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ScrollViewer}\OtherTok{ HorizontalScrollBarVisibility=}\StringTok{"Auto"}\OtherTok{ VerticalScrollBarVisibility=}\StringTok{"Auto"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ScrollViewer}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  For virtualization, panels may implement \texttt{ILogicalScrollable}
  (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/LogicalScroll.cs}{\texttt{LogicalScroll.cs}}).
\item
  \texttt{ScrollViewer} triggers layout when viewports change.
\end{itemize}

\subsection{7. Custom panels (when the built-ins aren't
enough)}\label{custom-panels-when-the-built-ins-arent-enough}

Derive from \texttt{Panel} and override
\texttt{MeasureOverride}/\texttt{ArrangeOverride} to create custom
layout logic. Example: a simplified \texttt{UniformGrid}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Controls}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Layout}\OperatorTok{;}

\KeywordTok{namespace}\NormalTok{ LayoutPlayground}\OperatorTok{.}\FunctionTok{Controls}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ UniformGridPanel }\OperatorTok{:}\NormalTok{ Panel}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static} \KeywordTok{readonly}\NormalTok{ StyledProperty}\OperatorTok{\textless{}}\DataTypeTok{int}\OperatorTok{\textgreater{}}\NormalTok{ ColumnsProperty }\OperatorTok{=}
\NormalTok{        AvaloniaProperty}\OperatorTok{.}\FunctionTok{Register}\OperatorTok{\textless{}}\NormalTok{UniformGridPanel}\OperatorTok{,} \DataTypeTok{int}\OperatorTok{\textgreater{}(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{Columns}\OperatorTok{),} \DecValTok{2}\OperatorTok{);}

    \KeywordTok{public} \DataTypeTok{int}\NormalTok{ Columns}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}} \FunctionTok{GetValue}\OperatorTok{(}\NormalTok{ColumnsProperty}\OperatorTok{);}
\NormalTok{        set }\OperatorTok{=\textgreater{}} \FunctionTok{SetValue}\OperatorTok{(}\NormalTok{ColumnsProperty}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{protected} \KeywordTok{override}\NormalTok{ Size }\FunctionTok{MeasureOverride}\OperatorTok{(}\NormalTok{Size availableSize}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ child }\KeywordTok{in}\NormalTok{ Children}\OperatorTok{)}
        \OperatorTok{\{}
\NormalTok{            child}\OperatorTok{.}\FunctionTok{Measure}\OperatorTok{(}\NormalTok{Size}\OperatorTok{.}\FunctionTok{Infinity}\OperatorTok{);}
        \OperatorTok{\}}

        \DataTypeTok{var}\NormalTok{ rows }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{int}\OperatorTok{)}\NormalTok{Math}\OperatorTok{.}\FunctionTok{Ceiling}\OperatorTok{(}\NormalTok{Children}\OperatorTok{.}\FunctionTok{Count} \OperatorTok{/} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\NormalTok{Columns}\OperatorTok{);}
        \DataTypeTok{var}\NormalTok{ cellWidth }\OperatorTok{=}\NormalTok{ availableSize}\OperatorTok{.}\FunctionTok{Width} \OperatorTok{/}\NormalTok{ Columns}\OperatorTok{;}
        \DataTypeTok{var}\NormalTok{ cellHeight }\OperatorTok{=}\NormalTok{ availableSize}\OperatorTok{.}\FunctionTok{Height} \OperatorTok{/}\NormalTok{ rows}\OperatorTok{;}

        \KeywordTok{return} \KeywordTok{new} \FunctionTok{Size}\OperatorTok{(}\NormalTok{cellWidth }\OperatorTok{*}\NormalTok{ Columns}\OperatorTok{,}\NormalTok{ cellHeight }\OperatorTok{*}\NormalTok{ rows}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{protected} \KeywordTok{override}\NormalTok{ Size }\FunctionTok{ArrangeOverride}\OperatorTok{(}\NormalTok{Size finalSize}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ rows }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{int}\OperatorTok{)}\NormalTok{Math}\OperatorTok{.}\FunctionTok{Ceiling}\OperatorTok{(}\NormalTok{Children}\OperatorTok{.}\FunctionTok{Count} \OperatorTok{/} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\NormalTok{Columns}\OperatorTok{);}
        \DataTypeTok{var}\NormalTok{ cellWidth }\OperatorTok{=}\NormalTok{ finalSize}\OperatorTok{.}\FunctionTok{Width} \OperatorTok{/}\NormalTok{ Columns}\OperatorTok{;}
        \DataTypeTok{var}\NormalTok{ cellHeight }\OperatorTok{=}\NormalTok{ finalSize}\OperatorTok{.}\FunctionTok{Height} \OperatorTok{/}\NormalTok{ rows}\OperatorTok{;}

        \KeywordTok{for} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ index }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ index }\OperatorTok{\textless{}}\NormalTok{ Children}\OperatorTok{.}\FunctionTok{Count}\OperatorTok{;}\NormalTok{ index}\OperatorTok{++)}
        \OperatorTok{\{}
            \DataTypeTok{var}\NormalTok{ child }\OperatorTok{=}\NormalTok{ Children}\OperatorTok{[}\NormalTok{index}\OperatorTok{];}
            \DataTypeTok{var}\NormalTok{ row }\OperatorTok{=}\NormalTok{ index }\OperatorTok{/}\NormalTok{ Columns}\OperatorTok{;}
            \DataTypeTok{var}\NormalTok{ column }\OperatorTok{=}\NormalTok{ index }\OperatorTok{\%}\NormalTok{ Columns}\OperatorTok{;}
            \DataTypeTok{var}\NormalTok{ rect }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Rect}\OperatorTok{(}\NormalTok{column }\OperatorTok{*}\NormalTok{ cellWidth}\OperatorTok{,}\NormalTok{ row }\OperatorTok{*}\NormalTok{ cellHeight}\OperatorTok{,}\NormalTok{ cellWidth}\OperatorTok{,}\NormalTok{ cellHeight}\OperatorTok{);}
\NormalTok{            child}\OperatorTok{.}\FunctionTok{Arrange}\OperatorTok{(}\NormalTok{rect}\OperatorTok{);}
        \OperatorTok{\}}

        \KeywordTok{return}\NormalTok{ finalSize}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  This panel ignores child desired sizes for simplicity; real panels
  usually respect \texttt{child.DesiredSize} from \texttt{Measure}.
\item
  Read \texttt{Layoutable} and \texttt{Panel} sources to understand
  helper methods like \texttt{ArrangeRect}.
\end{itemize}

\subsection{8. Layout diagnostics with
DevTools}\label{layout-diagnostics-with-devtools}

While running the app press \textbf{F12} -\textgreater{} Layout tab: -
Inspect the measurement and arrange rectangles for each control. -
Toggle the Layout Bounds overlay to visualise margins and paddings. -
Use the Render Options overlay to show dirty rectangles (requires
enabling \texttt{RendererDebugOverlays} in code: see
\texttt{RendererDebugOverlays.cs}).

You can also enable layout logging:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{LogToTrace}\OperatorTok{(}\NormalTok{LogEventLevel}\OperatorTok{.}\FunctionTok{Debug}\OperatorTok{,} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{}\NormalTok{ LogArea}\OperatorTok{.}\FunctionTok{Layout} \OperatorTok{\})}
    \OperatorTok{.}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{LogArea.Layout} logs measure/arrange operations to the console.

\subsection{9. Practice scenarios}\label{practice-scenarios}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Shared field labels}: Use \texttt{Grid.IsSharedSizeScope} and
  \texttt{SharedSizeGroup} across multiple form sections so labels align
  perfectly, even when collapsed sections are toggled.
\item
  \textbf{Resizable master-detail}: Combine \texttt{GridSplitter} with a
  two-column layout; ensure minimum sizes keep content readable.
\item
  \textbf{Rotated card}: Wrap a Border in
  \texttt{LayoutTransformControl} to rotate it; evaluate how alignment
  behaves inside the transform.
\item
  \textbf{Custom panel}: Replace a WrapPanel with your
  \texttt{UniformGridPanel} and compare measurement behaviour in
  DevTools.
\item
  \textbf{Scroll diagnostics}: Place a long list inside
  \texttt{ScrollViewer}, enable DevTools Layout overlay, and observe how
  viewport size changes the arrange rectangles.
\item
  \textbf{Layout logging}: Enable \texttt{LogArea.Layout} and capture a
  trace of \texttt{Measure}/\texttt{Arrange} calls when resizing.
  Inspect
  \texttt{LayoutManager.Instance.LayoutPassTiming.LastLayoutTime} to
  correlate with DevTools overlays.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-3}

\begin{itemize}
\tightlist
\item
  Base layout contract:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/Layoutable.cs}{\texttt{Layoutable.cs}}
\item
  Layout manager:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/LayoutManager.cs}{\texttt{LayoutManager.cs}}
\item
  Layout pass timing \& diagnostics:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/LayoutPassTiming.cs}{\texttt{LayoutPassTiming.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDebugOverlays.cs}{\texttt{RendererDebugOverlays.cs}}
\item
  Grid + shared size:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Grid.cs}{\texttt{Grid.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/DefinitionBase.cs}{\texttt{DefinitionBase.cs}}
\item
  Layout transforms:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/LayoutTransformControl.cs}{\texttt{LayoutTransformControl.cs}}
\item
  Scroll infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ScrollViewer.cs}{\texttt{ScrollViewer.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/LogicalScroll.cs}{\texttt{LogicalScroll.cs}}
\item
  Custom panels inspiration:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/VirtualizingStackPanel.cs}{\texttt{VirtualizingStackPanel.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-3}

\begin{itemize}
\tightlist
\item
  What two steps does the layout system run for every control, and which
  classes coordinate them?
\item
  How does \texttt{SharedSizeGroup} influence multiple grids? What
  property enables shared sizing?
\item
  When would you use \texttt{LayoutTransformControl} instead of a render
  transform?
\item
  What happens if you change \texttt{Panel.ZIndex} for children inside
  the same panel?
\item
  How can DevTools and logging help you diagnose a control that does not
  appear where expected?
\end{itemize}

What's next - Next: \href{Chapter06.md}{Chapter 6}

\newpage

\subsection{6. Controls tour you'll actually
use}\label{controls-tour-youll-actually-use}

Goal - Build confidence with Avalonia's everyday controls grouped by
scenario: text input, selection, navigation, editing, and feedback. -
Learn how to bind controls to view models, template items, and customise
interaction states. - Discover specialised controls such as
\texttt{NumericUpDown}, \texttt{MaskedTextBox},
\texttt{AutoCompleteBox}, \texttt{ColorPicker}, \texttt{TreeView},
\texttt{TabControl}, and \texttt{SplitView}. - Understand selection
models, virtualization, and templating so large lists stay responsive. -
Know where to find styles, templates, and extension points in the source
code.

Why this matters - Real apps mix many controls on the same screen.
Understanding their behaviour and key properties saves time. -
Avalonia's control set is broad; learning the structure of templates and
selection models prepares you for customisation later.

Prerequisites - You have built layouts (Chapter 5) and can bind data
(Chapter 3's data templates). Chapter 8 will deepen bindings further.

\subsection{1. Set up a sample project}\label{set-up-a-sample-project}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet}\NormalTok{ new avalonia.mvvm }\AttributeTok{{-}o}\NormalTok{ ControlsShowcase}
\BuiltInTok{cd}\NormalTok{ ControlsShowcase}
\end{Highlighting}
\end{Shaded}

We will extend \texttt{Views/MainWindow.axaml} with multiple sections
backed by \texttt{MainWindowViewModel}.

\subsection{2. Control overview matrix}\label{control-overview-matrix}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Scenario
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Key controls
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Highlights
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Source snapshot
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Text \& numeric input & \texttt{TextBox}, \texttt{MaskedTextBox},
\texttt{NumericUpDown}, \texttt{DatePicker} & Validation-friendly inputs
with watermarks, masks, spinner buttons, culture-aware dates &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TextBox.cs}{\texttt{TextBox.cs}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/MaskedTextBox/MaskedTextBox.cs}{\texttt{MaskedTextBox}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/NumericUpDown/NumericUpDown.cs}{\texttt{NumericUpDown}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/DateTimePickers/DatePicker.cs}{\texttt{DatePicker}} \\
Toggles \& commands & \texttt{ToggleSwitch}, \texttt{CheckBox},
\texttt{RadioButton}, \texttt{Button} & MVVM-friendly toggles and
grouped options with automation peers &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ToggleSwitch.cs}{\texttt{ToggleSwitch.cs}} \\
Lists \& selection & \texttt{ListBox}, \texttt{TreeView},
\texttt{SelectionModel}, \texttt{ItemsRepeater} & Single/multi-select,
hierarchical data, virtualization &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Selection/SelectionModel.cs}{\texttt{SelectionModel}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TreeView.cs}{\texttt{TreeView}} \\
Navigation surfaces & \texttt{TabControl}, \texttt{SplitView},
\texttt{Expander}, \texttt{TransitioningContentControl} & Tabbed pages,
collapsible panes, animated transitions &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SplitView/SplitView.cs}{\texttt{SplitView}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TransitioningContentControl.cs}{\texttt{TransitioningContentControl}} \\
Search \& pickers & \texttt{AutoCompleteBox}, \texttt{ComboBox},
\texttt{ColorPicker}, \texttt{FilePicker} dialogs & Suggest-as-you-type,
palette pickers, storage providers &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/AutoCompleteBox/AutoCompleteBox.cs}{\texttt{AutoCompleteBox}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls.ColorPicker/ColorPicker/ColorPicker.cs}{\texttt{ColorPicker}} \\
Command surfaces & \texttt{SplitButton}, \texttt{Menu},
\texttt{ContextMenu}, \texttt{Toolbar} & Primary/secondary actions,
keyboard shortcuts, flyouts &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SplitButton/SplitButton.cs}{\texttt{SplitButton}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Menu.cs}{\texttt{Menu}} \\
Refresh \& feedback & \texttt{RefreshContainer},
\texttt{RefreshVisualizer}, \texttt{WindowNotificationManager},
\texttt{StatusBar}, \texttt{NotificationCard} & Pull-to-refresh
gestures, toast notifications, status indicators &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/PullToRefresh/RefreshContainer.cs}{\texttt{RefreshContainer}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Notifications/WindowNotificationManager.cs}{\texttt{WindowNotificationManager}} \\
\end{longtable}

Use this table as a map while exploring ControlCatalog; each section
below dives into exemplars from these categories.

\subsection{3. Form inputs and validation
basics}\label{form-inputs-and-validation-basics}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{StackPanel}\OtherTok{ Spacing=}\StringTok{"16"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ Classes=}\StringTok{"h1"}\OtherTok{ Text=}\StringTok{"Customer profile"}\NormalTok{/\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{Grid}\OtherTok{ ColumnDefinitions=}\StringTok{"Auto,*"}\OtherTok{ RowDefinitions=}\StringTok{"Auto,Auto,Auto"}\OtherTok{ RowSpacing=}\StringTok{"8"}\OtherTok{ ColumnSpacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Name:"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBox}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ Text=}\StringTok{"\{Binding Customer.Name\}"}\OtherTok{ Watermark=}\StringTok{"Full name"}\NormalTok{/\textgreater{}}

\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ Text=}\StringTok{"Email:"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBox}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ Text=}\StringTok{"\{Binding Customer.Email\}"}\NormalTok{/\textgreater{}}

\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Grid.Row=}\StringTok{"2"}\OtherTok{ Text=}\StringTok{"Phone:"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{MaskedTextBox}\OtherTok{ Grid.Row=}\StringTok{"2"}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ Mask=}\StringTok{"(000) 000{-}0000"}\OtherTok{ Value=}\StringTok{"\{Binding Customer.Phone\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{NumericUpDown}\OtherTok{ Width=}\StringTok{"120"}\OtherTok{ Minimum=}\StringTok{"0"}\OtherTok{ Maximum=}\StringTok{"20"}\OtherTok{ Value=}\StringTok{"\{Binding Customer.Seats\}"}\OtherTok{ Header=}\StringTok{"Seats"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{DatePicker}\OtherTok{ SelectedDate=}\StringTok{"\{Binding Customer.RenewalDate\}"}\OtherTok{ Header=}\StringTok{"Renewal"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Notes: - \texttt{MaskedTextBox} lives in \texttt{Avalonia.Controls} (see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/MaskedTextBox/MaskedTextBox.cs}{\texttt{MaskedTextBox.cs}})
and enforces input patterns. - \texttt{NumericUpDown} (from
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/NumericUpDown/NumericUpDown.cs}{\texttt{NumericUpDown.cs}})
provides spinner buttons and numeric formatting. - Accessibility:
provide spoken labels via \texttt{AutomationProperties.Name} or
\texttt{HelpText} on inputs so screen readers identify the fields
correctly.

\subsection{4. Toggles, options, and
commands}\label{toggles-options-and-commands}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{GroupBox}\OtherTok{ Header=}\StringTok{"Plan options"}\OtherTok{ Padding=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ToggleSwitch}\OtherTok{ Header=}\StringTok{"Enable auto{-}renew"}\OtherTok{ IsChecked=}\StringTok{"\{Binding Customer.AutoRenew\}"}\NormalTok{/\textgreater{}}

\NormalTok{    \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{CheckBox}\OtherTok{ Content=}\StringTok{"Include analytics"}\OtherTok{ IsChecked=}\StringTok{"\{Binding Customer.IncludeAnalytics\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{CheckBox}\OtherTok{ Content=}\StringTok{"Priority support"}\OtherTok{ IsChecked=}\StringTok{"\{Binding Customer.IncludeSupport\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}

\NormalTok{    \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{RadioButton}\OtherTok{ GroupName=}\StringTok{"Plan"}\OtherTok{ Content=}\StringTok{"Starter"}\OtherTok{ IsChecked=}\StringTok{"\{Binding Customer.IsStarter\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{RadioButton}\OtherTok{ GroupName=}\StringTok{"Plan"}\OtherTok{ Content=}\StringTok{"Growth"}\OtherTok{ IsChecked=}\StringTok{"\{Binding Customer.IsGrowth\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{RadioButton}\OtherTok{ GroupName=}\StringTok{"Plan"}\OtherTok{ Content=}\StringTok{"Enterprise"}\OtherTok{ IsChecked=}\StringTok{"\{Binding Customer.IsEnterprise\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}

\NormalTok{    \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Save"}\OtherTok{ HorizontalAlignment=}\StringTok{"Left"}\OtherTok{ Command=}\StringTok{"\{Binding SaveCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{GroupBox}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{ToggleSwitch} gives a Fluent-styled toggle. Implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ToggleSwitch.cs}{\texttt{ToggleSwitch.cs}}.
\item
  RadioButtons share state via \texttt{GroupName} or \texttt{IsChecked}
  bindings.
\end{itemize}

\subsection{5. Selection lists with
templating}\label{selection-lists-with-templating}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{GroupBox}\OtherTok{ Header=}\StringTok{"Teams"}\OtherTok{ Padding=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ListBox}\OtherTok{ Items=}\StringTok{"\{Binding Teams\}"}\OtherTok{ SelectedItem=}\StringTok{"\{Binding SelectedTeam\}"}\OtherTok{ Height=}\StringTok{"160"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ListBox.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Ellipse}\OtherTok{ Width=}\StringTok{"24"}\OtherTok{ Height=}\StringTok{"24"}\OtherTok{ Fill=}\StringTok{"\{Binding Color\}"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Name\}"}\OtherTok{ FontWeight=}\StringTok{"SemiBold"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{ListBox.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ListBox}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{GroupBox}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{ListBox} supports selection out of the box. For custom
  selection logic, use \texttt{SelectionModel} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Selection/SelectionModel.cs}{\texttt{SelectionModel.cs}}).
\item
  Consider \texttt{ListBox.SelectionMode="Multiple"} for multi-select.
\end{itemize}

\subsubsection{Virtualization tip}\label{virtualization-tip}

Large lists should virtualize. Use \texttt{ListBox} with the default
\texttt{VirtualizingStackPanel} or switch panels:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ListBox}\OtherTok{ Items=}\StringTok{"\{Binding ManyItems\}"}\OtherTok{ VirtualizingPanel.IsVirtualizing=}\StringTok{"True"}\OtherTok{ VirtualizingPanel.CacheLength=}\StringTok{"2"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

Controls for virtualization:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/VirtualizingStackPanel.cs}{\texttt{VirtualizingStackPanel.cs}}.

\subsection{\texorpdfstring{6. Hierarchical data with
\texttt{TreeView}}{6. Hierarchical data with TreeView}}\label{hierarchical-data-with-treeview}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TreeView}\OtherTok{ Items=}\StringTok{"\{Binding Departments\}"}\OtherTok{ SelectedItems=}\StringTok{"\{Binding SelectedDepartments\}"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TreeView.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TreeDataTemplate}\OtherTok{ ItemsSource=}\StringTok{"\{Binding Teams\}"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Name\}"}\OtherTok{ FontWeight=}\StringTok{"SemiBold"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{TreeDataTemplate.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Name\}"}\OtherTok{ Margin=}\StringTok{"24,0,0,0"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{TreeDataTemplate.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{TreeDataTemplate}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{TreeView.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{TreeView}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{TreeView} uses \texttt{TreeDataTemplate} to describe
  hierarchical data. Each template can reference a property
  (\texttt{Teams}) for child items.
\item
  Source implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TreeView.cs}{\texttt{TreeView.cs}}.
\end{itemize}

\subsection{\texorpdfstring{7. Navigation controls (\texttt{TabControl},
\texttt{SplitView},
\texttt{Expander})}{7. Navigation controls (TabControl, SplitView, Expander)}}\label{navigation-controls-tabcontrol-splitview-expander}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TabControl}\OtherTok{ SelectedIndex=}\StringTok{"\{Binding SelectedTab\}"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TabItem}\OtherTok{ Header=}\StringTok{"Overview"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Overview content"}\OtherTok{ Margin=}\StringTok{"12"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{TabItem}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TabItem}\OtherTok{ Header=}\StringTok{"Reports"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Reports content"}\OtherTok{ Margin=}\StringTok{"12"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{TabItem}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TabItem}\OtherTok{ Header=}\StringTok{"Settings"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Settings content"}\OtherTok{ Margin=}\StringTok{"12"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{TabItem}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{TabControl}\NormalTok{\textgreater{}}

\NormalTok{\textless{}}\KeywordTok{SplitView}\OtherTok{ DisplayMode=}\StringTok{"CompactInline"}
\OtherTok{          IsPaneOpen=}\StringTok{"\{Binding IsPaneOpen\}"}
\OtherTok{          OpenPaneLength=}\StringTok{"240"}\OtherTok{ CompactPaneLength=}\StringTok{"56"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{SplitView.Pane}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{NavigationViewContent}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{SplitView.Pane}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{SplitView.Content}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Frame}\OtherTok{ Content=}\StringTok{"\{Binding ActivePage\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{SplitView.Content}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{SplitView}\NormalTok{\textgreater{}}

\NormalTok{\textless{}}\KeywordTok{Expander}\OtherTok{ Header=}\StringTok{"Advanced filters"}\OtherTok{ IsExpanded=}\StringTok{"False"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ Margin=}\StringTok{"12"}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ComboBox}\OtherTok{ Items=}\StringTok{"\{Binding FilterSets\}"}\OtherTok{ SelectedItem=}\StringTok{"\{Binding SelectedFilter\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{CheckBox}\OtherTok{ Content=}\StringTok{"Include archived"}\OtherTok{ IsChecked=}\StringTok{"\{Binding IncludeArchived\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Expander}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{TabControl} enables tabbed navigation. Tab headers are
  content--you can template them via \texttt{TabControl.ItemTemplate}.
\item
  \texttt{SplitView} (from
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SplitView/SplitView.cs}{\texttt{SplitView.cs}})
  provides collapsible navigation, useful for sidebars.
\item
  \texttt{Expander} collapses/expands content. Implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Expander.cs}{\texttt{Expander.cs}}.
\end{itemize}

\subsection{8. Auto-complete, pickers, and
dialogs}\label{auto-complete-pickers-and-dialogs}

\subsection{9. Command surfaces and
flyouts}\label{command-surfaces-and-flyouts}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{StackPanel}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{SplitButton}\OtherTok{ Content=}\StringTok{"Export"}\OtherTok{ Command=}\StringTok{"\{Binding ExportAllCommand\}"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{SplitButton.Flyout}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{MenuFlyout}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"Export CSV"}\OtherTok{ Command=}\StringTok{"\{Binding ExportCsvCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"Export JSON"}\OtherTok{ Command=}\StringTok{"\{Binding ExportJsonCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"Export PDF"}\OtherTok{ Command=}\StringTok{"\{Binding ExportPdfCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{MenuFlyout}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{SplitButton.Flyout}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{SplitButton}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{Menu}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"File"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"New"}\OtherTok{ Command=}\StringTok{"\{Binding NewCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"Open..."}\OtherTok{ Command=}\StringTok{"\{Binding OpenCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Separator}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"Exit"}\OtherTok{ Command=}\StringTok{"\{Binding ExitCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{MenuItem}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"Help"}\OtherTok{ Command=}\StringTok{"\{Binding ShowHelpCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Menu}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Copy"}\OtherTok{ Command=}\StringTok{"\{Binding CopyCommand\}"}\OtherTok{ HotKey=}\StringTok{"Ctrl+C"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Paste"}\OtherTok{ Command=}\StringTok{"\{Binding PasteCommand\}"}\OtherTok{ HotKey=}\StringTok{"Ctrl+V"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Notes: - \texttt{SplitButton} exposes a primary command and a flyout for
secondary options. Automation peers surface both the button and flyout;
see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SplitButton/SplitButton.cs}{\texttt{SplitButton.cs}}.
- \texttt{Menu}/\texttt{ContextMenu} support keyboard navigation and
\texttt{AutomationProperties.AcceleratorKey} so shortcuts are announced
to assistive tech. Implementation:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Menu.cs}{\texttt{Menu.cs}}.
- Flyouts can host any control (\texttt{MenuFlyout}, \texttt{Popup},
\texttt{FlyoutBase}). Use \texttt{FlyoutBase.ShowAttachedFlyout} to open
context actions from command handlers.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{StackPanel}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{AutoCompleteBox}\OtherTok{ Width=}\StringTok{"240"}
\OtherTok{                   Items=}\StringTok{"\{Binding Suggestions\}"}
\OtherTok{                   Text=}\StringTok{"\{Binding Query, Mode=TwoWay\}"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{AutoCompleteBox.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Icon\}"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Title\}"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{AutoCompleteBox.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{AutoCompleteBox}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{ColorPicker}\OtherTok{ SelectedColor=}\StringTok{"\{Binding ThemeColor\}"}\NormalTok{/\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Choose files"}\OtherTok{ Command=}\StringTok{"\{Binding OpenFilesCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{AutoCompleteBox} helps with large suggestion lists. Source:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/AutoCompleteBox/AutoCompleteBox.cs}{\texttt{AutoCompleteBox.cs}}.
\item
  \texttt{ColorPicker} shows palettes, sliders, and input fields (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls.ColorPicker/ColorPicker.cs}{\texttt{ColorPicker.cs}}).
\item
  File pickers will use \texttt{IStorageProvider} (Chapter 16).
\end{itemize}

\subsection{10. Refresh gestures and
feedback}\label{refresh-gestures-and-feedback}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window}\OtherTok{ xmlns:ptr=}\StringTok{"clr{-}namespace:Avalonia.Controls;assembly=Avalonia.Controls"}
\OtherTok{        xmlns:notifications=}\StringTok{"clr{-}namespace:Avalonia.Controls.Notifications;assembly=Avalonia.Controls"}
        \ErrorTok{...}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ptr:RefreshContainer}\OtherTok{ RefreshRequested=}\StringTok{"OnRefreshRequested"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{ptr:RefreshContainer.Visualizer}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{ptr:RefreshVisualizer}\OtherTok{ Orientation=}\StringTok{"TopToBottom"}
\OtherTok{                                Content=}\StringTok{"Pull to refresh"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{ptr:RefreshContainer.Visualizer}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{ScrollViewer}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{ItemsControl}\OtherTok{ Items=}\StringTok{"\{Binding Orders\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{ScrollViewer}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{ptr:RefreshContainer}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Window}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private}\NormalTok{ async }\DataTypeTok{void} \FunctionTok{OnRefreshRequested}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ RefreshRequestedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{using} \DataTypeTok{var}\NormalTok{ deferral }\OperatorTok{=}\NormalTok{ e}\OperatorTok{.}\FunctionTok{GetDeferral}\OperatorTok{();}
\NormalTok{    await ViewModel}\OperatorTok{.}\FunctionTok{ReloadAsync}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{RefreshContainer} + \texttt{RefreshVisualizer} implement
  pull-to-refresh on any scrollable surface. Source:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/PullToRefresh/RefreshContainer.cs}{\texttt{RefreshContainer}}.
\item
  Always provide an alternate refresh action (button, keyboard) for
  desktop scenarios.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ notifications }\OperatorTok{=} \KeywordTok{new} \FunctionTok{WindowNotificationManager}\OperatorTok{(}\KeywordTok{this}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    Position }\OperatorTok{=}\NormalTok{ NotificationPosition}\OperatorTok{.}\FunctionTok{TopRight}\OperatorTok{,}
\NormalTok{    MaxItems }\OperatorTok{=} \DecValTok{3}
\OperatorTok{\};}
\NormalTok{notifications}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Notification}\OperatorTok{(}\StringTok{"Update available"}\OperatorTok{,} \StringTok{"Restart to apply updates."}\OperatorTok{,}\NormalTok{ NotificationType}\OperatorTok{.}\FunctionTok{Success}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{WindowNotificationManager} displays toast notifications
  layered over the current window; combine with inline
  \texttt{NotificationCard} or \texttt{InfoBar} for longer-lived
  messages. Sources:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Notifications/WindowNotificationManager.cs}{\texttt{WindowNotificationManager}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Notifications/NotificationCard.cs}{\texttt{NotificationCard}}.
\item
  Mark status changes with
  \texttt{AutomationProperties.LiveSetting="Polite"} so assistive
  technologies announce them.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{StatusBar}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{StatusBarItem}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Ready"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{ProgressBar}\OtherTok{ Width=}\StringTok{"120"}\OtherTok{ IsIndeterminate=}\StringTok{"\{Binding IsBusy\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StatusBarItem}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{StatusBarItem}\OtherTok{ HorizontalAlignment=}\StringTok{"Right"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"v1.2.0"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StatusBarItem}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{StatusBar}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{StatusBar} hosts persistent indicators (connection status,
  progress). Implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/StatusBar/StatusBar.cs}{\texttt{StatusBar}}.
\end{itemize}

\subsection{11. Styling, classes, and visual
states}\label{styling-classes-and-visual-states}

Use classes (\texttt{Classes="primary"}) or pseudo-classes
(\texttt{:pointerover}, \texttt{:pressed}, \texttt{:checked}) to style
stateful controls:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Primary"}\OtherTok{ Classes=}\StringTok{"primary"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Style}\OtherTok{ Selector=}\StringTok{"Button.primary"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Background"}\OtherTok{ Value=}\StringTok{"\{DynamicResource AccentBrush\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Foreground"}\OtherTok{ Value=}\StringTok{"White"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}

\NormalTok{\textless{}}\KeywordTok{Style}\OtherTok{ Selector=}\StringTok{"Button.primary:pointerover"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Background"}\OtherTok{ Value=}\StringTok{"\{DynamicResource AccentBrush2\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Styles live in \texttt{App.axaml} or separate resource dictionaries.
Control templates are defined under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent/Controls}{\texttt{src/Avalonia.Themes.Fluent}}.
Inspect \texttt{Button.xaml}, \texttt{ListBox.xaml}, etc., to understand
structure and visual states.

\subsection{12. ControlCatalog treasure
hunt}\label{controlcatalog-treasure-hunt}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Clone the Avalonia repository and run the ControlCatalog (Desktop)
  sample:
  \texttt{dotnet\ run\ -\/-project\ samples/ControlCatalog.Desktop/ControlCatalog.Desktop.csproj}.
\item
  Use the built-in search to find controls. Explore the \texttt{Source}
  tab to jump to relevant XAML or C\# files.
\item
  Compare ControlCatalog pages with the source directory structure:

  \begin{itemize}
  \tightlist
  \item
    Text input demos map to
    \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TextBox.cs}{\texttt{src/Avalonia.Controls/TextBox.cs}}.
  \item
    Collections and virtualization demos map to
    \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/VirtualizingStackPanel.cs}{\texttt{VirtualizingStackPanel.cs}}.
  \item
    Navigation samples map to
    \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SplitView/SplitView.cs}{\texttt{SplitView.cs}}
    and \texttt{TabControl} templates.
  \end{itemize}
\end{enumerate}

\subsection{13. Practice exercises}\label{practice-exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a ``dashboard'' page mixing text input, selection lists, tabs,
  a \texttt{SplitButton}, and a collapsible filter panel. Bind every
  control to a view model.
\item
  Add an \texttt{AutoCompleteBox} that filters as you type. Use DevTools
  to inspect the generated \texttt{ListBox} inside the control and
  verify automation names.
\item
  Replace the \texttt{ListBox} with a \texttt{TreeView} for hierarchical
  data; add an \texttt{Expander} per root item.
\item
  Wire up a \texttt{RefreshContainer} around a scrollable list and
  implement the \texttt{RefreshRequested} deferal pattern. Provide a
  fallback refresh button for keyboard users.
\item
  Register a singleton \texttt{WindowNotificationManager}, show a toast
  when the refresh completes, and style inline \texttt{NotificationCard}
  messages for success and error states.
\item
  Customise button states by adding pseudo-class styles and confirm they
  match the ControlCatalog defaults.
\item
  Swap the \texttt{WrapPanel} for an \texttt{ItemsRepeater} (Chapter 14)
  to prepare for virtualization scenarios.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-4}

\begin{itemize}
\tightlist
\item
  Core controls:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls}{\texttt{src/Avalonia.Controls}}
\item
  Specialized controls:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls.ColorPicker}{\texttt{src/Avalonia.Controls.ColorPicker}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/NumericUpDown}{\texttt{src/Avalonia.Controls.NumericUpDown}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/AutoCompleteBox}{\texttt{src/Avalonia.Controls.AutoCompleteBox}}
\item
  Command \& navigation surfaces:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/SplitButton}{\texttt{src/Avalonia.Controls/SplitButton}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/SplitView}{\texttt{src/Avalonia.Controls/SplitView}}
\item
  Refresh \& notifications:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/PullToRefresh}{\texttt{src/Avalonia.Controls/PullToRefresh}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/Notifications}{\texttt{src/Avalonia.Controls/Notifications}}
\item
  Selection framework:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/Selection}{\texttt{src/Avalonia.Controls/Selection}}
\item
  Styles and templates:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent/Controls}{\texttt{src/Avalonia.Themes.Fluent/Controls}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-4}

\begin{itemize}
\tightlist
\item
  Which controls would you choose for numeric input, masked input, and
  auto-completion?
\item
  How do you template \texttt{ListBox} items and enable virtualization
  for large datasets?
\item
  Where do you look to customise the appearance of a
  \texttt{ToggleSwitch}?
\item
  What role does \texttt{SelectionModel} play for advanced selection
  scenarios?
\item
  How can ControlCatalog help you explore a control's API and default
  styles?
\end{itemize}

What's next - Next: \href{Chapter07.md}{Chapter 7}

\newpage

\subsection{7. Fluent theming and styles made
simple}\label{fluent-theming-and-styles-made-simple}

Goal - Understand Avalonia's Fluent theme architecture, theme variants,
and how theme resources flow through your app. - Organise resources and
styles with \texttt{ResourceInclude}, \texttt{StyleInclude},
\texttt{ThemeVariantScope}, and \texttt{ControlTheme} for clean reuse. -
Override control templates, use pseudo-classes, and scope theme changes
to specific regions. - Support runtime theme switching (light/dark/high
contrast) and accessibility requirements. - Map the styles you edit to
the Fluent source files so you can explore defaults and extend them
safely.

Why this matters - Styling controls consistently is the difference
between a polished UI and visual chaos. - Avalonia's Fluent theme ships
with rich resources; knowing how to extend them keeps your design system
maintainable. - Accessibility requirements (contrast, theming per
surface) are easier when you understand theme scoping and dynamic
resources.

Prerequisites - Comfort editing \texttt{App.axaml}, windows, and user
controls (Chapters 3-6). - Basic understanding of data binding and
commands (Chapters 3, 6).

\subsection{1. Fluent theme in a
nutshell}\label{fluent-theme-in-a-nutshell}

Avalonia ships with Fluent 2 based resources and templates. The theme
lives under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent}{\texttt{src/Avalonia.Themes.Fluent}}.
Templates reference resource keys (brushes, thicknesses, typography)
that resolve per theme variant.

\texttt{App.axaml} typically looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Application}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{             xmlns:x=}\StringTok{"http://schemas.microsoft.com/winfx/2006/xaml"}
\OtherTok{             x:Class=}\StringTok{"ThemePlayground.App"}
\OtherTok{             RequestedThemeVariant=}\StringTok{"Light"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Application.Styles}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{FluentTheme}\OtherTok{ Mode=}\StringTok{"Light"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Application.Styles}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Application}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{RequestedThemeVariant} controls the global variant
  (\texttt{ThemeVariant.Light}, \texttt{ThemeVariant.Dark},
  \texttt{ThemeVariant.HighContrast}).
\item
  \texttt{FluentTheme} can be configured with \texttt{Mode="Light"},
  \texttt{Mode="Dark"}, or \texttt{Mode="Default"} (auto based on OS
  hints). Source:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Themes.Fluent/FluentTheme.cs}{\texttt{FluentTheme.cs}}.
\end{itemize}

\subsection{2. Structure resources into
dictionaries}\label{structure-resources-into-dictionaries}

Split large resource sets into dedicated files. Create
\texttt{Styles/Colors.axaml}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ResourceDictionary}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Color}\OtherTok{ x:Key=}\StringTok{"BrandPrimaryColor"}\NormalTok{\textgreater{}\#2563EB\textless{}/}\KeywordTok{Color}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Color}\OtherTok{ x:Key=}\StringTok{"BrandPrimaryHover"}\NormalTok{\textgreater{}\#1D4ED8\textless{}/}\KeywordTok{Color}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{SolidColorBrush}\OtherTok{ x:Key=}\StringTok{"BrandPrimaryBrush"}
\OtherTok{                   Color=}\StringTok{"\{DynamicResource BrandPrimaryColor\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{SolidColorBrush}\OtherTok{ x:Key=}\StringTok{"BrandPrimaryHoverBrush"}
\OtherTok{                   Color=}\StringTok{"\{DynamicResource BrandPrimaryHover\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Then create \texttt{Styles/Controls.axaml}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Styles}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Style}\OtherTok{ Selector=}\StringTok{"Button.primary"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Background"}\OtherTok{ Value=}\StringTok{"\{DynamicResource BrandPrimaryBrush\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Foreground"}\OtherTok{ Value=}\StringTok{"White"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Padding"}\OtherTok{ Value=}\StringTok{"14,10"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"CornerRadius"}\OtherTok{ Value=}\StringTok{"6"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{Style}\OtherTok{ Selector=}\StringTok{"Button.primary:pointerover"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Background"}\OtherTok{ Value=}\StringTok{"\{DynamicResource BrandPrimaryHoverBrush\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Styles}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Include them in \texttt{App.axaml}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Application} \ErrorTok{...}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Application.Resources}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ResourceInclude}\OtherTok{ Source=}\StringTok{"avares://ThemePlayground/Styles/Colors.axaml"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Application.Resources}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Application.Styles}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{FluentTheme}\OtherTok{ Mode=}\StringTok{"Default"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{StyleInclude}\OtherTok{ Source=}\StringTok{"avares://ThemePlayground/Styles/Controls.axaml"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Application.Styles}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Application}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{ResourceInclude} expects a \texttt{ResourceDictionary} root
  and merges it into the resource lookup chain. Use it for brushes,
  colors, converters, and typography resources.
\item
  \texttt{StyleInclude} expects \texttt{Styles} (or a single
  \texttt{Style}) and registers selectors. Use
  \texttt{avares://Assembly/Path.axaml} URIs to include styles from
  other assemblies (for example,
  \texttt{avares://Avalonia.Themes.Fluent/Controls/Button.xaml}).
\item
  When you rename assemblies or move resource files, update the
  \texttt{Source} URI; missing includes surface as
  \texttt{XamlLoadException} during startup.
\end{itemize}

\subsection{3. Static vs dynamic
resources}\label{static-vs-dynamic-resources}

\begin{itemize}
\tightlist
\item
  \texttt{StaticResource} resolves once during load. Use it for values
  that never change (fonts, corner radius constants).
\item
  \texttt{DynamicResource} re-evaluates when the resource is replaced at
  runtime--essential for theme switching.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Border}\OtherTok{ CornerRadius=}\StringTok{"\{StaticResource CornerRadiusMedium\}"}
\OtherTok{        Background=}\StringTok{"\{DynamicResource BrandPrimaryBrush\}"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

Resource lookup order: 1. Control-local resources
(\texttt{this.Resources}). 2. Logical tree parents (user controls,
windows). 3. \texttt{Application.Resources}. 4. Theme dictionaries
merged by \texttt{FluentTheme} (light/dark/high contrast). 5. System
theme fallbacks.

The implementation lives in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Resources/ResourceDictionary.cs}{\texttt{ResourceDictionary.cs}}.
DevTools -\textgreater{} Resources panel shows the chain and which
dictionary satisfied a lookup.

\subsection{4. Theme variant scope (local
theming)}\label{theme-variant-scope-local-theming}

\subsection{5. Migrating and overriding Fluent
resources}\label{migrating-and-overriding-fluent-resources}

When you need to change Fluent defaults globally (for example, switch
accent colors or typography), supply variant-specific dictionaries.
Place these under \texttt{Application.Resources} with a
\texttt{ThemeVariant} attribute so they override the theme-provided
value only for matching variants.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Application.Resources}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ResourceInclude}\OtherTok{ Source=}\StringTok{"avares://ThemePlayground/Styles/Colors.axaml"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ResourceDictionary}\OtherTok{ ThemeVariant=}\StringTok{"Light"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{SolidColorBrush}\OtherTok{ x:Key=}\StringTok{"SystemAccentColor"}\OtherTok{ Color=}\StringTok{"\#2563EB"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ResourceDictionary}\OtherTok{ ThemeVariant=}\StringTok{"Dark"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{SolidColorBrush}\OtherTok{ x:Key=}\StringTok{"SystemAccentColor"}\OtherTok{ Color=}\StringTok{"\#60A5FA"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Application.Resources}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Keys that match Fluent resources (\texttt{SystemAccentColor},
  \texttt{SystemControlBackgroundBaseLowBrush}, etc.) override the
  defaults only for the specified variant.
\item
  Keep overrides minimal: inspect the Fluent source to copy exact keys.
  Replace \texttt{FluentTheme} with \texttt{SimpleTheme} if you want the
  simple default look.
\item
  To migrate an existing design system, split colors/typography into
  \texttt{ResourceDictionary} files and create \texttt{ControlTheme}
  overrides for specific controls rather than editing Fluent templates
  in place.
\end{itemize}

\texttt{ThemeVariantScope} lets you apply a specific theme to part of
the UI. Implementation:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ThemeVariantScope.cs}{\texttt{ThemeVariantScope.cs}}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ThemeVariantScope}\OtherTok{ RequestedThemeVariant=}\StringTok{"Dark"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Border}\OtherTok{ Padding=}\StringTok{"16"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{TextBlock}\OtherTok{ Classes=}\StringTok{"h2"}\OtherTok{ Text=}\StringTok{"Dark section"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Dark themed button"}\OtherTok{ Classes=}\StringTok{"primary"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ThemeVariantScope}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Everything inside the scope resolves resources as if the app were using
\texttt{ThemeVariant.Dark}. Useful for popovers or modal sheets.

\subsection{6. Runtime theme switching}\label{runtime-theme-switching}

Add a toggle to your main view:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ToggleSwitch}\OtherTok{ Content=}\StringTok{"Dark mode"}\OtherTok{ IsChecked=}\StringTok{"\{Binding IsDark\}"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

In the view model:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Styling}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ ShellViewModel }\OperatorTok{:}\NormalTok{ ObservableObject}
\OperatorTok{\{}
    \KeywordTok{private} \DataTypeTok{bool}\NormalTok{ \_isDark}\OperatorTok{;}
    \KeywordTok{public} \DataTypeTok{bool}\NormalTok{ IsDark}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_isDark}\OperatorTok{;}
\NormalTok{        set}
        \OperatorTok{\{}
            \KeywordTok{if} \OperatorTok{(}\FunctionTok{SetProperty}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_isDark}\OperatorTok{,}\NormalTok{ value}\OperatorTok{))}
            \OperatorTok{\{}
\NormalTok{                Application}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{!.}\FunctionTok{RequestedThemeVariant} \OperatorTok{=}\NormalTok{ value }\OperatorTok{?}\NormalTok{ ThemeVariant}\OperatorTok{.}\FunctionTok{Dark} \OperatorTok{:}\NormalTok{ ThemeVariant}\OperatorTok{.}\FunctionTok{Light}\OperatorTok{;}
            \OperatorTok{\}}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Because button styles use \texttt{DynamicResource}, they respond
immediately. For per-window overrides set \texttt{RequestedThemeVariant}
on the window itself or wrap content in \texttt{ThemeVariantScope}.

\subsection{\texorpdfstring{7. Customizing control templates with
\texttt{ControlTheme}}{7. Customizing control templates with ControlTheme}}\label{customizing-control-templates-with-controltheme}

\texttt{ControlTheme} lets you replace a control's default template and
resources without subclassing. Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/ControlTheme.cs}{\texttt{ControlTheme.cs}}.

Example: create a pill-shaped toggle button theme in
\texttt{Styles/ToggleButton.axaml}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ResourceDictionary}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{                    xmlns:x=}\StringTok{"http://schemas.microsoft.com/winfx/2006/xaml"}
\OtherTok{                    xmlns:themes=}\StringTok{"clr{-}namespace:Avalonia.Themes.Fluent;assembly=Avalonia.Themes.Fluent"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ControlTheme}\OtherTok{ x:Key=}\StringTok{"PillToggleTheme"}\OtherTok{ TargetType=}\StringTok{"ToggleButton"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Template"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{ControlTemplate}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{Border}\OtherTok{ x:Name=}\StringTok{"PART\_Root"}
\OtherTok{                Background=}\StringTok{"\{TemplateBinding Background\}"}
\OtherTok{                CornerRadius=}\StringTok{"20"}
\OtherTok{                Padding=}\StringTok{"\{TemplateBinding Padding\}"}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{ContentPresenter}\OtherTok{ HorizontalAlignment=}\StringTok{"Center"}
\OtherTok{                            VerticalAlignment=}\StringTok{"Center"}
\OtherTok{                            Content=}\StringTok{"\{TemplateBinding Content\}"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{ControlTemplate}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Setter}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ControlTheme}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Apply it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ToggleButton}\OtherTok{ Content=}\StringTok{"Pill"}\OtherTok{ Theme=}\StringTok{"\{StaticResource PillToggleTheme\}"}\OtherTok{ padding=}\StringTok{"12,6"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

To inherit Fluent visual states, you can base your theme on existing
resources by referencing \texttt{themes:ToggleButtonTheme}. Inspect
templates in
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent/Controls}{\texttt{src/Avalonia.Themes.Fluent/Controls}}
for structure and named parts.

\subsection{8. Working with pseudo-classes and
classes}\label{working-with-pseudo-classes-and-classes}

Use pseudo-classes to target interaction states. Example for
\texttt{ToggleSwitch}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Style}\OtherTok{ Selector=}\StringTok{"ToggleSwitch:checked"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"ThumbBrush"}\OtherTok{ Value=}\StringTok{"\{DynamicResource BrandPrimaryBrush\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}

\NormalTok{\textless{}}\KeywordTok{Style}\OtherTok{ Selector=}\StringTok{"ToggleSwitch:checked:focus"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"BorderBrush"}\OtherTok{ Value=}\StringTok{"\{DynamicResource BrandPrimaryHoverBrush\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Pseudo-class
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Applies when
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{:pointerover} & Pointer hovers over the control \\
\texttt{:pressed} & Pointer is pressed / command triggered \\
\texttt{:checked} & Toggleable control is on (\texttt{CheckBox},
\texttt{ToggleSwitch}, \texttt{RadioButton}) \\
\texttt{:focus} / \texttt{:focus-within} & Control (or a descendant) has
keyboard focus \\
\texttt{:disabled} & \texttt{IsEnabled\ =\ false} \\
\texttt{:invalid} & A binding reports validation errors \\
\end{longtable}

Pseudo-class documentation lives in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/docs/styles/selectors.md}{\texttt{Selectors.md}}
and runtime code under
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Styling/Selector.cs}{\texttt{Selector.cs}}.
Combine pseudo-classes with style classes (e.g.,
\texttt{Button.primary:pointerover}) to keep state-specific visuals
consistent and accessible.

\subsection{9. Accessibility and high contrast
themes}\label{accessibility-and-high-contrast-themes}

Fluent ships high contrast resources. Switch by setting
\texttt{RequestedThemeVariant="HighContrast"}.

\begin{itemize}
\tightlist
\item
  Provide alternative color dictionaries with increased contrast ratios.
\item
  Use \texttt{DynamicResource} for all brushes so high contrast palettes
  propagate automatically.
\item
  Test with screen readers and OS high contrast modes; ensure custom
  colors respect \texttt{ThemeVariant.HighContrast}.
\end{itemize}

Example dictionary addition:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ResourceDictionary}\OtherTok{ ThemeVariant=}\StringTok{"HighContrast"}
\OtherTok{                    xmlns=}\StringTok{"https://github.com/avaloniaui"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{SolidColorBrush}\OtherTok{ x:Key=}\StringTok{"BrandPrimaryBrush"}\OtherTok{ Color=}\StringTok{"\#00AACC"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{SolidColorBrush}\OtherTok{ x:Key=}\StringTok{"BrandPrimaryHoverBrush"}\OtherTok{ Color=}\StringTok{"\#007C99"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{ThemeVariant}-specific dictionaries override defaults when the
variant matches.

\subsection{10. Debugging styles with
DevTools}\label{debugging-styles-with-devtools}

Press \textbf{F12} to open DevTools -\textgreater{} Styles panel: -
Inspect applied styles, pseudo-classes, and resources. - Use the palette
to modify brushes live and copy the generated XAML. - Toggle the
\texttt{ThemeVariant} dropdown in DevTools (bottom) to preview
Light/Dark/HighContrast variants.

Enable style diagnostics via logging:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{LogToTrace}\OperatorTok{(}\NormalTok{LogEventLevel}\OperatorTok{.}\FunctionTok{Debug}\OperatorTok{,} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{}\NormalTok{ LogArea}\OperatorTok{.}\FunctionTok{Binding}\OperatorTok{,}\NormalTok{ LogArea}\OperatorTok{.}\FunctionTok{Styling} \OperatorTok{\})}
    \OperatorTok{.}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsection{11. Practice exercises}\label{practice-exercises-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Create a brand palette}: define primary and secondary brushes
  with theme-specific overrides (light/dark/high contrast) and apply
  them to buttons and toggles.
\item
  \textbf{Scope a sub-view}: wrap a settings pane in
  \texttt{ThemeVariantScope\ RequestedThemeVariant="Dark"} to preview
  dual-theme experiences.
\item
  \textbf{Control template override}: create a \texttt{ControlTheme} for
  \texttt{Button} that changes the visual tree (e.g., adds an icon
  placeholder) and apply it selectively.
\item
  \textbf{Runtime theme switching}: wire a \texttt{ToggleSwitch} or menu
  command to flip between Light/Dark; ensure all custom brushes use
  \texttt{DynamicResource}.
\item
  \textbf{DevTools audit}: use DevTools to inspect pseudo-classes on a
  \texttt{ToggleSwitch} and verify your custom styles apply in
  \texttt{:checked} and \texttt{:focus} states.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-5}

\begin{itemize}
\tightlist
\item
  Theme variant scoping:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ThemeVariantScope.cs}{\texttt{ThemeVariantScope.cs}}
\item
  Control themes and styles:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/ControlTheme.cs}{\texttt{ControlTheme.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/Style.cs}{\texttt{Style.cs}}
\item
  Selector engine \& pseudo-classes:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Styling/Selector.cs}{\texttt{Selector.cs}}
\item
  Fluent resources and templates:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent/Controls}{\texttt{src/Avalonia.Themes.Fluent/Controls}}
\item
  Theme variant definitions:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Styling/ThemeVariant.cs}{\texttt{ThemeVariant.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-5}

\begin{itemize}
\tightlist
\item
  How do \texttt{ResourceInclude} and \texttt{StyleInclude} differ, and
  what root elements do they expect?
\item
  When should you use \texttt{ThemeVariantScope} versus changing
  \texttt{RequestedThemeVariant} on the application?
\item
  What advantages does \texttt{ControlTheme} give over subclassing a
  control?
\item
  Why do you prefer \texttt{DynamicResource} for brushes that change
  with theme switches?
\item
  Where would you inspect the default template for \texttt{ToggleSwitch}
  or \texttt{ComboBox}?
\end{itemize}

What's next - Next: \href{Chapter08.md}{Chapter 8}

\newpage

\subsection{8. Data binding basics you'll use every
day}\label{data-binding-basics-youll-use-every-day}

Goal - Understand the binding engine (DataContext, binding paths,
inheritance) and when to use different binding modes. - Work with
binding variations (\texttt{Binding}, \texttt{CompiledBinding},
\texttt{MultiBinding}, \texttt{PriorityBinding}, \texttt{ElementName},
\texttt{RelativeSource}) and imperative helpers via
\texttt{BindingOperations}. - Connect collections to
\texttt{ItemsControl}/\texttt{ListBox} with data templates,
\texttt{SelectionModel}, and compiled binding expressions. - Use
converters, validation (\texttt{INotifyDataErrorInfo}), asynchronous
bindings, and reactive bridges (\texttt{AvaloniaPropertyObservable}). -
Bind to attached properties, tune performance with compiled bindings,
and diagnose issues using DevTools and \texttt{BindingDiagnostics}
logging.

Why this matters - Bindings keep UI and data in sync, reducing
boilerplate and keeping views declarative. - Picking the right binding
technique (compiled, multi-value, priority) improves performance and
readability. - Diagnostics help track down ``binding isn't working''
issues quickly.

Prerequisites - You can create a project and run it (Chapters 2-7). -
You've seen basic controls and templates (Chapters 3 \& 6).

\subsection{1. The binding engine at a
glance}\label{the-binding-engine-at-a-glance}

Avalonia's binding engine lives under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Data}{\texttt{src/Avalonia.Base/Data}}.
Key pieces: - \texttt{DataContext}: inherited down the logical tree.
Most bindings resolve relative to the current element's DataContext. -
\texttt{Binding}: describes a path, mode, converter, fallback, etc. -
\texttt{BindingBase}: base for compiled bindings, multi bindings,
priority bindings. - \texttt{BindingExpression}: runtime evaluation
created for each binding target. - \texttt{BindingOperations}: static
helpers to install, remove, or inspect bindings imperatively. -
\texttt{ExpressionObserver}: low-level observable pipeline underpinning
async, compiled, and reactive bindings.

Bindings resolve in this order: 1. Find the source (DataContext, element
name, relative source, etc.). 2. Evaluate the path (e.g.,
\texttt{Customer.Name}). 3. Apply converters or string formatting. 4.
Update the target property according to the binding mode.

\texttt{BindingOperations.SetBinding} mirrors WPF/WinUI and is useful
when you need to create bindings from code (for dynamic property names
or custom controls). \texttt{BindingOperations.ClearBinding} removes
them safely, keeping reference tracking intact.

\subsection{2. Binding scopes and source
selection}\label{binding-scopes-and-source-selection}

Binding sources are resolved differently depending on the binding type:

\begin{itemize}
\tightlist
\item
  \textbf{\texttt{DataContext} inheritance} --
  \texttt{StyledElement.DataContext} flows through the logical tree.
  Setting \texttt{DataContext} on a container automatically scopes child
  bindings.
\item
  \textbf{Element name} --
  \texttt{\{Binding\ ElementName=Root,\ Path=Value\}} uses
  \texttt{NameScope} lookup to find another control.
\item
  \textbf{Relative source} --
  \texttt{\{Binding\ RelativeSource=\{RelativeSource\ AncestorType=ListBox\}\}}
  walks the logical tree to find an ancestor of the specified type.
\item
  \textbf{Self bindings} --
  \texttt{\{Binding\ Path=Bounds,\ RelativeSource=\{RelativeSource\ Self\}\}}
  is handy when exposing properties of the control itself.
\item
  \textbf{Static/CLR properties} --
  \texttt{\{Binding\ Path=(local:ThemeOptions.AccentBrush)\}} reads
  attached or static properties registered as Avalonia properties.
\end{itemize}

Avalonia also supports multi-level ancestor search and templated parent
references:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding DataContext.Title, RelativeSource=\{RelativeSource AncestorType=Window\}\}"}\NormalTok{/\textgreater{}}

\NormalTok{\textless{}}\KeywordTok{ContentControl}\OtherTok{ ContentTemplate=}\StringTok{"\{StaticResource CardTemplate\}"}\NormalTok{ /\textgreater{}}

\NormalTok{\textless{}}\KeywordTok{DataTemplate}\OtherTok{ x:Key=}\StringTok{"CardTemplate"}\OtherTok{ x:DataType=}\StringTok{"vm:Card"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Border}\OtherTok{ Background=}\StringTok{"\{Binding Source=\{RelativeSource TemplatedParent\}, Path=Background\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

When creating controls dynamically, use
\texttt{BindingOperations.SetBinding} so the engine tracks lifetimes and
updates \texttt{DataContext} inheritance correctly:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ binding }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Binding}
\OperatorTok{\{}
\NormalTok{    Path }\OperatorTok{=} \StringTok{"Person.FullName"}\OperatorTok{,}
\NormalTok{    Mode }\OperatorTok{=}\NormalTok{ BindingMode}\OperatorTok{.}\FunctionTok{OneWay}
\OperatorTok{\};}

\NormalTok{BindingOperations}\OperatorTok{.}\FunctionTok{SetBinding}\OperatorTok{(}\NormalTok{nameTextBlock}\OperatorTok{,}\NormalTok{ TextBlock}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,}\NormalTok{ binding}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{BindingOperations.ClearBinding(nameTextBlock,\ TextBlock.TextProperty)}
detaches it. To observe \texttt{AvaloniaProperty} values reactively,
wrap them with \texttt{AvaloniaPropertyObservable.Observe}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ System}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Reactive}\OperatorTok{.}\FunctionTok{Linq}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Reactive}\OperatorTok{;}

\DataTypeTok{var}\NormalTok{ textStream }\OperatorTok{=}\NormalTok{ AvaloniaPropertyObservable}\OperatorTok{.}\FunctionTok{Observe}\OperatorTok{(}\KeywordTok{this}\OperatorTok{,}\NormalTok{ TextBox}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{Select}\OperatorTok{(}\NormalTok{value }\OperatorTok{=\textgreater{}}\NormalTok{ value }\KeywordTok{as} \DataTypeTok{string} \OperatorTok{??} \DataTypeTok{string}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{);}

\DataTypeTok{var}\NormalTok{ subscription }\OperatorTok{=}\NormalTok{ textStream}\OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{text }\OperatorTok{=\textgreater{}}\NormalTok{ ViewModel}\OperatorTok{.}\FunctionTok{TextLength} \OperatorTok{=}\NormalTok{ text}\OperatorTok{.}\FunctionTok{Length}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{AvaloniaPropertyObservable} lives in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Reactive/AvaloniaPropertyObservable.cs}{\texttt{AvaloniaPropertyObservable.cs}}
and bridges the binding system with
\texttt{IObservable\textless{}T\textgreater{}} pipelines. Dispose the
subscription in \texttt{OnDetachedFromVisualTree} (or your view's
\texttt{Dispose} pattern) to avoid leaks.

\subsection{3. Set up the sample
project}\label{set-up-the-sample-project}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet}\NormalTok{ new avalonia.mvvm }\AttributeTok{{-}o}\NormalTok{ BindingPlayground}
\BuiltInTok{cd}\NormalTok{ BindingPlayground}
\end{Highlighting}
\end{Shaded}

We'll expand \texttt{MainWindow.axaml} and
\texttt{MainWindowViewModel.cs}.

\subsection{4. Core bindings (OneWay, TwoWay,
OneTime)}\label{core-bindings-oneway-twoway-onetime}

View model implementing \texttt{INotifyPropertyChanged}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{ComponentModel}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Runtime}\OperatorTok{.}\FunctionTok{CompilerServices}\OperatorTok{;}

\KeywordTok{namespace}\NormalTok{ BindingPlayground}\OperatorTok{.}\FunctionTok{ViewModels}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ PersonViewModel }\OperatorTok{:}\NormalTok{ INotifyPropertyChanged}
\OperatorTok{\{}
    \KeywordTok{private} \DataTypeTok{string}\NormalTok{ \_firstName }\OperatorTok{=} \StringTok{"Ada"}\OperatorTok{;}
    \KeywordTok{private} \DataTypeTok{string}\NormalTok{ \_lastName }\OperatorTok{=} \StringTok{"Lovelace"}\OperatorTok{;}
    \KeywordTok{private} \DataTypeTok{int}\NormalTok{ \_age }\OperatorTok{=} \DecValTok{36}\OperatorTok{;}

    \KeywordTok{public} \DataTypeTok{string}\NormalTok{ FirstName}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_firstName}\OperatorTok{;}
        \KeywordTok{set} \OperatorTok{\{} \KeywordTok{if} \OperatorTok{(}\NormalTok{\_firstName }\OperatorTok{!=}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ \_firstName }\OperatorTok{=}\NormalTok{ value}\OperatorTok{;} \FunctionTok{OnPropertyChanged}\OperatorTok{();} \FunctionTok{OnPropertyChanged}\OperatorTok{(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{FullName}\OperatorTok{));} \OperatorTok{\}} \OperatorTok{\}}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{string}\NormalTok{ LastName}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_lastName}\OperatorTok{;}
        \KeywordTok{set} \OperatorTok{\{} \KeywordTok{if} \OperatorTok{(}\NormalTok{\_lastName }\OperatorTok{!=}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ \_lastName }\OperatorTok{=}\NormalTok{ value}\OperatorTok{;} \FunctionTok{OnPropertyChanged}\OperatorTok{();} \FunctionTok{OnPropertyChanged}\OperatorTok{(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{FullName}\OperatorTok{));} \OperatorTok{\}} \OperatorTok{\}}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{int}\NormalTok{ Age}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_age}\OperatorTok{;}
        \KeywordTok{set} \OperatorTok{\{} \KeywordTok{if} \OperatorTok{(}\NormalTok{\_age }\OperatorTok{!=}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ \_age }\OperatorTok{=}\NormalTok{ value}\OperatorTok{;} \FunctionTok{OnPropertyChanged}\OperatorTok{();} \OperatorTok{\}} \OperatorTok{\}}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{string}\NormalTok{ FullName }\OperatorTok{=\textgreater{}} \OperatorTok{(}\NormalTok{$}\StringTok{"\{FirstName\} \{LastName\}"}\OperatorTok{).}\FunctionTok{Trim}\OperatorTok{();}

    \KeywordTok{public} \KeywordTok{event}\NormalTok{ PropertyChangedEventHandler}\OperatorTok{?}\NormalTok{ PropertyChanged}\OperatorTok{;}
    \KeywordTok{protected} \DataTypeTok{void} \FunctionTok{OnPropertyChanged}\OperatorTok{([}\NormalTok{CallerMemberName}\OperatorTok{]} \DataTypeTok{string}\OperatorTok{?}\NormalTok{ name }\OperatorTok{=} \KeywordTok{null}\OperatorTok{)}
        \OperatorTok{=\textgreater{}}\NormalTok{ PropertyChanged}\OperatorTok{?.}\FunctionTok{Invoke}\OperatorTok{(}\KeywordTok{this}\OperatorTok{,} \KeywordTok{new} \FunctionTok{PropertyChangedEventArgs}\OperatorTok{(}\NormalTok{name}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

In \texttt{MainWindow.axaml} set the DataContext:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{        xmlns:x=}\StringTok{"http://schemas.microsoft.com/winfx/2006/xaml"}
\OtherTok{        xmlns:vm=}\StringTok{"clr{-}namespace:BindingPlayground.ViewModels"}
\OtherTok{        x:Class=}\StringTok{"BindingPlayground.Views.MainWindow"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Window.DataContext}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{vm:MainWindowViewModel}\NormalTok{ /\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Window.DataContext}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{Design.DataContext}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{vm:MainWindowViewModel}\NormalTok{ /\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Design.DataContext}\NormalTok{\textgreater{}}


\NormalTok{\textless{}/}\KeywordTok{Window}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{Design.DataContext} provides design-time data in the previewer.

\subsection{5. Binding modes in action}\label{binding-modes-in-action}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Grid}\OtherTok{ ColumnDefinitions=}\StringTok{"*,*"}\OtherTok{ RowDefinitions=}\StringTok{"Auto,*"}\OtherTok{ Padding=}\StringTok{"16"}\OtherTok{ RowSpacing=}\StringTok{"16"}\OtherTok{ ColumnSpacing=}\StringTok{"24"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ Grid.ColumnSpan=}\StringTok{"2"}\OtherTok{ Classes=}\StringTok{"h1"}\OtherTok{ Text=}\StringTok{"Binding basics"}\NormalTok{/\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBox}\OtherTok{ Watermark=}\StringTok{"First name"}\OtherTok{ Text=}\StringTok{"\{Binding Person.FirstName, Mode=TwoWay\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBox}\OtherTok{ Watermark=}\StringTok{"Last name"}\OtherTok{  Text=}\StringTok{"\{Binding Person.LastName, Mode=TwoWay\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{NumericUpDown}\OtherTok{ Minimum=}\StringTok{"0"}\OtherTok{ Maximum=}\StringTok{"120"}\OtherTok{ Value=}\StringTok{"\{Binding Person.Age, Mode=TwoWay\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Live view"}\OtherTok{ FontWeight=}\StringTok{"SemiBold"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Person.FullName, Mode=OneWay\}"}\OtherTok{ FontSize=}\StringTok{"20"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Person.Age, Mode=OneWay\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding CreatedAt, Mode=OneTime, StringFormat=\textquotesingle{}Created on \{0:d\}\textquotesingle{}\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{MainWindowViewModel} holds \texttt{Person} and other state:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ System}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Collections}\OperatorTok{.}\FunctionTok{ObjectModel}\OperatorTok{;}

\KeywordTok{namespace}\NormalTok{ BindingPlayground}\OperatorTok{.}\FunctionTok{ViewModels}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ MainWindowViewModel }\OperatorTok{:}\NormalTok{ INotifyPropertyChanged}
\OperatorTok{\{}
    \KeywordTok{public}\NormalTok{ PersonViewModel Person }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\OperatorTok{();}
    \KeywordTok{public}\NormalTok{ DateTime CreatedAt }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=}\NormalTok{ DateTime}\OperatorTok{.}\FunctionTok{Now}\OperatorTok{;}

    \CommentTok{// Additional samples below}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{6. ElementName and
RelativeSource}\label{elementname-and-relativesource}

\subsubsection{ElementName binding}\label{elementname-binding}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{StackPanel}\OtherTok{ Margin=}\StringTok{"0,24,0,0"}\OtherTok{ Spacing=}\StringTok{"6"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Slider}\OtherTok{ x:Name=}\StringTok{"VolumeSlider"}\OtherTok{ Minimum=}\StringTok{"0"}\OtherTok{ Maximum=}\StringTok{"100"}\OtherTok{ Value=}\StringTok{"50"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ProgressBar}\OtherTok{ Minimum=}\StringTok{"0"}\OtherTok{ Maximum=}\StringTok{"100"}\OtherTok{ Value=}\StringTok{"\{Binding \#VolumeSlider.Value\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{\#VolumeSlider} targets the element with
\texttt{x:Name="VolumeSlider"}.

\subsubsection{RelativeSource binding}\label{relativesource-binding}

Use \texttt{RelativeSource} to bind to ancestors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding DataContext.Person.FullName, RelativeSource=\{RelativeSource AncestorType=Window\}\}"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

This binds to the window's DataContext even if the local control has its
own DataContext.

Relative source syntax also supports \texttt{Self}
(\texttt{RelativeSource=\{RelativeSource\ Self\}}) and
\texttt{TemplatedParent} for control templates.

\subsubsection{Binding to attached
properties}\label{binding-to-attached-properties}

Avalonia registers attached properties (e.g.,
\texttt{ScrollViewer.HorizontalScrollBarVisibilityProperty}) as
\texttt{AvaloniaProperty}. Bind to them by wrapping the property name in
parentheses:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ListBox}\OtherTok{ ItemsSource=}\StringTok{"\{Binding Items\}"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ListBox.Styles}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Style}\OtherTok{ Selector=}\StringTok{"ListBox"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"(ScrollViewer.HorizontalScrollBarVisibility)"}\OtherTok{ Value=}\StringTok{"Disabled"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"(ScrollViewer.VerticalScrollBarVisibility)"}\OtherTok{ Value=}\StringTok{"Auto"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ListBox.Styles}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ListBox}\NormalTok{\textgreater{}}

\NormalTok{\textless{}}\KeywordTok{Border}\OtherTok{ Background=}\StringTok{"\{Binding (local:ThemeOptions.AccentBrush)\}"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

Attached property syntax also works inside \texttt{Binding} or
\texttt{MultiBinding}. When setting them from code, use the generated
static accessor (e.g.,
\texttt{ScrollViewer.SetHorizontalScrollBarVisibility(listBox,\ ScrollBarVisibility.Disabled);}).

\subsection{7. Compiled bindings}\label{compiled-bindings}

Compiled bindings (\texttt{CompiledBinding}) produce strongly-typed
accessors with better performance. Require \texttt{x:DataType} or
\texttt{CompiledBindings} namespace:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add namespace to the root element:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{xmlns:vm="clr{-}namespace:BindingPlayground.ViewModels"}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Set \texttt{x:DataType} on a scope:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{StackPanel}\OtherTok{ DataContext=}\StringTok{"\{Binding Person\}"}\OtherTok{ x:DataType=}\StringTok{"vm:PersonViewModel"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{CompiledBinding FullName\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBox}\OtherTok{ Text=}\StringTok{"\{CompiledBinding FirstName\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

If \texttt{x:DataType} is set, \texttt{CompiledBinding} uses
compile-time checking and generates binding code. Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/MarkupExtensions/CompiledBindingExtension.cs}{\texttt{CompiledBindingExtension.cs}}.

\subsection{8. MultiBinding and
PriorityBinding}\label{multibinding-and-prioritybinding}

\subsubsection{MultiBinding}\label{multibinding}

Combine multiple values into one target:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ NameAgeFormatter }\OperatorTok{:}\NormalTok{ IMultiValueConverter}
\OperatorTok{\{}
    \KeywordTok{public} \DataTypeTok{object}\OperatorTok{?} \FunctionTok{Convert}\OperatorTok{(}\NormalTok{IList}\OperatorTok{\textless{}}\DataTypeTok{object}\OperatorTok{?\textgreater{}}\NormalTok{ values}\OperatorTok{,}\NormalTok{ Type targetType}\OperatorTok{,} \DataTypeTok{object}\OperatorTok{?}\NormalTok{ parameter}\OperatorTok{,}\NormalTok{ CultureInfo culture}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ name }\OperatorTok{=}\NormalTok{ values}\OperatorTok{[}\DecValTok{0}\OperatorTok{]} \KeywordTok{as} \DataTypeTok{string} \OperatorTok{??} \StringTok{""}\OperatorTok{;}
        \DataTypeTok{var}\NormalTok{ age }\OperatorTok{=}\NormalTok{ values}\OperatorTok{[}\DecValTok{1}\OperatorTok{]} \KeywordTok{as} \DataTypeTok{int}\OperatorTok{?} \OperatorTok{??} \DecValTok{0}\OperatorTok{;}
        \KeywordTok{return}\NormalTok{ $}\StringTok{"\{name\} (\{age\})"}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{object}\OperatorTok{?} \FunctionTok{ConvertBack}\OperatorTok{(}\NormalTok{IList}\OperatorTok{\textless{}}\DataTypeTok{object}\OperatorTok{?\textgreater{}}\NormalTok{ values}\OperatorTok{,}\NormalTok{ Type targetType}\OperatorTok{,} \DataTypeTok{object}\OperatorTok{?}\NormalTok{ parameter}\OperatorTok{,}\NormalTok{ CultureInfo culture}\OperatorTok{)} \OperatorTok{=\textgreater{}} \KeywordTok{throw} \KeywordTok{new} \FunctionTok{NotSupportedException}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Register in resources:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window.Resources}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{conv:NameAgeFormatter}\OtherTok{ x:Key=}\StringTok{"NameAgeFormatter"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Window.Resources}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Use it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TextBlock}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBlock.Text}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{MultiBinding}\OtherTok{ Converter=}\StringTok{"\{StaticResource NameAgeFormatter\}"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Binding}\OtherTok{ Path=}\StringTok{"Person.FullName"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Binding}\OtherTok{ Path=}\StringTok{"Person.Age"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{MultiBinding}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{TextBlock.Text}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{TextBlock}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{PriorityBinding}\label{prioritybinding}

Priority bindings try sources in order and use the first that yields a
value:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TextBlock}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBlock.Text}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{PriorityBinding}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Binding}\OtherTok{ Path=}\StringTok{"OverrideTitle"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Binding}\OtherTok{ Path=}\StringTok{"Person.FullName"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Binding}\OtherTok{ Path=}\StringTok{"Person.FirstName"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Binding}\OtherTok{ Path=}\StringTok{"\textquotesingle{}Unknown user\textquotesingle{}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{PriorityBinding}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{TextBlock.Text}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{TextBlock}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup/Data/PriorityBinding.cs}{\texttt{PriorityBinding.cs}}.

\subsection{9. Lists, selection, and
templates}\label{lists-selection-and-templates}

\texttt{MainWindowViewModel} exposes collections:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public}\NormalTok{ ObservableCollection}\OperatorTok{\textless{}}\NormalTok{PersonViewModel}\OperatorTok{\textgreater{}}\NormalTok{ People }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\OperatorTok{()}
\OperatorTok{\{}
    \KeywordTok{new}\NormalTok{ PersonViewModel }\OperatorTok{\{}\NormalTok{ FirstName }\OperatorTok{=} \StringTok{"Ada"}\OperatorTok{,}\NormalTok{ LastName }\OperatorTok{=} \StringTok{"Lovelace"}\OperatorTok{,}\NormalTok{ Age }\OperatorTok{=} \DecValTok{36} \OperatorTok{\},}
    \KeywordTok{new}\NormalTok{ PersonViewModel }\OperatorTok{\{}\NormalTok{ FirstName }\OperatorTok{=} \StringTok{"Grace"}\OperatorTok{,}\NormalTok{ LastName }\OperatorTok{=} \StringTok{"Hopper"}\OperatorTok{,}\NormalTok{ Age }\OperatorTok{=} \DecValTok{45} \OperatorTok{\},}
    \KeywordTok{new}\NormalTok{ PersonViewModel }\OperatorTok{\{}\NormalTok{ FirstName }\OperatorTok{=} \StringTok{"Linus"}\OperatorTok{,}\NormalTok{ LastName }\OperatorTok{=} \StringTok{"Torvalds"}\OperatorTok{,}\NormalTok{ Age }\OperatorTok{=} \DecValTok{32} \OperatorTok{\}}
\OperatorTok{\};}

\KeywordTok{private}\NormalTok{ PersonViewModel}\OperatorTok{?}\NormalTok{ \_selectedPerson}\OperatorTok{;}
\KeywordTok{public}\NormalTok{ PersonViewModel}\OperatorTok{?}\NormalTok{ SelectedPerson}
\OperatorTok{\{}
\NormalTok{    get }\OperatorTok{=\textgreater{}}\NormalTok{ \_selectedPerson}\OperatorTok{;}
    \KeywordTok{set} \OperatorTok{\{} \KeywordTok{if} \OperatorTok{(}\NormalTok{\_selectedPerson }\OperatorTok{!=}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ \_selectedPerson }\OperatorTok{=}\NormalTok{ value}\OperatorTok{;} \FunctionTok{OnPropertyChanged}\OperatorTok{();} \OperatorTok{\}} \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Template the list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ListBox}\OtherTok{ Items=}\StringTok{"\{Binding People\}"}
\OtherTok{         SelectedItem=}\StringTok{"\{Binding SelectedPerson, Mode=TwoWay\}"}
\OtherTok{         Height=}\StringTok{"180"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ListBox.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{DataTemplate}\OtherTok{ x:DataType=}\StringTok{"vm:PersonViewModel"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{CompiledBinding FullName\}"}\OtherTok{ FontWeight=}\StringTok{"SemiBold"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{CompiledBinding Age\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ListBox.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ListBox}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Inside the details pane, bind to \texttt{SelectedPerson} safely using
null-conditional binding (C\#) or triggers. XAML automatically handles
null (shows blank). Use \texttt{x:DataType} for compile-time checks.

\subsubsection{\texorpdfstring{\texttt{SelectionModel}}{SelectionModel}}\label{selectionmodel}

For advanced selection (multi-select, range), use
\texttt{SelectionModel\textless{}T\textgreater{}} from
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Selection/SelectionModel.cs}{\texttt{SelectionModel.cs}}.
Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public}\NormalTok{ SelectionModel}\OperatorTok{\textless{}}\NormalTok{PersonViewModel}\OperatorTok{\textgreater{}}\NormalTok{ PeopleSelection }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\OperatorTok{()} \OperatorTok{\{}\NormalTok{ SelectionMode }\OperatorTok{=}\NormalTok{ SelectionMode}\OperatorTok{.}\FunctionTok{Multiple} \OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Bind it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ListBox}\OtherTok{ Items=}\StringTok{"\{Binding People\}"}\OtherTok{ Selection=}\StringTok{"\{Binding PeopleSelection\}"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{10. Validation with
\texttt{INotifyDataErrorInfo}}{10. Validation with INotifyDataErrorInfo}}\label{validation-with-inotifydataerrorinfo}

Implement \texttt{INotifyDataErrorInfo} for asynchronous validation.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Collections}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Collections}\OperatorTok{.}\FunctionTok{Generic}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{ComponentModel}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ ValidatingPersonViewModel }\OperatorTok{:}\NormalTok{ PersonViewModel}\OperatorTok{,}\NormalTok{ INotifyDataErrorInfo}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Dictionary}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{,}\NormalTok{ List}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{\textgreater{}\textgreater{}}\NormalTok{ \_errors }\OperatorTok{=} \KeywordTok{new}\OperatorTok{();}

    \KeywordTok{public} \DataTypeTok{bool}\NormalTok{ HasErrors }\OperatorTok{=\textgreater{}}\NormalTok{ \_errors}\OperatorTok{.}\FunctionTok{Count} \OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{;}

    \KeywordTok{public} \KeywordTok{event}\NormalTok{ EventHandler}\OperatorTok{\textless{}}\NormalTok{DataErrorsChangedEventArgs}\OperatorTok{\textgreater{}?}\NormalTok{ ErrorsChanged}\OperatorTok{;}

    \KeywordTok{public}\NormalTok{ IEnumerable }\FunctionTok{GetErrors}\OperatorTok{(}\DataTypeTok{string}\OperatorTok{?}\NormalTok{ propertyName}\OperatorTok{)}
        \OperatorTok{=\textgreater{}}\NormalTok{ propertyName }\KeywordTok{is}\NormalTok{ not }\KeywordTok{null} \OperatorTok{\&\&}\NormalTok{ \_errors}\OperatorTok{.}\FunctionTok{TryGetValue}\OperatorTok{(}\NormalTok{propertyName}\OperatorTok{,} \KeywordTok{out} \DataTypeTok{var}\NormalTok{ errors}\OperatorTok{)} \OperatorTok{?}\NormalTok{ errors }\OperatorTok{:}\NormalTok{ Array}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{\textgreater{}();}

    \KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnPropertyChanged}\OperatorTok{(}\DataTypeTok{string}\OperatorTok{?}\NormalTok{ propertyName}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnPropertyChanged}\OperatorTok{(}\NormalTok{propertyName}\OperatorTok{);}
        \FunctionTok{Validate}\OperatorTok{(}\NormalTok{propertyName}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{private} \DataTypeTok{void} \FunctionTok{Validate}\OperatorTok{(}\DataTypeTok{string}\OperatorTok{?}\NormalTok{ propertyName}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{propertyName }\KeywordTok{is} \FunctionTok{nameof}\OperatorTok{(}\NormalTok{Age}\OperatorTok{))}
        \OperatorTok{\{}
            \KeywordTok{if} \OperatorTok{(}\NormalTok{Age }\OperatorTok{\textless{}} \DecValTok{0} \OperatorTok{||}\NormalTok{ Age }\OperatorTok{\textgreater{}} \DecValTok{120}\OperatorTok{)}
                \FunctionTok{AddError}\OperatorTok{(}\NormalTok{propertyName}\OperatorTok{,} \StringTok{"Age must be between 0 and 120"}\OperatorTok{);}
            \KeywordTok{else}
                \FunctionTok{ClearErrors}\OperatorTok{(}\NormalTok{propertyName}\OperatorTok{);}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \KeywordTok{private} \DataTypeTok{void} \FunctionTok{AddError}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ propertyName}\OperatorTok{,} \DataTypeTok{string}\NormalTok{ error}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(!}\NormalTok{\_errors}\OperatorTok{.}\FunctionTok{TryGetValue}\OperatorTok{(}\NormalTok{propertyName}\OperatorTok{,} \KeywordTok{out} \DataTypeTok{var}\NormalTok{ list}\OperatorTok{))}
\NormalTok{            \_errors}\OperatorTok{[}\NormalTok{propertyName}\OperatorTok{]} \OperatorTok{=}\NormalTok{ list }\OperatorTok{=} \KeywordTok{new}\NormalTok{ List}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{\textgreater{}();}

        \KeywordTok{if} \OperatorTok{(!}\NormalTok{list}\OperatorTok{.}\FunctionTok{Contains}\OperatorTok{(}\NormalTok{error}\OperatorTok{))}
        \OperatorTok{\{}
\NormalTok{            list}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{error}\OperatorTok{);}
\NormalTok{            ErrorsChanged}\OperatorTok{?.}\FunctionTok{Invoke}\OperatorTok{(}\KeywordTok{this}\OperatorTok{,} \KeywordTok{new} \FunctionTok{DataErrorsChangedEventArgs}\OperatorTok{(}\NormalTok{propertyName}\OperatorTok{));}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \KeywordTok{private} \DataTypeTok{void} \FunctionTok{ClearErrors}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ propertyName}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{\_errors}\OperatorTok{.}\FunctionTok{Remove}\OperatorTok{(}\NormalTok{propertyName}\OperatorTok{))}
\NormalTok{            ErrorsChanged}\OperatorTok{?.}\FunctionTok{Invoke}\OperatorTok{(}\KeywordTok{this}\OperatorTok{,} \KeywordTok{new} \FunctionTok{DataErrorsChangedEventArgs}\OperatorTok{(}\NormalTok{propertyName}\OperatorTok{));}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Bind the validation feedback automatically:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TextBox}\OtherTok{ Text=}\StringTok{"\{Binding ValidatingPerson.FirstName, Mode=TwoWay\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}}\KeywordTok{TextBox}\OtherTok{ Text=}\StringTok{"\{Binding ValidatingPerson.Age, Mode=TwoWay\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}}\KeywordTok{TextBlock}\OtherTok{ Foreground=}\StringTok{"\#B91C1C"}\OtherTok{ Text=}\StringTok{"\{Binding (Validation.Errors)[0].ErrorContent, RelativeSource=\{RelativeSource Self\}\}"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

Avalonia surfaces validation errors via attached properties. For a full
pattern see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Validation}{\texttt{Validation}}.

\subsection{11. Asynchronous bindings}\label{asynchronous-bindings}

Use \texttt{Task}-returning properties with \texttt{Binding} and
\texttt{BindingPriority.AsyncLocalValue}. Example view model property:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private} \DataTypeTok{string}\OperatorTok{?}\NormalTok{ \_weather}\OperatorTok{;}
\KeywordTok{public} \DataTypeTok{string}\OperatorTok{?}\NormalTok{ Weather}
\OperatorTok{\{}
\NormalTok{    get }\OperatorTok{=\textgreater{}}\NormalTok{ \_weather}\OperatorTok{;}
    \KeywordTok{private} \KeywordTok{set} \OperatorTok{\{} \KeywordTok{if} \OperatorTok{(}\NormalTok{\_weather }\OperatorTok{!=}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ \_weather }\OperatorTok{=}\NormalTok{ value}\OperatorTok{;} \FunctionTok{OnPropertyChanged}\OperatorTok{();} \OperatorTok{\}} \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{public}\NormalTok{ async Task }\FunctionTok{LoadWeatherAsync}\OperatorTok{()}
\OperatorTok{\{}
\NormalTok{    Weather }\OperatorTok{=} \StringTok{"Loading..."}\OperatorTok{;}
    \DataTypeTok{var}\NormalTok{ result }\OperatorTok{=}\NormalTok{ await \_weatherService}\OperatorTok{.}\FunctionTok{GetForecastAsync}\OperatorTok{();}
\NormalTok{    Weather }\OperatorTok{=}\NormalTok{ result}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Bind with fallback until the value arrives:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Weather, FallbackValue=\textquotesingle{}Fetching forecast...\textquotesingle{}\}"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

You can also bind directly to \texttt{Task} results using
\texttt{TaskObservableCollection} or reactive extensions (Chapter 17
covers background work).

\subsection{12. Binding diagnostics}\label{binding-diagnostics}

\begin{itemize}
\tightlist
\item
  \textbf{DevTools}: press F12 -\textgreater{} Diagnostics
  -\textgreater{} Binding Errors tab. Inspect live errors (missing
  properties, converters failing).
\item
  \textbf{Binding logging}: enable via \texttt{BindingDiagnostics}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Diagnostics}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{()}
\OperatorTok{\{}
\NormalTok{    BindingDiagnostics}\OperatorTok{.}\FunctionTok{Enable}\OperatorTok{(}
\NormalTok{        log }\OperatorTok{=\textgreater{}}\NormalTok{ Console}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\NormalTok{log}\OperatorTok{.}\FunctionTok{Message}\OperatorTok{),}
        \KeywordTok{new}\NormalTok{ BindingDiagnosticOptions}
        \OperatorTok{\{}
\NormalTok{            Level }\OperatorTok{=}\NormalTok{ BindingDiagnosticLogLevel}\OperatorTok{.}\FunctionTok{Warning}
        \OperatorTok{\});}

    \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Diagnostics/Diagnostics/BindingDiagnostics.cs}{\texttt{BindingDiagnostics.cs}}.

Use \texttt{TraceBindingFailures} extension to log failures for specific
bindings.

\subsection{13. Practice exercises}\label{practice-exercises-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Compiled binding sweep}: add \texttt{x:DataType} to each data
  template and replace \texttt{Binding} with \texttt{CompiledBinding}
  where possible. Observe compile-time errors when property names are
  mistyped.
\item
  \textbf{MultiBinding formatting}: create a multi binding that formats
  \texttt{FirstName}, \texttt{LastName}, and \texttt{Age} into a
  sentence like ``Ada Lovelace is 36 years old.'' Add a converter
  parameter for custom formats.
\item
  \textbf{Priority fallback}: allow a user-provided display name to
  override \texttt{FullName}, falling back to initials if names are
  empty.
\item
  \textbf{Validation UX}: display validation errors inline using
  \texttt{INotifyDataErrorInfo} and highlight inputs
  (\texttt{Style\ Selector="TextBox:invalid"}).
\item
  \textbf{Runtime binding helpers}: dynamically add a \texttt{TextBlock}
  for each person in a collection, use
  \texttt{BindingOperations.SetBinding} to wire \texttt{TextBlock.Text},
  then \texttt{ClearBinding} when removing the item.
\item
  \textbf{Observable probes}: pipe \texttt{TextBox.TextProperty} through
  \texttt{AvaloniaPropertyObservable.Observe} and surface the text
  length in the UI.
\item
  \textbf{Diagnostics drill}: intentionally break a binding (typo) and
  use DevTools and \texttt{BindingDiagnostics} to find it. Fix the
  binding and confirm logs clear.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-6}

\begin{itemize}
\tightlist
\item
  Binding implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/Binding.cs}{\texttt{Binding.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/BindingExpression.cs}{\texttt{BindingExpression.cs}}
\item
  Binding helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/BindingOperations.cs}{\texttt{BindingOperations.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/ExpressionObserver.cs}{\texttt{ExpressionObserver.cs}}
\item
  Compiled bindings:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/MarkupExtensions/CompiledBindingExtension.cs}{\texttt{CompiledBindingExtension.cs}}
\item
  Multi/Priority binding:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup/Data/MultiBinding.cs}{\texttt{MultiBinding.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup/Data/PriorityBinding.cs}{\texttt{PriorityBinding.cs}}
\item
  Reactive bridge:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Reactive/AvaloniaPropertyObservable.cs}{\texttt{AvaloniaPropertyObservable.cs}}
\item
  Selection model:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Selection/SelectionModel.cs}{\texttt{SelectionModel.cs}}
\item
  Validation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Validation/Validation.cs}{\texttt{Validation.cs}}
\item
  Diagnostics:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Diagnostics/Diagnostics/BindingDiagnostics.cs}{\texttt{BindingDiagnostics.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-6}

\begin{itemize}
\tightlist
\item
  When would you choose \texttt{CompiledBinding} over \texttt{Binding},
  and what prerequisites does it have?
\item
  How do \texttt{ElementName}, \texttt{RelativeSource}, and attached
  property syntax change the binding source?
\item
  Which scenarios call for \texttt{MultiBinding},
  \texttt{PriorityBinding}, or programmatic calls to
  \texttt{BindingOperations.SetBinding}?
\item
  How does \texttt{AvaloniaPropertyObservable.Observe} integrate with
  the binding engine, and when would you prefer it over classic
  bindings?
\item
  Which tooling surfaces validation and binding errors during
  development, and how would you enable the relevant diagnostics?
\end{itemize}

What's next - Next: \href{Chapter09.md}{Chapter 9}

\newpage

\subsection{9. Commands, events, and user
input}\label{commands-events-and-user-input}

Goal - Understand how routed events flow through \texttt{InputElement}
and how gesture recognizers, commands, and keyboard navigation fit
together. - Choose between MVVM-friendly commands and low-level events
effectively (and bridge them with hotkeys and toolkits). - Wire keyboard
shortcuts, pointer gestures, and access keys; capture pointer input for
drag scenarios with \texttt{HotKeyManager} and pointer capture APIs. -
Implement asynchronous commands and recycle CanExecute logic with
reactive or toolkit helpers. - Diagnose input issues with DevTools
(Events view), logging, and custom event tracing.

Why this matters - Robust input handling keeps UI responsive and
testable. - Commands keep business logic in view models; events cover
fine-grained gestures. - Knowing the pipeline (routed events
-\textgreater{} gesture recognizers -\textgreater{} commands) helps
debug ``nothing happened'' scenarios.

Prerequisites - Chapters 3-8 (layouts, controls, binding, theming). -
Basic MVVM knowledge and an \texttt{INotifyPropertyChanged} view model.

\subsection{1. Input building blocks}\label{input-building-blocks}

Avalonia input pieces live under: - Routed events:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Interactivity}{\texttt{Avalonia.Interactivity}}
defines \texttt{RoutedEvent}, event descriptors, and routing strategies.
- Core element hierarchy:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/InputElement.cs}{\texttt{InputElement}}
(inherits \texttt{Interactive} → \texttt{Visual} → \texttt{Animatable})
exposes focus, input, and command helpers that every control inherits. -
Devices \& state:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Input}{\texttt{Avalonia.Base/Input}}
provides \texttt{Pointer}, \texttt{KeyboardDevice}, \texttt{KeyGesture},
\texttt{PointerPoint}. - Gesture recognizers:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Input/GestureRecognizers}{\texttt{GestureRecognizers}}
translate raw pointer data into tap, scroll, drag behaviors. - Hotkeys
\& command sources:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/HotkeyManager.cs}{\texttt{HotkeyManager}}
walks the visual tree to resolve \texttt{KeyGesture}s against
\texttt{ICommand} targets.

Event flow: 1. Devices raise raw events (\texttt{PointerPressed},
\texttt{KeyDown}). Each is registered as a \texttt{RoutedEvent} with a
routing strategy (tunnel, bubble, direct). 2. \texttt{InputElement}
hosts the event metadata, raising class handlers and instance handlers.
3. Gesture recognizers subscribe to pointer streams and emit semantic
events (\texttt{Tapped}, \texttt{DoubleTapped},
\texttt{PointerPressedEventArgs}). 4. Command sources
(\texttt{Button.Command}, \texttt{KeyBinding}, \texttt{InputGesture})
execute \texttt{ICommand} implementations and update
\texttt{CanExecute}.

Creating custom events uses the static registration helpers:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{readonly}\NormalTok{ RoutedEvent}\OperatorTok{\textless{}}\NormalTok{RoutedEventArgs}\OperatorTok{\textgreater{}}\NormalTok{ DragStartedEvent }\OperatorTok{=}
\NormalTok{    RoutedEvent}\OperatorTok{.}\FunctionTok{Register}\OperatorTok{\textless{}}\NormalTok{Control}\OperatorTok{,}\NormalTok{ RoutedEventArgs}\OperatorTok{\textgreater{}(}
        \FunctionTok{nameof}\OperatorTok{(}\NormalTok{DragStarted}\OperatorTok{),}
\NormalTok{        RoutingStrategies}\OperatorTok{.}\FunctionTok{Bubble}\OperatorTok{);}

\KeywordTok{public} \KeywordTok{event}\NormalTok{ EventHandler}\OperatorTok{\textless{}}\NormalTok{RoutedEventArgs}\OperatorTok{\textgreater{}}\NormalTok{ DragStarted}
\OperatorTok{\{}
\NormalTok{    add }\OperatorTok{=\textgreater{}} \FunctionTok{AddHandler}\OperatorTok{(}\NormalTok{DragStartedEvent}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
\NormalTok{    remove }\OperatorTok{=\textgreater{}} \FunctionTok{RemoveHandler}\OperatorTok{(}\NormalTok{DragStartedEvent}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{RoutingStrategies} live in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Interactivity/RoutedEvent.cs}{\texttt{RoutedEvent.cs}};
each handler chooses whether the event should travel from root to leaf
(tunnel) or leaf to root (bubble).

\subsection{2. Input playground setup}\label{input-playground-setup}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet}\NormalTok{ new avalonia.mvvm }\AttributeTok{{-}o}\NormalTok{ InputPlayground}
\BuiltInTok{cd}\NormalTok{ InputPlayground}
\end{Highlighting}
\end{Shaded}

\texttt{MainWindowViewModel} exposes commands and state. Add
\texttt{CommunityToolkit.Mvvm} or implement your own
\texttt{AsyncRelayCommand} to simplify asynchronous logic. Hotkeys are
attached in XAML using \texttt{HotKeyManager.HotKey}, keeping the view
model free of UI dependencies.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ System}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Threading}\OperatorTok{.}\FunctionTok{Tasks}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Windows}\OperatorTok{.}\FunctionTok{Input}\OperatorTok{;}

\KeywordTok{namespace}\NormalTok{ InputPlayground}\OperatorTok{.}\FunctionTok{ViewModels}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ MainWindowViewModel }\OperatorTok{:}\NormalTok{ ViewModelBase}
\OperatorTok{\{}
    \KeywordTok{private} \DataTypeTok{string}\NormalTok{ \_status }\OperatorTok{=} \StringTok{"Ready"}\OperatorTok{;}
    \KeywordTok{public} \DataTypeTok{string}\NormalTok{ Status}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_status}\OperatorTok{;}
        \KeywordTok{private}\NormalTok{ set }\OperatorTok{=\textgreater{}} \FunctionTok{SetProperty}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_status}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{private} \DataTypeTok{bool}\NormalTok{ \_hasChanges}\OperatorTok{;}
    \KeywordTok{public} \DataTypeTok{bool}\NormalTok{ HasChanges}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_hasChanges}\OperatorTok{;}
\NormalTok{        set}
        \OperatorTok{\{}
            \KeywordTok{if} \OperatorTok{(}\FunctionTok{SetProperty}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_hasChanges}\OperatorTok{,}\NormalTok{ value}\OperatorTok{))}
            \OperatorTok{\{}
\NormalTok{                SaveCommand}\OperatorTok{.}\FunctionTok{RaiseCanExecuteChanged}\OperatorTok{();}
            \OperatorTok{\}}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \KeywordTok{public}\NormalTok{ RelayCommand SaveCommand }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}
    \KeywordTok{public}\NormalTok{ RelayCommand DeleteCommand }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}
    \KeywordTok{public}\NormalTok{ AsyncRelayCommand RefreshCommand }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}

    \KeywordTok{public} \FunctionTok{MainWindowViewModel}\OperatorTok{()}
    \OperatorTok{\{}
\NormalTok{        SaveCommand }\OperatorTok{=} \KeywordTok{new} \FunctionTok{RelayCommand}\OperatorTok{(}\NormalTok{\_ }\OperatorTok{=\textgreater{}} \FunctionTok{Save}\OperatorTok{(),}\NormalTok{ \_ }\OperatorTok{=\textgreater{}}\NormalTok{ HasChanges}\OperatorTok{);}
\NormalTok{        DeleteCommand }\OperatorTok{=} \KeywordTok{new} \FunctionTok{RelayCommand}\OperatorTok{(}\NormalTok{item }\OperatorTok{=\textgreater{}} \FunctionTok{Delete}\OperatorTok{(}\NormalTok{item}\OperatorTok{));}
\NormalTok{        RefreshCommand }\OperatorTok{=} \KeywordTok{new} \FunctionTok{AsyncRelayCommand}\OperatorTok{(}\NormalTok{RefreshAsync}\OperatorTok{,} \OperatorTok{()} \OperatorTok{=\textgreater{}} \OperatorTok{!}\NormalTok{IsBusy}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{private} \DataTypeTok{bool}\NormalTok{ \_isBusy}\OperatorTok{;}
    \KeywordTok{public} \DataTypeTok{bool}\NormalTok{ IsBusy}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_isBusy}\OperatorTok{;}
        \KeywordTok{private}\NormalTok{ set}
        \OperatorTok{\{}
            \KeywordTok{if} \OperatorTok{(}\FunctionTok{SetProperty}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_isBusy}\OperatorTok{,}\NormalTok{ value}\OperatorTok{))}
            \OperatorTok{\{}
\NormalTok{                RefreshCommand}\OperatorTok{.}\FunctionTok{RaiseCanExecuteChanged}\OperatorTok{();}
            \OperatorTok{\}}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \KeywordTok{private} \DataTypeTok{void} \FunctionTok{Save}\OperatorTok{()}
    \OperatorTok{\{}
\NormalTok{        Status }\OperatorTok{=} \StringTok{"Saved"}\OperatorTok{;}
\NormalTok{        HasChanges }\OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{private} \DataTypeTok{void} \FunctionTok{Delete}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ parameter}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        Status }\OperatorTok{=}\NormalTok{ parameter }\KeywordTok{is} \DataTypeTok{string}\NormalTok{ name }\OperatorTok{?}\NormalTok{ $}\StringTok{"Deleted \{name\}"} \OperatorTok{:} \StringTok{"Deleted item"}\OperatorTok{;}
\NormalTok{        HasChanges }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{private}\NormalTok{ async Task }\FunctionTok{RefreshAsync}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{try}
        \OperatorTok{\{}
\NormalTok{            IsBusy }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
\NormalTok{            Status }\OperatorTok{=} \StringTok{"Refreshing..."}\OperatorTok{;}
\NormalTok{            await Task}\OperatorTok{.}\FunctionTok{Delay}\OperatorTok{(}\DecValTok{1500}\OperatorTok{);}
\NormalTok{            Status }\OperatorTok{=} \StringTok{"Data refreshed"}\OperatorTok{;}
        \OperatorTok{\}}
        \KeywordTok{finally}
        \OperatorTok{\{}
\NormalTok{            IsBusy }\OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Supporting command classes (\texttt{RelayCommand},
\texttt{AsyncRelayCommand}) go in \texttt{Commands} folder. You may
reuse the ones from CommunityToolkit.Mvvm or ReactiveUI.

\subsection{3. Commands vs events cheat
sheet}\label{commands-vs-events-cheat-sheet}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Use command when\ldots{}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Use event when\ldots{}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
You expose an action (Save/Delete) from view model & You need pointer
coordinates, delta, or low-level control \\
You want CanExecute/disable logic & You're implementing custom
gestures/drag interactions \\
The action runs from buttons, menus, shortcuts & Work is purely visual
or specific to a view \\
You plan to unit test the action & Data is transient or you need
immediate UI feedback \\
\end{longtable}

Most real views mix both: commands for operations, events for gestures.

\subsection{4. Binding commands in XAML}\label{binding-commands-in-xaml}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{StackPanel}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBox}\OtherTok{ Watermark=}\StringTok{"Name"}\OtherTok{ Text=}\StringTok{"\{Binding SelectedName, Mode=TwoWay\}"}\NormalTok{/\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Save"}\OtherTok{ Command=}\StringTok{"\{Binding SaveCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Refresh"}\OtherTok{ Command=}\StringTok{"\{Binding RefreshCommand\}"}\OtherTok{ IsEnabled=}\StringTok{"\{Binding !IsBusy\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Delete"}\OtherTok{ Command=}\StringTok{"\{Binding DeleteCommand\}"}
\OtherTok{            CommandParameter=}\StringTok{"\{Binding SelectedName\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Status\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Buttons disable automatically when \texttt{SaveCommand.CanExecute}
returns false.

\subsection{5. Keyboard shortcuts, KeyGesture, and
HotKeyManager}\label{keyboard-shortcuts-keygesture-and-hotkeymanager}

\subsubsection{KeyBinding / KeyGesture}\label{keybinding-keygesture}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window} \ErrorTok{...}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Window.InputBindings}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{KeyBinding}\OtherTok{ Gesture=}\StringTok{"Ctrl+S"}\OtherTok{ Command=}\StringTok{"\{Binding SaveCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{KeyBinding}\OtherTok{ Gesture=}\StringTok{"Ctrl+R"}\OtherTok{ Command=}\StringTok{"\{Binding RefreshCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{KeyBinding}\OtherTok{ Gesture=}\StringTok{"Ctrl+Delete"}\OtherTok{ Command=}\StringTok{"\{Binding DeleteCommand\}"}\OtherTok{ CommandParameter=}\StringTok{"\{Binding SelectedName\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Window.InputBindings}\NormalTok{\textgreater{}}


\NormalTok{\textless{}/}\KeywordTok{Window}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{KeyGesture} parsing is handled by
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyGesture.cs}{\texttt{KeyGesture}}
and
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyGestureConverter.cs}{\texttt{KeyGestureConverter}}.
For multiple gestures, add more \texttt{KeyBinding} entries on the
relevant \texttt{InputElement}.

\subsubsection{\texorpdfstring{\texttt{HotKeyManager} attached
property}{HotKeyManager attached property}}\label{hotkeymanager-attached-property}

\texttt{KeyBinding} only fires while the owning control is focused. To
register process-wide hotkeys that stay active as long as a control is
in the visual tree, attach a \texttt{KeyGesture} via
\texttt{HotKeyManager.HotKey}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window}\OtherTok{ xmlns:controls=}\StringTok{"clr{-}namespace:Avalonia.Controls;assembly=Avalonia.Controls"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Save"}
\OtherTok{          Command=}\StringTok{"\{Binding SaveCommand\}"}
\OtherTok{          controls:HotKeyManager.HotKey=}\StringTok{"Ctrl+Shift+S"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Window}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{HotKeyManager} walks up to the owning \texttt{TopLevel} and
injects a \texttt{KeyBinding} for you, even when the button is not
focused. In code you can call
\texttt{HotKeyManager.SetHotKey(button,\ new\ KeyGesture(Key.S,\ KeyModifiers.Control\ \textbar{}\ KeyModifiers.Shift));}.
Implementation lives in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/HotkeyManager.cs}{\texttt{HotkeyManager.cs}}.

Bring \texttt{Avalonia.Input} into scope when assigning gestures
programmatically so \texttt{KeyGesture} and \texttt{KeyModifiers}
resolve.

\subsubsection{Access keys (mnemonics)}\label{access-keys-mnemonics}

Use \texttt{\_} to define an access key in headers (e.g.,
\texttt{\_Save}). Access keys work when Alt is pressed.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Menu}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"\_File"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"\_Save"}\OtherTok{ Command=}\StringTok{"\{Binding SaveCommand\}"}\OtherTok{ InputGesture=}\StringTok{"Ctrl+S"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{MenuItem}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Menu}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Access keys are processed via \texttt{AccessKeyHandler}
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/AccessKeyHandler.cs}{\texttt{AccessKeyHandler.cs}}).
Combine them with \texttt{HotKeyManager} to offer both menu accelerators
and global commands.

\subsection{6. Pointer gestures, capture, and drag
initiation}\label{pointer-gestures-capture-and-drag-initiation}

Avalonia ships gesture recognizers derived from
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/GestureRecognizer.cs}{\texttt{GestureRecognizer}}.
Attach them via \texttt{GestureRecognizers} to translate raw pointer
data into commands:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Border}\OtherTok{ Background=}\StringTok{"\#1e293b"}\OtherTok{ Padding=}\StringTok{"16"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Border.GestureRecognizers}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TapGestureRecognizer}\OtherTok{ NumberOfTapsRequired=}\StringTok{"2"}\OtherTok{ Command=}\StringTok{"\{Binding DoubleTapCommand\}"}\OtherTok{ CommandParameter=}\StringTok{"Canvas"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ScrollGestureRecognizer}\OtherTok{ CanHorizontallyScroll=}\StringTok{"True"}\OtherTok{ CanVerticallyScroll=}\StringTok{"True"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Border.GestureRecognizers}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ Foreground=}\StringTok{"White"}\OtherTok{ Text=}\StringTok{"Double{-}tap or scroll"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Implementation:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/TapGestureRecognizer.cs}{\texttt{TapGestureRecognizer.cs}}.

For custom gestures (e.g., drag-to-reorder), handle
\texttt{PointerPressed}, call \texttt{e.Pointer.Capture(control)} to
capture input, and release on \texttt{PointerReleased}. Pointer capture
ensures subsequent move/press events go to the capture target even if
the pointer leaves its bounds. Use
\texttt{PointerEventArgs.GetCurrentPoint} to inspect buttons, pressure,
tilt, or contact rectangles for richer interactions.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private} \DataTypeTok{bool}\NormalTok{ \_isDragging}\OperatorTok{;}
\KeywordTok{private}\NormalTok{ Point \_dragStart}\OperatorTok{;}

\KeywordTok{private} \DataTypeTok{void} \FunctionTok{Card\_PointerPressed}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ PointerPressedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    \_isDragging }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
\NormalTok{    \_dragStart }\OperatorTok{=}\NormalTok{ e}\OperatorTok{.}\FunctionTok{GetPosition}\OperatorTok{((}\NormalTok{Control}\OperatorTok{)}\NormalTok{sender}\OperatorTok{!);}
\NormalTok{    e}\OperatorTok{.}\FunctionTok{Pointer}\OperatorTok{.}\FunctionTok{Capture}\OperatorTok{((}\NormalTok{IInputElement}\OperatorTok{)}\NormalTok{sender}\OperatorTok{!);}
\OperatorTok{\}}

\KeywordTok{private} \DataTypeTok{void} \FunctionTok{Card\_PointerMoved}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ PointerEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{\_isDragging }\OperatorTok{\&\&}\NormalTok{ sender }\KeywordTok{is}\NormalTok{ Control control}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ offset }\OperatorTok{=}\NormalTok{ e}\OperatorTok{.}\FunctionTok{GetPosition}\OperatorTok{(}\NormalTok{control}\OperatorTok{)} \OperatorTok{{-}}\NormalTok{ \_dragStart}\OperatorTok{;}
\NormalTok{        Canvas}\OperatorTok{.}\FunctionTok{SetLeft}\OperatorTok{(}\NormalTok{control}\OperatorTok{,}\NormalTok{ offset}\OperatorTok{.}\FunctionTok{X}\OperatorTok{);}
\NormalTok{        Canvas}\OperatorTok{.}\FunctionTok{SetTop}\OperatorTok{(}\NormalTok{control}\OperatorTok{,}\NormalTok{ offset}\OperatorTok{.}\FunctionTok{Y}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{private} \DataTypeTok{void} \FunctionTok{Card\_PointerReleased}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ PointerReleasedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    \_isDragging }\OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
\NormalTok{    e}\OperatorTok{.}\FunctionTok{Pointer}\OperatorTok{.}\FunctionTok{Capture}\OperatorTok{(}\KeywordTok{null}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

To cancel capture, call \texttt{e.Pointer.Capture(null)} or use
\texttt{Pointer.Captured}. See
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/Pointer/PointerDevice.cs}{\texttt{PointerDevice.cs}}
and
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/PointerEventArgs.cs}{\texttt{PointerEventArgs.cs}}
for details.

\subsection{7. Text input pipeline (IME \&
composition)}\label{text-input-pipeline-ime-composition}

Text entry flows through \texttt{TextInput} events. For IME (Asian
languages), Avalonia raises \texttt{TextInput} with composition events.
To hook into the pipeline, subscribe to \texttt{TextInput} or implement
\texttt{ITextInputMethodClient} in custom controls. Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputMethodClient.cs}{\texttt{TextInputMethodClient.cs}}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TextBox}\OtherTok{ TextInput=}\StringTok{"TextBox\_TextInput"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private} \DataTypeTok{void} \FunctionTok{TextBox\_TextInput}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ TextInputEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    Debug}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\NormalTok{$}\StringTok{"TextInput: \{e.Text\}"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

In most MVVM apps you rely on \texttt{TextBox} handling IME; implement
this only when creating custom text editors.

\subsection{8. Keyboard focus management and
navigation}\label{keyboard-focus-management-and-navigation}

\begin{itemize}
\tightlist
\item
  Call \texttt{Focus()} to move input programmatically.
  \texttt{InputElement.Focus()} delegates to
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/FocusManager.cs}{\texttt{FocusManager}}.
\item
  Use \texttt{Focusable="False"} on decorative elements so they are
  skipped in traversal.
\item
  Control tab order with \texttt{TabIndex} (lower numbers focus first);
  combine with \texttt{KeyboardNavigation.TabNavigation} to scope loops.
\item
  Create focus scopes (\texttt{Focusable="True"} +
  \texttt{IsTabStop="True"}) for popups/overlays so focus returns to the
  invoking control when closed.
\item
  Use \texttt{TraversalRequest} and \texttt{KeyboardNavigationHandler}
  to implement custom arrow-key navigation for grids or toolbars.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{StackPanel}\OtherTok{ KeyboardNavigation.TabNavigation=}\StringTok{"Cycle"}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBox}\OtherTok{ x:Name=}\StringTok{"First"}\OtherTok{ Watermark=}\StringTok{"First name"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBox}\OtherTok{ x:Name=}\StringTok{"Second"}\OtherTok{ Watermark=}\StringTok{"Last name"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Focus second"}\OtherTok{ Command=}\StringTok{"\{Binding FocusSecondCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \DataTypeTok{void} \FunctionTok{FocusSecond}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ scope }\OperatorTok{=}\NormalTok{ FocusManager}\OperatorTok{.}\FunctionTok{Instance}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{;}
    \DataTypeTok{var}\NormalTok{ second }\OperatorTok{=} \KeywordTok{this}\OperatorTok{.}\FunctionTok{FindControl}\OperatorTok{\textless{}}\NormalTok{TextBox}\OperatorTok{\textgreater{}(}\StringTok{"Second"}\OperatorTok{);}
\NormalTok{    scope}\OperatorTok{?.}\FunctionTok{Focus}\OperatorTok{(}\NormalTok{second}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

For MVVM-safe focus changes, expose an interaction request (event or
\texttt{Interaction\textless{}T\textgreater{}} from ReactiveUI) and let
the view handle it. Keyboard navigation services live under
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/IKeyboardNavigationHandler.cs}{\texttt{IKeyboardNavigationHandler}}.

\subsection{9. Bridging commands with MVVM
frameworks}\label{bridging-commands-with-mvvm-frameworks}

\begin{itemize}
\tightlist
\item
  \textbf{CommunityToolkit.Mvvm} --
  \texttt{RelayCommand}/\texttt{AsyncRelayCommand} implement
  \texttt{ICommand} and expose \texttt{CanExecuteChanged}. Use
  \texttt{{[}RelayCommand{]}} attributes to generate commands and wrap
  business logic in partial classes.
\item
  \textbf{ReactiveUI} -- \texttt{ReactiveCommand} exposes
  \texttt{IObservable} execution pipelines, throttling, and
  cancellation. Bind with \texttt{\{Binding\ SaveCommand\}} just like
  any other \texttt{ICommand}.
\item
  \textbf{Prism / DryIoc} -- \texttt{DelegateCommand} supports
  \texttt{ObservesCanExecute} and integrates with dependency injection
  lifetimes.
\end{itemize}

To unify event-heavy code paths with commands, expose interaction
helpers instead of code-behind:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public}\NormalTok{ Interaction}\OperatorTok{\textless{}}\NormalTok{Unit}\OperatorTok{,}\NormalTok{ PointerPoint}\OperatorTok{?\textgreater{}}\NormalTok{ StartDragInteraction }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\OperatorTok{();}

\KeywordTok{public}\NormalTok{ async Task }\FunctionTok{BeginDragAsync}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ pointerPoint }\OperatorTok{=}\NormalTok{ await StartDragInteraction}\OperatorTok{.}\FunctionTok{Handle}\OperatorTok{(}\NormalTok{Unit}\OperatorTok{.}\FunctionTok{Default}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{pointerPoint }\KeywordTok{is} \OperatorTok{\{} \OperatorTok{\}}\NormalTok{ point}\OperatorTok{)}
    \OperatorTok{\{}
        \CommentTok{// Use pointer data to seed drag operation}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The example uses \texttt{ReactiveUI.Interaction} and
\texttt{Avalonia.Input.PointerPoint}; adapt the pattern to your MVVM
framework of choice.

In XAML, use \texttt{Interaction} behaviors
(\texttt{\textless{}interactions:Interaction.Triggers\textgreater{}} or
toolkit \texttt{EventToCommandBehavior}) to connect events such as
\texttt{PointerPressed} to \texttt{ReactiveCommand}s without writing
code-behind. This keeps event routing logic discoverable while leaving
testable command logic in the view model.

\subsection{10. Routed commands and command
routing}\label{routed-commands-and-command-routing}

Avalonia supports routed commands similar to WPF. Define a
\texttt{RoutedCommand} (\texttt{RoutedCommandLibrary.Save}, etc.) and
attach handlers via \texttt{CommandBinding}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window.CommandBindings}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{CommandBinding}\OtherTok{ Command=}\StringTok{"\{x:Static commands:AppCommands.Save\}"}\OtherTok{ Executed=}\StringTok{"Save\_Executed"}\OtherTok{ CanExecute=}\StringTok{"Save\_CanExecute"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Window.CommandBindings}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private} \DataTypeTok{void} \FunctionTok{Save\_Executed}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ ExecutedRoutedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{DataContext }\KeywordTok{is}\NormalTok{ MainWindowViewModel vm}\OperatorTok{)}
\NormalTok{        vm}\OperatorTok{.}\FunctionTok{SaveCommand}\OperatorTok{.}\FunctionTok{Execute}\OperatorTok{(}\KeywordTok{null}\OperatorTok{);}
\OperatorTok{\}}

\KeywordTok{private} \DataTypeTok{void} \FunctionTok{Save\_CanExecute}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ CanExecuteRoutedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    e}\OperatorTok{.}\FunctionTok{CanExecute} \OperatorTok{=} \OperatorTok{(}\NormalTok{DataContext }\KeywordTok{as}\NormalTok{ MainWindowViewModel}\OperatorTok{)?.}\FunctionTok{SaveCommand}\OperatorTok{.}\FunctionTok{CanExecute}\OperatorTok{(}\KeywordTok{null}\OperatorTok{)} \OperatorTok{==} \KeywordTok{true}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Routed commands bubble up the tree if not handled, allowing menu items
and toolbars to share command logic.

Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Interactivity/Input/RoutedCommand.cs}{\texttt{RoutedCommand.cs}}.

\subsection{11. Asynchronous command
patterns}\label{asynchronous-command-patterns}

Avoid blocking the UI thread. Use \texttt{AsyncRelayCommand} or custom
\texttt{ICommand} that runs \texttt{Task}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ AsyncRelayCommand }\OperatorTok{:}\NormalTok{ ICommand}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Func}\OperatorTok{\textless{}}\NormalTok{Task}\OperatorTok{\textgreater{}}\NormalTok{ \_execute}\OperatorTok{;}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Func}\OperatorTok{\textless{}}\DataTypeTok{bool}\OperatorTok{\textgreater{}?}\NormalTok{ \_canExecute}\OperatorTok{;}
    \KeywordTok{private} \DataTypeTok{bool}\NormalTok{ \_isExecuting}\OperatorTok{;}

    \KeywordTok{public} \FunctionTok{AsyncRelayCommand}\OperatorTok{(}\NormalTok{Func}\OperatorTok{\textless{}}\NormalTok{Task}\OperatorTok{\textgreater{}}\NormalTok{ execute}\OperatorTok{,}\NormalTok{ Func}\OperatorTok{\textless{}}\DataTypeTok{bool}\OperatorTok{\textgreater{}?}\NormalTok{ canExecute }\OperatorTok{=} \KeywordTok{null}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        \_execute }\OperatorTok{=}\NormalTok{ execute}\OperatorTok{;}
\NormalTok{        \_canExecute }\OperatorTok{=}\NormalTok{ canExecute}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{bool} \FunctionTok{CanExecute}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ parameter}\OperatorTok{)} \OperatorTok{=\textgreater{}} \OperatorTok{!}\NormalTok{\_isExecuting }\OperatorTok{\&\&} \OperatorTok{(}\NormalTok{\_canExecute}\OperatorTok{?.}\FunctionTok{Invoke}\OperatorTok{()} \OperatorTok{??} \KeywordTok{true}\OperatorTok{);}

    \KeywordTok{public}\NormalTok{ async }\DataTypeTok{void} \FunctionTok{Execute}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ parameter}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(!}\FunctionTok{CanExecute}\OperatorTok{(}\NormalTok{parameter}\OperatorTok{))}
            \KeywordTok{return}\OperatorTok{;}

        \KeywordTok{try}
        \OperatorTok{\{}
\NormalTok{            \_isExecuting }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
            \FunctionTok{RaiseCanExecuteChanged}\OperatorTok{();}
\NormalTok{            await }\FunctionTok{\_execute}\OperatorTok{();}
        \OperatorTok{\}}
        \KeywordTok{finally}
        \OperatorTok{\{}
\NormalTok{            \_isExecuting }\OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
            \FunctionTok{RaiseCanExecuteChanged}\OperatorTok{();}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \KeywordTok{public} \KeywordTok{event}\NormalTok{ EventHandler}\OperatorTok{?}\NormalTok{ CanExecuteChanged}\OperatorTok{;}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{RaiseCanExecuteChanged}\OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ CanExecuteChanged}\OperatorTok{?.}\FunctionTok{Invoke}\OperatorTok{(}\KeywordTok{this}\OperatorTok{,}\NormalTok{ EventArgs}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{12. Diagnostics: watch input
live}\label{diagnostics-watch-input-live}

DevTools (F12) -\textgreater{} \textbf{Events} tab let you monitor
events (PointerPressed, KeyDown). Select an element, toggle events to
watch.

Enable input logging:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{LogToTrace}\OperatorTok{(}\NormalTok{LogEventLevel}\OperatorTok{.}\FunctionTok{Debug}\OperatorTok{,} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{}\NormalTok{ LogArea}\OperatorTok{.}\FunctionTok{Input} \OperatorTok{\})}
    \OperatorTok{.}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{LogArea.Input} (source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Logging/LogArea.cs}{\texttt{LogArea.cs}})
emits detailed input information.

\subsection{13. Practice exercises}\label{practice-exercises-3}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Extend InputPlayground with a routed event logger: call
  \texttt{AddHandler} for
  \texttt{PointerPressedEvent}/\texttt{KeyDownEvent}, display bubbling
  order, and compare to the DevTools Events tab.
\item
  Register a global \texttt{Ctrl+Shift+S} gesture with
  \texttt{HotKeyManager.HotKey} (in XAML or via
  \texttt{HotKeyManager.SetHotKey}), then toggle the button's
  \texttt{IsEnabled} state and confirm \texttt{CanExecute} updates
  propagate.
\item
  Build a drag-to-reorder list that uses pointer capture and
  \texttt{PointerPoint.Properties} to track left vs right button drags.
\item
  Integrate a \texttt{ReactiveCommand} or toolkit
  \texttt{AsyncRelayCommand} with a drag
  \texttt{Interaction\textless{}T\textgreater{}} so the view model
  decides when async work starts.
\item
  Configure \texttt{KeyboardNavigation.TabNavigation="Cycle"} on a popup
  and verify focus returns to the launcher when it closes.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-7}

\begin{itemize}
\tightlist
\item
  Routed events:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Interactivity/RoutedEvent.cs}{\texttt{RoutedEvent.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Interactivity/RoutingStrategies.cs}{\texttt{RoutingStrategies}}
\item
  Commands:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Primitives/ButtonBase.cs}{\texttt{ButtonBase.Command}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/MenuItem.cs}{\texttt{MenuItem.Command}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Input/KeyBinding.cs}{\texttt{KeyBinding}}
\item
  Hotkeys:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyGesture.cs}{\texttt{KeyGesture.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/HotkeyManager.cs}{\texttt{HotkeyManager.cs}}
\item
  Input elements \& gestures:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/InputElement.cs}{\texttt{InputElement.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/GestureRecognizer.cs}{\texttt{GestureRecognizer.cs}}
\item
  Focus:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/FocusManager.cs}{\texttt{FocusManager.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/IKeyboardNavigationHandler.cs}{\texttt{IKeyboardNavigationHandler}}
\item
  Text input pipeline:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputMethodClient.cs}{\texttt{TextInputMethodClient.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-7}

\begin{itemize}
\tightlist
\item
  What advantages do commands offer over events in MVVM architectures?
\item
  When would you choose \texttt{KeyBinding} vs registering a gesture
  with \texttt{HotKeyManager}?
\item
  Which API captures \texttt{PointerPoint} data during drag initiation
  and why does it matter?
\item
  How would you bridge a pointer event to a \texttt{ReactiveCommand} or
  toolkit command without code-behind?
\item
  Which tooling surfaces routed events, and how do you enable verbose
  input logging?
\end{itemize}

What's next - Next: \href{Chapter10.md}{Chapter 10}

\newpage

\subsection{10. Working with resources, images, and
fonts}\label{working-with-resources-images-and-fonts}

Goal - Master \texttt{avares://} URIs,
\texttt{AssetLoader}/\texttt{IAssetLoader}, and
\texttt{ResourceDictionary} lookup so you can bundle assets cleanly. -
Display raster and vector images, control caching/interpolation, and
brush surfaces with images (including SVG pipelines). - Load custom
fonts, configure \texttt{FontManagerOptions}, and swap font families at
runtime. - Understand resource fallback order, dynamic
\texttt{ResourceDictionary} updates, and diagnostics when a lookup
fails. - Tune DPI scaling, bitmap interpolation, and responsive asset
strategies that scale across devices.

Why this matters - Assets and fonts give your app brand identity; doing
it right avoids blurry visuals or missing resources. - Avalonia's
resource system mirrors WPF/UWP but with cross-platform packaging; once
you know the patterns, you can deploy confidently.

Prerequisites - You can edit \texttt{App.axaml}, views, and bind data
(Ch. 3-9). - Familiarity with MVVM and theming (Ch. 7) helps when wiring
assets dynamically.

\subsection{\texorpdfstring{1. \texttt{avares://} URIs and project
structure}{1. avares:// URIs and project structure}}\label{avares-uris-and-project-structure}

Assets live under your project (e.g., \texttt{Assets/Images},
\texttt{Assets/Fonts}). Include them as \texttt{AvaloniaResource} in the
\texttt{.csproj}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ItemGroup}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{AvaloniaResource}\OtherTok{ Include=}\StringTok{"Assets/**"}\NormalTok{ /\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ItemGroup}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

URI structure:
\texttt{avares://\textless{}AssemblyName\textgreater{}/\textless{}RelativePath\textgreater{}}.

Example: \texttt{avares://InputPlayground/Assets/Images/logo.png}.

\texttt{avares://} references the compiled resource stream (not the file
system). Use it consistently even within the same assembly to avoid
issues with resource lookups.

\subsection{2. Resource dictionaries and lookup
order}\label{resource-dictionaries-and-lookup-order}

\texttt{ResourceDictionary} derives from
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Controls/ResourceProvider.cs}{\texttt{ResourceProvider}}
and implements
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Controls/IResourceProvider.cs}{\texttt{IResourceProvider}}.
When you request \texttt{\{StaticResource\}} or call
\texttt{TryGetResource}, Avalonia walks this chain:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The requesting \texttt{IResourceHost} (control, style, or
  application).
\item
  Parent styles (\texttt{\textless{}Style.Resources\textgreater{}}),
  control templates, and data templates.
\item
  Theme dictionaries (\texttt{ThemeVariantScope},
  \texttt{Application.Styles}, \texttt{Application.Resources}).
\item
  Merged dictionaries
  (\texttt{\textless{}ResourceDictionary.MergedDictionaries\textgreater{}}
  or \texttt{\textless{}ResourceInclude\textgreater{}}).
\item
  Global application resources and finally platform defaults
  (\texttt{SystemResources}).
\end{enumerate}

\texttt{ResourceDictionary.cs} and \texttt{ResourceNode.cs} coordinate
this traversal. Use \texttt{TryGetResource} when retrieving values from
code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \OperatorTok{(}\NormalTok{control}\OperatorTok{.}\FunctionTok{TryGetResource}\OperatorTok{(}\StringTok{"AccentBrush"}\OperatorTok{,}\NormalTok{ ThemeVariant}\OperatorTok{.}\FunctionTok{Dark}\OperatorTok{,} \KeywordTok{out} \DataTypeTok{var}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\&\&}\NormalTok{ value }\KeywordTok{is}\NormalTok{ IBrush brush}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    control}\OperatorTok{.}\FunctionTok{Background} \OperatorTok{=}\NormalTok{ brush}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{ThemeVariant} lets you request a variant-specific value; pass
\texttt{ThemeVariant.Default} to follow the same logic as
\texttt{\{DynamicResource\}}.

Merge dictionaries to break assets into reusable packs:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ResourceDictionary.MergedDictionaries}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ResourceInclude}\OtherTok{ Source=}\StringTok{"avares://AssetsDemo/Assets/Colors.axaml"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ResourceInclude}\OtherTok{ Source=}\StringTok{"avares://AssetsDemo/Assets/Icons.axaml"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ResourceDictionary.MergedDictionaries}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Each merged dictionary is loaded lazily via \texttt{IAssetLoader}, so
make sure the referenced file is marked as \texttt{AvaloniaResource}.

\subsection{3. Loading assets in XAML and
code}\label{loading-assets-in-xaml-and-code}

\subsubsection{XAML}\label{xaml}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Image}\OtherTok{ Source=}\StringTok{"avares://AssetsDemo/Assets/Images/logo.png"}
\OtherTok{       Stretch=}\StringTok{"Uniform"}\OtherTok{ Width=}\StringTok{"160"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Code using
\texttt{AssetLoader}}{Code using AssetLoader}}\label{code-using-assetloader}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Media}\OperatorTok{.}\FunctionTok{Imaging}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Platform}\OperatorTok{;}

\DataTypeTok{var}\NormalTok{ uri }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Uri}\OperatorTok{(}\StringTok{"avares://AssetsDemo/Assets/Images/logo.png"}\OperatorTok{);}
\DataTypeTok{var}\NormalTok{ assetLoader }\OperatorTok{=}\NormalTok{ AvaloniaLocator}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{IAssetLoader}\OperatorTok{\textgreater{}();}

\NormalTok{await }\KeywordTok{using} \DataTypeTok{var}\NormalTok{ stream }\OperatorTok{=}\NormalTok{ assetLoader}\OperatorTok{.}\FunctionTok{Open}\OperatorTok{(}\NormalTok{uri}\OperatorTok{);}
\NormalTok{LogoImage}\OperatorTok{.}\FunctionTok{Source} \OperatorTok{=} \KeywordTok{new} \FunctionTok{Bitmap}\OperatorTok{(}\NormalTok{stream}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{AssetLoader} is a static helper over the same
\texttt{IAssetLoader} service. Prefer the interface when unit testing or
when you need to mock resource access. Both live in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/AssetLoader.cs}{\texttt{Avalonia.Platform}}.

Need to probe for optional assets? Use \texttt{assetLoader.TryOpen(uri)}
or \texttt{AssetLoader.Exists(uri)} to avoid exceptions.

\subsubsection{Resource dictionaries}\label{resource-dictionaries}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ResourceDictionary}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Bitmap}\OtherTok{ x:Key=}\StringTok{"LogoBitmap"}\NormalTok{\textgreater{}avares://AssetsDemo/Assets/Images/logo.png\textless{}/}\KeywordTok{Bitmap}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

You can then \texttt{StaticResource} expose \texttt{LogoBitmap}. Bitmaps
created this way are cached.

\subsection{4. Raster images, decoders, and
caching}\label{raster-images-decoders-and-caching}

\texttt{Image} renders \texttt{Avalonia.Media.Imaging.Bitmap}. Decode
streams once and keep the bitmap alive when the pixels are reused,
instead of calling \texttt{new\ Bitmap(stream)} for every render.
Performance tips: - Set \texttt{Stretch} to avoid unexpected distortions
(Uniform, UniformToFill, Fill, None). - Use
\texttt{RenderOptions.BitmapInterpolationMode} for scaling quality:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Image}\OtherTok{ Source=}\StringTok{"avares://AssetsDemo/Assets/Images/photo.jpg"}
\OtherTok{       Width=}\StringTok{"240"}\OtherTok{ Height=}\StringTok{"160"}
\OtherTok{       RenderOptions.BitmapInterpolationMode=}\StringTok{"HighQuality"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

Interpolation modes defined in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/RenderOptions.cs}{\texttt{RenderOptions.cs}}.

Decode oversized images to a target width/height to save memory:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{await }\KeywordTok{using} \DataTypeTok{var}\NormalTok{ stream }\OperatorTok{=}\NormalTok{ assetLoader}\OperatorTok{.}\FunctionTok{Open}\OperatorTok{(}\NormalTok{uri}\OperatorTok{);}
\KeywordTok{using} \DataTypeTok{var}\NormalTok{ decoded }\OperatorTok{=}\NormalTok{ Bitmap}\OperatorTok{.}\FunctionTok{DecodeToWidth}\OperatorTok{(}\NormalTok{stream}\OperatorTok{,} \DecValTok{512}\OperatorTok{);}
\NormalTok{PhotoImage}\OperatorTok{.}\FunctionTok{Source} \OperatorTok{=}\NormalTok{ decoded}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\texttt{Bitmap} and decoder helpers live in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/Imaging/Bitmap.cs}{\texttt{Bitmap.cs}}.
Avalonia picks the right codec (PNG, JPEG, WebP, BMP, GIF) using Skia;
for unsupported formats supply a custom \texttt{IBitmapDecoder}.

\subsection{5. ImageBrush and tiled
backgrounds}\label{imagebrush-and-tiled-backgrounds}

\texttt{ImageBrush} paints surfaces:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Ellipse}\OtherTok{ Width=}\StringTok{"96"}\OtherTok{ Height=}\StringTok{"96"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Ellipse.Fill}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ImageBrush}\OtherTok{ Source=}\StringTok{"avares://AssetsDemo/Assets/Images/avatar.png"}
\OtherTok{                Stretch=}\StringTok{"UniformToFill"}\OtherTok{ AlignmentX=}\StringTok{"Center"}\OtherTok{ AlignmentY=}\StringTok{"Center"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Ellipse.Fill}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Ellipse}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Tile backgrounds:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Border}\OtherTok{ Width=}\StringTok{"200"}\OtherTok{ Height=}\StringTok{"120"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Border.Background}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ImageBrush}\OtherTok{ Source=}\StringTok{"avares://AssetsDemo/Assets/Images/pattern.png"}
\OtherTok{                TileMode=}\StringTok{"Tile"}
\OtherTok{                Stretch=}\StringTok{"None"}
\OtherTok{                Transform=}\StringTok{"\{ScaleTransform 0.5,0.5\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Border.Background}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{ImageBrush} documentation:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/ImageBrush.cs}{\texttt{ImageBrush.cs}}.

\subsection{6. Vector graphics}\label{vector-graphics}

Vector art scales with DPI, can adapt to theme colors, and stays crisp.

\subsubsection{Inline geometry}\label{inline-geometry}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Path}\OtherTok{ Data=}\StringTok{"M2 12 L9 19 L22 4"}
\OtherTok{      Stroke=}\StringTok{"\{DynamicResource AccentBrush\}"}
\OtherTok{      StrokeThickness=}\StringTok{"3"}
\OtherTok{      StrokeLineCap=}\StringTok{"Round"}\OtherTok{ StrokeLineJoin=}\StringTok{"Round"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

Store geometry in resources for reuse:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ResourceDictionary}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Geometry}\OtherTok{ x:Key=}\StringTok{"IconCheck"}\NormalTok{\textgreater{}M2 12 L9 19 L22 4\textless{}/}\KeywordTok{Geometry}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Vector classes live under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Media}{\texttt{Avalonia.Media}}.

\subsubsection{\texorpdfstring{\texttt{StreamGeometryContext} for
programmatic
icons}{StreamGeometryContext for programmatic icons}}\label{streamgeometrycontext-for-programmatic-icons}

Generate vector shapes in code when you need to compose icons
dynamically or reuse geometry logic:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ geometry }\OperatorTok{=} \KeywordTok{new} \FunctionTok{StreamGeometry}\OperatorTok{();}

\KeywordTok{using} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ ctx }\OperatorTok{=}\NormalTok{ geometry}\OperatorTok{.}\FunctionTok{Open}\OperatorTok{())}
\OperatorTok{\{}
\NormalTok{    ctx}\OperatorTok{.}\FunctionTok{BeginFigure}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{12}\OperatorTok{),}\NormalTok{ isFilled}\OperatorTok{:} \KeywordTok{false}\OperatorTok{);}
\NormalTok{    ctx}\OperatorTok{.}\FunctionTok{LineTo}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{9}\OperatorTok{,} \DecValTok{19}\OperatorTok{));}
\NormalTok{    ctx}\OperatorTok{.}\FunctionTok{LineTo}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{22}\OperatorTok{,} \DecValTok{4}\OperatorTok{));}
\NormalTok{    ctx}\OperatorTok{.}\FunctionTok{EndFigure}\OperatorTok{(}\NormalTok{isClosed}\OperatorTok{:} \KeywordTok{false}\OperatorTok{);}
\OperatorTok{\}}

\NormalTok{IconPath}\OperatorTok{.}\FunctionTok{Data} \OperatorTok{=}\NormalTok{ geometry}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\texttt{StreamGeometry} and \texttt{StreamGeometryContext} live in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/StreamGeometryContext.cs}{\texttt{StreamGeometryContext.cs}}.
Remember to freeze geometry instances or share them via resources to
reduce allocations.

\subsubsection{SVG support}\label{svg-support}

Install the \texttt{Avalonia.Svg.Skia} package to render SVG assets
natively:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{svg:SvgImage}\OtherTok{ xmlns:svg=}\StringTok{"clr{-}namespace:Avalonia.Svg.Controls;assembly=Avalonia.Svg.Skia"}
\OtherTok{              Source=}\StringTok{"avares://AssetsDemo/Assets/Images/logo.svg"}
\OtherTok{              Stretch=}\StringTok{"Uniform"}\NormalTok{ /\textgreater{}}
\end{Highlighting}
\end{Shaded}

SVGs stay sharp at any DPI and can adapt colors if you parameterize them
(e.g., replace fill attributes at build time). For simple icons,
converting the path data into XAML keeps dependencies minimal.

\subsection{7. Fonts and typography}\label{fonts-and-typography}

Place fonts in \texttt{Assets/Fonts}. Register them in
\texttt{App.axaml} via \texttt{Global::Avalonia} URI and specify the
font face after \texttt{\#}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Application.Resources}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{FontFamily}\OtherTok{ x:Key=}\StringTok{"HeadingFont"}\NormalTok{\textgreater{}avares://AssetsDemo/Assets/Fonts/Inter.ttf\#Inter\textless{}/}\KeywordTok{FontFamily}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Application.Resources}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Use the font in styles:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Application.Styles}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Style}\OtherTok{ Selector=}\StringTok{"TextBlock.h1"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"FontFamily"}\OtherTok{ Value=}\StringTok{"\{StaticResource HeadingFont\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"FontSize"}\OtherTok{ Value=}\StringTok{"28"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"FontWeight"}\OtherTok{ Value=}\StringTok{"SemiBold"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Application.Styles}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{FontManager options}\label{fontmanager-options}

Configure global font settings in \texttt{AppBuilder}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{With}\OperatorTok{(}\KeywordTok{new}\NormalTok{ FontManagerOptions}
    \OperatorTok{\{}
\NormalTok{        DefaultFamilyName }\OperatorTok{=} \StringTok{"avares://AssetsDemo/Assets/Fonts/Inter.ttf\#Inter"}\OperatorTok{,}
\NormalTok{        FontFallbacks }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{} \KeywordTok{new}\NormalTok{ FontFallback }\OperatorTok{\{}\NormalTok{ Family }\OperatorTok{=} \StringTok{"Segoe UI"} \OperatorTok{\},} \KeywordTok{new}\NormalTok{ FontFallback }\OperatorTok{\{}\NormalTok{ Family }\OperatorTok{=} \StringTok{"Roboto"} \OperatorTok{\}} \OperatorTok{\}}
    \OperatorTok{\})}
    \OperatorTok{.}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{FontManagerOptions} lives in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/FontManagerOptions.cs}{\texttt{FontManagerOptions.cs}}.

\subsubsection{Multi-weight fonts}\label{multi-weight-fonts}

If fonts include multiple weights, specify them with
\texttt{FontWeight}. If you ship multiple font files (Regular, Bold),
ensure the \texttt{\#Family} name is consistent.

\subsubsection{Runtime font swaps and custom
collections}\label{runtime-font-swaps-and-custom-collections}

You can inject fonts at runtime without restarting the app. Register an
embedded collection and update resources:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Media}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Media}\OperatorTok{.}\FunctionTok{Fonts}\OperatorTok{;}

\DataTypeTok{var}\NormalTok{ baseUri }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Uri}\OperatorTok{(}\StringTok{"avares://AssetsDemo/Assets/BrandFonts/"}\OperatorTok{);}
\DataTypeTok{var}\NormalTok{ collection }\OperatorTok{=} \KeywordTok{new} \FunctionTok{EmbeddedFontCollection}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Uri}\OperatorTok{(}\StringTok{"fonts:brand"}\OperatorTok{),}\NormalTok{ baseUri}\OperatorTok{);}

\NormalTok{FontManager}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{.}\FunctionTok{AddFontCollection}\OperatorTok{(}\NormalTok{collection}\OperatorTok{);}

\NormalTok{Application}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{!.}\FunctionTok{Resources}\OperatorTok{[}\StringTok{"BodyFont"}\OperatorTok{]} \OperatorTok{=} \KeywordTok{new} \FunctionTok{FontFamily}\OperatorTok{(}\StringTok{"fonts:brand\#Brand Sans"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{EmbeddedFontCollection} pulls all font files under the provided
URI using \texttt{IAssetLoader}. Removing the collection via
\texttt{FontManager.Current.RemoveFontCollection(new\ Uri("fonts:brand"))}
detaches it again.

\subsection{8. DPI scaling, caching, and
performance}\label{dpi-scaling-caching-and-performance}

Avalonia measures layout in DIPs (1 DIP = 1/96 inch). High DPI monitors
scale automatically.

\begin{itemize}
\tightlist
\item
  Prefer vector assets or high-resolution bitmaps.
\item
  Use \texttt{RenderOptions.BitmapInterpolationMode="None"} for pixel
  art.
\item
  For expensive bitmaps (charts) consider caching via
  \texttt{RenderTargetBitmap} or \texttt{WriteableBitmap}.
\end{itemize}

\texttt{RenderTargetBitmap} and \texttt{WriteableBitmap} under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Media/Imaging}{\texttt{Avalonia.Media.Imaging}}.

\subsection{9. Dynamic resources, theme variants, and runtime
updates}\label{dynamic-resources-theme-variants-and-runtime-updates}

Bind brushes via \texttt{DynamicResource} so assets respond to theme
changes. When a dictionary entry changes,
\texttt{ResourceDictionary.ResourcesChanged} notifies every subscriber
and controls update automatically:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Application.Resources}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{SolidColorBrush}\OtherTok{ x:Key=}\StringTok{"AvatarFallbackBrush"}\OtherTok{ Color=}\StringTok{"\#1F2937"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Application.Resources}\NormalTok{\textgreater{}}

\NormalTok{\textless{}}\KeywordTok{Ellipse}\OtherTok{ Fill=}\StringTok{"\{DynamicResource AvatarFallbackBrush\}"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

At runtime you can swap assets:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Application}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{!.}\FunctionTok{Resources}\OperatorTok{[}\StringTok{"AvatarFallbackBrush"}\OperatorTok{]} \OperatorTok{=} \KeywordTok{new} \FunctionTok{SolidColorBrush}\OperatorTok{(}\NormalTok{Color}\OperatorTok{.}\FunctionTok{Parse}\OperatorTok{(}\StringTok{"\#3B82F6"}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

To scope variants, wrap content in a \texttt{ThemeVariantScope} and
supply dictionaries per variant:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ThemeVariantScope}\OtherTok{ RequestedThemeVariant=}\StringTok{"Dark"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ThemeVariantScope.Resources}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{SolidColorBrush}\OtherTok{ x:Key=}\StringTok{"AvatarFallbackBrush"}\OtherTok{ Color=}\StringTok{"\#E5E7EB"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ThemeVariantScope.Resources}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ContentPresenter}\OtherTok{ Content=}\StringTok{"\{Binding\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ThemeVariantScope}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{ThemeVariantScope} relies on \texttt{IResourceHost} to merge
dictionaries in order (scope → parent scope → application). To inspect
all merged resources in DevTools, open \textbf{Resources} and observe
how \texttt{RequestedThemeVariant} switches dictionaries.

\subsection{10. Diagnostics}\label{diagnostics}

\begin{itemize}
\tightlist
\item
  DevTools -\textgreater{} Resources shows resolved resources.
\item
  Missing asset? Check the output logs (\texttt{RenderOptions} area) for
  ``not found'' messages.
\item
  Use \texttt{AssetLoader.Exists(uri)} to verify at runtime:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \OperatorTok{(!}\NormalTok{AssetLoader}\OperatorTok{.}\FunctionTok{Exists}\OperatorTok{(}\NormalTok{uri}\OperatorTok{))}
    \KeywordTok{throw} \KeywordTok{new} \FunctionTok{FileNotFoundException}\OperatorTok{(}\NormalTok{$}\StringTok{"Asset \{uri\} not found"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Subscribe to \texttt{Application.Current.Resources.ResourcesChanged}
  (or scope-specific hosts) to log when dictionaries update, especially
  when debugging \texttt{DynamicResource} refreshes.
\end{itemize}

\subsection{11. Sample ``asset gallery''}\label{sample-asset-gallery}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Grid}\OtherTok{ ColumnDefinitions=}\StringTok{"Auto,24,Auto"}\OtherTok{ RowDefinitions=}\StringTok{"Auto,12,Auto"}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{Image}\OtherTok{ Width=}\StringTok{"160"}\OtherTok{ Height=}\StringTok{"80"}\OtherTok{ Stretch=}\StringTok{"Uniform"}
\OtherTok{         Source=}\StringTok{"avares://AssetsDemo/Assets/Images/logo.png"}\NormalTok{/\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{Rectangle}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ Grid.RowSpan=}\StringTok{"3"}\OtherTok{ Width=}\StringTok{"24"}\NormalTok{/\textgreater{}}


\NormalTok{  \textless{}}\KeywordTok{Ellipse}\OtherTok{ Grid.Column=}\StringTok{"2"}\OtherTok{ Width=}\StringTok{"96"}\OtherTok{ Height=}\StringTok{"96"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Ellipse.Fill}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{ImageBrush}\OtherTok{ Source=}\StringTok{"avares://AssetsDemo/Assets/Images/avatar.png"}\OtherTok{ Stretch=}\StringTok{"UniformToFill"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Ellipse.Fill}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Ellipse}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{Rectangle}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ Grid.ColumnSpan=}\StringTok{"3"}\OtherTok{ Height=}\StringTok{"12"}\NormalTok{/\textgreater{}}


\NormalTok{  \textless{}}\KeywordTok{Canvas}\OtherTok{ Grid.Row=}\StringTok{"2"}\OtherTok{ Grid.Column=}\StringTok{"0"}\OtherTok{ Width=}\StringTok{"28"}\OtherTok{ Height=}\StringTok{"28"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Path}\OtherTok{ Data=}\StringTok{"M2 14 L10 22 L26 6"}
\OtherTok{          Stroke=}\StringTok{"\{DynamicResource AccentBrush\}"}
\OtherTok{          StrokeThickness=}\StringTok{"3"}\OtherTok{ StrokeLineCap=}\StringTok{"Round"}\OtherTok{ StrokeLineJoin=}\StringTok{"Round"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Canvas}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ Grid.Row=}\StringTok{"2"}\OtherTok{ Grid.Column=}\StringTok{"2"}\OtherTok{ Classes=}\StringTok{"h1"}\OtherTok{ Text=}\StringTok{"Asset gallery"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsection{12. Practice exercises}\label{practice-exercises-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Move brand colors into \texttt{Assets/Brand.axaml}, include it with
  \texttt{\textless{}ResourceInclude\ Source="avares://AssetsDemo/Assets/Brand.axaml"/\textgreater{}},
  and verify lookups succeed from a control in another assembly.
\item
  Build an image component that prefers SVG (\texttt{SvgImage}) but
  falls back to a PNG \texttt{Bitmap} on platforms where the SVG package
  is missing.
\item
  Decode a high-resolution photo with \texttt{Bitmap.DecodeToWidth} and
  compare memory usage against eagerly loading the original stream.
\item
  Register an \texttt{EmbeddedFontCollection} at runtime and swap your
  typography resources by updating
  \texttt{Application.Current.Resources{[}"BodyFont"{]}}.
\item
  Toggle \texttt{ThemeVariantScope.RequestedThemeVariant} at runtime and
  confirm \texttt{DynamicResource}-bound brushes and images update
  without recreating controls.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-8}

\begin{itemize}
\tightlist
\item
  Resource system:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Controls/ResourceProvider.cs}{\texttt{ResourceProvider.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Controls/ResourceDictionary.cs}{\texttt{ResourceDictionary.cs}}
\item
  Asset loader and URIs:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/AssetLoader.cs}{\texttt{AssetLoader.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Markup/ResourceInclude.cs}{\texttt{ResourceInclude.cs}}
\item
  Bitmap and imaging:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/Imaging/Bitmap.cs}{\texttt{Bitmap.cs}}
\item
  Vector geometry:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/StreamGeometryContext.cs}{\texttt{StreamGeometryContext.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Shapes/Path.cs}{\texttt{Path.cs}}
\item
  Fonts \& text formatting:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/FontManager.cs}{\texttt{FontManager.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/Fonts/EmbeddedFontCollection.cs}{\texttt{EmbeddedFontCollection.cs}}
\item
  Theme variants and resources:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/ThemeVariantScope.cs}{\texttt{ThemeVariantScope.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Controls/ResourcesChangedHelper.cs}{\texttt{ResourcesChangedHelper.cs}}
\item
  Render options and DPI:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/RenderOptions.cs}{\texttt{RenderOptions.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-8}

\begin{itemize}
\tightlist
\item
  What order does Avalonia search when resolving
  \texttt{\{StaticResource\}} and \texttt{\{DynamicResource\}}?
\item
  When do you reach for \texttt{IAssetLoader} instead of the static
  \texttt{AssetLoader} helper?
\item
  How would you build a responsive icon pipeline that prefers
  \texttt{StreamGeometry}/SVG but falls back to a bitmap?
\item
  Which APIs let you swap font families at runtime without restarting
  the app?
\item
  How can you confirm that dynamic resource updates propagated after
  changing \texttt{Application.Current.Resources}?
\end{itemize}

What's next - Next: \href{Chapter11.md}{Chapter 11}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part III — Application patterns that scale}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part III — Application patterns that scale}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{11. MVVM in depth (with or without
ReactiveUI)}\label{mvvm-in-depth-with-or-without-reactiveui}

Goal - Build production-ready MVVM layers using classic
\texttt{INotifyPropertyChanged}, CommunityToolkit.Mvvm helpers, or
ReactiveUI. - Map view models to views with data templates, view locator
patterns, and dependency injection. - Compose complex state using
property change notifications, derived properties, async commands, and
navigation stacks. - Test view models and reactive flows confidently.

Why this matters - MVVM separates concerns so you can scale UI
complexity, swap views, and run automated tests. - Avalonia supports
multiple MVVM toolkits; understanding their trade-offs lets you choose
the right fit per feature.

Prerequisites - Binding basics (Chapter 8) and commands/input (Chapter
9). - Familiarity with resource organization (Chapter 7) for styles and
data templates.

\subsection{1. MVVM recap}\label{mvvm-recap}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Layer
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Role
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Contains
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Model & Core data/domain logic & POCOs, validation, persistence
models \\
ViewModel & Bindable state, commands & \texttt{INotifyPropertyChanged},
\texttt{ICommand}, services \\
View & XAML + minimal code-behind & DataTemplates, layout, visuals \\
\end{longtable}

Focus on keeping business logic in view models/models; views remain
thin.

\subsection{2. Classic MVVM (manual or
CommunityToolkit.Mvvm)}\label{classic-mvvm-manual-or-communitytoolkit.mvvm}

\subsubsection{2.1 Property change base
class}\label{property-change-base-class}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{ComponentModel}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Runtime}\OperatorTok{.}\FunctionTok{CompilerServices}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ ObservableObject }\OperatorTok{:}\NormalTok{ INotifyPropertyChanged}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{event}\NormalTok{ PropertyChangedEventHandler}\OperatorTok{?}\NormalTok{ PropertyChanged}\OperatorTok{;}

    \KeywordTok{protected} \DataTypeTok{bool}\NormalTok{ SetProperty}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{\textgreater{}(}\KeywordTok{ref}\NormalTok{ T field}\OperatorTok{,}\NormalTok{ T value}\OperatorTok{,} \OperatorTok{[}\NormalTok{CallerMemberName}\OperatorTok{]} \DataTypeTok{string}\OperatorTok{?}\NormalTok{ propertyName }\OperatorTok{=} \KeywordTok{null}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\FunctionTok{Equals}\OperatorTok{(}\NormalTok{field}\OperatorTok{,}\NormalTok{ value}\OperatorTok{))}
            \KeywordTok{return} \KeywordTok{false}\OperatorTok{;}

\NormalTok{        field }\OperatorTok{=}\NormalTok{ value}\OperatorTok{;}
\NormalTok{        PropertyChanged}\OperatorTok{?.}\FunctionTok{Invoke}\OperatorTok{(}\KeywordTok{this}\OperatorTok{,} \KeywordTok{new} \FunctionTok{PropertyChangedEventArgs}\OperatorTok{(}\NormalTok{propertyName}\OperatorTok{));}
        \KeywordTok{return} \KeywordTok{true}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

CommunityToolkit.Mvvm offers \texttt{ObservableObject},
\texttt{ObservableProperty} attribute, and \texttt{RelayCommand} out of
the box. If you prefer built-in solutions, install
\texttt{CommunityToolkit.Mvvm} and inherit from
\texttt{ObservableObject} there.

\subsubsection{\texorpdfstring{2.2 Commands
(\texttt{RelayCommand})}{2.2 Commands (RelayCommand)}}\label{commands-relaycommand}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ RelayCommand }\OperatorTok{:}\NormalTok{ ICommand}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Action}\OperatorTok{\textless{}}\DataTypeTok{object}\OperatorTok{?\textgreater{}}\NormalTok{ \_execute}\OperatorTok{;}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Func}\OperatorTok{\textless{}}\DataTypeTok{object}\OperatorTok{?,} \DataTypeTok{bool}\OperatorTok{\textgreater{}?}\NormalTok{ \_canExecute}\OperatorTok{;}

    \KeywordTok{public} \FunctionTok{RelayCommand}\OperatorTok{(}\NormalTok{Action}\OperatorTok{\textless{}}\DataTypeTok{object}\OperatorTok{?\textgreater{}}\NormalTok{ execute}\OperatorTok{,}\NormalTok{ Func}\OperatorTok{\textless{}}\DataTypeTok{object}\OperatorTok{?,} \DataTypeTok{bool}\OperatorTok{\textgreater{}?}\NormalTok{ canExecute }\OperatorTok{=} \KeywordTok{null}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        \_execute }\OperatorTok{=}\NormalTok{ execute }\OperatorTok{??} \KeywordTok{throw} \KeywordTok{new} \FunctionTok{ArgumentNullException}\OperatorTok{(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{execute}\OperatorTok{));}
\NormalTok{        \_canExecute }\OperatorTok{=}\NormalTok{ canExecute}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{bool} \FunctionTok{CanExecute}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ parameter}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_canExecute}\OperatorTok{?.}\FunctionTok{Invoke}\OperatorTok{(}\NormalTok{parameter}\OperatorTok{)} \OperatorTok{??} \KeywordTok{true}\OperatorTok{;}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Execute}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ parameter}\OperatorTok{)} \OperatorTok{=\textgreater{}} \FunctionTok{\_execute}\OperatorTok{(}\NormalTok{parameter}\OperatorTok{);}

    \KeywordTok{public} \KeywordTok{event}\NormalTok{ EventHandler}\OperatorTok{?}\NormalTok{ CanExecuteChanged}\OperatorTok{;}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{RaiseCanExecuteChanged}\OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ CanExecuteChanged}\OperatorTok{?.}\FunctionTok{Invoke}\OperatorTok{(}\KeywordTok{this}\OperatorTok{,}\NormalTok{ EventArgs}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{2.3 Sample: People view
model}\label{sample-people-view-model}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Collections}\OperatorTok{.}\FunctionTok{ObjectModel}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ Person }\OperatorTok{:}\NormalTok{ ObservableObject}
\OperatorTok{\{}
    \KeywordTok{private} \DataTypeTok{string}\NormalTok{ \_firstName}\OperatorTok{;}
    \KeywordTok{private} \DataTypeTok{string}\NormalTok{ \_lastName}\OperatorTok{;}

    \KeywordTok{public} \FunctionTok{Person}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ first}\OperatorTok{,} \DataTypeTok{string}\NormalTok{ last}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        \_firstName }\OperatorTok{=}\NormalTok{ first}\OperatorTok{;}
\NormalTok{        \_lastName }\OperatorTok{=}\NormalTok{ last}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{string}\NormalTok{ FirstName}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_firstName}\OperatorTok{;}
\NormalTok{        set }\OperatorTok{=\textgreater{}} \FunctionTok{SetProperty}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_firstName}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{string}\NormalTok{ LastName}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_lastName}\OperatorTok{;}
\NormalTok{        set }\OperatorTok{=\textgreater{}} \FunctionTok{SetProperty}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_lastName}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{public} \KeywordTok{override} \DataTypeTok{string} \FunctionTok{ToString}\OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ $}\StringTok{"\{FirstName\} \{LastName\}"}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ PeopleViewModel }\OperatorTok{:}\NormalTok{ ObservableObject}
\OperatorTok{\{}
    \KeywordTok{private}\NormalTok{ Person}\OperatorTok{?}\NormalTok{ \_selected}\OperatorTok{;}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ IPersonService \_personService}\OperatorTok{;}

    \KeywordTok{public}\NormalTok{ ObservableCollection}\OperatorTok{\textless{}}\NormalTok{Person}\OperatorTok{\textgreater{}}\NormalTok{ People }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\OperatorTok{();}
    \KeywordTok{public}\NormalTok{ RelayCommand AddCommand }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}
    \KeywordTok{public}\NormalTok{ RelayCommand RemoveCommand }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}

    \KeywordTok{public} \FunctionTok{PeopleViewModel}\OperatorTok{(}\NormalTok{IPersonService personService}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        \_personService }\OperatorTok{=}\NormalTok{ personService}\OperatorTok{;}
\NormalTok{        AddCommand }\OperatorTok{=} \KeywordTok{new} \FunctionTok{RelayCommand}\OperatorTok{(}\NormalTok{\_ }\OperatorTok{=\textgreater{}} \FunctionTok{AddPerson}\OperatorTok{());}
\NormalTok{        RemoveCommand }\OperatorTok{=} \KeywordTok{new} \FunctionTok{RelayCommand}\OperatorTok{(}\NormalTok{\_ }\OperatorTok{=\textgreater{}} \FunctionTok{RemovePerson}\OperatorTok{(),}\NormalTok{ \_ }\OperatorTok{=\textgreater{}}\NormalTok{ Selected }\KeywordTok{is}\NormalTok{ not }\KeywordTok{null}\OperatorTok{);}

        \FunctionTok{LoadInitialPeople}\OperatorTok{();}
    \OperatorTok{\}}

    \KeywordTok{public}\NormalTok{ Person}\OperatorTok{?}\NormalTok{ Selected}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_selected}\OperatorTok{;}
\NormalTok{        set}
        \OperatorTok{\{}
            \KeywordTok{if} \OperatorTok{(}\FunctionTok{SetProperty}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_selected}\OperatorTok{,}\NormalTok{ value}\OperatorTok{))}
\NormalTok{                RemoveCommand}\OperatorTok{.}\FunctionTok{RaiseCanExecuteChanged}\OperatorTok{();}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \KeywordTok{private} \DataTypeTok{void} \FunctionTok{LoadInitialPeople}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ person }\KeywordTok{in}\NormalTok{ \_personService}\OperatorTok{.}\FunctionTok{GetInitialPeople}\OperatorTok{())}
\NormalTok{            People}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{person}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{private} \DataTypeTok{void} \FunctionTok{AddPerson}\OperatorTok{()}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ newPerson }\OperatorTok{=}\NormalTok{ \_personService}\OperatorTok{.}\FunctionTok{CreateNewPerson}\OperatorTok{();}
\NormalTok{        People}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{newPerson}\OperatorTok{);}
\NormalTok{        Selected }\OperatorTok{=}\NormalTok{ newPerson}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{private} \DataTypeTok{void} \FunctionTok{RemovePerson}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{Selected }\KeywordTok{is} \KeywordTok{null}\OperatorTok{)}
            \KeywordTok{return}\OperatorTok{;}

\NormalTok{        \_personService}\OperatorTok{.}\FunctionTok{DeletePerson}\OperatorTok{(}\NormalTok{Selected}\OperatorTok{);}
\NormalTok{        People}\OperatorTok{.}\FunctionTok{Remove}\OperatorTok{(}\NormalTok{Selected}\OperatorTok{);}
\NormalTok{        Selected }\OperatorTok{=} \KeywordTok{null}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{IPersonService} represents data access. Inject it via DI in
\texttt{App.axaml.cs} (see Section 3).

\subsubsection{2.4 Binding notifications and
validation}\label{binding-notifications-and-validation}

Bindings surface both conversion errors and validation failures through
\texttt{BindingNotification} and the \texttt{DataValidationException}
payload. Listening to those notifications helps you surface validation
summaries in the UI and quickly diagnose binding issues during
development.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ AccountViewModel }\OperatorTok{:}\NormalTok{ ObservableValidator}
\OperatorTok{\{}
    \KeywordTok{private} \DataTypeTok{string}\NormalTok{ \_email }\OperatorTok{=} \DataTypeTok{string}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{;}
    \KeywordTok{public}\NormalTok{ ObservableCollection}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{\textgreater{}}\NormalTok{ ValidationMessages }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\OperatorTok{();}

    \OperatorTok{[}\FunctionTok{Required}\OperatorTok{(}\NormalTok{ErrorMessage }\OperatorTok{=} \StringTok{"Email is required"}\OperatorTok{)]}
    \OperatorTok{[}\FunctionTok{EmailAddress}\OperatorTok{(}\NormalTok{ErrorMessage }\OperatorTok{=} \StringTok{"Enter a valid email address"}\OperatorTok{)]}
    \KeywordTok{public} \DataTypeTok{string}\NormalTok{ Email}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_email}\OperatorTok{;}
\NormalTok{        set }\OperatorTok{=\textgreater{}} \FunctionTok{SetProperty}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_email}\OperatorTok{,}\NormalTok{ value}\OperatorTok{,} \KeywordTok{true}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{ObservableValidator} lives in CommunityToolkit.Mvvm and combines
property change notification with \texttt{INotifyDataErrorInfo} support.
Expose \texttt{ValidationMessages} (e.g., an
\texttt{ObservableCollection\textless{}string\textgreater{}}) to feed
summaries or inline hints.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TextBox}\OtherTok{ x:Name=}\StringTok{"EmailBox"}
\OtherTok{         Text=}\StringTok{"\{Binding Email, Mode=TwoWay, ValidatesOnNotifyDataErrors=True, UpdateSourceTrigger=PropertyChanged\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}}\KeywordTok{ItemsControl}\OtherTok{ ItemsSource=}\StringTok{"\{Binding ValidationMessages\}"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ subscription }\OperatorTok{=}\NormalTok{ EmailBox}\OperatorTok{.}\FunctionTok{GetBindingObservable}\OperatorTok{(}\NormalTok{TextBox}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{result }\OperatorTok{=\textgreater{}}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{result}\OperatorTok{.}\FunctionTok{HasError} \OperatorTok{\&\&}\NormalTok{ result}\OperatorTok{.}\FunctionTok{Error} \KeywordTok{is}\NormalTok{ BindingNotification notification}\OperatorTok{)}
        \OperatorTok{\{}
            \KeywordTok{if} \OperatorTok{(}\NormalTok{notification}\OperatorTok{.}\FunctionTok{Error} \KeywordTok{is}\NormalTok{ ValidationException validation}\OperatorTok{)}
\NormalTok{                ValidationMessages}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{validation}\OperatorTok{.}\FunctionTok{Message}\OperatorTok{);}
            \KeywordTok{else}
\NormalTok{                Logger}\OperatorTok{.}\FunctionTok{LogError}\OperatorTok{(}\NormalTok{notification}\OperatorTok{.}\FunctionTok{Error}\OperatorTok{,} \StringTok{"Binding failure for Email"}\OperatorTok{);}
        \OperatorTok{\}}
    \OperatorTok{\});}

\NormalTok{DataValidationErrors}\OperatorTok{.}\FunctionTok{GetObservable}\OperatorTok{(}\NormalTok{EmailBox}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{args }\OperatorTok{=\textgreater{}}\NormalTok{ ValidationMessages}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{args}\OperatorTok{.}\FunctionTok{Error}\OperatorTok{.}\FunctionTok{Content}\OperatorTok{?.}\FunctionTok{ToString}\OperatorTok{()} \OperatorTok{??} \DataTypeTok{string}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

\texttt{BindingNotification} distinguishes between binding errors and
data validation errors (\texttt{BindingErrorType}). Validation failures
arrive as \texttt{DataValidationException} instances on the
notification, exposing the offending property and message. Use
Avalonia's \texttt{DataValidationErrors} helper to observe validation
changes and feed a summary control or toast.

\subsubsection{2.5 Value converters and
formatting}\label{value-converters-and-formatting}

When view and view model types differ, implement
\texttt{IValueConverter} or \texttt{IBindingTypeConverter} to keep view
models POCO-friendly.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ TimestampToLocalTimeConverter }\OperatorTok{:}\NormalTok{ IValueConverter}
\OperatorTok{\{}
    \KeywordTok{public} \DataTypeTok{object}\OperatorTok{?} \FunctionTok{Convert}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ value}\OperatorTok{,}\NormalTok{ Type targetType}\OperatorTok{,} \DataTypeTok{object}\OperatorTok{?}\NormalTok{ parameter}\OperatorTok{,}\NormalTok{ CultureInfo culture}\OperatorTok{)}
        \OperatorTok{=\textgreater{}}\NormalTok{ value }\KeywordTok{is}\NormalTok{ DateTimeOffset dto }\OperatorTok{?}\NormalTok{ dto}\OperatorTok{.}\FunctionTok{ToLocalTime}\OperatorTok{().}\FunctionTok{ToString}\OperatorTok{(}\StringTok{"t"}\OperatorTok{,}\NormalTok{ culture}\OperatorTok{)} \OperatorTok{:} \DataTypeTok{string}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{;}

    \KeywordTok{public} \DataTypeTok{object}\OperatorTok{?} \FunctionTok{ConvertBack}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ value}\OperatorTok{,}\NormalTok{ Type targetType}\OperatorTok{,} \DataTypeTok{object}\OperatorTok{?}\NormalTok{ parameter}\OperatorTok{,}\NormalTok{ CultureInfo culture}\OperatorTok{)}
        \OperatorTok{=\textgreater{}}\NormalTok{ DateTimeOffset}\OperatorTok{.}\FunctionTok{TryParse}\OperatorTok{(}\NormalTok{value }\KeywordTok{as} \DataTypeTok{string}\OperatorTok{,}\NormalTok{ culture}\OperatorTok{,}\NormalTok{ DateTimeStyles}\OperatorTok{.}\FunctionTok{AssumeLocal}\OperatorTok{,} \KeywordTok{out} \DataTypeTok{var}\NormalTok{ dto}\OperatorTok{)} \OperatorTok{?}\NormalTok{ dto }\OperatorTok{:}\NormalTok{ BindingOperations}\OperatorTok{.}\FunctionTok{DoNothing}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Register converters in resources and reuse them across DataTemplates:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window.Resources}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{local:TimestampToLocalTimeConverter}\OtherTok{ x:Key=}\StringTok{"LocalTime"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Window.Resources}\NormalTok{\textgreater{}}

\NormalTok{\textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding LastSignIn, Converter=\{StaticResource LocalTime\}\}"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

Converters keep view models focused on domain types while views shape
presentation. For complex pipelines, combine converters with
\texttt{Binding.ConverterParameter} or chained bindings.

\subsubsection{2.6 Mapping view models to views via
DataTemplates}\label{mapping-view-models-to-views-via-datatemplates}

\begin{Shaded}
\begin{Highlighting}[]

\NormalTok{\textless{}}\KeywordTok{Application}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{             xmlns:x=}\StringTok{"http://schemas.microsoft.com/winfx/2006/xaml"}
\OtherTok{             xmlns:views=}\StringTok{"clr{-}namespace:MyApp.Views"}
\OtherTok{             xmlns:viewmodels=}\StringTok{"clr{-}namespace:MyApp.ViewModels"}
\OtherTok{             x:Class=}\StringTok{"MyApp.App"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Application.DataTemplates}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{DataTemplate}\OtherTok{ DataType=}\StringTok{"\{x:Type viewmodels:PeopleViewModel\}"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{views:PeopleView}\NormalTok{ /\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Application.DataTemplates}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Application}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

In \texttt{MainWindow.axaml}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ContentControl}\OtherTok{ Content=}\StringTok{"\{Binding CurrentViewModel\}"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{CurrentViewModel} property determines which view to display.
This is the ViewModel-first approach: DataTemplates map VM types to
Views automatically. For advanced scenarios, register an
\texttt{IGlobalDataTemplates} implementation to provide templates at
runtime (e.g., when view models live in feature modules).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ AppDataTemplates }\OperatorTok{:}\NormalTok{ IGlobalDataTemplates}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ IServiceProvider \_services}\OperatorTok{;}

    \KeywordTok{public} \FunctionTok{AppDataTemplates}\OperatorTok{(}\NormalTok{IServiceProvider services}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_services }\OperatorTok{=}\NormalTok{ services}\OperatorTok{;}

    \KeywordTok{public} \DataTypeTok{bool} \FunctionTok{Match}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ data}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ data }\KeywordTok{is}\NormalTok{ ViewModelBase}\OperatorTok{;}

    \KeywordTok{public}\NormalTok{ Control }\FunctionTok{Build}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ data}\OperatorTok{)}
        \OperatorTok{=\textgreater{}}\NormalTok{ data }\KeywordTok{switch}
        \OperatorTok{\{}
\NormalTok{            HomeViewModel }\OperatorTok{=\textgreater{}}\NormalTok{ \_services}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{HomeView}\OperatorTok{\textgreater{}(),}
\NormalTok{            SettingsViewModel }\OperatorTok{=\textgreater{}}\NormalTok{ \_services}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{SettingsView}\OperatorTok{\textgreater{}(),}
\NormalTok{            \_ }\OperatorTok{=\textgreater{}} \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Text }\OperatorTok{=} \StringTok{"No view registered."} \OperatorTok{\}}
        \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Register the implementation in \texttt{App} or DI container so Avalonia
uses it when resolving content.

\subsubsection{2.7 Navigation service (classic
MVVM)}\label{navigation-service-classic-mvvm}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{interface}\NormalTok{ INavigationService}
\OperatorTok{\{}
    \DataTypeTok{void}\NormalTok{ NavigateTo}\OperatorTok{\textless{}}\NormalTok{TViewModel}\OperatorTok{\textgreater{}()}\NormalTok{ where TViewModel }\OperatorTok{:} \KeywordTok{class}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ NavigationService }\OperatorTok{:}\NormalTok{ ObservableObject}\OperatorTok{,}\NormalTok{ INavigationService}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ IServiceProvider \_services}\OperatorTok{;}
    \KeywordTok{private} \DataTypeTok{object}\OperatorTok{?}\NormalTok{ \_currentViewModel}\OperatorTok{;}

    \KeywordTok{public} \DataTypeTok{object}\OperatorTok{?}\NormalTok{ CurrentViewModel}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_currentViewModel}\OperatorTok{;}
        \KeywordTok{private}\NormalTok{ set }\OperatorTok{=\textgreater{}} \FunctionTok{SetProperty}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_currentViewModel}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{public} \FunctionTok{NavigationService}\OperatorTok{(}\NormalTok{IServiceProvider services}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        \_services }\OperatorTok{=}\NormalTok{ services}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{void}\NormalTok{ NavigateTo}\OperatorTok{\textless{}}\NormalTok{TViewModel}\OperatorTok{\textgreater{}()}\NormalTok{ where TViewModel }\OperatorTok{:} \KeywordTok{class}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ vm }\OperatorTok{=}\NormalTok{ \_services}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{TViewModel}\OperatorTok{\textgreater{}();}
\NormalTok{        CurrentViewModel }\OperatorTok{=}\NormalTok{ vm}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Register navigation service via dependency injection (next section).
View models call
\texttt{navigationService.NavigateTo\textless{}PeopleViewModel\textgreater{}()}
to swap views.

\subsection{3. Composition and state
management}\label{composition-and-state-management}

\subsubsection{3.1 Dependency injection and view model
factories}\label{dependency-injection-and-view-model-factories}

Use your favorite DI container. Example with
Microsoft.Extensions.DependencyInjection in \texttt{App.axaml.cs}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Microsoft}\OperatorTok{.}\FunctionTok{Extensions}\OperatorTok{.}\FunctionTok{DependencyInjection}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{partial} \KeywordTok{class}\NormalTok{ App }\OperatorTok{:}\NormalTok{ Application}
\OperatorTok{\{}
    \KeywordTok{private}\NormalTok{ IServiceProvider}\OperatorTok{?}\NormalTok{ \_services}\OperatorTok{;}

    \KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{()}
    \OperatorTok{\{}
\NormalTok{        \_services }\OperatorTok{=} \FunctionTok{ConfigureServices}\OperatorTok{();}

        \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ IClassicDesktopStyleApplicationLifetime desktop}\OperatorTok{)}
        \OperatorTok{\{}
\NormalTok{            desktop}\OperatorTok{.}\FunctionTok{MainWindow} \OperatorTok{=}\NormalTok{ \_services}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{MainWindow}\OperatorTok{\textgreater{}();}
        \OperatorTok{\}}
        \KeywordTok{else} \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ ISingleViewApplicationLifetime singleView}\OperatorTok{)}
        \OperatorTok{\{}
\NormalTok{            singleView}\OperatorTok{.}\FunctionTok{MainView} \OperatorTok{=}\NormalTok{ \_services}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{ShellView}\OperatorTok{\textgreater{}();}
        \OperatorTok{\}}

        \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{();}
    \OperatorTok{\}}

    \KeywordTok{private} \KeywordTok{static}\NormalTok{ IServiceProvider }\FunctionTok{ConfigureServices}\OperatorTok{()}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ services }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ServiceCollection}\OperatorTok{();}
\NormalTok{        services}\OperatorTok{.}\FunctionTok{AddSingleton}\OperatorTok{\textless{}}\NormalTok{MainWindow}\OperatorTok{\textgreater{}();}
\NormalTok{        services}\OperatorTok{.}\FunctionTok{AddSingleton}\OperatorTok{\textless{}}\NormalTok{ShellView}\OperatorTok{\textgreater{}();}
\NormalTok{        services}\OperatorTok{.}\FunctionTok{AddSingleton}\OperatorTok{\textless{}}\NormalTok{INavigationService}\OperatorTok{,}\NormalTok{ NavigationService}\OperatorTok{\textgreater{}();}
\NormalTok{        services}\OperatorTok{.}\FunctionTok{AddTransient}\OperatorTok{\textless{}}\NormalTok{PeopleViewModel}\OperatorTok{\textgreater{}();}
\NormalTok{        services}\OperatorTok{.}\FunctionTok{AddTransient}\OperatorTok{\textless{}}\NormalTok{HomeViewModel}\OperatorTok{\textgreater{}();}
\NormalTok{        services}\OperatorTok{.}\FunctionTok{AddSingleton}\OperatorTok{\textless{}}\NormalTok{IPersonService}\OperatorTok{,}\NormalTok{ PersonService}\OperatorTok{\textgreater{}();}
\NormalTok{        services}\OperatorTok{.}\FunctionTok{AddSingleton}\OperatorTok{\textless{}}\NormalTok{IGlobalDataTemplates}\OperatorTok{,}\NormalTok{ AppDataTemplates}\OperatorTok{\textgreater{}();}
        \KeywordTok{return}\NormalTok{ services}\OperatorTok{.}\FunctionTok{BuildServiceProvider}\OperatorTok{();}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Inject \texttt{INavigationService} (or a more opinionated router) into
view models to drive navigation. Supplying \texttt{IGlobalDataTemplates}
from the service provider keeps view discovery aligned with DI---views
can request their own dependencies on construction.

\subsubsection{3.2 State orchestration with
observables}\label{state-orchestration-with-observables}

Centralize shared state in dedicated services so view models remain
focused on UI coordination:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ DocumentStore }\OperatorTok{:}\NormalTok{ ObservableObject}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ ObservableCollection}\OperatorTok{\textless{}}\NormalTok{DocumentViewModel}\OperatorTok{\textgreater{}}\NormalTok{ \_documents }\OperatorTok{=} \KeywordTok{new}\OperatorTok{();}
    \KeywordTok{public}\NormalTok{ ReadOnlyObservableCollection}\OperatorTok{\textless{}}\NormalTok{DocumentViewModel}\OperatorTok{\textgreater{}}\NormalTok{ OpenDocuments }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}

    \KeywordTok{public} \FunctionTok{DocumentStore}\OperatorTok{()}
        \OperatorTok{=\textgreater{}}\NormalTok{ OpenDocuments }\OperatorTok{=} \KeywordTok{new}\NormalTok{ ReadOnlyObservableCollection}\OperatorTok{\textless{}}\NormalTok{DocumentViewModel}\OperatorTok{\textgreater{}(}\NormalTok{\_documents}\OperatorTok{);}

    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Open}\OperatorTok{(}\NormalTok{DocumentViewModel document}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(!}\NormalTok{\_documents}\OperatorTok{.}\FunctionTok{Contains}\OperatorTok{(}\NormalTok{document}\OperatorTok{))}
\NormalTok{            \_documents}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{document}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Close}\OperatorTok{(}\NormalTok{DocumentViewModel document}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_documents}\OperatorTok{.}\FunctionTok{Remove}\OperatorTok{(}\NormalTok{document}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Expose commands that call into the store instead of duplicating logic
across view models. For undo/redo, track a stack of undoable actions and
leverage property observables to record mutations:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{interface}\NormalTok{ IUndoableAction}
\OperatorTok{\{}
    \DataTypeTok{void} \FunctionTok{Execute}\OperatorTok{();}
    \DataTypeTok{void} \FunctionTok{Undo}\OperatorTok{();}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ UndoRedoManager}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Stack}\OperatorTok{\textless{}}\NormalTok{IUndoableAction}\OperatorTok{\textgreater{}}\NormalTok{ \_undo }\OperatorTok{=} \KeywordTok{new}\OperatorTok{();}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Stack}\OperatorTok{\textless{}}\NormalTok{IUndoableAction}\OperatorTok{\textgreater{}}\NormalTok{ \_redo }\OperatorTok{=} \KeywordTok{new}\OperatorTok{();}

    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Do}\OperatorTok{(}\NormalTok{IUndoableAction action}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        action}\OperatorTok{.}\FunctionTok{Execute}\OperatorTok{();}
\NormalTok{        \_undo}\OperatorTok{.}\FunctionTok{Push}\OperatorTok{(}\NormalTok{action}\OperatorTok{);}
\NormalTok{        \_redo}\OperatorTok{.}\FunctionTok{Clear}\OperatorTok{();}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Undo}\OperatorTok{()} \OperatorTok{=\textgreater{}} \FunctionTok{Execute}\OperatorTok{(}\NormalTok{\_undo}\OperatorTok{,}\NormalTok{ \_redo}\OperatorTok{);}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Redo}\OperatorTok{()} \OperatorTok{=\textgreater{}} \FunctionTok{Execute}\OperatorTok{(}\NormalTok{\_redo}\OperatorTok{,}\NormalTok{ \_undo}\OperatorTok{);}

    \KeywordTok{private} \KeywordTok{static} \DataTypeTok{void} \FunctionTok{Execute}\OperatorTok{(}\NormalTok{Stack}\OperatorTok{\textless{}}\NormalTok{IUndoableAction}\OperatorTok{\textgreater{}}\NormalTok{ source}\OperatorTok{,}\NormalTok{ Stack}\OperatorTok{\textless{}}\NormalTok{IUndoableAction}\OperatorTok{\textgreater{}}\NormalTok{ target}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{source}\OperatorTok{.}\FunctionTok{TryPop}\OperatorTok{(}\KeywordTok{out} \DataTypeTok{var}\NormalTok{ action}\OperatorTok{))}
        \OperatorTok{\{}
\NormalTok{            action}\OperatorTok{.}\FunctionTok{Undo}\OperatorTok{();}
\NormalTok{            target}\OperatorTok{.}\FunctionTok{Push}\OperatorTok{(}\NormalTok{action}\OperatorTok{);}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Subscribe to \texttt{INotifyPropertyChanged} or use
\texttt{Observable.FromEventPattern} to capture state snapshots whenever
important properties change. This approach works equally well for manual
MVVM, CommunityToolkit, or ReactiveUI view models.

\subsubsection{3.3 Bridging other MVVM
frameworks}\label{bridging-other-mvvm-frameworks}

\begin{itemize}
\tightlist
\item
  \textbf{Prism}: Register \texttt{ViewModelLocator.AutoWireViewModel}
  in XAML and let Prism resolve view models via Avalonia DI. Use Prism's
  region navigation on top of \texttt{ContentControl}-based shells.
\item
  \textbf{Caliburn.Micro / Stylet}: Hook their view locator into
  Avalonia by implementing \texttt{IGlobalDataTemplates} or setting
  \texttt{ViewLocator.LocateForModelType} to the framework's resolver.
\item
  \textbf{PropertyChanged.Fody / FSharp.ViewModule}: Combine source
  generators with Avalonia bindings---\texttt{BindingNotification} still
  surfaces validation errors, so logging and diagnostics remain
  consistent.
\end{itemize}

The key is to treat Avalonia's property system as the integration point:
as long as view models raise property change notifications, you can plug
in different MVVM toolkits without rewriting view code.

\subsection{4. Testing classic MVVM view
models}\label{testing-classic-mvvm-view-models}

A unit test using xUnit:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\NormalTok{Fact}\OperatorTok{]}
\KeywordTok{public} \DataTypeTok{void} \FunctionTok{RemovePerson\_Disables\_When\_No\_Selection}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ service }\OperatorTok{=}\NormalTok{ Substitute}\OperatorTok{.}\FunctionTok{For}\OperatorTok{\textless{}}\NormalTok{IPersonService}\OperatorTok{\textgreater{}();}
    \DataTypeTok{var}\NormalTok{ vm }\OperatorTok{=} \KeywordTok{new} \FunctionTok{PeopleViewModel}\OperatorTok{(}\NormalTok{service}\OperatorTok{);}

\NormalTok{    vm}\OperatorTok{.}\FunctionTok{Selected} \OperatorTok{=}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{People}\OperatorTok{.}\FunctionTok{First}\OperatorTok{();}
\NormalTok{    Assert}\OperatorTok{.}\FunctionTok{True}\OperatorTok{(}\NormalTok{vm}\OperatorTok{.}\FunctionTok{RemoveCommand}\OperatorTok{.}\FunctionTok{CanExecute}\OperatorTok{(}\KeywordTok{null}\OperatorTok{));}

\NormalTok{    vm}\OperatorTok{.}\FunctionTok{Selected} \OperatorTok{=} \KeywordTok{null}\OperatorTok{;}
\NormalTok{    Assert}\OperatorTok{.}\FunctionTok{False}\OperatorTok{(}\NormalTok{vm}\OperatorTok{.}\FunctionTok{RemoveCommand}\OperatorTok{.}\FunctionTok{CanExecute}\OperatorTok{(}\KeywordTok{null}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Testing ensures command states and property changes behave correctly.

\subsection{5. ReactiveUI approach}\label{reactiveui-approach}

ReactiveUI provides \texttt{ReactiveObject}, \texttt{ReactiveCommand},
\texttt{WhenAnyValue}, and routing/interaction helpers. Source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.ReactiveUI}{\texttt{Avalonia.ReactiveUI}}.

\subsubsection{5.1 Reactive object and derived
state}\label{reactive-object-and-derived-state}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ ReactiveUI}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Reactive}\OperatorTok{.}\FunctionTok{Linq}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ PersonViewModelRx }\OperatorTok{:}\NormalTok{ ReactiveObject}
\OperatorTok{\{}
    \KeywordTok{private} \DataTypeTok{string}\NormalTok{ \_firstName }\OperatorTok{=} \StringTok{"Ada"}\OperatorTok{;}
    \KeywordTok{private} \DataTypeTok{string}\NormalTok{ \_lastName }\OperatorTok{=} \StringTok{"Lovelace"}\OperatorTok{;}

    \KeywordTok{public} \DataTypeTok{string}\NormalTok{ FirstName}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_firstName}\OperatorTok{;}
\NormalTok{        set }\OperatorTok{=\textgreater{}} \KeywordTok{this}\OperatorTok{.}\FunctionTok{RaiseAndSetIfChanged}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_firstName}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{string}\NormalTok{ LastName}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_lastName}\OperatorTok{;}
\NormalTok{        set }\OperatorTok{=\textgreater{}} \KeywordTok{this}\OperatorTok{.}\FunctionTok{RaiseAndSetIfChanged}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_lastName}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{string}\NormalTok{ FullName }\OperatorTok{=\textgreater{}}\NormalTok{ $}\StringTok{"\{FirstName\} \{LastName\}"}\OperatorTok{;}

    \KeywordTok{public} \FunctionTok{PersonViewModelRx}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{this}\OperatorTok{.}\FunctionTok{WhenAnyValue}\OperatorTok{(}\NormalTok{x }\OperatorTok{=\textgreater{}}\NormalTok{ x}\OperatorTok{.}\FunctionTok{FirstName}\OperatorTok{,}\NormalTok{ x }\OperatorTok{=\textgreater{}}\NormalTok{ x}\OperatorTok{.}\FunctionTok{LastName}\OperatorTok{)}
            \OperatorTok{.}\FunctionTok{Select}\OperatorTok{(}\NormalTok{\_ }\OperatorTok{=\textgreater{}}\NormalTok{ Unit}\OperatorTok{.}\FunctionTok{Default}\OperatorTok{)}
            \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{\_ }\OperatorTok{=\textgreater{}} \KeywordTok{this}\OperatorTok{.}\FunctionTok{RaisePropertyChanged}\OperatorTok{(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{FullName}\OperatorTok{)));}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{WhenAnyValue} observes properties and recomputes derived values.

\subsubsection{5.2 ReactiveCommand and async
workflows}\label{reactivecommand-and-async-workflows}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Reactive}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Reactive}\OperatorTok{.}\FunctionTok{Linq}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ PeopleViewModelRx }\OperatorTok{:}\NormalTok{ ReactiveObject}
\OperatorTok{\{}
    \KeywordTok{private}\NormalTok{ PersonViewModelRx}\OperatorTok{?}\NormalTok{ \_selected}\OperatorTok{;}

    \KeywordTok{public}\NormalTok{ ObservableCollection}\OperatorTok{\textless{}}\NormalTok{PersonViewModelRx}\OperatorTok{\textgreater{}}\NormalTok{ People }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{new}\NormalTok{ PersonViewModelRx }\OperatorTok{\{}\NormalTok{ FirstName }\OperatorTok{=} \StringTok{"Ada"}\OperatorTok{,}\NormalTok{ LastName }\OperatorTok{=} \StringTok{"Lovelace"} \OperatorTok{\},}
        \KeywordTok{new}\NormalTok{ PersonViewModelRx }\OperatorTok{\{}\NormalTok{ FirstName }\OperatorTok{=} \StringTok{"Grace"}\OperatorTok{,}\NormalTok{ LastName }\OperatorTok{=} \StringTok{"Hopper"} \OperatorTok{\}}
    \OperatorTok{\};}

    \KeywordTok{public}\NormalTok{ PersonViewModelRx}\OperatorTok{?}\NormalTok{ Selected}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_selected}\OperatorTok{;}
\NormalTok{        set }\OperatorTok{=\textgreater{}} \KeywordTok{this}\OperatorTok{.}\FunctionTok{RaiseAndSetIfChanged}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_selected}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{public}\NormalTok{ ReactiveCommand}\OperatorTok{\textless{}}\NormalTok{Unit}\OperatorTok{,}\NormalTok{ Unit}\OperatorTok{\textgreater{}}\NormalTok{ AddCommand }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}
    \KeywordTok{public}\NormalTok{ ReactiveCommand}\OperatorTok{\textless{}}\NormalTok{PersonViewModelRx}\OperatorTok{,}\NormalTok{ Unit}\OperatorTok{\textgreater{}}\NormalTok{ RemoveCommand }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}
    \KeywordTok{public}\NormalTok{ ReactiveCommand}\OperatorTok{\textless{}}\NormalTok{Unit}\OperatorTok{,}\NormalTok{ IReadOnlyList}\OperatorTok{\textless{}}\NormalTok{PersonViewModelRx}\OperatorTok{\textgreater{}\textgreater{}}\NormalTok{ LoadCommand }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}

    \KeywordTok{public} \FunctionTok{PeopleViewModelRx}\OperatorTok{(}\NormalTok{IPersonService service}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        AddCommand }\OperatorTok{=}\NormalTok{ ReactiveCommand}\OperatorTok{.}\FunctionTok{Create}\OperatorTok{(()} \OperatorTok{=\textgreater{}}
        \OperatorTok{\{}
            \DataTypeTok{var}\NormalTok{ vm }\OperatorTok{=} \KeywordTok{new}\NormalTok{ PersonViewModelRx }\OperatorTok{\{}\NormalTok{ FirstName }\OperatorTok{=} \StringTok{"New"}\OperatorTok{,}\NormalTok{ LastName }\OperatorTok{=} \StringTok{"Person"} \OperatorTok{\};}
\NormalTok{            People}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{vm}\OperatorTok{);}
\NormalTok{            Selected }\OperatorTok{=}\NormalTok{ vm}\OperatorTok{;}
        \OperatorTok{\});}

        \DataTypeTok{var}\NormalTok{ canRemove }\OperatorTok{=} \KeywordTok{this}\OperatorTok{.}\FunctionTok{WhenAnyValue}\OperatorTok{(}\NormalTok{x }\OperatorTok{=\textgreater{}}\NormalTok{ x}\OperatorTok{.}\FunctionTok{Selected}\OperatorTok{).}\FunctionTok{Select}\OperatorTok{(}\NormalTok{selected }\OperatorTok{=\textgreater{}}\NormalTok{ selected }\KeywordTok{is}\NormalTok{ not }\KeywordTok{null}\OperatorTok{);}
\NormalTok{        RemoveCommand }\OperatorTok{=}\NormalTok{ ReactiveCommand}\OperatorTok{.}\FunctionTok{Create}\OperatorTok{\textless{}}\NormalTok{PersonViewModelRx}\OperatorTok{\textgreater{}(}\NormalTok{person }\OperatorTok{=\textgreater{}}\NormalTok{ People}\OperatorTok{.}\FunctionTok{Remove}\OperatorTok{(}\NormalTok{person}\OperatorTok{),}\NormalTok{ canRemove}\OperatorTok{);}

\NormalTok{        LoadCommand }\OperatorTok{=}\NormalTok{ ReactiveCommand}\OperatorTok{.}\FunctionTok{CreateFromTask}\OperatorTok{(}\FunctionTok{async} \OperatorTok{()} \OperatorTok{=\textgreater{}}
        \OperatorTok{\{}
            \DataTypeTok{var}\NormalTok{ people }\OperatorTok{=}\NormalTok{ await service}\OperatorTok{.}\FunctionTok{FetchPeopleAsync}\OperatorTok{();}
\NormalTok{            People}\OperatorTok{.}\FunctionTok{Clear}\OperatorTok{();}
            \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ p }\KeywordTok{in}\NormalTok{ people}\OperatorTok{)}
\NormalTok{                People}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\KeywordTok{new}\NormalTok{ PersonViewModelRx }\OperatorTok{\{}\NormalTok{ FirstName }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{FirstName}\OperatorTok{,}\NormalTok{ LastName }\OperatorTok{=}\NormalTok{ p}\OperatorTok{.}\FunctionTok{LastName} \OperatorTok{\});}
            \KeywordTok{return}\NormalTok{ People}\OperatorTok{.}\FunctionTok{ToList}\OperatorTok{();}
        \OperatorTok{\});}

\NormalTok{        LoadCommand}\OperatorTok{.}\FunctionTok{ThrownExceptions}\OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{ex }\OperatorTok{=\textgreater{}} \OperatorTok{\{}\CommentTok{/* handle errors */}\OperatorTok{\});}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{ReactiveCommand} exposes \texttt{IsExecuting},
\texttt{ThrownExceptions}, and ensures asynchronous flows stay on the UI
thread.

\subsubsection{\texorpdfstring{5.3 \texttt{ReactiveUserControl} and
activation}{5.3 ReactiveUserControl and activation}}\label{reactiveusercontrol-and-activation}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ ReactiveUI}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Reactive}\OperatorTok{.}\FunctionTok{Disposables}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{partial} \KeywordTok{class}\NormalTok{ PeopleViewRx }\OperatorTok{:}\NormalTok{ ReactiveUserControl}\OperatorTok{\textless{}}\NormalTok{PeopleViewModelRx}\OperatorTok{\textgreater{}}
\OperatorTok{\{}
    \KeywordTok{public} \FunctionTok{PeopleViewRx}\OperatorTok{()}
    \OperatorTok{\{}
        \FunctionTok{InitializeComponent}\OperatorTok{();}

        \KeywordTok{this}\OperatorTok{.}\FunctionTok{WhenActivated}\OperatorTok{(}\NormalTok{disposables }\OperatorTok{=\textgreater{}}
        \OperatorTok{\{}
            \KeywordTok{this}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{ViewModel}\OperatorTok{,}\NormalTok{ vm }\OperatorTok{=\textgreater{}}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{Selected}\OperatorTok{,}\NormalTok{ v }\OperatorTok{=\textgreater{}}\NormalTok{ v}\OperatorTok{.}\FunctionTok{PersonList}\OperatorTok{.}\FunctionTok{SelectedItem}\OperatorTok{)}
                \OperatorTok{.}\FunctionTok{DisposeWith}\OperatorTok{(}\NormalTok{disposables}\OperatorTok{);}
            \KeywordTok{this}\OperatorTok{.}\FunctionTok{BindCommand}\OperatorTok{(}\NormalTok{ViewModel}\OperatorTok{,}\NormalTok{ vm }\OperatorTok{=\textgreater{}}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{AddCommand}\OperatorTok{,}\NormalTok{ v }\OperatorTok{=\textgreater{}}\NormalTok{ v}\OperatorTok{.}\FunctionTok{AddButton}\OperatorTok{)}
                \OperatorTok{.}\FunctionTok{DisposeWith}\OperatorTok{(}\NormalTok{disposables}\OperatorTok{);}
        \OperatorTok{\});}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{WhenActivated} manages subscriptions.
\texttt{Bind}/\texttt{BindCommand} reduce boilerplate. Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.ReactiveUI/ReactiveUserControl.cs}{\texttt{ReactiveUserControl.cs}}.

\subsubsection{5.4 View locator}\label{view-locator}

ReactiveUI auto resolves views via naming conventions. Register
\texttt{IViewLocator} in DI or implement your own to map view models to
views. Avalonia.ReactiveUI includes \texttt{ViewLocator} class you can
override.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ AppViewLocator }\OperatorTok{:}\NormalTok{ IViewLocator}
\OperatorTok{\{}
    \KeywordTok{public}\NormalTok{ IViewFor}\OperatorTok{?}\NormalTok{ ResolveView}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{\textgreater{}(}\NormalTok{T viewModel}\OperatorTok{,} \DataTypeTok{string}\OperatorTok{?}\NormalTok{ contract }\OperatorTok{=} \KeywordTok{null}\OperatorTok{)}\NormalTok{ where T }\OperatorTok{:} \KeywordTok{class}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ name }\OperatorTok{=}\NormalTok{ viewModel}\OperatorTok{.}\FunctionTok{GetType}\OperatorTok{().}\FunctionTok{FullName}\OperatorTok{.}\FunctionTok{Replace}\OperatorTok{(}\StringTok{"ViewModel"}\OperatorTok{,} \StringTok{"View"}\OperatorTok{);}
        \DataTypeTok{var}\NormalTok{ type }\OperatorTok{=}\NormalTok{ Type}\OperatorTok{.}\FunctionTok{GetType}\OperatorTok{(}\NormalTok{name }\OperatorTok{??} \DataTypeTok{string}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{);}
        \KeywordTok{return}\NormalTok{ type }\KeywordTok{is} \KeywordTok{null} \OperatorTok{?} \KeywordTok{null} \OperatorTok{:} \OperatorTok{(}\NormalTok{IViewFor}\OperatorTok{?)}\NormalTok{Activator}\OperatorTok{.}\FunctionTok{CreateInstance}\OperatorTok{(}\NormalTok{type}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Register it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{services}\OperatorTok{.}\FunctionTok{AddSingleton}\OperatorTok{\textless{}}\NormalTok{IViewLocator}\OperatorTok{,}\NormalTok{ AppViewLocator}\OperatorTok{\textgreater{}();}
\end{Highlighting}
\end{Shaded}

\subsubsection{5.5 Routing and navigation}\label{routing-and-navigation}

Routers manage stacks of \texttt{IRoutableViewModel} instances. Example
shell view model shown earlier. Use
\texttt{\textless{}rxui:RoutedViewHost\ Router="\{Binding\ Router\}"/\textgreater{}}
to display the current view.

ReactiveUI navigation supports back/forward, parameter passing, and
async transitions.

\subsubsection{5.6 Avalonia.ReactiveUI
helpers}\label{avalonia.reactiveui-helpers}

\texttt{Avalonia.ReactiveUI} ships opinionated base classes such as
\texttt{ReactiveWindow\textless{}TViewModel\textgreater{}},
\texttt{ReactiveContentControl\textless{}TViewModel\textgreater{}}, and
extension methods that bridge Avalonia's property system with
ReactiveUI's \texttt{IObservable} pipelines.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{partial} \KeywordTok{class}\NormalTok{ ShellWindow }\OperatorTok{:}\NormalTok{ ReactiveWindow}\OperatorTok{\textless{}}\NormalTok{ShellViewModel}\OperatorTok{\textgreater{}}
\OperatorTok{\{}
    \KeywordTok{public} \FunctionTok{ShellWindow}\OperatorTok{()}
    \OperatorTok{\{}
        \FunctionTok{InitializeComponent}\OperatorTok{();}

        \KeywordTok{this}\OperatorTok{.}\FunctionTok{WhenActivated}\OperatorTok{(}\NormalTok{disposables }\OperatorTok{=\textgreater{}}
        \OperatorTok{\{}
            \KeywordTok{this}\OperatorTok{.}\FunctionTok{OneWayBind}\OperatorTok{(}\NormalTok{ViewModel}\OperatorTok{,}\NormalTok{ vm }\OperatorTok{=\textgreater{}}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{Router}\OperatorTok{,}\NormalTok{ v }\OperatorTok{=\textgreater{}}\NormalTok{ v}\OperatorTok{.}\FunctionTok{RouterHost}\OperatorTok{.}\FunctionTok{Router}\OperatorTok{)}
                \OperatorTok{.}\FunctionTok{DisposeWith}\OperatorTok{(}\NormalTok{disposables}\OperatorTok{);}
            \KeywordTok{this}\OperatorTok{.}\FunctionTok{BindCommand}\OperatorTok{(}\NormalTok{ViewModel}\OperatorTok{,}\NormalTok{ vm }\OperatorTok{=\textgreater{}}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{ExitCommand}\OperatorTok{,}\NormalTok{ v }\OperatorTok{=\textgreater{}}\NormalTok{ v}\OperatorTok{.}\FunctionTok{ExitMenuItem}\OperatorTok{)}
                \OperatorTok{.}\FunctionTok{DisposeWith}\OperatorTok{(}\NormalTok{disposables}\OperatorTok{);}
        \OperatorTok{\});}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Activation hooks route \texttt{BindingNotification} instances through
ReactiveUI's logging infrastructure, so binding failures show up in
\texttt{RxApp.DefaultExceptionHandler}. Register
\texttt{ActivationForViewFetcher} when hosting custom controls so
ReactiveUI can discover activation semantics:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Locator}\OperatorTok{.}\FunctionTok{CurrentMutable}\OperatorTok{.}\FunctionTok{Register}\OperatorTok{(()} \OperatorTok{=\textgreater{}} \KeywordTok{new} \FunctionTok{ShellWindow}\OperatorTok{(),} \KeywordTok{typeof}\OperatorTok{(}\NormalTok{IViewFor}\OperatorTok{\textless{}}\NormalTok{ShellViewModel}\OperatorTok{\textgreater{}));}
\NormalTok{Locator}\OperatorTok{.}\FunctionTok{CurrentMutable}\OperatorTok{.}\FunctionTok{RegisterConstant}\OperatorTok{(}\KeywordTok{new} \FunctionTok{AvaloniaActivationForViewFetcher}\OperatorTok{(),} \KeywordTok{typeof}\OperatorTok{(}\NormalTok{IActivationForViewFetcher}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

These helpers keep Avalonia bindings, routing, and interactions in sync
with ReactiveUI conventions.

\subsection{6. Interactions and dialogs}\label{interactions-and-dialogs}

Use \texttt{Interaction\textless{}TInput,TOutput\textgreater{}} to
request UI interactions from view models.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public}\NormalTok{ Interaction}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{,} \DataTypeTok{bool}\OperatorTok{\textgreater{}}\NormalTok{ ConfirmDelete }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\OperatorTok{();}

\NormalTok{DeleteCommand }\OperatorTok{=}\NormalTok{ ReactiveCommand}\OperatorTok{.}\FunctionTok{CreateFromTask}\OperatorTok{(}\FunctionTok{async} \OperatorTok{()} \OperatorTok{=\textgreater{}}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{Selected }\KeywordTok{is} \KeywordTok{null}\OperatorTok{)}
        \KeywordTok{return}\OperatorTok{;}

    \DataTypeTok{var}\NormalTok{ ok }\OperatorTok{=}\NormalTok{ await ConfirmDelete}\OperatorTok{.}\FunctionTok{Handle}\OperatorTok{(}\NormalTok{$}\StringTok{"Delete \{Selected.FullName\}?"}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{ok}\OperatorTok{)}
\NormalTok{        People}\OperatorTok{.}\FunctionTok{Remove}\OperatorTok{(}\NormalTok{Selected}\OperatorTok{);}
\OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

In the view:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{this}\OperatorTok{.}\FunctionTok{WhenActivated}\OperatorTok{(}\NormalTok{d }\OperatorTok{=\textgreater{}}
\OperatorTok{\{}
    \FunctionTok{d}\OperatorTok{(}\NormalTok{ViewModel}\OperatorTok{!.}\FunctionTok{ConfirmDelete}\OperatorTok{.}\FunctionTok{RegisterHandler}\OperatorTok{(}\NormalTok{async ctx }\OperatorTok{=\textgreater{}}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ dialog }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ConfirmDialog}\OperatorTok{(}\NormalTok{ctx}\OperatorTok{.}\FunctionTok{Input}\OperatorTok{);}
        \DataTypeTok{var}\NormalTok{ result }\OperatorTok{=}\NormalTok{ await dialog}\OperatorTok{.}\FunctionTok{ShowDialog}\OperatorTok{\textless{}}\DataTypeTok{bool}\OperatorTok{\textgreater{}(}\KeywordTok{this}\OperatorTok{);}
\NormalTok{        ctx}\OperatorTok{.}\FunctionTok{SetOutput}\OperatorTok{(}\NormalTok{result}\OperatorTok{);}
    \OperatorTok{\}));}
\OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

\subsection{7. Testing ReactiveUI view
models}\label{testing-reactiveui-view-models}

Use \texttt{TestScheduler} from \texttt{ReactiveUI.Testing} to control
time:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\NormalTok{Test}\OperatorTok{]}
\KeywordTok{public} \DataTypeTok{void} \FunctionTok{LoadCommand\_PopulatesPeople}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ scheduler }\OperatorTok{=} \KeywordTok{new} \FunctionTok{TestScheduler}\OperatorTok{();}
    \DataTypeTok{var}\NormalTok{ service }\OperatorTok{=}\NormalTok{ Substitute}\OperatorTok{.}\FunctionTok{For}\OperatorTok{\textless{}}\NormalTok{IPersonService}\OperatorTok{\textgreater{}();}
\NormalTok{    service}\OperatorTok{.}\FunctionTok{FetchPeopleAsync}\OperatorTok{().}\FunctionTok{Returns}\OperatorTok{(}\NormalTok{Task}\OperatorTok{.}\FunctionTok{FromResult}\OperatorTok{(}\KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{} \KeywordTok{new} \FunctionTok{Person}\OperatorTok{(}\StringTok{"Alan"}\OperatorTok{,} \StringTok{"Turing"}\OperatorTok{)} \OperatorTok{\}));}

    \DataTypeTok{var}\NormalTok{ vm }\OperatorTok{=} \KeywordTok{new} \FunctionTok{PeopleViewModelRx}\OperatorTok{(}\NormalTok{service}\OperatorTok{);}
\NormalTok{    vm}\OperatorTok{.}\FunctionTok{LoadCommand}\OperatorTok{.}\FunctionTok{Execute}\OperatorTok{().}\FunctionTok{Subscribe}\OperatorTok{();}

\NormalTok{    scheduler}\OperatorTok{.}\FunctionTok{Start}\OperatorTok{();}

\NormalTok{    Assert}\OperatorTok{.}\FunctionTok{Single}\OperatorTok{(}\NormalTok{vm}\OperatorTok{.}\FunctionTok{People}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{8. Choosing between
toolkits}\label{choosing-between-toolkits}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Toolkit
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Pros
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Cons
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Manual / CommunityToolkit.Mvvm & Minimal dependencies, familiar, great
for straightforward forms & More boilerplate for async flows, manual
derived state \\
ReactiveUI & Powerful reactive composition, built-in
routing/interaction, great for complex async state & Learning curve,
more dependencies \\
\end{longtable}

Mixing is common: use classic MVVM for most pages; ReactiveUI for
reactive-heavy screens.

\subsection{9. Practice exercises}\label{practice-exercises-5}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compose a multi-view shell that swaps
  \texttt{HomeViewModel}/\texttt{SettingsViewModel} via DI-backed
  \texttt{IGlobalDataTemplates} and an \texttt{INavigationService}.
\item
  Extend the account form to surface a validation summary by listening
  to \texttt{DataValidationErrors.GetObservable} and logging
  \texttt{BindingNotification} errors.
\item
  Author a currency \texttt{IValueConverter}, register it in resources,
  and verify formatting in both classic and ReactiveUI views.
\item
  Implement an async load pipeline with \texttt{ReactiveCommand},
  binding \texttt{IsExecuting} to a progress indicator and asserting
  behaviour with \texttt{TestScheduler}.
\item
  Add undo/redo support to the People sample by capturing
  \texttt{INotifyPropertyChanged} via
  \texttt{Observable.FromEventPattern} and replaying changes.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-9}

\begin{itemize}
\tightlist
\item
  Binding diagnostics:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/BindingNotification.cs}{\texttt{BindingNotification.cs}}
\item
  Data validation surfaces:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/DataValidationErrors.cs}{\texttt{DataValidationErrors.cs}}
\item
  Avalonia + ReactiveUI integration:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.ReactiveUI}{\texttt{Avalonia.ReactiveUI}}
\item
  Global templates:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/IGlobalDataTemplates.cs}{\texttt{IGlobalDataTemplates.cs}}
\item
  Value conversion defaults:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/Converters/DefaultValueConverter.cs}{\texttt{DefaultValueConverter.cs}}
\item
  Reactive command implementation:
  \href{https://github.com/reactiveui/ReactiveUI/blob/main/src/ReactiveUI/ReactiveCommand.cs}{\texttt{ReactiveCommand.cs}}
\item
  Interaction pattern:
  \href{https://github.com/reactiveui/ReactiveUI/blob/main/src/ReactiveUI/Interaction.cs}{\texttt{Interaction.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-9}

\begin{itemize}
\tightlist
\item
  What benefits does a view locator provide compared to manual view
  creation?
\item
  How do \texttt{BindingNotification} and \texttt{DataValidationErrors}
  help diagnose problems during binding?
\item
  How do \texttt{ReactiveCommand} and classic \texttt{RelayCommand}
  differ in async handling?
\item
  Why is DI helpful when constructing view models? How would you
  register services in Avalonia?
\item
  Which scenarios justify ReactiveUI's routing over simple
  \texttt{ContentControl} swaps?
\item
  What advantage does \texttt{IGlobalDataTemplates} offer over static
  XAML data templates?
\end{itemize}

What's next - Next: \href{Chapter12.md}{Chapter 12}

\newpage

\subsection{12. Navigation, windows, and
lifetimes}\label{navigation-windows-and-lifetimes}

Goal - Understand how Avalonia lifetimes (desktop, single-view, browser)
drive app startup and shutdown. - Manage windows: main, owned, modal,
dialogs; persist placement; respect multiple screens. - Implement
navigation patterns (content swapping, navigation services, transitions)
that work across platforms. - Leverage \texttt{TopLevel} services
(clipboard, storage, screens) from view models via abstractions.

Why this matters - Predictable navigation and windowing keep apps
maintainable on desktop, mobile, and web. - Lifetimes differ per
platform; knowing them prevents ``works on Windows, fails on Android''
surprises. - Services like file pickers or clipboard should be
accessible through MVVM-friendly patterns.

Prerequisites - Chapter 4 (AppBuilder and lifetimes), Chapter 11 (MVVM
patterns), Chapter 16 (storage) is referenced later.

\subsection{1. Lifetimes recap}\label{lifetimes-recap}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Lifetime
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Use case
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Entry method
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{ClassicDesktopStyleApplicationLifetime} & Windows/macOS/Linux
windowed apps & \texttt{StartWithClassicDesktopLifetime(args)} \\
\texttt{SingleViewApplicationLifetime} & Mobile (Android/iOS), embedded
& \texttt{StartWithSingleViewLifetime(view)} \\
\texttt{BrowserSingleViewLifetime} & WebAssembly &
\texttt{BrowserAppBuilder} setup \\
\texttt{ISingleTopLevelApplicationLifetime} & Single top-level host
(preview/embedded scenarios) & Exposed by the runtime; inspect via
\texttt{ApplicationLifetime\ as\ ISingleTopLevelApplicationLifetime} \\
\end{longtable}

\texttt{App.OnFrameworkInitializationCompleted} should handle all
lifetimes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ services }\OperatorTok{=} \FunctionTok{ConfigureServices}\OperatorTok{();}

    \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ IClassicDesktopStyleApplicationLifetime desktop}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ shell }\OperatorTok{=}\NormalTok{ services}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{MainWindow}\OperatorTok{\textgreater{}();}
\NormalTok{        desktop}\OperatorTok{.}\FunctionTok{MainWindow} \OperatorTok{=}\NormalTok{ shell}\OperatorTok{;}

        \CommentTok{// optional: intercept shutdown}
\NormalTok{        desktop}\OperatorTok{.}\FunctionTok{ShutdownMode} \OperatorTok{=}\NormalTok{ ShutdownMode}\OperatorTok{.}\FunctionTok{OnLastWindowClose}\OperatorTok{;}
    \OperatorTok{\}}
    \KeywordTok{else} \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ ISingleViewApplicationLifetime singleView}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        singleView}\OperatorTok{.}\FunctionTok{MainView} \OperatorTok{=}\NormalTok{ services}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{ShellView}\OperatorTok{\textgreater{}();}
    \OperatorTok{\}}

    \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{ISingleTopLevelApplicationLifetime} is currently marked
\texttt{{[}PrivateApi{]}}, but you may see it when Avalonia hosts supply
a single \texttt{TopLevel}. Treat it as read-only metadata rather than
something you implement yourself.

When targeting browser, use \texttt{BrowserAppBuilder} with
\texttt{SetupBrowserApp}.

\subsection{2. Desktop windows in depth}\label{desktop-windows-in-depth}

\subsubsection{2.1 Creating a main window with
MVVM}\label{creating-a-main-window-with-mvvm}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{partial} \KeywordTok{class}\NormalTok{ MainWindow }\OperatorTok{:}\NormalTok{ Window}
\OperatorTok{\{}
    \KeywordTok{public} \FunctionTok{MainWindow}\OperatorTok{()}
    \OperatorTok{\{}
        \FunctionTok{InitializeComponent}\OperatorTok{();}
\NormalTok{        Opened }\OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}} \FunctionTok{RestorePlacement}\OperatorTok{();}
\NormalTok{        Closing }\OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}} \FunctionTok{SavePlacement}\OperatorTok{();}
    \OperatorTok{\}}

    \KeywordTok{private} \DataTypeTok{const} \DataTypeTok{string}\NormalTok{ PlacementKey }\OperatorTok{=} \StringTok{"MainWindowPlacement"}\OperatorTok{;}

    \KeywordTok{private} \DataTypeTok{void} \FunctionTok{RestorePlacement}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{LocalSettings}\OperatorTok{.}\FunctionTok{TryReadWindowPlacement}\OperatorTok{(}\NormalTok{PlacementKey}\OperatorTok{,} \KeywordTok{out} \DataTypeTok{var}\NormalTok{ placement}\OperatorTok{))}
        \OperatorTok{\{}
\NormalTok{            Position }\OperatorTok{=}\NormalTok{ placement}\OperatorTok{.}\FunctionTok{Position}\OperatorTok{;}
\NormalTok{            Width }\OperatorTok{=}\NormalTok{ placement}\OperatorTok{.}\FunctionTok{Size}\OperatorTok{.}\FunctionTok{Width}\OperatorTok{;}
\NormalTok{            Height }\OperatorTok{=}\NormalTok{ placement}\OperatorTok{.}\FunctionTok{Size}\OperatorTok{.}\FunctionTok{Height}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \KeywordTok{private} \DataTypeTok{void} \FunctionTok{SavePlacement}\OperatorTok{()}
    \OperatorTok{\{}
\NormalTok{        LocalSettings}\OperatorTok{.}\FunctionTok{WriteWindowPlacement}\OperatorTok{(}\NormalTok{PlacementKey}\OperatorTok{,} \KeywordTok{new}\NormalTok{ WindowPlacement}
        \OperatorTok{\{}
\NormalTok{            Position }\OperatorTok{=}\NormalTok{ Position}\OperatorTok{,}
\NormalTok{            Size }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Size}\OperatorTok{(}\NormalTok{Width}\OperatorTok{,}\NormalTok{ Height}\OperatorTok{)}
        \OperatorTok{\});}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{LocalSettings} is a simple persistence helper (file or user
settings). Persisting placement keeps UX consistent.

\subsubsection{2.2 Owned windows, modal vs
modeless}\label{owned-windows-modal-vs-modeless}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ AboutWindow }\OperatorTok{:}\NormalTok{ Window}
\OperatorTok{\{}
    \KeywordTok{public} \FunctionTok{AboutWindow}\OperatorTok{()}
    \OperatorTok{\{}
\NormalTok{        Title }\OperatorTok{=} \StringTok{"About"}\OperatorTok{;}
\NormalTok{        Width }\OperatorTok{=} \DecValTok{360}\OperatorTok{;}
\NormalTok{        Height }\OperatorTok{=} \DecValTok{200}\OperatorTok{;}
\NormalTok{        WindowStartupLocation }\OperatorTok{=}\NormalTok{ WindowStartupLocation}\OperatorTok{.}\FunctionTok{CenterOwner}\OperatorTok{;}
\NormalTok{        Content }\OperatorTok{=} \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Margin }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Thickness}\OperatorTok{(}\DecValTok{16}\OperatorTok{),}\NormalTok{ Text }\OperatorTok{=} \StringTok{"My App v1.0"} \OperatorTok{\};}
    \OperatorTok{\}}
\OperatorTok{\}}

\CommentTok{// From main window or service}
\KeywordTok{public}\NormalTok{ Task }\FunctionTok{ShowAboutDialogAsync}\OperatorTok{(}\NormalTok{Window owner}\OperatorTok{)}
    \OperatorTok{=\textgreater{}} \KeywordTok{new}\NormalTok{ AboutWindow }\OperatorTok{\{}\NormalTok{ Owner }\OperatorTok{=}\NormalTok{ owner }\OperatorTok{\}.}\FunctionTok{ShowDialog}\OperatorTok{(}\NormalTok{owner}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Modeless window:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ tool }\OperatorTok{=} \KeywordTok{new}\NormalTok{ ToolWindow }\OperatorTok{\{}\NormalTok{ Owner }\OperatorTok{=} \KeywordTok{this} \OperatorTok{\};}
\NormalTok{tool}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{();}
\end{Highlighting}
\end{Shaded}

Always set \texttt{Owner} so modal blocks correctly and centering works.

\subsubsection{2.3 Multiple screens \&
placement}\label{multiple-screens-placement}

Use \texttt{Screens} service from \texttt{TopLevel}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ topLevel }\OperatorTok{=}\NormalTok{ TopLevel}\OperatorTok{.}\FunctionTok{GetTopLevel}\OperatorTok{(}\KeywordTok{this}\OperatorTok{);}
\KeywordTok{if} \OperatorTok{(}\NormalTok{topLevel}\OperatorTok{?.}\FunctionTok{Screens} \KeywordTok{is} \OperatorTok{\{} \OperatorTok{\}}\NormalTok{ screens}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ screen }\OperatorTok{=}\NormalTok{ screens}\OperatorTok{.}\FunctionTok{ScreenFromPoint}\OperatorTok{(}\NormalTok{Position}\OperatorTok{);}
    \DataTypeTok{var}\NormalTok{ workingArea }\OperatorTok{=}\NormalTok{ screen}\OperatorTok{.}\FunctionTok{WorkingArea}\OperatorTok{;}
\NormalTok{    Position }\OperatorTok{=} \KeywordTok{new} \FunctionTok{PixelPoint}\OperatorTok{(}\NormalTok{workingArea}\OperatorTok{.}\FunctionTok{X}\OperatorTok{,}\NormalTok{ workingArea}\OperatorTok{.}\FunctionTok{Y}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{Screens} live under
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Screens.cs}{\texttt{Avalonia.Controls/Screens.cs}}.

Subscribe to \texttt{screens.Changed} when you need to react to
hot-plugging monitors or DPI changes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{screens}\OperatorTok{.}\FunctionTok{Changed} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ active }\OperatorTok{=}\NormalTok{ screens}\OperatorTok{.}\FunctionTok{ScreenFromWindow}\OperatorTok{(}\KeywordTok{this}\OperatorTok{);}
\NormalTok{    Logger}\OperatorTok{.}\FunctionTok{LogInformation}\OperatorTok{(}\StringTok{"Monitor layout changed. Active screen: \{Bounds\}"}\OperatorTok{,}\NormalTok{ active}\OperatorTok{.}\FunctionTok{WorkingArea}\OperatorTok{);}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

\texttt{WindowBase.Screens} always maps to the platform's latest monitor
topology, so you can reposition tool windows or popups when displays
change.

\subsubsection{2.4 Prevent closing with unsaved
changes}\label{prevent-closing-with-unsaved-changes}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Closing }\OperatorTok{+=} \FunctionTok{async} \OperatorTok{(}\NormalTok{sender}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{DataContext }\KeywordTok{is}\NormalTok{ ShellViewModel vm }\OperatorTok{\&\&}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{HasUnsavedChanges}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ confirm }\OperatorTok{=}\NormalTok{ await MessageBox}\OperatorTok{.}\FunctionTok{ShowAsync}\OperatorTok{(}\KeywordTok{this}\OperatorTok{,} \StringTok{"Unsaved changes"}\OperatorTok{,} \StringTok{"Exit without saving?"}\OperatorTok{,}\NormalTok{ MessageBoxButtons}\OperatorTok{.}\FunctionTok{YesNo}\OperatorTok{);}
        \KeywordTok{if} \OperatorTok{(!}\NormalTok{confirm}\OperatorTok{)}
\NormalTok{            e}\OperatorTok{.}\FunctionTok{Cancel} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Implement \texttt{MessageBox} yourself or using Avalonia.MessageBox
community package.

\subsubsection{\texorpdfstring{2.5 Window lifecycle events
(\texttt{WindowBase})}{2.5 Window lifecycle events (WindowBase)}}\label{window-lifecycle-events-windowbase}

\texttt{WindowBase} is the shared base type for \texttt{Window} and
other top-levels. It raises events that fire before layout runs, letting
you respond to activation, resizing, and positioning at the window
layer:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{partial} \KeywordTok{class}\NormalTok{ ToolWindow }\OperatorTok{:}\NormalTok{ Window}
\OperatorTok{\{}
    \KeywordTok{public} \FunctionTok{ToolWindow}\OperatorTok{()}
    \OperatorTok{\{}
        \FunctionTok{InitializeComponent}\OperatorTok{();}
\NormalTok{        Activated }\OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ StatusBar}\OperatorTok{.}\FunctionTok{Text} \OperatorTok{=} \StringTok{"Active"}\OperatorTok{;}
\NormalTok{        Deactivated }\OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ StatusBar}\OperatorTok{.}\FunctionTok{Text} \OperatorTok{=} \StringTok{"Inactive"}\OperatorTok{;}
\NormalTok{        PositionChanged }\OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ Logger}\OperatorTok{.}\FunctionTok{LogInformation}\OperatorTok{(}\StringTok{"Moved to \{Point\}"}\OperatorTok{,}\NormalTok{ e}\OperatorTok{.}\FunctionTok{Point}\OperatorTok{);}
\NormalTok{        Resized }\OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ Metrics}\OperatorTok{.}\FunctionTok{Track}\OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{Size}\OperatorTok{,}\NormalTok{ e}\OperatorTok{.}\FunctionTok{Reason}\OperatorTok{);}
\NormalTok{        Closed }\OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_subscriptions}\OperatorTok{.}\FunctionTok{Dispose}\OperatorTok{();}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{WindowBase.Resized} reports the reason the platform resized your
window (user drag, system DPI change, maximize). Distinguish it from
\texttt{Control.SizeChanged}, which fires after layout completes. Use
\texttt{WindowBase.IsActive} to trigger focus-sensitive behaviour such
as pausing animations when the window moves to the background.

\subsubsection{2.6 Platform-specific window
features}\label{platform-specific-window-features}

Avalonia exposes chrome customisation through \texttt{TopLevel}
properties:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{TransparencyLevelHint }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{}\NormalTok{ WindowTransparencyLevel}\OperatorTok{.}\FunctionTok{Mica}\OperatorTok{,}\NormalTok{ WindowTransparencyLevel}\OperatorTok{.}\FunctionTok{Acrylic}\OperatorTok{,}\NormalTok{ WindowTransparencyLevel}\OperatorTok{.}\FunctionTok{Transparent} \OperatorTok{\};}
\NormalTok{SystemDecorations }\OperatorTok{=}\NormalTok{ SystemDecorations}\OperatorTok{.}\FunctionTok{None}\OperatorTok{;}
\NormalTok{ExtendClientAreaToDecorationsHint }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
\NormalTok{ExtendClientAreaChromeHints }\OperatorTok{=}\NormalTok{ ExtendClientAreaChromeHints}\OperatorTok{.}\FunctionTok{SystemChrome} \OperatorTok{|}\NormalTok{ ExtendClientAreaChromeHints}\OperatorTok{.}\FunctionTok{OSXIssueUglyDropShadowHack}\OperatorTok{;}
\NormalTok{WindowStartupLocation }\OperatorTok{=}\NormalTok{ WindowStartupLocation}\OperatorTok{.}\FunctionTok{CenterScreen}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Combine those settings with platform options to unlock OS-specific
effects:

\begin{itemize}
\tightlist
\item
  \textbf{Windows} (\texttt{Win32PlatformOptions}): enable
  \texttt{CompositionBackdrop} or \texttt{UseWgl} for specific GPU
  paths. Set \texttt{WindowEffect\ =\ new\ MicaEffect();} to match
  Windows 11 styling.
\item
  \textbf{macOS} (\texttt{MacOSPlatformOptions}): toggle
  \texttt{ShowInDock}, \texttt{DisableDefaultApplicationMenu}, and
  \texttt{UseNativeMenuBar} per window.
\item
  \textbf{Linux/X11} (\texttt{X11PlatformOptions}): control
  \texttt{EnableIME}, \texttt{EnableTransparency}, and
  \texttt{DisableDecorations} when providing custom chrome.
\end{itemize}

Always test transparency fallbacks---older GPUs may fall back to
\texttt{Opaque}. Query \texttt{ActualTransparencyLevel} at runtime to
reflect final behaviour in the UI.

\subsubsection{\texorpdfstring{2.7 Coordinating shutdown with
\texttt{ShutdownRequestedEventArgs}}{2.7 Coordinating shutdown with ShutdownRequestedEventArgs}}\label{coordinating-shutdown-with-shutdownrequestedeventargs}

\texttt{IClassicDesktopStyleApplicationLifetime} exposes a
\texttt{ShutdownRequested} event. Cancel it when critical work is in
progress or when you must prompt the user:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ IClassicDesktopStyleApplicationLifetime desktop}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    desktop}\OperatorTok{.}\FunctionTok{ShutdownRequested} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{\_documentStore}\OperatorTok{.}\FunctionTok{HasDirtyDocuments} \OperatorTok{\&\&} \OperatorTok{!}\FunctionTok{ConfirmShutdown}\OperatorTok{())}
\NormalTok{            e}\OperatorTok{.}\FunctionTok{Cancel} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;}

        \KeywordTok{if} \OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{IsOSShutdown}\OperatorTok{)}
\NormalTok{            Logger}\OperatorTok{.}\FunctionTok{LogWarning}\OperatorTok{(}\StringTok{"OS initiated shutdown"}\OperatorTok{);}
    \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Return \texttt{true} from \texttt{ConfirmShutdown()} only after
persisting state or when the user explicitly approves. Pair this with
\texttt{ShutdownMode} to decide whether closing the main window exits
the entire application.

\subsection{3. Navigation patterns}\label{navigation-patterns}

\subsubsection{3.1 Content control navigation (shared for desktop \&
mobile)}\label{content-control-navigation-shared-for-desktop-mobile}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ NavigationService }\OperatorTok{:}\NormalTok{ INavigationService}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ IServiceProvider \_services}\OperatorTok{;}
    \KeywordTok{private} \DataTypeTok{object}\OperatorTok{?}\NormalTok{ \_current}\OperatorTok{;}

    \KeywordTok{public} \DataTypeTok{object}\OperatorTok{?}\NormalTok{ Current}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}}\NormalTok{ \_current}\OperatorTok{;}
        \KeywordTok{private}\NormalTok{ set }\OperatorTok{=\textgreater{}}\NormalTok{ \_current }\OperatorTok{=}\NormalTok{ value}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{public} \FunctionTok{NavigationService}\OperatorTok{(}\NormalTok{IServiceProvider services}\OperatorTok{)}
        \OperatorTok{=\textgreater{}}\NormalTok{ \_services }\OperatorTok{=}\NormalTok{ services}\OperatorTok{;}

    \KeywordTok{public} \DataTypeTok{void}\NormalTok{ NavigateTo}\OperatorTok{\textless{}}\NormalTok{TViewModel}\OperatorTok{\textgreater{}()}\NormalTok{ where TViewModel }\OperatorTok{:} \KeywordTok{class}
        \OperatorTok{=\textgreater{}}\NormalTok{ Current }\OperatorTok{=}\NormalTok{ \_services}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{TViewModel}\OperatorTok{\textgreater{}();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{ShellViewModel} coordinates navigation:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ ShellViewModel }\OperatorTok{:}\NormalTok{ ObservableObject}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ INavigationService \_navigationService}\OperatorTok{;}
    \KeywordTok{public} \DataTypeTok{object}\OperatorTok{?}\NormalTok{ Current }\OperatorTok{=\textgreater{}}\NormalTok{ \_navigationService}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{;}

    \KeywordTok{public}\NormalTok{ RelayCommand GoHome }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}
    \KeywordTok{public}\NormalTok{ RelayCommand GoSettings }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}

    \KeywordTok{public} \FunctionTok{ShellViewModel}\OperatorTok{(}\NormalTok{INavigationService navigationService}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        \_navigationService }\OperatorTok{=}\NormalTok{ navigationService}\OperatorTok{;}
\NormalTok{        GoHome }\OperatorTok{=} \KeywordTok{new} \FunctionTok{RelayCommand}\OperatorTok{(}\NormalTok{\_ }\OperatorTok{=\textgreater{}}\NormalTok{ \_navigationService}\OperatorTok{.}\FunctionTok{NavigateTo}\OperatorTok{\textless{}}\NormalTok{HomeViewModel}\OperatorTok{\textgreater{}());}
\NormalTok{        GoSettings }\OperatorTok{=} \KeywordTok{new} \FunctionTok{RelayCommand}\OperatorTok{(}\NormalTok{\_ }\OperatorTok{=\textgreater{}}\NormalTok{ \_navigationService}\OperatorTok{.}\FunctionTok{NavigateTo}\OperatorTok{\textless{}}\NormalTok{SettingsViewModel}\OperatorTok{\textgreater{}());}
\NormalTok{        \_navigationService}\OperatorTok{.}\FunctionTok{NavigateTo}\OperatorTok{\textless{}}\NormalTok{HomeViewModel}\OperatorTok{\textgreater{}();}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Bind in view:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{DockPanel}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ DockPanel.Dock=}\StringTok{"Top"}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Home"}\OtherTok{ Command=}\StringTok{"\{Binding GoHome\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Settings"}\OtherTok{ Command=}\StringTok{"\{Binding GoSettings\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TransitioningContentControl}\OtherTok{ Content=}\StringTok{"\{Binding Current\}"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TransitioningContentControl.Transitions}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{PageSlide}\OtherTok{ Transition=}\StringTok{"\{Transitions:Slide FromRight\}"}\OtherTok{ Duration=}\StringTok{"0:0:0.2"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{TransitioningContentControl.Transitions}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{TransitioningContentControl}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{DockPanel}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{TransitioningContentControl} (from \texttt{Avalonia.Controls})
adds page transitions. Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TransitioningContentControl.cs}{\texttt{TransitioningContentControl.cs}}.

\subsubsection{3.2 View mapping via
DataTemplates}\label{view-mapping-via-datatemplates}

Register view-model-to-view templates (Chapter 11 showed details).
Example snippet:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Application.DataTemplates}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{DataTemplate}\OtherTok{ DataType=}\StringTok{"\{x:Type vm:HomeViewModel\}"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{views:HomeView}\NormalTok{ /\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{DataTemplate}\OtherTok{ DataType=}\StringTok{"\{x:Type vm:SettingsViewModel\}"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{views:SettingsView}\NormalTok{ /\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Application.DataTemplates}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{3.3 SplitView shell
navigation}\label{splitview-shell-navigation}

For sidebars or hamburger menus, wrap the navigation service in a
\texttt{SplitView} so content and commands share a host:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{SplitView}\OtherTok{ IsPaneOpen=}\StringTok{"\{Binding IsPaneOpen\}"}
\OtherTok{           DisplayMode=}\StringTok{"CompactOverlay"}
\OtherTok{           CompactPaneLength=}\StringTok{"48"}
\OtherTok{           OpenPaneLength=}\StringTok{"200"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{SplitView.Pane}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ItemsControl}\OtherTok{ ItemsSource=}\StringTok{"\{Binding NavigationItems\}"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{ItemsControl.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"\{Binding Title\}"}
\OtherTok{                  Command=}\StringTok{"\{Binding NavigateCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{ItemsControl.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{ItemsControl}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{SplitView.Pane}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TransitioningContentControl}\OtherTok{ Content=}\StringTok{"\{Binding Current\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{SplitView}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Expose \texttt{NavigationItems} as view-model descriptors (title +
command). Pair with \texttt{SplitView.PanePlacement} to adapt between
desktop (left rail) and mobile (bottom sheet). Listen to
\texttt{TopLevel.BackRequested} to collapse the pane when the host
(Android, browser, web view) signals a system back gesture.

\subsubsection{3.4 Dialog service
abstraction}\label{dialog-service-abstraction}

Expose a dialog API from view models without referencing
\texttt{Window}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{interface}\NormalTok{ IDialogService}
\OperatorTok{\{}
\NormalTok{    Task}\OperatorTok{\textless{}}\DataTypeTok{bool}\OperatorTok{\textgreater{}} \FunctionTok{ShowConfirmationAsync}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ title}\OperatorTok{,} \DataTypeTok{string}\NormalTok{ message}\OperatorTok{);}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ DialogService }\OperatorTok{:}\NormalTok{ IDialogService}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Window \_owner}\OperatorTok{;}
    \KeywordTok{public} \FunctionTok{DialogService}\OperatorTok{(}\NormalTok{Window owner}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_owner }\OperatorTok{=}\NormalTok{ owner}\OperatorTok{;}

    \KeywordTok{public}\NormalTok{ async Task}\OperatorTok{\textless{}}\DataTypeTok{bool}\OperatorTok{\textgreater{}} \FunctionTok{ShowConfirmationAsync}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ title}\OperatorTok{,} \DataTypeTok{string}\NormalTok{ message}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ dialog }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ConfirmationWindow}\OperatorTok{(}\NormalTok{title}\OperatorTok{,}\NormalTok{ message}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ Owner }\OperatorTok{=}\NormalTok{ \_owner }\OperatorTok{\};}
        \KeywordTok{return}\NormalTok{ await dialog}\OperatorTok{.}\FunctionTok{ShowDialog}\OperatorTok{\textless{}}\DataTypeTok{bool}\OperatorTok{\textgreater{}(}\NormalTok{\_owner}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Register a per-window dialog service in DI. For single-view scenarios,
use \texttt{TopLevel.GetTopLevel(control)} to retrieve the root and use
\texttt{StorageProvider} or custom dialogs.

\subsection{4. Single-view navigation
(mobile/web)}\label{single-view-navigation-mobileweb}

For \texttt{ISingleViewApplicationLifetime}, use a root
\texttt{UserControl} (e.g., \texttt{ShellView}) with the same
\texttt{TransitioningContentControl} pattern. Keep navigation inside
that control.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{UserControl}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}\OtherTok{ x:Class=}\StringTok{"MyApp.Views.ShellView"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TransitioningContentControl}\OtherTok{ Content=}\StringTok{"\{Binding Current\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{UserControl}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

From view models, use \texttt{INavigationService} as before; the
lifetime determines whether a window or root view hosts the content.

\subsection{5. TopLevel services: clipboard, storage,
screens}\label{toplevel-services-clipboard-storage-screens}

\texttt{TopLevel.GetTopLevel(control)} returns the hosting top-level
(Window or root). Useful for services.

\subsubsection{5.1 Clipboard}\label{clipboard}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ topLevel }\OperatorTok{=}\NormalTok{ TopLevel}\OperatorTok{.}\FunctionTok{GetTopLevel}\OperatorTok{(}\NormalTok{control}\OperatorTok{);}
\KeywordTok{if} \OperatorTok{(}\NormalTok{topLevel}\OperatorTok{?.}\FunctionTok{Clipboard} \KeywordTok{is} \OperatorTok{\{} \OperatorTok{\}}\NormalTok{ clipboard}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    await clipboard}\OperatorTok{.}\FunctionTok{SetTextAsync}\OperatorTok{(}\StringTok{"Copied text"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Clipboard API defined in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/Platform/IClipboard.cs}{\texttt{IClipboard}}.

\subsubsection{5.2 Storage provider}\label{storage-provider}

Works in both desktop and single-view (browser has OS limitations):

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ topLevel }\OperatorTok{=}\NormalTok{ TopLevel}\OperatorTok{.}\FunctionTok{GetTopLevel}\OperatorTok{(}\NormalTok{control}\OperatorTok{);}
\KeywordTok{if} \OperatorTok{(}\NormalTok{topLevel}\OperatorTok{?.}\FunctionTok{StorageProvider} \KeywordTok{is} \OperatorTok{\{} \OperatorTok{\}}\NormalTok{ sp}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ file }\OperatorTok{=} \OperatorTok{(}\NormalTok{await sp}\OperatorTok{.}\FunctionTok{OpenFilePickerAsync}\OperatorTok{(}\KeywordTok{new}\NormalTok{ FilePickerOpenOptions}
    \OperatorTok{\{}
\NormalTok{        AllowMultiple }\OperatorTok{=} \KeywordTok{false}\OperatorTok{,}
\NormalTok{        FileTypeFilter }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{}\NormalTok{ FilePickerFileTypes}\OperatorTok{.}\FunctionTok{TextPlain} \OperatorTok{\}}
    \OperatorTok{\})).}\FunctionTok{FirstOrDefault}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{5.3 Screens info}\label{screens-info}

\texttt{topLevel!.Screens} provides monitor layout. Use for placing
dialogs on active monitor or respecting working area.

\subsubsection{5.4 System back navigation}\label{system-back-navigation}

\texttt{TopLevel.BackRequested} bubbles up hardware or browser
navigation gestures through Avalonia's
\texttt{ISystemNavigationManagerImpl}. Subscribe to it when embedding in
Android, browser, or platform WebView hosts:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ topLevel }\OperatorTok{=}\NormalTok{ TopLevel}\OperatorTok{.}\FunctionTok{GetTopLevel}\OperatorTok{(}\NormalTok{control}\OperatorTok{);}
\KeywordTok{if} \OperatorTok{(}\NormalTok{topLevel }\KeywordTok{is} \OperatorTok{\{} \OperatorTok{\})}
\OperatorTok{\{}
\NormalTok{    topLevel}\OperatorTok{.}\FunctionTok{BackRequested} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{\_navigation}\OperatorTok{.}\FunctionTok{Pop}\OperatorTok{())}
\NormalTok{            e}\OperatorTok{.}\FunctionTok{Handled} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
    \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Mark the event as handled when your navigation stack consumes the back
action; otherwise Avalonia lets the host perform its default behaviour
(e.g., browser history navigation).

\subsection{6. Browser (WebAssembly)
considerations}\label{browser-webassembly-considerations}

Use \texttt{BrowserAppBuilder} and \texttt{BrowserSingleViewLifetime}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \DataTypeTok{void} \FunctionTok{Main}\OperatorTok{(}\DataTypeTok{string}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)}
    \OperatorTok{=\textgreater{}} \FunctionTok{BuildAvaloniaApp}\OperatorTok{().}\FunctionTok{SetupBrowserApp}\OperatorTok{(}\StringTok{"app"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Use \texttt{TopLevel.StorageProvider} for limited file access (via
JavaScript APIs). Use JS interop for features missing from storage
provider. \texttt{TopLevel.BackRequested} maps to the browser's history
stack---handle it to keep SPA navigation in sync with the host's back
button.

\subsection{7. Practice exercises}\label{practice-exercises-6}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Spawn a secondary tool window from the shell, handle
  \texttt{WindowBase.Resized}/\texttt{PositionChanged}, and persist
  placement per monitor.
\item
  Hook \texttt{ShutdownRequested} to prompt about unsaved documents,
  cancelling the shutdown when the user declines.
\item
  Subscribe to \texttt{Screens.Changed} and reposition floating windows
  onto the active display when monitors are hot-plugged.
\item
  Build a \texttt{SplitView} navigation shell that collapses in response
  to \texttt{TopLevel.BackRequested} on Android or the browser.
\item
  Toggle \texttt{TransparencyLevelHint} and \texttt{SystemDecorations}
  per platform and display the resulting
  \texttt{ActualTransparencyLevel} in the UI.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-10}

\begin{itemize}
\tightlist
\item
  Window management:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Window.cs}{\texttt{Window.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/WindowBase.cs}{\texttt{WindowBase.cs}}
\item
  Lifetimes \& shutdown:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs}{\texttt{ClassicDesktopStyleApplicationLifetime.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ShutdownRequestedEventArgs.cs}{\texttt{ShutdownRequestedEventArgs.cs}}
\item
  Navigation surfaces:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TopLevel.cs}{\texttt{TopLevel.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SplitView.cs}{\texttt{SplitView.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/SystemNavigationManagerImpl.cs}{\texttt{SystemNavigationManagerImpl.cs}}
\item
  Screens API:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Screens.cs}{\texttt{Screens.cs}}
\item
  Transitioning content:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TransitioningContentControl.cs}{\texttt{TransitioningContentControl.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-10}

\begin{itemize}
\tightlist
\item
  How does \texttt{ClassicDesktopStyleApplicationLifetime} differ from
  \texttt{SingleViewApplicationLifetime} when showing windows?
\item
  When should you use \texttt{Show} vs \texttt{ShowDialog}? Why set
  \texttt{Owner}?
\item
  Which \texttt{WindowBase} events fire before layout, and how do they
  differ from \texttt{SizeChanged}?
\item
  How can \texttt{TopLevel.BackRequested} improve the experience on
  Android or the browser?
\item
  What does \texttt{ShutdownRequestedEventArgs.IsOSShutdown} tell you,
  and how would you react to it?
\item
  Which \texttt{TopLevel} service would you use to access the clipboard
  or file picker from a view model?
\end{itemize}

What's next - Next: \href{Chapter13.md}{Chapter 13}

\newpage

\subsection{13. Menus, dialogs, tray icons, and system
features}\label{menus-dialogs-tray-icons-and-system-features}

Goal - Wire desktop menus, context menus, and native menu bars using
\texttt{Menu}, \texttt{MenuItem}, \texttt{ContextMenu}, and
\texttt{NativeMenu}. - Surface dialogs through MVVM-friendly services
that switch between \texttt{ManagedFileChooser}, \texttt{SystemDialog},
and storage providers. - Integrate tray icons, notifications, and
app-level commands with the \texttt{TrayIcon} API and \texttt{TopLevel}
services. - Document platform-specific behaviour so menus, dialogs, and
tray features degrade gracefully.

Why this matters - Desktop users expect menu bars, keyboard
accelerators, and tray icons that follow their OS conventions. - Dialog
flows that stay inside services remain unit-testable and work across
desktop, mobile, and browser hosts. - System integrations (storage,
notifications, clipboard) require a clear view of per-platform
capabilities to avoid runtime surprises.

Prerequisites - Chapters 9 (commands and input), 11 (MVVM patterns), and
12 (lifetimes and windowing).

Key namespaces -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Menu.cs}{\texttt{Menu.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/MenuItem.cs}{\texttt{MenuItem.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/NativeMenu.cs}{\texttt{NativeMenu.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ContextMenu.cs}{\texttt{ContextMenu.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TrayIcon.cs}{\texttt{TrayIcon.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SystemDialog.cs}{\texttt{SystemDialog.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Dialogs/ManagedFileChooser.cs}{\texttt{ManagedFileChooser.cs}}

\subsection{1. Menu surfaces at a
glance}\label{menu-surfaces-at-a-glance}

\subsubsection{\texorpdfstring{1.1 In-window menus
(\texttt{Menu}/\texttt{MenuItem})}{1.1 In-window menus (Menu/MenuItem)}}\label{in-window-menus-menumenuitem}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{        xmlns:x=}\StringTok{"http://schemas.microsoft.com/winfx/2006/xaml"}
\OtherTok{        x:Class=}\StringTok{"MyApp.MainWindow"}
\OtherTok{        Title=}\StringTok{"My App"}\OtherTok{ Width=}\StringTok{"1000"}\OtherTok{ Height=}\StringTok{"700"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{DockPanel}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Menu}\OtherTok{ DockPanel.Dock=}\StringTok{"Top"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"\_File"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"\_New"}\OtherTok{ Command=}\StringTok{"\{Binding AppCommands.New\}"}\OtherTok{ HotKey=}\StringTok{"Ctrl+N"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"\_Open..."}\OtherTok{ Command=}\StringTok{"\{Binding AppCommands.Open\}"}\OtherTok{ HotKey=}\StringTok{"Ctrl+O"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"\_Save"}\OtherTok{ Command=}\StringTok{"\{Binding AppCommands.Save\}"}\OtherTok{ HotKey=}\StringTok{"Ctrl+S"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"Save \_As..."}\OtherTok{ Command=}\StringTok{"\{Binding AppCommands.SaveAs\}"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{Separator}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"E\_xit"}\OtherTok{ Command=}\StringTok{"\{Binding AppCommands.Exit\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{MenuItem}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"\_Edit"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"\_Undo"}\OtherTok{ Command=}\StringTok{"\{Binding AppCommands.Undo\}"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"\_Redo"}\OtherTok{ Command=}\StringTok{"\{Binding AppCommands.Redo\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{MenuItem}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"\_Help"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"\_About"}\OtherTok{ Command=}\StringTok{"\{Binding AppCommands.ShowAbout\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{MenuItem}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Menu}\NormalTok{\textgreater{}}

\NormalTok{    \textless{}}\KeywordTok{ContentControl}\OtherTok{ Content=}\StringTok{"\{Binding CurrentView\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{DockPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Window}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{MenuItem.HotKey} accepts \texttt{KeyGesture} syntax, keeping
  accelerators in sync with displayed text.
\item
  \texttt{AppCommands} is a shared command aggregate in the view model
  layer; use the same instances for menus, toolbars, and tray commands
  so \texttt{CanExecute} state stays consistent.
\item
  Add \texttt{KeyBinding} entries on the window so shortcuts remain
  active even when focus is inside a text box:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window.InputBindings}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{KeyBinding}\OtherTok{ Gesture=}\StringTok{"Ctrl+N"}\OtherTok{ Command=}\StringTok{"\{Binding AppCommands.New\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{KeyBinding}\OtherTok{ Gesture=}\StringTok{"Ctrl+O"}\OtherTok{ Command=}\StringTok{"\{Binding AppCommands.Open\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Window.InputBindings}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{1.2 Native menus and the macOS menu
bar}\label{native-menus-and-the-macos-menu-bar}

\texttt{NativeMenu} exports menu metadata to the host OS when available
(macOS, some Linux environments). Attach it to the \texttt{TopLevel} so
Avalonia's native exporters keep it in sync with window focus.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{()}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ IClassicDesktopStyleApplicationLifetime desktop}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ window }\OperatorTok{=}\NormalTok{ Services}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{MainWindow}\OperatorTok{\textgreater{}();}
\NormalTok{        desktop}\OperatorTok{.}\FunctionTok{MainWindow} \OperatorTok{=}\NormalTok{ window}\OperatorTok{;}

\NormalTok{        NativeMenu}\OperatorTok{.}\FunctionTok{SetMenu}\OperatorTok{(}\NormalTok{window}\OperatorTok{,} \FunctionTok{BuildNativeMenu}\OperatorTok{());}
    \OperatorTok{\}}

    \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{();}
\OperatorTok{\}}

\KeywordTok{private} \KeywordTok{static}\NormalTok{ NativeMenu }\FunctionTok{BuildNativeMenu}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ appMenu }\OperatorTok{=} \KeywordTok{new}\NormalTok{ NativeMenu}
    \OperatorTok{\{}
        \KeywordTok{new} \FunctionTok{NativeMenuItem}\OperatorTok{(}\StringTok{"About"}\OperatorTok{,} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ Locator}\OperatorTok{.}\FunctionTok{Commands}\OperatorTok{.}\FunctionTok{ShowAbout}\OperatorTok{.}\FunctionTok{Execute}\OperatorTok{(}\KeywordTok{null}\OperatorTok{)),}
        \KeywordTok{new} \FunctionTok{NativeMenuItemSeparator}\OperatorTok{(),}
        \KeywordTok{new} \FunctionTok{NativeMenuItem}\OperatorTok{(}\StringTok{"Quit"}\OperatorTok{,} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ Locator}\OperatorTok{.}\FunctionTok{Commands}\OperatorTok{.}\FunctionTok{Exit}\OperatorTok{.}\FunctionTok{Execute}\OperatorTok{(}\KeywordTok{null}\OperatorTok{))}
    \OperatorTok{\};}

    \DataTypeTok{var}\NormalTok{ fileMenu }\OperatorTok{=} \KeywordTok{new}\NormalTok{ NativeMenu}
    \OperatorTok{\{}
        \KeywordTok{new} \FunctionTok{NativeMenuItem}\OperatorTok{(}\StringTok{"New"}\OperatorTok{,} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ Locator}\OperatorTok{.}\FunctionTok{Commands}\OperatorTok{.}\FunctionTok{New}\OperatorTok{.}\FunctionTok{Execute}\OperatorTok{(}\KeywordTok{null}\OperatorTok{))}
        \OperatorTok{\{}
\NormalTok{            Gesture }\OperatorTok{=} \KeywordTok{new} \FunctionTok{KeyGesture}\OperatorTok{(}\NormalTok{Key}\OperatorTok{.}\FunctionTok{N}\OperatorTok{,}\NormalTok{ KeyModifiers}\OperatorTok{.}\FunctionTok{Control}\OperatorTok{)}
        \OperatorTok{\},}
        \KeywordTok{new} \FunctionTok{NativeMenuItem}\OperatorTok{(}\StringTok{"Open..."}\OperatorTok{,} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ Locator}\OperatorTok{.}\FunctionTok{Commands}\OperatorTok{.}\FunctionTok{Open}\OperatorTok{.}\FunctionTok{Execute}\OperatorTok{(}\KeywordTok{null}\OperatorTok{))}
    \OperatorTok{\};}

    \KeywordTok{return} \KeywordTok{new}\NormalTok{ NativeMenu}
    \OperatorTok{\{}
        \KeywordTok{new} \FunctionTok{NativeMenuItem}\OperatorTok{(}\StringTok{"MyApp"}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ Menu }\OperatorTok{=}\NormalTok{ appMenu }\OperatorTok{\},}
        \KeywordTok{new} \FunctionTok{NativeMenuItem}\OperatorTok{(}\StringTok{"File"}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ Menu }\OperatorTok{=}\NormalTok{ fileMenu }\OperatorTok{\}}
    \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{NativeMenuItem.Gesture} mirrors \texttt{MenuItem.HotKey} and
  feeds the OS accelerator tables.
\item
  Use \texttt{NativeMenuBar} in XAML when you want markup control over
  the native bar:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{native:NativeMenuBar}\OtherTok{ DockPanel.Dock=}\StringTok{"Top"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{native:NativeMenuBar.Menu}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{native:NativeMenu}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{native:NativeMenuItem}\OtherTok{ Header=}\StringTok{"My App"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{native:NativeMenuItem}\OtherTok{ Header=}\StringTok{"About"}\OtherTok{ Command=}\StringTok{"\{Binding AppCommands.ShowAbout\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{native:NativeMenuItem}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{native:NativeMenuItem}\OtherTok{ Header=}\StringTok{"File"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{native:NativeMenuItem}\OtherTok{ Header=}\StringTok{"New"}\OtherTok{ Command=}\StringTok{"\{Binding AppCommands.New\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{native:NativeMenuItem}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{native:NativeMenu}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{native:NativeMenuBar.Menu}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{native:NativeMenuBar}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{1.3 Command state and
routing}\label{command-state-and-routing}

\texttt{MenuItem} observes \texttt{ICommand.CanExecute}. Use commands
that publish notifications (\texttt{ReactiveCommand},
\texttt{DelegateCommand}) and call \texttt{RaiseCanExecuteChanged()}
whenever state changes. Keep command instances long-lived (registered in
DI or a singleton \texttt{AppCommands} class) so every menu, toolbar,
context menu, and tray icon reflects the same enable/disable state.

\subsection{2. Context menus and
flyouts}\label{context-menus-and-flyouts}

Attach \texttt{ContextMenu} to items directly or via styles so each
container gets the same commands:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ListBox}\OtherTok{ Items=}\StringTok{"\{Binding Documents\}"}\OtherTok{ SelectedItem=}\StringTok{"\{Binding SelectedDocument\}"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ListBox.Styles}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Style}\OtherTok{ Selector=}\StringTok{"ListBoxItem"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"ContextMenu"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{ContextMenu}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"Rename"}
\OtherTok{                    Command=}\StringTok{"\{Binding DataContext.Rename, RelativeSource=\{RelativeSource AncestorType=ListBox\}\}"}
\OtherTok{                    CommandParameter=}\StringTok{"\{Binding\}"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"Delete"}
\OtherTok{                    Command=}\StringTok{"\{Binding DataContext.Delete, RelativeSource=\{RelativeSource AncestorType=ListBox\}\}"}
\OtherTok{                    CommandParameter=}\StringTok{"\{Binding\}"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{ContextMenu}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{Setter}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ListBox.Styles}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ListBox}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{RelativeSource\ AncestorType=ListBox} bridges from the item
  container back to the list's data context.
\item
  For richer layouts (toggles, sliders, forms) use \texttt{Flyout} or
  \texttt{MenuFlyout} -- both live in \texttt{Avalonia.Controls} and
  share placement logic with context menus.
\item
  Remember accessibility: set \texttt{MenuItem.InputGestureText} or
  \texttt{HotKey} so screen readers announce shortcuts.
\end{itemize}

\subsection{3. Dialog pipelines}\label{dialog-pipelines}

\subsubsection{3.1 Define a dialog service
interface}\label{define-a-dialog-service-interface}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{interface}\NormalTok{ IFileDialogService}
\OperatorTok{\{}
\NormalTok{    Task}\OperatorTok{\textless{}}\NormalTok{IReadOnlyList}\OperatorTok{\textless{}}\NormalTok{FilePickResult}\OperatorTok{\textgreater{}\textgreater{}} \FunctionTok{PickFilesAsync}\OperatorTok{(}\NormalTok{FilePickerOpenOptions options}\OperatorTok{,}\NormalTok{ CancellationToken ct }\OperatorTok{=} \KeywordTok{default}\OperatorTok{);}
\NormalTok{    Task}\OperatorTok{\textless{}}\NormalTok{FilePickResult}\OperatorTok{?\textgreater{}} \FunctionTok{SaveFileAsync}\OperatorTok{(}\NormalTok{FilePickerSaveOptions options}\OperatorTok{,}\NormalTok{ CancellationToken ct }\OperatorTok{=} \KeywordTok{default}\OperatorTok{);}
\NormalTok{    Task}\OperatorTok{\textless{}}\NormalTok{IReadOnlyList}\OperatorTok{\textless{}}\NormalTok{FilePickResult}\OperatorTok{\textgreater{}\textgreater{}} \FunctionTok{PickFoldersAsync}\OperatorTok{(}\NormalTok{FolderPickerOpenOptions options}\OperatorTok{,}\NormalTok{ CancellationToken ct }\OperatorTok{=} \KeywordTok{default}\OperatorTok{);}
\OperatorTok{\}}

\KeywordTok{public}\NormalTok{ record }\FunctionTok{FilePickResult}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ Path}\OperatorTok{,}\NormalTok{ IStorageItem}\OperatorTok{?}\NormalTok{ Handle}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Expose the service through dependency injection so view models request
it instead of referencing \texttt{Window} or \texttt{TopLevel}.

\subsubsection{\texorpdfstring{3.2 Choose between
\texttt{IStorageProvider}, \texttt{SystemDialog}, and
\texttt{ManagedFileChooser}}{3.2 Choose between IStorageProvider, SystemDialog, and ManagedFileChooser}}\label{choose-between-istorageprovider-systemdialog-and-managedfilechooser}

\texttt{TopLevel.StorageProvider} supplies the native picker
implementation (\texttt{IStorageProvider}). When it is unavailable
(custom hosts, limited backends), fall back to the managed dialog stack
built on \texttt{ManagedFileChooser}. The extension method
\texttt{OpenFileDialog.ShowManagedAsync} renders the managed UI and is
enabled automatically when you call
\texttt{AppBuilder.UseManagedSystemDialogs()} during startup.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Dialogs}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Platform}\OperatorTok{.}\FunctionTok{Storage}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ FileDialogService }\OperatorTok{:}\NormalTok{ IFileDialogService}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ TopLevel \_topLevel}\OperatorTok{;}

    \KeywordTok{public} \FunctionTok{FileDialogService}\OperatorTok{(}\NormalTok{TopLevel topLevel}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_topLevel }\OperatorTok{=}\NormalTok{ topLevel}\OperatorTok{;}

    \KeywordTok{public}\NormalTok{ async Task}\OperatorTok{\textless{}}\NormalTok{IReadOnlyList}\OperatorTok{\textless{}}\NormalTok{FilePickResult}\OperatorTok{\textgreater{}\textgreater{}} \FunctionTok{PickFilesAsync}\OperatorTok{(}\NormalTok{FilePickerOpenOptions options}\OperatorTok{,}\NormalTok{ CancellationToken ct }\OperatorTok{=} \KeywordTok{default}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ provider }\OperatorTok{=}\NormalTok{ \_topLevel}\OperatorTok{.}\FunctionTok{StorageProvider}\OperatorTok{;}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{provider }\KeywordTok{is} \OperatorTok{\{}\NormalTok{ CanOpen}\OperatorTok{:} \KeywordTok{true} \OperatorTok{\})}
        \OperatorTok{\{}
            \DataTypeTok{var}\NormalTok{ files }\OperatorTok{=}\NormalTok{ await provider}\OperatorTok{.}\FunctionTok{OpenFilePickerAsync}\OperatorTok{(}\NormalTok{options}\OperatorTok{,}\NormalTok{ ct}\OperatorTok{);}
            \KeywordTok{return}\NormalTok{ files}\OperatorTok{.}\FunctionTok{Select}\OperatorTok{(}\NormalTok{f }\OperatorTok{=\textgreater{}} \KeywordTok{new} \FunctionTok{FilePickResult}\OperatorTok{(}\NormalTok{f}\OperatorTok{.}\FunctionTok{TryGetLocalPath}\OperatorTok{()} \OperatorTok{??}\NormalTok{ f}\OperatorTok{.}\FunctionTok{Name}\OperatorTok{,}\NormalTok{ f}\OperatorTok{)).}\FunctionTok{ToArray}\OperatorTok{();}
        \OperatorTok{\}}

        \KeywordTok{if} \OperatorTok{(}\NormalTok{\_topLevel }\KeywordTok{is}\NormalTok{ Window window}\OperatorTok{)}
        \OperatorTok{\{}
            \DataTypeTok{var}\NormalTok{ dialog }\OperatorTok{=} \KeywordTok{new}\NormalTok{ OpenFileDialog }\OperatorTok{\{}\NormalTok{ AllowMultiple }\OperatorTok{=}\NormalTok{ options}\OperatorTok{.}\FunctionTok{AllowMultiple} \OperatorTok{\};}
            \DataTypeTok{var}\NormalTok{ paths }\OperatorTok{=}\NormalTok{ await dialog}\OperatorTok{.}\FunctionTok{ShowManagedAsync}\OperatorTok{(}\NormalTok{window}\OperatorTok{,} \KeywordTok{new} \FunctionTok{ManagedFileDialogOptions}\OperatorTok{());}
            \KeywordTok{return}\NormalTok{ paths}\OperatorTok{.}\FunctionTok{Select}\OperatorTok{(}\NormalTok{p }\OperatorTok{=\textgreater{}} \KeywordTok{new} \FunctionTok{FilePickResult}\OperatorTok{(}\NormalTok{p}\OperatorTok{,}\NormalTok{ handle}\OperatorTok{:} \KeywordTok{null}\OperatorTok{)).}\FunctionTok{ToArray}\OperatorTok{();}
        \OperatorTok{\}}

        \KeywordTok{return}\NormalTok{ Array}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{\textless{}}\NormalTok{FilePickResult}\OperatorTok{\textgreater{}();}
    \OperatorTok{\}}

    \KeywordTok{public}\NormalTok{ async Task}\OperatorTok{\textless{}}\NormalTok{FilePickResult}\OperatorTok{?\textgreater{}} \FunctionTok{SaveFileAsync}\OperatorTok{(}\NormalTok{FilePickerSaveOptions options}\OperatorTok{,}\NormalTok{ CancellationToken ct }\OperatorTok{=} \KeywordTok{default}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ provider }\OperatorTok{=}\NormalTok{ \_topLevel}\OperatorTok{.}\FunctionTok{StorageProvider}\OperatorTok{;}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{provider }\KeywordTok{is} \OperatorTok{\{}\NormalTok{ CanSave}\OperatorTok{:} \KeywordTok{true} \OperatorTok{\})}
        \OperatorTok{\{}
            \DataTypeTok{var}\NormalTok{ file }\OperatorTok{=}\NormalTok{ await provider}\OperatorTok{.}\FunctionTok{SaveFilePickerAsync}\OperatorTok{(}\NormalTok{options}\OperatorTok{,}\NormalTok{ ct}\OperatorTok{);}
            \KeywordTok{return}\NormalTok{ file }\KeywordTok{is} \KeywordTok{null} \OperatorTok{?} \KeywordTok{null} \OperatorTok{:} \KeywordTok{new} \FunctionTok{FilePickResult}\OperatorTok{(}\NormalTok{file}\OperatorTok{.}\FunctionTok{TryGetLocalPath}\OperatorTok{()} \OperatorTok{??}\NormalTok{ file}\OperatorTok{.}\FunctionTok{Name}\OperatorTok{,}\NormalTok{ file}\OperatorTok{);}
        \OperatorTok{\}}

        \KeywordTok{if} \OperatorTok{(}\NormalTok{\_topLevel }\KeywordTok{is}\NormalTok{ Window window}\OperatorTok{)}
        \OperatorTok{\{}
            \DataTypeTok{var}\NormalTok{ dialog }\OperatorTok{=} \KeywordTok{new}\NormalTok{ SaveFileDialog}
            \OperatorTok{\{}
\NormalTok{                DefaultExtension }\OperatorTok{=}\NormalTok{ options}\OperatorTok{.}\FunctionTok{DefaultExtension}\OperatorTok{,}
\NormalTok{                InitialFileName }\OperatorTok{=}\NormalTok{ options}\OperatorTok{.}\FunctionTok{SuggestedFileName}
            \OperatorTok{\};}
            \DataTypeTok{var}\NormalTok{ path }\OperatorTok{=}\NormalTok{ await dialog}\OperatorTok{.}\FunctionTok{ShowAsync}\OperatorTok{(}\NormalTok{window}\OperatorTok{);}
            \KeywordTok{return}\NormalTok{ path }\KeywordTok{is} \KeywordTok{null} \OperatorTok{?} \KeywordTok{null} \OperatorTok{:} \KeywordTok{new} \FunctionTok{FilePickResult}\OperatorTok{(}\NormalTok{path}\OperatorTok{,}\NormalTok{ handle}\OperatorTok{:} \KeywordTok{null}\OperatorTok{);}
        \OperatorTok{\}}

        \KeywordTok{return} \KeywordTok{null}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{public}\NormalTok{ async Task}\OperatorTok{\textless{}}\NormalTok{IReadOnlyList}\OperatorTok{\textless{}}\NormalTok{FilePickResult}\OperatorTok{\textgreater{}\textgreater{}} \FunctionTok{PickFoldersAsync}\OperatorTok{(}\NormalTok{FolderPickerOpenOptions options}\OperatorTok{,}\NormalTok{ CancellationToken ct }\OperatorTok{=} \KeywordTok{default}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ provider }\OperatorTok{=}\NormalTok{ \_topLevel}\OperatorTok{.}\FunctionTok{StorageProvider}\OperatorTok{;}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{provider }\KeywordTok{is} \OperatorTok{\{}\NormalTok{ CanPickFolder}\OperatorTok{:} \KeywordTok{true} \OperatorTok{\})}
        \OperatorTok{\{}
            \DataTypeTok{var}\NormalTok{ folders }\OperatorTok{=}\NormalTok{ await provider}\OperatorTok{.}\FunctionTok{OpenFolderPickerAsync}\OperatorTok{(}\NormalTok{options}\OperatorTok{,}\NormalTok{ ct}\OperatorTok{);}
            \KeywordTok{return}\NormalTok{ folders}\OperatorTok{.}\FunctionTok{Select}\OperatorTok{(}\NormalTok{f }\OperatorTok{=\textgreater{}} \KeywordTok{new} \FunctionTok{FilePickResult}\OperatorTok{(}\NormalTok{f}\OperatorTok{.}\FunctionTok{TryGetLocalPath}\OperatorTok{()} \OperatorTok{??}\NormalTok{ f}\OperatorTok{.}\FunctionTok{Name}\OperatorTok{,}\NormalTok{ f}\OperatorTok{)).}\FunctionTok{ToArray}\OperatorTok{();}
        \OperatorTok{\}}

        \KeywordTok{if} \OperatorTok{(}\NormalTok{\_topLevel }\KeywordTok{is}\NormalTok{ Window window}\OperatorTok{)}
        \OperatorTok{\{}
            \DataTypeTok{var}\NormalTok{ dialog }\OperatorTok{=} \KeywordTok{new} \FunctionTok{OpenFolderDialog}\OperatorTok{();}
            \DataTypeTok{var}\NormalTok{ path }\OperatorTok{=}\NormalTok{ await dialog}\OperatorTok{.}\FunctionTok{ShowAsync}\OperatorTok{(}\NormalTok{window}\OperatorTok{);}
            \KeywordTok{return}\NormalTok{ path }\KeywordTok{is} \KeywordTok{null}
                \OperatorTok{?}\NormalTok{ Array}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{\textless{}}\NormalTok{FilePickResult}\OperatorTok{\textgreater{}()}
                \OperatorTok{:} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{} \KeywordTok{new} \FunctionTok{FilePickResult}\OperatorTok{(}\NormalTok{path}\OperatorTok{,}\NormalTok{ handle}\OperatorTok{:} \KeywordTok{null}\OperatorTok{)} \OperatorTok{\};}
        \OperatorTok{\}}

        \KeywordTok{return}\NormalTok{ Array}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{\textless{}}\NormalTok{FilePickResult}\OperatorTok{\textgreater{}();}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{OpenFileDialog}, \texttt{SaveFileDialog}, and
  \texttt{OpenFolderDialog} derive from \texttt{SystemDialog}. They
  remain useful when you need to force specific behaviour or when the
  platform lacks a proper storage provider.
\item
  \texttt{AppBuilder.UseManagedSystemDialogs()} configures Avalonia to
  instantiate \texttt{ManagedFileChooser} by default whenever a native
  dialog is unavailable.
\item
  Treat \texttt{FilePickResult.Handle} as optional: on browser/mobile
  targets you might only receive virtual URIs, while desktop gives full
  file system access.
\end{itemize}

\subsection{4. Tray icons, notifications, and app
commands}\label{tray-icons-notifications-and-app-commands}

The tray API exports icons through the \texttt{Application}. Add them
during application initialization so they follow the application
lifetime automatically.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{Initialize}\OperatorTok{()}
\OperatorTok{\{}
    \KeywordTok{base}\OperatorTok{.}\FunctionTok{Initialize}\OperatorTok{();}

    \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ not IClassicDesktopStyleApplicationLifetime}\OperatorTok{)}
        \KeywordTok{return}\OperatorTok{;}

    \DataTypeTok{var}\NormalTok{ trayIcons }\OperatorTok{=} \KeywordTok{new}\NormalTok{ TrayIcons}
    \OperatorTok{\{}
        \KeywordTok{new}\NormalTok{ TrayIcon}
        \OperatorTok{\{}
\NormalTok{            Icon }\OperatorTok{=} \KeywordTok{new} \FunctionTok{WindowIcon}\OperatorTok{(}\StringTok{"avares://MyApp/Assets/App.ico"}\OperatorTok{),}
\NormalTok{            ToolTipText }\OperatorTok{=} \StringTok{"My App"}\OperatorTok{,}
\NormalTok{            Menu }\OperatorTok{=} \KeywordTok{new}\NormalTok{ NativeMenu}
            \OperatorTok{\{}
                \KeywordTok{new} \FunctionTok{NativeMenuItem}\OperatorTok{(}\StringTok{"Show"}\OperatorTok{,} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ Locator}\OperatorTok{.}\FunctionTok{Commands}\OperatorTok{.}\FunctionTok{ShowMain}\OperatorTok{.}\FunctionTok{Execute}\OperatorTok{(}\KeywordTok{null}\OperatorTok{)),}
                \KeywordTok{new} \FunctionTok{NativeMenuItemSeparator}\OperatorTok{(),}
                \KeywordTok{new} \FunctionTok{NativeMenuItem}\OperatorTok{(}\StringTok{"Exit"}\OperatorTok{,} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ Locator}\OperatorTok{.}\FunctionTok{Commands}\OperatorTok{.}\FunctionTok{Exit}\OperatorTok{.}\FunctionTok{Execute}\OperatorTok{(}\KeywordTok{null}\OperatorTok{))}
            \OperatorTok{\}}
        \OperatorTok{\}}
    \OperatorTok{\};}

\NormalTok{    TrayIcon}\OperatorTok{.}\FunctionTok{SetIcons}\OperatorTok{(}\KeywordTok{this}\OperatorTok{,}\NormalTok{ trayIcons}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Toggle \texttt{TrayIcon.IsVisible} in response to \texttt{Window}
  events to implement ``minimize to tray''. Guard the feature by
  checking \texttt{TrayIcon.SetIcons} only when running with a desktop
  lifetime.
\item
  \texttt{NativeMenu} attached to a tray icon becomes the right-click
  menu. Reuse the same command implementations that power your primary
  menu to avoid duplication.
\item
  Detect tray support by asking
  \texttt{AvaloniaLocator.Current.GetService\textless{}IWindowingPlatform\textgreater{}()?.CreateTrayIcon()}
  inside a try/catch before you rely on it.
\end{itemize}

In-app notifications come from \texttt{Avalonia.Controls.Notifications}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Controls}\OperatorTok{.}\FunctionTok{Notifications}\OperatorTok{;}

\DataTypeTok{var}\NormalTok{ manager }\OperatorTok{=} \KeywordTok{new} \FunctionTok{WindowNotificationManager}\OperatorTok{(}\NormalTok{\_desktopLifetime}\OperatorTok{.}\FunctionTok{MainWindow}\OperatorTok{!)}
\OperatorTok{\{}
\NormalTok{    Position }\OperatorTok{=}\NormalTok{ NotificationPosition}\OperatorTok{.}\FunctionTok{TopRight}\OperatorTok{,}
\NormalTok{    MaxItems }\OperatorTok{=} \DecValTok{3}
\OperatorTok{\};}

\NormalTok{manager}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Notification}\OperatorTok{(}\StringTok{"Saved"}\OperatorTok{,} \StringTok{"Document saved successfully"}\OperatorTok{,}\NormalTok{ NotificationType}\OperatorTok{.}\FunctionTok{Success}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

\subsection{5. Top-level services and system
integrations}\label{top-level-services-and-system-integrations}

\texttt{TopLevel} exposes cross-platform services you should wrap behind
interfaces for testability:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{interface}\NormalTok{ IClipboardService}
\OperatorTok{\{}
\NormalTok{    Task }\FunctionTok{SetTextAsync}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ text}\OperatorTok{);}
\NormalTok{    Task}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{?\textgreater{}} \FunctionTok{GetTextAsync}\OperatorTok{();}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ ClipboardService }\OperatorTok{:}\NormalTok{ IClipboardService}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ TopLevel \_topLevel}\OperatorTok{;}
    \KeywordTok{public} \FunctionTok{ClipboardService}\OperatorTok{(}\NormalTok{TopLevel topLevel}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_topLevel }\OperatorTok{=}\NormalTok{ topLevel}\OperatorTok{;}

    \KeywordTok{public}\NormalTok{ Task }\FunctionTok{SetTextAsync}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ text}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_topLevel}\OperatorTok{.}\FunctionTok{Clipboard}\OperatorTok{?.}\FunctionTok{SetTextAsync}\OperatorTok{(}\NormalTok{text}\OperatorTok{)} \OperatorTok{??}\NormalTok{ Task}\OperatorTok{.}\FunctionTok{CompletedTask}\OperatorTok{;}
    \KeywordTok{public}\NormalTok{ Task}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{?\textgreater{}} \FunctionTok{GetTextAsync}\OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ \_topLevel}\OperatorTok{.}\FunctionTok{Clipboard}\OperatorTok{?.}\FunctionTok{GetTextAsync}\OperatorTok{()} \OperatorTok{??}\NormalTok{ Task}\OperatorTok{.}\FunctionTok{FromResult}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{?\textgreater{}(}\KeywordTok{null}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Other helpful services on \texttt{TopLevel}: - \texttt{Screens} for
multi-monitor awareness and DPI scaling. - \texttt{DragDrop} helpers
(covered in Chapter 16) for integrating system drag-and-drop. -
\texttt{TryGetFeature\textless{}T\textgreater{}} for platform-specific
features (\texttt{ITrayIconImpl}, \texttt{IPlatformThemeVariant}).

\subsection{6. Platform notes}\label{platform-notes}

\begin{itemize}
\tightlist
\item
  \textbf{Windows} -- In-window \texttt{Menu} is standard. Tray icons
  appear in the notification area and expect \texttt{.ico} assets with
  multiple sizes. Native system dialogs are available; managed dialogs
  appear only if you opt in.
\item
  \textbf{macOS} -- Use \texttt{NativeMenu}/\texttt{NativeMenuBar} so
  menu items land in the global menu bar. Provide monochrome template
  tray icons via \texttt{MacOSProperties.SetIsTemplateIcon}.
\item
  \textbf{Linux} -- Desktop environments vary. Ship an in-window
  \texttt{Menu} even if you export a \texttt{NativeMenu}. Tray support
  may require AppIndicator or extensions.
\item
  \textbf{Mobile (Android/iOS)} -- Skip menu bars and tray icons.
  Replace them with toolbars, flyouts, and platform navigation. Storage
  providers surface document pickers that may not expose local file
  paths.
\item
  \textbf{Browser} -- No native menus or tray. Use in-app overlays and
  rely on the browser storage APIs (\texttt{BrowserStorageProvider}).
  Managed dialogs are not available.
\end{itemize}

\subsection{7. Practice exercises}\label{practice-exercises-7}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Build a shared \texttt{AppCommands} class that drives in-window menus,
  a \texttt{NativeMenu}, and a toolbar, verifying that
  \texttt{CanExecute} disables items everywhere.
\item
  Implement the dialog service above and log whether each operation used
  \texttt{IStorageProvider}, \texttt{SystemDialog}, or
  \texttt{ManagedFileChooser}. Run it on Windows, macOS, and Linux to
  compare behaviour.
\item
  Add a tray icon that toggles a ``compact mode'': closing the window
  hides it, the tray command re-opens it, and the tray menu reflects the
  current state.
\item
  Provide context menus for list items that reuse the same commands as
  the main menu. Confirm command parameters work for both entry points.
\item
  Surface toast notifications for long-running operations using
  \texttt{WindowNotificationManager}, and ensure they disappear
  automatically when the user navigates away.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-11}

\begin{itemize}
\tightlist
\item
  Menus and native export:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Menu.cs}{\texttt{Menu.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/NativeMenu.Export.cs}{\texttt{NativeMenu.Export.cs}}
\item
  Context menus \& flyouts:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ContextMenu.cs}{\texttt{ContextMenu.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Flyouts/FlyoutBase.cs}{\texttt{FlyoutBase.cs}}
\item
  Dialog infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SystemDialog.cs}{\texttt{SystemDialog.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Dialogs/ManagedFileChooser.cs}{\texttt{ManagedFileChooser.cs}}
\item
  Storage provider abstractions:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/IStorageProvider.cs}{\texttt{IStorageProvider.cs}}
\item
  Tray icons:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TrayIcon.cs}{\texttt{TrayIcon.cs}}
\item
  Notifications:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls.Notifications/WindowNotificationManager.cs}{\texttt{WindowNotificationManager.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-11}

\begin{itemize}
\tightlist
\item
  How do \texttt{MenuItem} and \texttt{NativeMenuItem} share the same
  command instances, and why does that matter for \texttt{CanExecute}?
\item
  When would you enable \texttt{UseManagedSystemDialogs}, and what UX
  differences should you anticipate compared to native dialogs?
\item
  Which \texttt{TopLevel} services help you access storage, clipboard,
  and screens without referencing \texttt{Window} in view models?
\item
  How can you detect tray icon availability before exposing
  tray-dependent features?
\item
  What platform-specific adjustments do macOS and Linux require for
  menus and tray icons?
\end{itemize}

What's next - Next: \href{Chapter14.md}{Chapter 14}

\newpage

\subsection{14. Lists, virtualization, and
performance}\label{lists-virtualization-and-performance}

Goal - Choose the right items control (\texttt{ItemsControl},
\texttt{ListBox}, \texttt{TreeView}, \texttt{DataGrid},
\texttt{ItemsRepeater}) for the data shape and user interactions you
need. - Understand the \texttt{ItemsControl} pipeline
(\texttt{ItemsSourceView}, item container generator,
\texttt{ItemsPresenter}) and how virtualization keeps UIs responsive. -
Apply virtualization techniques (\texttt{VirtualizingStackPanel},
\texttt{ItemsRepeater} layouts) alongside incremental loading and
selection synchronization with \texttt{SelectionModel}. - Diagnose
virtualization regressions using DevTools, logging, and layout
instrumentation.

Why this matters - Lists power dashboards, log viewers, chat apps, and
tables; poorly configured lists can freeze your UI. - Virtualization
keeps memory and CPU usage manageable even with hundreds of thousands of
rows. - Knowing the pipeline lets you extend list controls, add
grouping, or inject placeholders without breaking performance.

Prerequisites - Binding and commands (Chapters 8--9), MVVM patterns
(Chapter 11), styling and resources (Chapter 10).

Key namespaces -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ItemsControl.cs}{\texttt{ItemsControl.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ItemsSourceView.cs}{\texttt{ItemsSourceView.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Generators/ItemContainerGenerator.cs}{\texttt{ItemContainerGenerator.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/VirtualizingStackPanel.cs}{\texttt{VirtualizingStackPanel.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Primitives/ItemsPresenter.cs}{\texttt{ItemsPresenter.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Selection/SelectionModel.cs}{\texttt{SelectionModel.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/ItemsRepeater}{\texttt{ItemsRepeater}}

\subsection{1. ItemsControl pipeline
overview}\label{itemscontrol-pipeline-overview}

Every items control follows the same data flow:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{Items}/\texttt{ItemsSource} is wrapped in an
  \texttt{ItemsSourceView} that projects the data as
  \texttt{IReadOnlyList\textless{}object?\textgreater{}}, tracks the
  current item, and provides grouping hooks.
\item
  \texttt{ItemContainerGenerator} materializes containers
  (\texttt{ListBoxItem}, \texttt{TreeViewItem}, etc.) for realized
  indices and recycles them when virtualization is enabled.
\item
  \texttt{ItemsPresenter} hosts the actual panel (by default
  \texttt{StackPanel} or \texttt{VirtualizingStackPanel}) and plugs into
  \texttt{ScrollViewer} to handle scrolling.
\item
  Templates render your view models inside each container.
\end{enumerate}

Inspecting the view and generator helps when debugging:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ view }\OperatorTok{=}\NormalTok{ MyListBox}\OperatorTok{.}\FunctionTok{ItemsSourceView}\OperatorTok{;}
\DataTypeTok{var}\NormalTok{ current }\OperatorTok{=}\NormalTok{ view}\OperatorTok{?.}\FunctionTok{CurrentItem}\OperatorTok{;}

\NormalTok{MyListBox}\OperatorTok{.}\FunctionTok{ItemContainerGenerator}\OperatorTok{.}\FunctionTok{Materialized} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}}
\NormalTok{    Debug}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\NormalTok{$}\StringTok{"Realized range \{e.StartIndex\}..\{e.StartIndex + e.Count {-} 1\}"}\OperatorTok{);}

\NormalTok{MyListBox}\OperatorTok{.}\FunctionTok{ItemContainerGenerator}\OperatorTok{.}\FunctionTok{Dematerialized} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}}
\NormalTok{    Debug}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\NormalTok{$}\StringTok{"Recycled \{e.Count\} containers"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Customize the items presenter when you need a different panel:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ListBox}\OtherTok{ Items=}\StringTok{"\{Binding Orders\}"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ListBox.ItemsPanel}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ItemsPanelTemplate}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{VirtualizingStackPanel}\OtherTok{ Orientation=}\StringTok{"Vertical"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{ItemsPanelTemplate}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ListBox.ItemsPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ListBox}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{ItemsPresenter} can also be styled to add headers, footers, or
empty-state placeholders while still respecting virtualization.

\subsection{2. VirtualizingStackPanel in
practice}\label{virtualizingstackpanel-in-practice}

\texttt{VirtualizingStackPanel} implements \texttt{ILogicalScrollable},
creating visuals only for the viewport (plus a configurable buffer).
Keep virtualization intact by:

\begin{itemize}
\tightlist
\item
  Hosting the items panel directly inside a \texttt{ScrollViewer} (no
  extra wrappers between them).
\item
  Avoiding nested \texttt{ScrollViewer}s inside item templates.
\item
  Preferring fixed or predictable item sizes so layout calculations are
  cheap.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ListBox}\OtherTok{ Items=}\StringTok{"\{Binding People\}"}
\OtherTok{         SelectedItem=}\StringTok{"\{Binding Selected\}"}
\OtherTok{         Height=}\StringTok{"360"}
\OtherTok{         ScrollViewer.HorizontalScrollBarVisibility=}\StringTok{"Disabled"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ListBox.ItemsPanel}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ItemsPanelTemplate}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{VirtualizingStackPanel}\OtherTok{ Orientation=}\StringTok{"Vertical"}
\OtherTok{                              AreHorizontalSnapPointsRegular=}\StringTok{"True"}
\OtherTok{                              CacheLength=}\StringTok{"1"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{ItemsPanelTemplate}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ListBox.ItemsPanel}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ListBox.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{DataTemplate}\OtherTok{ x:DataType=}\StringTok{"vm:PersonViewModel"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Grid}\OtherTok{ ColumnDefinitions=}\StringTok{"Auto,*,Auto"}\OtherTok{ Height=}\StringTok{"48"}\OtherTok{ Margin=}\StringTok{"4"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{TextBlock}\OtherTok{ Grid.Column=}\StringTok{"0"}\OtherTok{ Text=}\StringTok{"\{CompiledBinding Id\}"}\OtherTok{ Width=}\StringTok{"56"}\OtherTok{ HorizontalAlignment=}\StringTok{"Right"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{StackPanel}\OtherTok{ Grid.Column=}\StringTok{"1"}\OtherTok{ Orientation=}\StringTok{"Vertical"}\OtherTok{ Margin=}\StringTok{"12,0"}\OtherTok{ Spacing=}\StringTok{"2"}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{CompiledBinding FullName\}"}\OtherTok{ FontWeight=}\StringTok{"SemiBold"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{CompiledBinding Email\}"}\OtherTok{ FontSize=}\StringTok{"12"}\OtherTok{ Foreground=}\StringTok{"\#6B7280"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{Button}\OtherTok{ Grid.Column=}\StringTok{"2"}
\OtherTok{                Content=}\StringTok{"Open"}
\OtherTok{                Command=}\StringTok{"\{Binding DataContext.Open, RelativeSource=\{RelativeSource AncestorType=ListBox\}\}"}
\OtherTok{                CommandParameter=}\StringTok{"\{Binding\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ListBox.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ListBox}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{CacheLength} retains extra realized rows before and after the
  viewport (measured in viewport heights) for smoother scrolling.
\item
  \texttt{ItemContainerGenerator.Materialized} events confirm
  virtualization: the count should remain small even with large data
  sets.
\item
  Use \texttt{CompiledBinding} to avoid runtime reflection overhead when
  recycling containers.
\end{itemize}

\subsection{3. Optimising item
containers}\label{optimising-item-containers}

Container recycling reuses realized \texttt{ListBoxItem} instances. Keep
containers lightweight:

\begin{itemize}
\tightlist
\item
  Offload expensive visuals into shared \texttt{ControlTheme} resources.
\item
  Style containers instead of adding extra elements for selection/hover
  state.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Style}\OtherTok{ Selector=}\StringTok{"ListBoxItem:selected TextBlock.title"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Foreground"}\OtherTok{ Value=}\StringTok{"\{DynamicResource AccentBrush\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

When you need to interact with containers manually, use
\texttt{ItemContainerGenerator.ContainerFromIndex}/\texttt{IndexFromContainer}
rather than walking the visual tree.

\subsection{4. ItemsRepeater for custom
layouts}\label{itemsrepeater-for-custom-layouts}

\texttt{ItemsRepeater} separates data virtualization from layout so you
can design custom grids or timelines.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{controls:ItemsRepeater}\OtherTok{ Items=}\StringTok{"\{Binding Photos\}"}
\OtherTok{                        xmlns:controls=}\StringTok{"clr{-}namespace:Avalonia.Controls;assembly=Avalonia.Controls"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{controls:ItemsRepeater.Layout}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{controls:UniformGridLayout}\OtherTok{ Orientation=}\StringTok{"Vertical"}\OtherTok{ MinItemWidth=}\StringTok{"220"}\OtherTok{ MinItemHeight=}\StringTok{"180"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{controls:ItemsRepeater.Layout}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{controls:ItemsRepeater.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{DataTemplate}\OtherTok{ x:DataType=}\StringTok{"vm:PhotoViewModel"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Border}\OtherTok{ Margin=}\StringTok{"8"}\OtherTok{ Padding=}\StringTok{"8"}\OtherTok{ Background=}\StringTok{"\#111827"}\OtherTok{ CornerRadius=}\StringTok{"6"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Image}\OtherTok{ Source=}\StringTok{"\{CompiledBinding Thumbnail\}"}\OtherTok{ Width=}\StringTok{"204"}\OtherTok{ Height=}\StringTok{"128"}\OtherTok{ Stretch=}\StringTok{"UniformToFill"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{CompiledBinding Title\}"}\OtherTok{ Margin=}\StringTok{"0,8,0,0"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{controls:ItemsRepeater.ItemTemplate}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{controls:ItemsRepeater}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{ItemsRepeater.ItemsSourceView} exposes the same API as
  \texttt{ItemsControl}, so you can layer grouping or filtering on top.
\item
  Implement a custom \texttt{VirtualizingLayout} when you need masonry
  or staggered layouts that still recycle elements.
\end{itemize}

\subsection{\texorpdfstring{5. Selection with
\texttt{SelectionModel}}{5. Selection with SelectionModel}}\label{selection-with-selectionmodel}

\texttt{SelectionModel\textless{}T\textgreater{}} tracks selection
without relying on realized containers, making it
virtualization-friendly.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public}\NormalTok{ SelectionModel}\OperatorTok{\textless{}}\NormalTok{PersonViewModel}\OperatorTok{\textgreater{}}\NormalTok{ PeopleSelection }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=}
    \KeywordTok{new}\OperatorTok{()} \OperatorTok{\{}\NormalTok{ SelectionMode }\OperatorTok{=}\NormalTok{ SelectionMode}\OperatorTok{.}\FunctionTok{Multiple} \OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Bind directly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ListBox}\OtherTok{ Items=}\StringTok{"\{Binding People\}"}
\OtherTok{         Selection=}\StringTok{"\{Binding PeopleSelection\}"}
\OtherTok{         Height=}\StringTok{"360"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{SelectionModel.SelectedItems} returns a snapshot of selected
  view models; use it for batch operations.
\item
  Hook \texttt{SelectionModel.SelectionChanged} to synchronize selection
  with other views or persisted state.
\item
  For custom surfaces (e.g., an \texttt{ItemsRepeater} dashboard), set
  \texttt{selectionModel.Source\ =\ repeater.ItemsSourceView} and drive
  selection manually.
\end{itemize}

\subsection{6. Incremental loading
patterns}\label{incremental-loading-patterns}

Load data in pages to keep virtualization responsive. The view model
owns the collection and exposes an async method that appends new items.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ LogViewModel }\OperatorTok{:}\NormalTok{ ObservableObject}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ ILogService \_service}\OperatorTok{;}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ ObservableCollection}\OperatorTok{\textless{}}\NormalTok{LogEntryViewModel}\OperatorTok{\textgreater{}}\NormalTok{ \_entries }\OperatorTok{=} \KeywordTok{new}\OperatorTok{();}
    \KeywordTok{private} \DataTypeTok{bool}\NormalTok{ \_isLoading}\OperatorTok{;}
    \KeywordTok{private} \DataTypeTok{int}\NormalTok{ \_pageIndex}\OperatorTok{;}
    \KeywordTok{private} \DataTypeTok{const} \DataTypeTok{int}\NormalTok{ PageSize }\OperatorTok{=} \DecValTok{500}\OperatorTok{;}

    \KeywordTok{public} \FunctionTok{LogViewModel}\OperatorTok{(}\NormalTok{ILogService service}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        \_service }\OperatorTok{=}\NormalTok{ service}\OperatorTok{;}
\NormalTok{        Entries }\OperatorTok{=} \KeywordTok{new}\NormalTok{ ReadOnlyObservableCollection}\OperatorTok{\textless{}}\NormalTok{LogEntryViewModel}\OperatorTok{\textgreater{}(}\NormalTok{\_entries}\OperatorTok{);}
\NormalTok{        \_ }\OperatorTok{=} \FunctionTok{LoadMoreAsync}\OperatorTok{();}
    \OperatorTok{\}}

    \KeywordTok{public}\NormalTok{ ReadOnlyObservableCollection}\OperatorTok{\textless{}}\NormalTok{LogEntryViewModel}\OperatorTok{\textgreater{}}\NormalTok{ Entries }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}
    \KeywordTok{public} \DataTypeTok{bool}\NormalTok{ HasMore }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \KeywordTok{private} \KeywordTok{set}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;}

    \KeywordTok{public}\NormalTok{ async Task }\FunctionTok{LoadMoreAsync}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{\_isLoading }\OperatorTok{||} \OperatorTok{!}\NormalTok{HasMore}\OperatorTok{)}
            \KeywordTok{return}\OperatorTok{;}

\NormalTok{        \_isLoading }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
        \KeywordTok{try}
        \OperatorTok{\{}
            \DataTypeTok{var}\NormalTok{ batch }\OperatorTok{=}\NormalTok{ await \_service}\OperatorTok{.}\FunctionTok{GetEntriesAsync}\OperatorTok{(}\NormalTok{\_pageIndex}\OperatorTok{,}\NormalTok{ PageSize}\OperatorTok{);}
            \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ entry }\KeywordTok{in}\NormalTok{ batch}\OperatorTok{)}
\NormalTok{                \_entries}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\KeywordTok{new} \FunctionTok{LogEntryViewModel}\OperatorTok{(}\NormalTok{entry}\OperatorTok{));}

\NormalTok{            \_pageIndex}\OperatorTok{++;}
\NormalTok{            HasMore }\OperatorTok{=}\NormalTok{ batch}\OperatorTok{.}\FunctionTok{Count} \OperatorTok{==}\NormalTok{ PageSize}\OperatorTok{;}
        \OperatorTok{\}}
        \KeywordTok{finally}
        \OperatorTok{\{}
\NormalTok{            \_isLoading }\OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Trigger loading when the user scrolls near the end:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private}\NormalTok{ async }\DataTypeTok{void} \FunctionTok{OnScrollChanged}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ ScrollChangedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{DataContext }\KeywordTok{is}\NormalTok{ LogViewModel vm }\OperatorTok{\&\&}
\NormalTok{        vm}\OperatorTok{.}\FunctionTok{HasMore} \OperatorTok{\&\&}
\NormalTok{        e}\OperatorTok{.}\FunctionTok{Source} \KeywordTok{is}\NormalTok{ ScrollViewer scroll }\OperatorTok{\&\&}
\NormalTok{        scroll}\OperatorTok{.}\FunctionTok{Offset}\OperatorTok{.}\FunctionTok{Y} \OperatorTok{+}\NormalTok{ scroll}\OperatorTok{.}\FunctionTok{Viewport}\OperatorTok{.}\FunctionTok{Height} \OperatorTok{\textgreater{}=}\NormalTok{ scroll}\OperatorTok{.}\FunctionTok{Extent}\OperatorTok{.}\FunctionTok{Height} \OperatorTok{{-}} \DecValTok{200}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        await vm}\OperatorTok{.}\FunctionTok{LoadMoreAsync}\OperatorTok{();}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

While loading, display lightweight placeholders (e.g., skeleton rows)
bound to \texttt{IsLoading} flags; keep them inside the same template so
virtualization still applies.

\subsection{7. Diagnosing virtualization
issues}\label{diagnosing-virtualization-issues}

When scrolling stutters or memory spikes:

\begin{itemize}
\tightlist
\item
  \textbf{DevTools ➔ Visual Tree}: select the list and open the
  \textbf{Diagnostics} tab to inspect realized item counts and
  virtualization mode.
\item
  Enable layout/render logging:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{LogToTrace}\OperatorTok{(}\NormalTok{LogEventLevel}\OperatorTok{.}\FunctionTok{Debug}\OperatorTok{,} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{}\NormalTok{ LogArea}\OperatorTok{.}\FunctionTok{Layout}\OperatorTok{,}\NormalTok{ LogArea}\OperatorTok{.}\FunctionTok{Rendering}\OperatorTok{,}\NormalTok{ LogArea}\OperatorTok{.}\FunctionTok{Control} \OperatorTok{\})}
    \OperatorTok{.}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Monitor
  \texttt{ItemContainerGenerator.Materialized}/\texttt{Dematerialized}
  events; if counts climb with scroll distance, virtualization is
  broken.
\item
  Verify the scroll host is the list's immediate parent; wrappers like
  \texttt{StackPanel} or \texttt{Grid} can disable virtualization.
\item
  Profile templates with \texttt{dotnet-trace} or
  \texttt{dotnet-counters} to spot expensive bindings or allocations
  while scrolling.
\end{itemize}

\subsection{8. Practice exercises}\label{practice-exercises-8}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Inspect \texttt{ItemsControl.ItemsSourceView} for a dashboard list and
  log the current item index whenever selection changes. Explain how it
  differs from binding directly to \texttt{ItemsSource}.
\item
  Convert a slow \texttt{ItemsControl} to a virtualized \texttt{ListBox}
  with \texttt{VirtualizingStackPanel} and record container creation
  counts before/after.
\item
  Build an \texttt{ItemsRepeater} gallery with
  \texttt{UniformGridLayout} and compare realized item counts against a
  \texttt{WrapPanel} version.
\item
  Replace \texttt{SelectedItems} with \texttt{SelectionModel} in a
  multi-select list, then synchronize the selection with a detail pane
  while keeping virtualization intact.
\item
  Implement the incremental log viewer above, including skeleton
  placeholders during fetch, and capture frame-time metrics before and
  after the optimization.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-12}

\begin{itemize}
\tightlist
\item
  Pipeline internals:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ItemsControl.cs}{\texttt{ItemsControl.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Generators/ItemContainerGenerator.cs}{\texttt{ItemContainerGenerator.cs}}
\item
  Data views:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ItemsSourceView.cs}{\texttt{ItemsSourceView.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/Core/CollectionView.cs}{\texttt{CollectionView.cs}}
\item
  Virtualization core:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/VirtualizingStackPanel.cs}{\texttt{VirtualizingStackPanel.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ItemsRepeater/Layout/VirtualizingLayout.cs}{\texttt{VirtualizingLayout.cs}}
\item
  Selection infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Selection/SelectionModel.cs}{\texttt{SelectionModel.cs}}
\item
  Diagnostics tooling:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Diagnostics/Diagnostics/LayoutDiagnosticBridge.cs}{\texttt{LayoutDiagnosticBridge.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-12}

\begin{itemize}
\tightlist
\item
  What distinguishes \texttt{ItemsSource} from \texttt{ItemsSourceView},
  and when would you inspect the latter?
\item
  How does \texttt{VirtualizingStackPanel} decide which containers to
  recycle, and what breaks that logic?
\item
  Why does \texttt{SelectionModel} survive virtualization better than
  \texttt{SelectedItems}?
\item
  Which DevTools views help you confirm virtualization is active?
\item
  How can incremental loading keep long lists responsive without
  overwhelming the UI thread?
\end{itemize}

What's next - Next: \href{Chapter15.md}{Chapter 15}

\newpage

\subsection{15. Accessibility and
internationalization}\label{accessibility-and-internationalization}

Goal - Deliver interfaces that are usable with keyboard, screen readers,
and high-contrast themes. - Implement automation metadata
(\texttt{AutomationProperties}, custom \texttt{AutomationPeer}s) so
assistive technologies understand your UI. - Localize content, formats,
fonts, and layout direction for multiple cultures while supporting IME
and text services. - Build a repeatable accessibility testing loop that
spans platform tooling and automated checks.

Why this matters - Accessibility ensures compliance (WCAG/ADA) and a
better experience for keyboard and assistive-technology users. -
Internationalization widens your reach and avoids locale-specific bugs
in formatting or layout direction. - Treating accessibility and
localization as first-class requirements keeps your app portable across
desktop, mobile, and browser targets.

Prerequisites - Keyboard input and commands (Chapter 9), resources
(Chapter 10), MVVM patterns (Chapter 11), navigation and lifetimes
(Chapter 12).

Key namespaces -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Automation/AutomationProperties.cs}{\texttt{AutomationProperties.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Automation/Peers/AutomationPeer.cs}{\texttt{AutomationPeer.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Automation/Peers/ControlAutomationPeer.cs}{\texttt{ControlAutomationPeer.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputMethodClient.cs}{\texttt{TextInputMethodClient.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputOptions.cs}{\texttt{TextInputOptions.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/FontManagerOptions.cs}{\texttt{FontManagerOptions.cs}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Visuals/FlowDirection.cs}{\texttt{FlowDirection.cs}}

\subsection{1. Keyboard accessibility}\label{keyboard-accessibility}

\subsubsection{1.1 Focus order and tab
navigation}\label{focus-order-and-tab-navigation}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{StackPanel}\OtherTok{ Spacing=}\StringTok{"8"}\OtherTok{ KeyboardNavigation.TabNavigation=}\StringTok{"Cycle"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\_User name"}\OtherTok{ RecognizesAccessKey=}\StringTok{"True"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBox}\OtherTok{ x:Name=}\StringTok{"UserName"}\OtherTok{ TabIndex=}\StringTok{"0"}\NormalTok{/\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\_Password"}\OtherTok{ RecognizesAccessKey=}\StringTok{"True"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{PasswordBox}\OtherTok{ x:Name=}\StringTok{"Password"}\OtherTok{ TabIndex=}\StringTok{"1"}\NormalTok{/\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{CheckBox}\OtherTok{ TabIndex=}\StringTok{"2"}\OtherTok{ Content=}\StringTok{"\_Remember me"}\NormalTok{/\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Button}\OtherTok{ TabIndex=}\StringTok{"3"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{AccessText}\OtherTok{ Text=}\StringTok{"\_Sign in"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Button}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Button}\OtherTok{ TabIndex=}\StringTok{"4"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{AccessText}\OtherTok{ Text=}\StringTok{"\_Cancel"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Button}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{KeyboardNavigation.TabNavigation="Cycle"} keeps focus within
  the container, ideal for dialogs.
\item
  Use \texttt{AccessText} or \texttt{RecognizesAccessKey="True"} to
  expose mnemonic keys.
\item
  Disable focus for decorative elements via \texttt{IsTabStop="False"}
  or \texttt{Focusable="False"}.
\end{itemize}

\subsubsection{1.2 Keyboard navigation
helpers}\label{keyboard-navigation-helpers}

\texttt{KeyboardNavigation} (source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyboardNavigation.cs}{\texttt{KeyboardNavigation.cs}})
provides: - \texttt{DirectionalNavigation="Cycle"} for arrow-key
traversal in menus/panels. - \texttt{TabNavigation} modes
(\texttt{Continue}, \texttt{Once}, \texttt{Local}, \texttt{Cycle},
\texttt{None}). - \texttt{Control.IsTabStop} per element when you need
to skip items like labels or icons.

\subsection{2. Screen reader semantics}\label{screen-reader-semantics}

Attach \texttt{AutomationProperties} to expose names, help text, and
relationships:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{StackPanel}\OtherTok{ Spacing=}\StringTok{"10"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ x:Name=}\StringTok{"EmailLabel"}\OtherTok{ Text=}\StringTok{"Email"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBox}\OtherTok{ Text=}\StringTok{"\{Binding Email\}"}
\OtherTok{           AutomationProperties.LabeledBy=}\StringTok{"\{Binding \#EmailLabel\}"}
\OtherTok{           AutomationProperties.AutomationId=}\StringTok{"EmailInput"}\NormalTok{/\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ x:Name=}\StringTok{"StatusLabel"}\OtherTok{ Text=}\StringTok{"Status"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Status\}"}
\OtherTok{             AutomationProperties.LabeledBy=}\StringTok{"\{Binding \#StatusLabel\}"}
\OtherTok{             AutomationProperties.LiveSetting=}\StringTok{"Polite"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{AutomationProperties.Name} provides a fallback label when
  there is no visible text.
\item
  \texttt{AutomationProperties.HelpText} supplies extra instructions for
  screen readers.
\item
  \texttt{AutomationProperties.LiveSetting} (\texttt{Polite},
  \texttt{Assertive}) controls how urgent announcements are.
\item
  \texttt{AutomationProperties.ControlType} lets you override the role
  in edge cases (use sparingly).
\end{itemize}

\texttt{AutomationProperties} map to automation peers. The base
\texttt{ControlAutomationPeer} inspects properties and pseudo-classes to
expose state.

\subsection{3. Custom automation peers}\label{custom-automation-peers}

Create peers when you author custom controls so assistive technology can
identify them correctly.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ ProgressBadge }\OperatorTok{:}\NormalTok{ TemplatedControl}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static} \KeywordTok{readonly}\NormalTok{ StyledProperty}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{?\textgreater{}}\NormalTok{ TextProperty }\OperatorTok{=}
\NormalTok{        AvaloniaProperty}\OperatorTok{.}\FunctionTok{Register}\OperatorTok{\textless{}}\NormalTok{ProgressBadge}\OperatorTok{,} \DataTypeTok{string}\OperatorTok{?\textgreater{}(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{Text}\OperatorTok{));}

    \KeywordTok{public} \DataTypeTok{string}\OperatorTok{?}\NormalTok{ Text}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}} \FunctionTok{GetValue}\OperatorTok{(}\NormalTok{TextProperty}\OperatorTok{);}
\NormalTok{        set }\OperatorTok{=\textgreater{}} \FunctionTok{SetValue}\OperatorTok{(}\NormalTok{TextProperty}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{protected} \KeywordTok{override}\NormalTok{ AutomationPeer}\OperatorTok{?} \FunctionTok{OnCreateAutomationPeer}\OperatorTok{()}
        \OperatorTok{=\textgreater{}} \KeywordTok{new} \FunctionTok{ProgressBadgeAutomationPeer}\OperatorTok{(}\KeywordTok{this}\OperatorTok{);}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ ProgressBadgeAutomationPeer }\OperatorTok{:}\NormalTok{ ControlAutomationPeer}
\OperatorTok{\{}
    \KeywordTok{public} \FunctionTok{ProgressBadgeAutomationPeer}\OperatorTok{(}\NormalTok{ProgressBadge owner}\OperatorTok{)} \OperatorTok{:} \KeywordTok{base}\OperatorTok{(}\NormalTok{owner}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{\}}

    \KeywordTok{protected} \KeywordTok{override} \DataTypeTok{string}\OperatorTok{?} \FunctionTok{GetNameCore}\OperatorTok{()} \OperatorTok{=\textgreater{}} \OperatorTok{(}\NormalTok{Owner }\KeywordTok{as}\NormalTok{ ProgressBadge}\OperatorTok{)?.}\FunctionTok{Text}\OperatorTok{;}
    \KeywordTok{protected} \KeywordTok{override}\NormalTok{ AutomationControlType }\FunctionTok{GetAutomationControlTypeCore}\OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ AutomationControlType}\OperatorTok{.}\FunctionTok{Text}\OperatorTok{;}
    \KeywordTok{protected} \KeywordTok{override}\NormalTok{ AutomationLiveSetting }\FunctionTok{GetLiveSettingCore}\OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ AutomationLiveSetting}\OperatorTok{.}\FunctionTok{Polite}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Override \texttt{PatternInterfaces} (e.g.,
  \texttt{IRangeValueProvider}, \texttt{IValueProvider}) when your
  control supports specific automation patterns.
\item
  Use \texttt{AutomationProperties.AccessibilityView} to control whether
  a control appears in the content vs.~control view.
\end{itemize}

\subsection{4. High contrast and theme
variants}\label{high-contrast-and-theme-variants}

Avalonia supports theme variants (\texttt{Light}, \texttt{Dark},
\texttt{HighContrast}). Bind colors to resources instead of hard-coding
values.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ResourceDictionary.ThemeDictionaries}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ResourceDictionary}\OtherTok{ x:Key=}\StringTok{"Default"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{SolidColorBrush}\OtherTok{ x:Key=}\StringTok{"AccentBrush"}\OtherTok{ Color=}\StringTok{"\#2563EB"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ResourceDictionary}\OtherTok{ x:Key=}\StringTok{"HighContrast"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{SolidColorBrush}\OtherTok{ x:Key=}\StringTok{"AccentBrush"}\OtherTok{ Color=}\StringTok{"\#00FF00"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ResourceDictionary.ThemeDictionaries}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Switch variants for testing:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Application}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{!.}\FunctionTok{RequestedThemeVariant} \OperatorTok{=}\NormalTok{ ThemeVariant}\OperatorTok{.}\FunctionTok{HighContrast}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Provide clear focus visuals using pseudo-classes (\texttt{:focus},
\texttt{:pointerover}) and ensure contrast ratios meet WCAG (4.5:1 for
body text). For Windows, respect system accent colors by reading
\texttt{RequestedThemeVariant} and \texttt{SystemBarColor} (Chapter 7).

\subsection{5. Text input, IME, and text
services}\label{text-input-ime-and-text-services}

IME support matters for CJK languages and handwriting.
\texttt{TextInputMethodClient} is the bridge between your control and
platform IME surfaces. Text controls in Avalonia already implement it;
custom text editors should derive from \texttt{TextInputMethodClient}
(or reuse \texttt{TextPresenter}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ CodeEditorTextInputClient }\OperatorTok{:}\NormalTok{ TextInputMethodClient}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ CodeEditor \_editor}\OperatorTok{;}

    \KeywordTok{public} \FunctionTok{CodeEditorTextInputClient}\OperatorTok{(}\NormalTok{CodeEditor editor}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_editor }\OperatorTok{=}\NormalTok{ editor}\OperatorTok{;}

    \KeywordTok{public} \KeywordTok{override}\NormalTok{ Visual TextViewVisual }\OperatorTok{=\textgreater{}}\NormalTok{ \_editor}\OperatorTok{.}\FunctionTok{TextLayer}\OperatorTok{;}
    \KeywordTok{public} \KeywordTok{override} \DataTypeTok{bool}\NormalTok{ SupportsPreedit }\OperatorTok{=\textgreater{}} \KeywordTok{true}\OperatorTok{;}
    \KeywordTok{public} \KeywordTok{override} \DataTypeTok{bool}\NormalTok{ SupportsSurroundingText }\OperatorTok{=\textgreater{}} \KeywordTok{true}\OperatorTok{;}
    \KeywordTok{public} \KeywordTok{override} \DataTypeTok{string}\NormalTok{ SurroundingText }\OperatorTok{=\textgreater{}}\NormalTok{ \_editor}\OperatorTok{.}\FunctionTok{Document}\OperatorTok{.}\FunctionTok{GetText}\OperatorTok{();}
    \KeywordTok{public} \KeywordTok{override}\NormalTok{ Rect CursorRectangle }\OperatorTok{=\textgreater{}}\NormalTok{ \_editor}\OperatorTok{.}\FunctionTok{GetCaretRect}\OperatorTok{();}
    \KeywordTok{public} \KeywordTok{override}\NormalTok{ TextSelection Selection}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}} \KeywordTok{new}\OperatorTok{(}\NormalTok{\_editor}\OperatorTok{.}\FunctionTok{SelectionStart}\OperatorTok{,}\NormalTok{ \_editor}\OperatorTok{.}\FunctionTok{SelectionEnd}\OperatorTok{);}
\NormalTok{        set }\OperatorTok{=\textgreater{}}\NormalTok{ \_editor}\OperatorTok{.}\FunctionTok{SetSelection}\OperatorTok{(}\NormalTok{value}\OperatorTok{.}\FunctionTok{Start}\OperatorTok{,}\NormalTok{ value}\OperatorTok{.}\FunctionTok{End}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{UpdateCursor}\OperatorTok{()}
    \OperatorTok{\{}
        \FunctionTok{RaiseCursorRectangleChanged}\OperatorTok{();}
        \FunctionTok{RaiseSelectionChanged}\OperatorTok{();}
        \FunctionTok{RaiseSurroundingTextChanged}\OperatorTok{();}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Configure text options with the attached \texttt{TextInputOptions}
properties:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TextBox}\OtherTok{ Text=}\StringTok{"\{Binding PhoneNumber\}"}
\OtherTok{         InputMethod.TextInputOptions.ContentType=}\StringTok{"TelephoneNumber"}
\OtherTok{         InputMethod.TextInputOptions.ReturnKeyType=}\StringTok{"Done"}
\OtherTok{         InputMethod.TextInputOptions.IsCorrectionEnabled=}\StringTok{"False"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  On mobile, \texttt{ReturnKeyType} changes the soft keyboard button
  (e.g., ``Go'', ``Send'').
\item
  \texttt{ContentType} hints at expected input, enabling numeric
  keyboards or email layouts.
\item
  \texttt{IsContentPredictionEnabled}/\texttt{IsSpellCheckEnabled}
  toggle autocorrect.
\end{itemize}

When you detect IME-specific behaviour, test on Windows (IMM32), macOS,
Linux (IBus/Fcitx), Android, and iOS --- each backend surfaces slightly
different capabilities.

\subsection{6. Localization workflow}\label{localization-workflow}

\subsubsection{6.1 Resource management}\label{resource-management}

Use RESX resources or a localization service that surfaces
culture-specific strings.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ Loc }\OperatorTok{:}\NormalTok{ INotifyPropertyChanged}
\OperatorTok{\{}
    \KeywordTok{private}\NormalTok{ CultureInfo \_culture }\OperatorTok{=}\NormalTok{ CultureInfo}\OperatorTok{.}\FunctionTok{CurrentUICulture}\OperatorTok{;}
    \KeywordTok{public} \DataTypeTok{string} \KeywordTok{this}\OperatorTok{[}\DataTypeTok{string}\NormalTok{ key}\OperatorTok{]} \OperatorTok{=\textgreater{}}\NormalTok{ Resources}\OperatorTok{.}\FunctionTok{ResourceManager}\OperatorTok{.}\FunctionTok{GetString}\OperatorTok{(}\NormalTok{key}\OperatorTok{,}\NormalTok{ \_culture}\OperatorTok{)} \OperatorTok{??}\NormalTok{ key}\OperatorTok{;}

    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{SetCulture}\OperatorTok{(}\NormalTok{CultureInfo culture}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{\_culture}\OperatorTok{.}\FunctionTok{Equals}\OperatorTok{(}\NormalTok{culture}\OperatorTok{))}
            \KeywordTok{return}\OperatorTok{;}

\NormalTok{        \_culture }\OperatorTok{=}\NormalTok{ culture}\OperatorTok{;}
\NormalTok{        PropertyChanged}\OperatorTok{?.}\FunctionTok{Invoke}\OperatorTok{(}\KeywordTok{this}\OperatorTok{,} \KeywordTok{new} \FunctionTok{PropertyChangedEventArgs}\OperatorTok{(}\KeywordTok{null}\OperatorTok{));}
    \OperatorTok{\}}

    \KeywordTok{public} \KeywordTok{event}\NormalTok{ PropertyChangedEventHandler}\OperatorTok{?}\NormalTok{ PropertyChanged}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Register in \texttt{App.axaml} and bind:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Application.Resources}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{local:Loc}\OtherTok{ x:Key=}\StringTok{"Loc"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Application.Resources}\NormalTok{\textgreater{}}

\NormalTok{\textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding [Ready], Source=\{StaticResource Loc\}\}"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

Switch culture at runtime:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ culture }\OperatorTok{=} \KeywordTok{new} \FunctionTok{CultureInfo}\OperatorTok{(}\StringTok{"fr{-}FR"}\OperatorTok{);}
\NormalTok{CultureInfo}\OperatorTok{.}\FunctionTok{CurrentCulture} \OperatorTok{=}\NormalTok{ CultureInfo}\OperatorTok{.}\FunctionTok{CurrentUICulture} \OperatorTok{=}\NormalTok{ culture}\OperatorTok{;}
\OperatorTok{((}\NormalTok{Loc}\OperatorTok{)}\NormalTok{Application}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{!.}\FunctionTok{Resources}\OperatorTok{[}\StringTok{"Loc"}\OperatorTok{]).}\FunctionTok{SetCulture}\OperatorTok{(}\NormalTok{culture}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{6.2 Formatting and layout
direction}\label{formatting-and-layout-direction}

\begin{itemize}
\tightlist
\item
  Use binding \texttt{StringFormat} or \texttt{string.Format} with the
  current culture for dates, numbers, and currency.
\item
  Set \texttt{FlowDirection="RightToLeft"} for RTL languages and
  override back to \texttt{LeftToRight} for controls that must remain
  LTR (e.g., numeric fields).
\item
  Mirror icons and layout padding when mirrored (use
  \texttt{ScaleTransform} or \texttt{LayoutTransform}).
\end{itemize}

\subsection{7. Fonts and fallbacks}\label{fonts-and-fallbacks}

Ensure glyph coverage with \texttt{FontManagerOptions}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{With}\OperatorTok{(}\KeywordTok{new}\NormalTok{ FontManagerOptions}
    \OperatorTok{\{}
\NormalTok{        DefaultFamilyName }\OperatorTok{=} \StringTok{"Noto Sans"}\OperatorTok{,}
\NormalTok{        FontFallbacks }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]}
        \OperatorTok{\{}
            \KeywordTok{new}\NormalTok{ FontFallback }\OperatorTok{\{}\NormalTok{ Family }\OperatorTok{=} \StringTok{"Noto Sans Arabic"} \OperatorTok{\},}
            \KeywordTok{new}\NormalTok{ FontFallback }\OperatorTok{\{}\NormalTok{ Family }\OperatorTok{=} \StringTok{"Noto Sans CJK SC"} \OperatorTok{\}}
        \OperatorTok{\}}
    \OperatorTok{\})}
    \OperatorTok{.}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Ship branded fonts via
  \texttt{FontFamily="avares://MyApp/Assets/Fonts/Brand.ttf\#Brand"}.
\item
  Test scripts that require surrogate pairs (emoji, rare CJK ideographs)
  to ensure fallbacks load.
\item
  On Windows, consider \texttt{TextRenderingMode} for clarity
  vs.~smoothness.
\end{itemize}

\subsection{8. Testing accessibility}\label{testing-accessibility}

Tips for a repeatable test loop:

\begin{itemize}
\tightlist
\item
  \textbf{Keyboard} -- Tab through each screen, ensure focus indicators
  are visible, and verify shortcuts work.
\item
  \textbf{Screen readers} -- Use Narrator, NVDA, or JAWS on Windows;
  VoiceOver on macOS/iOS; TalkBack on Android; Orca on Linux. Confirm
  names, roles, and help text.
\item
  \textbf{Automation tree} -- Avalonia DevTools → \textbf{Automation}
  tab visualizes peers and properties.
\item
  \textbf{Contrast} -- Run \texttt{Accessibility\ Insights} (Windows),
  \texttt{Color\ Oracle}, or browser dev tools to verify contrast
  ratios.
\item
  \textbf{Automated} -- Combine \texttt{Avalonia.Headless} UI tests
  (Chapter 21) with assertions on \texttt{AutomationId} and localized
  content.
\end{itemize}

Document gaps (e.g., missing peers, insufficient contrast) and track
them like any other defect.

\subsection{9. Practice exercises}\label{practice-exercises-9}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Annotate a settings page with \texttt{AutomationProperties.Name},
  \texttt{HelpText}, and \texttt{AutomationId}; inspect the automation
  tree with DevTools and NVDA.
\item
  Derive a custom \texttt{AutomationPeer} for a progress pill control,
  exposing live updates and value patterns, then verify announcements in
  a screen reader.
\item
  Configure \texttt{TextInputOptions} for phone number input on Windows,
  Android, and iOS. Test with an IME (Japanese/Chinese) to ensure
  composition events render correctly.
\item
  Localize UI strings into two additional cultures (e.g., es-ES, ar-SA),
  toggle \texttt{FlowDirection}, and confirm mirrored layouts do not
  break focus order.
\item
  Set up \texttt{FontManagerOptions} with script-specific fallbacks and
  validate that Arabic, Cyrillic, and CJK text render without tofu
  glyphs.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-13}

\begin{itemize}
\tightlist
\item
  Keyboard navigation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyboardNavigation.cs}{\texttt{KeyboardNavigation.cs}}
\item
  Automation metadata:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Automation/AutomationProperties.cs}{\texttt{AutomationProperties.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Automation/Peers/ControlAutomationPeer.cs}{\texttt{ControlAutomationPeer.cs}}
\item
  Text input \& IME:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputMethodClient.cs}{\texttt{TextInputMethodClient.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputOptions.cs}{\texttt{TextInputOptions.cs}}
\item
  Localization:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Localization/CultureInfoExtensions.cs}{\texttt{CultureInfoExtensions}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Runtime/PlatformServices.cs}{\texttt{RuntimePlatformServices}}
\item
  Font management:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/FontManagerOptions.cs}{\texttt{FontManagerOptions.cs}}
\item
  Flow direction:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Visuals/FlowDirection.cs}{\texttt{FlowDirection.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-13}

\begin{itemize}
\tightlist
\item
  How do \texttt{AutomationProperties.LabeledBy} and
  \texttt{AutomationId} improve automated testing and screen reader
  output?
\item
  When should you implement a custom \texttt{AutomationPeer}, and which
  patterns do you need to expose for value-based controls?
\item
  Which \texttt{TextInputOptions} settings influence IME behaviour and
  soft keyboard layouts across platforms?
\item
  How do you switch UI language at runtime and ensure both text and
  layout update correctly?
\item
  Where do you configure font fallbacks to cover multiple scripts
  without shipping duplicate glyphs?
\end{itemize}

What's next - Next: \href{Chapter16.md}{Chapter 16}

\newpage

\subsection{16. Files, storage, drag/drop, and
clipboard}\label{files-storage-dragdrop-and-clipboard}

Goal - Use Avalonia's storage provider to open, save, and enumerate
files/folders across desktop, mobile, and browser. - Abstract file
dialogs behind services so MVVM view models remain testable. - Handle
drag-and-drop data (files, text, custom formats) and initiate drags from
your app. - Work with the clipboard safely, including multi-format
payloads.

Why this matters - Users expect native pickers, drag/drop, and clipboard
support. Implementing them well keeps experiences consistent across
platforms. - Proper abstractions keep storage logic off the UI thread
and ready for unit testing.

Prerequisites - Chapter 9 (commands/input), Chapter 11 (MVVM), Chapter
12 (TopLevel services).

\subsection{1. Storage provider
fundamentals}\label{storage-provider-fundamentals}

All pickers live on \texttt{TopLevel.StorageProvider} (Window, control,
etc.). The storage provider is an abstraction over native dialogs and
sandbox rules.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ topLevel }\OperatorTok{=}\NormalTok{ TopLevel}\OperatorTok{.}\FunctionTok{GetTopLevel}\OperatorTok{(}\NormalTok{control}\OperatorTok{);}
\KeywordTok{if} \OperatorTok{(}\NormalTok{topLevel}\OperatorTok{?.}\FunctionTok{StorageProvider} \KeywordTok{is} \OperatorTok{\{} \OperatorTok{\}}\NormalTok{ storage}\OperatorTok{)}
\OperatorTok{\{}
    \CommentTok{// storage.OpenFilePickerAsync(...)}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If \texttt{StorageProvider} is null, ensure the control is attached
(e.g., call after \texttt{Loaded}/\texttt{Opened}).

\texttt{IStorageProvider} exposes capability flags such as
\texttt{CanOpen}, \texttt{CanSave}, and \texttt{CanPickFolder}. Check
them before presenting commands so sandboxed targets (browser/mobile)
can hide unsupported options. Dialog methods accept option records
(\texttt{FilePickerOpenOptions}, \texttt{FolderPickerOpenOptions}, etc.)
that describe filters, suggested locations, and tokens for continuing
previous sessions.

\subsubsection{1.1 Service abstraction for
MVVM}\label{service-abstraction-for-mvvm}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{interface}\NormalTok{ IFileDialogService}
\OperatorTok{\{}
\NormalTok{    Task}\OperatorTok{\textless{}}\NormalTok{IReadOnlyList}\OperatorTok{\textless{}}\NormalTok{IStorageFile}\OperatorTok{\textgreater{}\textgreater{}} \FunctionTok{OpenFilesAsync}\OperatorTok{(}\NormalTok{FilePickerOpenOptions options}\OperatorTok{);}
\NormalTok{    Task}\OperatorTok{\textless{}}\NormalTok{IStorageFile}\OperatorTok{?\textgreater{}} \FunctionTok{SaveFileAsync}\OperatorTok{(}\NormalTok{FilePickerSaveOptions options}\OperatorTok{);}
\NormalTok{    Task}\OperatorTok{\textless{}}\NormalTok{IStorageFolder}\OperatorTok{?\textgreater{}} \FunctionTok{PickFolderAsync}\OperatorTok{(}\NormalTok{FolderPickerOpenOptions options}\OperatorTok{);}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ FileDialogService }\OperatorTok{:}\NormalTok{ IFileDialogService}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ TopLevel \_topLevel}\OperatorTok{;}
    \KeywordTok{public} \FunctionTok{FileDialogService}\OperatorTok{(}\NormalTok{TopLevel topLevel}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_topLevel }\OperatorTok{=}\NormalTok{ topLevel}\OperatorTok{;}

    \KeywordTok{public}\NormalTok{ Task}\OperatorTok{\textless{}}\NormalTok{IReadOnlyList}\OperatorTok{\textless{}}\NormalTok{IStorageFile}\OperatorTok{\textgreater{}\textgreater{}} \FunctionTok{OpenFilesAsync}\OperatorTok{(}\NormalTok{FilePickerOpenOptions options}\OperatorTok{)}
        \OperatorTok{=\textgreater{}}\NormalTok{ \_topLevel}\OperatorTok{.}\FunctionTok{StorageProvider}\OperatorTok{?.}\FunctionTok{OpenFilePickerAsync}\OperatorTok{(}\NormalTok{options}\OperatorTok{)} \OperatorTok{??}\NormalTok{ Task}\OperatorTok{.}\FunctionTok{FromResult}\OperatorTok{\textless{}}\NormalTok{IReadOnlyList}\OperatorTok{\textless{}}\NormalTok{IStorageFile}\OperatorTok{\textgreater{}\textgreater{}(}\NormalTok{Array}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{\textless{}}\NormalTok{IStorageFile}\OperatorTok{\textgreater{}());}

    \KeywordTok{public}\NormalTok{ Task}\OperatorTok{\textless{}}\NormalTok{IStorageFile}\OperatorTok{?\textgreater{}} \FunctionTok{SaveFileAsync}\OperatorTok{(}\NormalTok{FilePickerSaveOptions options}\OperatorTok{)}
        \OperatorTok{=\textgreater{}}\NormalTok{ \_topLevel}\OperatorTok{.}\FunctionTok{StorageProvider}\OperatorTok{?.}\FunctionTok{SaveFilePickerAsync}\OperatorTok{(}\NormalTok{options}\OperatorTok{)} \OperatorTok{??}\NormalTok{ Task}\OperatorTok{.}\FunctionTok{FromResult}\OperatorTok{\textless{}}\NormalTok{IStorageFile}\OperatorTok{?\textgreater{}(}\KeywordTok{null}\OperatorTok{);}

    \KeywordTok{public}\NormalTok{ async Task}\OperatorTok{\textless{}}\NormalTok{IStorageFolder}\OperatorTok{?\textgreater{}} \FunctionTok{PickFolderAsync}\OperatorTok{(}\NormalTok{FolderPickerOpenOptions options}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{\_topLevel}\OperatorTok{.}\FunctionTok{StorageProvider} \KeywordTok{is} \KeywordTok{null}\OperatorTok{)}
            \KeywordTok{return} \KeywordTok{null}\OperatorTok{;}
        \DataTypeTok{var}\NormalTok{ folders }\OperatorTok{=}\NormalTok{ await \_topLevel}\OperatorTok{.}\FunctionTok{StorageProvider}\OperatorTok{.}\FunctionTok{OpenFolderPickerAsync}\OperatorTok{(}\NormalTok{options}\OperatorTok{);}
        \KeywordTok{return}\NormalTok{ folders}\OperatorTok{.}\FunctionTok{FirstOrDefault}\OperatorTok{();}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Register the service per window (in DI) so view models request dialogs
via \texttt{IFileDialogService} without touching UI types.

\subsubsection{1.2 Launching files and
URIs}\label{launching-files-and-uris}

\texttt{TopLevel.Launcher} gives access to \texttt{ILauncher}, which
opens files, folders, or URIs using the platform shell (Finder,
Explorer, default browser, etc.). Combine it with storage results to let
users reveal files after saving.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ topLevel }\OperatorTok{=}\NormalTok{ TopLevel}\OperatorTok{.}\FunctionTok{GetTopLevel}\OperatorTok{(}\NormalTok{control}\OperatorTok{);}
\KeywordTok{if} \OperatorTok{(}\NormalTok{topLevel}\OperatorTok{?.}\FunctionTok{Launcher} \KeywordTok{is} \OperatorTok{\{} \OperatorTok{\}}\NormalTok{ launcher }\OperatorTok{\&\&}\NormalTok{ file }\KeywordTok{is}\NormalTok{ not }\KeywordTok{null}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    await launcher}\OperatorTok{.}\FunctionTok{LaunchFileAsync}\OperatorTok{(}\NormalTok{file}\OperatorTok{);}
\NormalTok{    await launcher}\OperatorTok{.}\FunctionTok{LaunchUriAsync}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Uri}\OperatorTok{(}\StringTok{"https://docs.avaloniaui.net"}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Return values indicate whether the launch succeeded; fall back to in-app
viewers when it returns false.

\subsection{2. Opening files (async
streams)}\label{opening-files-async-streams}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public}\NormalTok{ async Task}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{?\textgreater{}} \FunctionTok{ReadTextFileAsync}\OperatorTok{(}\NormalTok{IStorageFile file}\OperatorTok{,}\NormalTok{ CancellationToken ct}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    await }\KeywordTok{using} \DataTypeTok{var}\NormalTok{ stream }\OperatorTok{=}\NormalTok{ await file}\OperatorTok{.}\FunctionTok{OpenReadAsync}\OperatorTok{();}
    \KeywordTok{using} \DataTypeTok{var}\NormalTok{ reader }\OperatorTok{=} \KeywordTok{new} \FunctionTok{StreamReader}\OperatorTok{(}\NormalTok{stream}\OperatorTok{,}\NormalTok{ Encoding}\OperatorTok{.}\FunctionTok{UTF8}\OperatorTok{,}\NormalTok{ detectEncodingFromByteOrderMarks}\OperatorTok{:} \KeywordTok{true}\OperatorTok{);}
    \KeywordTok{return}\NormalTok{ await reader}\OperatorTok{.}\FunctionTok{ReadToEndAsync}\OperatorTok{(}\NormalTok{ct}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Always wrap streams in \texttt{using}/\texttt{await\ using}.
\item
  Pass \texttt{CancellationToken} to long operations.
\item
  For binary files, use \texttt{BinaryReader} or direct \texttt{Stream}
  APIs.
\end{itemize}

\subsubsection{2.1 Remote or sandboxed
locations}\label{remote-or-sandboxed-locations}

On Android/iOS/Browser the returned stream might be virtual (no direct
file path). Always rely on stream APIs; avoid \texttt{LocalPath} if
\texttt{Path} is null.

\subsubsection{2.2 File type filters}\label{file-type-filters}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ options }\OperatorTok{=} \KeywordTok{new}\NormalTok{ FilePickerOpenOptions}
\OperatorTok{\{}
\NormalTok{    Title }\OperatorTok{=} \StringTok{"Open images"}\OperatorTok{,}
\NormalTok{    AllowMultiple }\OperatorTok{=} \KeywordTok{true}\OperatorTok{,}
\NormalTok{    SuggestedStartLocation }\OperatorTok{=}\NormalTok{ await storage}\OperatorTok{.}\FunctionTok{TryGetWellKnownFolderAsync}\OperatorTok{(}\NormalTok{WellKnownFolder}\OperatorTok{.}\FunctionTok{Pictures}\OperatorTok{),}
\NormalTok{    FileTypeFilter }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]}
    \OperatorTok{\{}
        \KeywordTok{new} \FunctionTok{FilePickerFileType}\OperatorTok{(}\StringTok{"Images"}\OperatorTok{)}
        \OperatorTok{\{}
\NormalTok{            Patterns }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{} \StringTok{"*.png"}\OperatorTok{,} \StringTok{"*.jpg"}\OperatorTok{,} \StringTok{"*.jpeg"}\OperatorTok{,} \StringTok{"*.webp"}\OperatorTok{,} \StringTok{"*.gif"} \OperatorTok{\}}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

\texttt{TryGetWellKnownFolderAsync} returns common directories when
supported (desktop/mobile). Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/WellKnownFolder.cs}{\texttt{WellKnownFolder.cs}}.

\subsection{3. Saving files}\label{saving-files}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ saveOptions }\OperatorTok{=} \KeywordTok{new}\NormalTok{ FilePickerSaveOptions}
\OperatorTok{\{}
\NormalTok{    Title }\OperatorTok{=} \StringTok{"Export report"}\OperatorTok{,}
\NormalTok{    SuggestedFileName }\OperatorTok{=}\NormalTok{ $}\StringTok{"report{-}\{DateTime.UtcNow:yyyyMMdd\}.csv"}\OperatorTok{,}
\NormalTok{    DefaultExtension }\OperatorTok{=} \StringTok{"csv"}\OperatorTok{,}
\NormalTok{    FileTypeChoices }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]}
    \OperatorTok{\{}
        \KeywordTok{new} \FunctionTok{FilePickerFileType}\OperatorTok{(}\StringTok{"CSV"}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ Patterns }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{} \StringTok{"*.csv"} \OperatorTok{\}} \OperatorTok{\},}
        \KeywordTok{new} \FunctionTok{FilePickerFileType}\OperatorTok{(}\StringTok{"All files"}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ Patterns }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{} \StringTok{"*"} \OperatorTok{\}} \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\};}

\DataTypeTok{var}\NormalTok{ file }\OperatorTok{=}\NormalTok{ await \_dialogService}\OperatorTok{.}\FunctionTok{SaveFileAsync}\OperatorTok{(}\NormalTok{saveOptions}\OperatorTok{);}
\KeywordTok{if} \OperatorTok{(}\NormalTok{file }\KeywordTok{is}\NormalTok{ not }\KeywordTok{null}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    await }\KeywordTok{using} \DataTypeTok{var}\NormalTok{ stream }\OperatorTok{=}\NormalTok{ await file}\OperatorTok{.}\FunctionTok{OpenWriteAsync}\OperatorTok{();}
\NormalTok{    await }\KeywordTok{using} \DataTypeTok{var}\NormalTok{ writer }\OperatorTok{=} \KeywordTok{new} \FunctionTok{StreamWriter}\OperatorTok{(}\NormalTok{stream}\OperatorTok{,}\NormalTok{ Encoding}\OperatorTok{.}\FunctionTok{UTF8}\OperatorTok{,}\NormalTok{ leaveOpen}\OperatorTok{:} \KeywordTok{false}\OperatorTok{);}
\NormalTok{    await writer}\OperatorTok{.}\FunctionTok{WriteLineAsync}\OperatorTok{(}\StringTok{"Id,Name,Email"}\OperatorTok{);}
    \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ row }\KeywordTok{in}\NormalTok{ rows}\OperatorTok{)}
\NormalTok{        await writer}\OperatorTok{.}\FunctionTok{WriteLineAsync}\OperatorTok{(}\NormalTok{$}\StringTok{"\{row.Id\},\{row.Name\},\{row.Email\}"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{OpenWriteAsync} truncates the existing file. Use
  \texttt{OpenReadWriteAsync} for editing.
\item
  Some platforms prompt for confirmation when writing to previously
  granted locations.
\end{itemize}

\subsection{4. Enumerating folders}\label{enumerating-folders}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ folder }\OperatorTok{=}\NormalTok{ await storage}\OperatorTok{.}\FunctionTok{TryGetFolderFromPathAsync}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Uri}\OperatorTok{(}\StringTok{"file:///C:/Logs"}\OperatorTok{));}
\KeywordTok{if} \OperatorTok{(}\NormalTok{folder }\KeywordTok{is}\NormalTok{ not }\KeywordTok{null}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    await }\KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ item }\KeywordTok{in}\NormalTok{ folder}\OperatorTok{.}\FunctionTok{GetItemsAsync}\OperatorTok{())}
    \OperatorTok{\{}
        \KeywordTok{switch} \OperatorTok{(}\NormalTok{item}\OperatorTok{)}
        \OperatorTok{\{}
            \KeywordTok{case}\NormalTok{ IStorageFile file}\OperatorTok{:}
                \CommentTok{// Process file}
                \KeywordTok{break}\OperatorTok{;}
            \KeywordTok{case}\NormalTok{ IStorageFolder subfolder}\OperatorTok{:}
                \CommentTok{// Recurse or display}
                \KeywordTok{break}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{GetItemsAsync()} returns an async sequence; iterate with
\texttt{await\ foreach} on .NET 7+. Use
\texttt{GetFilesAsync}/\texttt{GetFoldersAsync} to filter.

\subsection{5. Bookmarks and persisted
access}\label{bookmarks-and-persisted-access}

Some platforms revoke file permissions when your app suspends. If an
\texttt{IStorageItem} reports \texttt{CanBookmark}, call
\texttt{SaveBookmarkAsync()} and store the returned string (e.g., in
preferences). Later, reopen it via
\texttt{IStorageProvider.OpenFileBookmarkAsync}/\texttt{OpenFolderBookmarkAsync}.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ bookmarks }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Dictionary}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{,} \DataTypeTok{string}\OperatorTok{\textgreater{}();}

\KeywordTok{if} \OperatorTok{(}\NormalTok{file}\OperatorTok{.}\FunctionTok{CanBookmark}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ bookmarkId }\OperatorTok{=}\NormalTok{ await file}\OperatorTok{.}\FunctionTok{SaveBookmarkAsync}\OperatorTok{();}
    \KeywordTok{if} \OperatorTok{(!}\DataTypeTok{string}\OperatorTok{.}\FunctionTok{IsNullOrEmpty}\OperatorTok{(}\NormalTok{bookmarkId}\OperatorTok{))}
\NormalTok{        bookmarks}\OperatorTok{[}\NormalTok{file}\OperatorTok{.}\FunctionTok{Path}\OperatorTok{.}\FunctionTok{ToString}\OperatorTok{()]} \OperatorTok{=}\NormalTok{ bookmarkId}\OperatorTok{;}
\OperatorTok{\}}

\DataTypeTok{var}\NormalTok{ restored }\OperatorTok{=}\NormalTok{ await storage}\OperatorTok{.}\FunctionTok{OpenFileBookmarkAsync}\OperatorTok{(}\NormalTok{bookmarkId}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Keep bookmarks updated when users revoke access. iOS and Android can
throw when bookmarks expire---wrap calls in try/catch and ask users to
reselect the folder. Desktop platforms typically return standard file
paths, but bookmarks still help retain portal-granted access (e.g.,
Flatpak).

\texttt{IStorageItem.GetBasicPropertiesAsync()} exposes metadata (size,
modified time) without opening streams---use it when building file
browsers.

\subsection{6. Platform notes}\label{platform-notes-1}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Platform
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Storage provider
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Considerations
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Windows/macOS/Linux & Native dialogs; file system access & Standard
read/write. Some Linux desktops require portals (Flatpak/Snap). \\
Android/iOS & Native pickers; sandboxed URIs & Streams may be content
URIs; persist permissions if needed. \\
Browser (WASM) & File System Access API & Requires user gestures; may
return handles that expire when page reloads. \\
\end{longtable}

Wrap storage calls in try/catch to handle permission denials or canceled
dialogs gracefully.

\subsection{7. Drag-and-drop: receiving
data}\label{drag-and-drop-receiving-data}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Border}\OtherTok{ AllowDrop=}\StringTok{"True"}
\OtherTok{        DragOver=}\StringTok{"OnDragOver"}
\OtherTok{        Drop=}\StringTok{"OnDrop"}
\OtherTok{        Background=}\StringTok{"\#111827"}\OtherTok{ Padding=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Drop files or text"}\OtherTok{ Foreground=}\StringTok{"\#CBD5F5"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private} \DataTypeTok{void} \FunctionTok{OnDragOver}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ DragEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{Data}\OperatorTok{.}\FunctionTok{Contains}\OperatorTok{(}\NormalTok{DataFormats}\OperatorTok{.}\FunctionTok{Files}\OperatorTok{)} \OperatorTok{||}\NormalTok{ e}\OperatorTok{.}\FunctionTok{Data}\OperatorTok{.}\FunctionTok{Contains}\OperatorTok{(}\NormalTok{DataFormats}\OperatorTok{.}\FunctionTok{Text}\OperatorTok{))}
\NormalTok{        e}\OperatorTok{.}\FunctionTok{DragEffects} \OperatorTok{=}\NormalTok{ DragDropEffects}\OperatorTok{.}\FunctionTok{Copy}\OperatorTok{;}
    \KeywordTok{else}
\NormalTok{        e}\OperatorTok{.}\FunctionTok{DragEffects} \OperatorTok{=}\NormalTok{ DragDropEffects}\OperatorTok{.}\FunctionTok{None}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{private}\NormalTok{ async }\DataTypeTok{void} \FunctionTok{OnDrop}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ DragEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ files }\OperatorTok{=}\NormalTok{ await e}\OperatorTok{.}\FunctionTok{Data}\OperatorTok{.}\FunctionTok{GetFilesAsync}\OperatorTok{();}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{files }\KeywordTok{is}\NormalTok{ not }\KeywordTok{null}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ item }\KeywordTok{in}\NormalTok{ files}\OperatorTok{.}\FunctionTok{OfType}\OperatorTok{\textless{}}\NormalTok{IStorageFile}\OperatorTok{\textgreater{}())}
        \OperatorTok{\{}
\NormalTok{            await }\KeywordTok{using} \DataTypeTok{var}\NormalTok{ stream }\OperatorTok{=}\NormalTok{ await item}\OperatorTok{.}\FunctionTok{OpenReadAsync}\OperatorTok{();}
            \CommentTok{// import}
        \OperatorTok{\}}
        \KeywordTok{return}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{if} \OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{Data}\OperatorTok{.}\FunctionTok{Contains}\OperatorTok{(}\NormalTok{DataFormats}\OperatorTok{.}\FunctionTok{Text}\OperatorTok{))}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ text }\OperatorTok{=}\NormalTok{ await e}\OperatorTok{.}\FunctionTok{Data}\OperatorTok{.}\FunctionTok{GetTextAsync}\OperatorTok{();}
        \CommentTok{// handle text}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{GetFilesAsync()} returns storage items; check for
  \texttt{IStorageFile}.
\item
  Inspect \texttt{e.KeyModifiers} to adjust behavior (e.g., Ctrl for
  copy).
\end{itemize}

\subsubsection{7.1 Initiating
drag-and-drop}\label{initiating-drag-and-drop}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private}\NormalTok{ async }\DataTypeTok{void} \FunctionTok{DragSource\_PointerPressed}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ PointerPressedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{sender }\KeywordTok{is}\NormalTok{ not Control control}\OperatorTok{)}
        \KeywordTok{return}\OperatorTok{;}

    \DataTypeTok{var}\NormalTok{ data }\OperatorTok{=} \KeywordTok{new} \FunctionTok{DataObject}\OperatorTok{();}
\NormalTok{    data}\OperatorTok{.}\FunctionTok{Set}\OperatorTok{(}\NormalTok{DataFormats}\OperatorTok{.}\FunctionTok{Text}\OperatorTok{,} \StringTok{"Example text"}\OperatorTok{);}

    \DataTypeTok{var}\NormalTok{ effects }\OperatorTok{=}\NormalTok{ await DragDrop}\OperatorTok{.}\FunctionTok{DoDragDrop}\OperatorTok{(}\NormalTok{e}\OperatorTok{,}\NormalTok{ data}\OperatorTok{,}\NormalTok{ DragDropEffects}\OperatorTok{.}\FunctionTok{Copy} \OperatorTok{|}\NormalTok{ DragDropEffects}\OperatorTok{.}\FunctionTok{Move}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{effects}\OperatorTok{.}\FunctionTok{HasFlag}\OperatorTok{(}\NormalTok{DragDropEffects}\OperatorTok{.}\FunctionTok{Move}\OperatorTok{))}
    \OperatorTok{\{}
        \CommentTok{// remove item}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{DataObject} supports multiple formats (text, files, custom
types). For custom data, both source and target must agree on a format
string.

\subsubsection{7.2 Custom visuals and
adorners}\label{custom-visuals-and-adorners}

Wrap your layout in an \texttt{AdornerDecorator} and render drop cues
while a drag is in progress. Toggle overlays in
\texttt{DragEnter}/\texttt{DragLeave} handlers to show hit targets or
counts.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private} \DataTypeTok{void} \FunctionTok{OnDragEnter}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ DragEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    \_dropOverlay}\OperatorTok{.}\FunctionTok{IsVisible} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
\OperatorTok{\}}

\KeywordTok{private} \DataTypeTok{void} \FunctionTok{OnDragLeave}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ RoutedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    \_dropOverlay}\OperatorTok{.}\FunctionTok{IsVisible} \OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You can also inspect \texttt{e.DragEffects} to switch icons (copy vs
move) or reject unsupported formats with a custom message. For complex
scenarios create a lightweight \texttt{Window} as a drag adorner so the
pointer stays responsive on multi-monitor setups.

\subsection{8. Clipboard operations}\label{clipboard-operations}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{interface}\NormalTok{ IClipboardService}
\OperatorTok{\{}
\NormalTok{    Task }\FunctionTok{SetTextAsync}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ text}\OperatorTok{);}
\NormalTok{    Task}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{?\textgreater{}} \FunctionTok{GetTextAsync}\OperatorTok{();}
\NormalTok{    Task }\FunctionTok{SetDataObjectAsync}\OperatorTok{(}\NormalTok{IDataObject dataObject}\OperatorTok{);}
\NormalTok{    Task}\OperatorTok{\textless{}}\NormalTok{IReadOnlyList}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{\textgreater{}\textgreater{}} \FunctionTok{GetFormatsAsync}\OperatorTok{();}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ ClipboardService }\OperatorTok{:}\NormalTok{ IClipboardService}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ TopLevel \_topLevel}\OperatorTok{;}
    \KeywordTok{public} \FunctionTok{ClipboardService}\OperatorTok{(}\NormalTok{TopLevel topLevel}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_topLevel }\OperatorTok{=}\NormalTok{ topLevel}\OperatorTok{;}

    \KeywordTok{public}\NormalTok{ Task }\FunctionTok{SetTextAsync}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ text}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_topLevel}\OperatorTok{.}\FunctionTok{Clipboard}\OperatorTok{?.}\FunctionTok{SetTextAsync}\OperatorTok{(}\NormalTok{text}\OperatorTok{)} \OperatorTok{??}\NormalTok{ Task}\OperatorTok{.}\FunctionTok{CompletedTask}\OperatorTok{;}
    \KeywordTok{public}\NormalTok{ Task}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{?\textgreater{}} \FunctionTok{GetTextAsync}\OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ \_topLevel}\OperatorTok{.}\FunctionTok{Clipboard}\OperatorTok{?.}\FunctionTok{GetTextAsync}\OperatorTok{()} \OperatorTok{??}\NormalTok{ Task}\OperatorTok{.}\FunctionTok{FromResult}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{?\textgreater{}(}\KeywordTok{null}\OperatorTok{);}
    \KeywordTok{public}\NormalTok{ Task }\FunctionTok{SetDataObjectAsync}\OperatorTok{(}\NormalTok{IDataObject dataObject}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_topLevel}\OperatorTok{.}\FunctionTok{Clipboard}\OperatorTok{?.}\FunctionTok{SetDataObjectAsync}\OperatorTok{(}\NormalTok{dataObject}\OperatorTok{)} \OperatorTok{??}\NormalTok{ Task}\OperatorTok{.}\FunctionTok{CompletedTask}\OperatorTok{;}
    \KeywordTok{public}\NormalTok{ Task}\OperatorTok{\textless{}}\NormalTok{IReadOnlyList}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{\textgreater{}\textgreater{}} \FunctionTok{GetFormatsAsync}\OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ \_topLevel}\OperatorTok{.}\FunctionTok{Clipboard}\OperatorTok{?.}\FunctionTok{GetFormatsAsync}\OperatorTok{()} \OperatorTok{??}\NormalTok{ Task}\OperatorTok{.}\FunctionTok{FromResult}\OperatorTok{\textless{}}\NormalTok{IReadOnlyList}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{\textgreater{}\textgreater{}(}\NormalTok{Array}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{\textgreater{}());}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{8.1 Multi-format clipboard
payload}\label{multi-format-clipboard-payload}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ dataObject }\OperatorTok{=} \KeywordTok{new} \FunctionTok{DataObject}\OperatorTok{();}
\NormalTok{dataObject}\OperatorTok{.}\FunctionTok{Set}\OperatorTok{(}\NormalTok{DataFormats}\OperatorTok{.}\FunctionTok{Text}\OperatorTok{,} \StringTok{"Plain text"}\OperatorTok{);}
\NormalTok{dataObject}\OperatorTok{.}\FunctionTok{Set}\OperatorTok{(}\StringTok{"text/html"}\OperatorTok{,} \StringTok{"\textless{}strong\textgreater{}Bold\textless{}/strong\textgreater{}"}\OperatorTok{);}
\NormalTok{dataObject}\OperatorTok{.}\FunctionTok{Set}\OperatorTok{(}\StringTok{"application/x{-}myapp{-}item"}\OperatorTok{,}\NormalTok{ myItemId}\OperatorTok{);}

\NormalTok{await clipboardService}\OperatorTok{.}\FunctionTok{SetDataObjectAsync}\OperatorTok{(}\NormalTok{dataObject}\OperatorTok{);}
\DataTypeTok{var}\NormalTok{ formats }\OperatorTok{=}\NormalTok{ await clipboardService}\OperatorTok{.}\FunctionTok{GetFormatsAsync}\OperatorTok{();}
\end{Highlighting}
\end{Shaded}

Browser restrictions: clipboard APIs require user gesture and may only
allow text formats.

\subsection{9. Error handling \& async
patterns}\label{error-handling-async-patterns}

\begin{itemize}
\tightlist
\item
  Wrap storage operations in try/catch for \texttt{IOException},
  \texttt{UnauthorizedAccessException}.
\item
  Offload heavy parsing to background threads with \texttt{Task.Run}
  (keep UI thread responsive).
\item
  Use \texttt{Progress\textless{}T\textgreater{}} to report progress to
  view models.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ progress }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Progress}\OperatorTok{\textless{}}\DataTypeTok{int}\OperatorTok{\textgreater{}(}\NormalTok{value }\OperatorTok{=\textgreater{}}\NormalTok{ ImportProgress }\OperatorTok{=}\NormalTok{ value}\OperatorTok{);}
\NormalTok{await \_importService}\OperatorTok{.}\FunctionTok{ImportAsync}\OperatorTok{(}\NormalTok{file}\OperatorTok{,}\NormalTok{ progress}\OperatorTok{,}\NormalTok{ cancellationToken}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsection{10. Diagnostics}\label{diagnostics-1}

\begin{itemize}
\tightlist
\item
  Log storage/drag errors with \texttt{LogArea.Platform} or custom
  logger.
\item
  DevTools -\textgreater{} Events tab shows drag/drop events.
\item
  On Linux portals (Flatpak/Snap), check console logs for portal errors.
\end{itemize}

\subsection{11. Practice exercises}\label{practice-exercises-10}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Implement \texttt{IFileDialogService} and expose commands for Open,
  Save, and Pick Folder; update the UI with results.
\item
  Build a file manager pane that enumerates folders asynchronously,
  persists bookmarks for sandboxed platforms, and mirrors changes via
  drag/drop.
\item
  Create a clipboard history panel that stores the last N text snippets
  using the \texttt{IClipboard} service.
\item
  Add drag support from a list to the OS shell (export files) with a
  custom adorner overlay showing the item count.
\item
  Implement cancellation for long-running file imports and confirm
  resources are disposed when canceled.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-14}

\begin{itemize}
\tightlist
\item
  Storage provider:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/IStorageProvider.cs}{\texttt{IStorageProvider}}
\item
  File/folder abstractions:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/FileIO/IStorageFile.cs}{\texttt{IStorageFile}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/FileIO/IStorageFolder.cs}{\texttt{IStorageFolder}}
\item
  Bookmarks \& metadata:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/IStorageItem.cs}{\texttt{IStorageItem}}
\item
  Picker options:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/FilePickerOpenOptions.cs}{\texttt{FilePickerOpenOptions}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/FilePickerSaveOptions.cs}{\texttt{FilePickerSaveOptions}}
\item
  Drag/drop:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/DragDrop.cs}{\texttt{DragDrop.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/DataObject.cs}{\texttt{DataObject.cs}}
\item
  Clipboard:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/IClipboard.cs}{\texttt{IClipboard}}
\item
  Launcher:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/ILauncher.cs}{\texttt{ILauncher}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-14}

\begin{itemize}
\tightlist
\item
  How do you obtain an \texttt{IStorageProvider} when you only have a
  view model?
\item
  What are the advantages of using asynchronous streams
  (\texttt{await\ using}) when reading/writing files?
\item
  How can you detect which drag/drop formats are available during a drop
  event?
\item
  Which APIs let you enumerate well-known folders cross-platform?
\item
  What restrictions exist for clipboard and storage operations on
  browser/mobile?
\end{itemize}

What's next - Next: \href{Chapter17.md}{Chapter 17}

\newpage

\subsection{17. Background work and
networking}\label{background-work-and-networking}

Goal - Keep the UI responsive while doing heavy or long-running tasks
using async/await, Task.Run, and progress reporting. - Surface status,
progress, and cancellation to users. - Call web APIs with HttpClient,
handle retries/timeouts, and stream downloads/upload. - Respond to
connectivity changes and test background logic predictably.

Why this matters - Real apps load data, crunch files, and hit APIs.
Blocking the UI thread ruins UX. - Async-first code scales across
desktop, mobile, and browser with minimal changes.

Prerequisites - Chapters 8-9 (binding \& commands), Chapter 11 (MVVM),
Chapter 16 (file IO).

\subsection{1. The UI thread and
Dispatcher}\label{the-ui-thread-and-dispatcher}

Avalonia has a single UI thread managed by \texttt{Dispatcher.UIThread}.
UI elements and bound properties must be updated on this thread.

Rules of thumb: - Prefer async I/O (await network/file operations). -
For CPU-bound work, use \texttt{Task.Run} to offload to a thread pool
thread. - Use \texttt{Dispatcher.UIThread.Post/InvokeAsync} to marshal
back to the UI thread if needed (though
\texttt{Progress\textless{}T\textgreater{}} usually keeps you on the UI
thread).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{await Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{InvokeAsync}\OperatorTok{(()} \OperatorTok{=\textgreater{}}\NormalTok{ Status }\OperatorTok{=} \StringTok{"Ready"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{1.1 Dispatcher priorities}\label{dispatcher-priorities}

\texttt{DispatcherPriority} controls when queued work runs relative to
layout, input, and rendering. Use \texttt{Dispatcher.UIThread.Post} with
an explicit priority when you want work to wait until after animations
or to run ahead of rendering.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{Post}\OperatorTok{(}
    \OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ Notifications}\OperatorTok{.}\FunctionTok{Clear}\OperatorTok{(),}
\NormalTok{    priority}\OperatorTok{:}\NormalTok{ DispatcherPriority}\OperatorTok{.}\FunctionTok{Background}\OperatorTok{);}

\NormalTok{Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{Post}\OperatorTok{(}
    \OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ Toasts}\OperatorTok{.}\FunctionTok{Enqueue}\OperatorTok{(}\NormalTok{message}\OperatorTok{),}
\NormalTok{    priority}\OperatorTok{:}\NormalTok{ DispatcherPriority}\OperatorTok{.}\FunctionTok{Input}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Avoid defaulting everything to \texttt{DispatcherPriority.Send}
(synchronous) because it can starve input processing.

\subsubsection{1.2 SynchronizationContext
awareness}\label{synchronizationcontext-awareness}

\texttt{DispatcherSynchronizationContext} is installed on the UI thread;
async continuations captured there automatically hop back to Avalonia
when you \texttt{await}. When running background tasks (e.g., unit tests
or hosted services) ensure you resume on the UI thread by capturing the
context:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ uiContext }\OperatorTok{=}\NormalTok{ SynchronizationContext}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{;}

\NormalTok{await Task}\OperatorTok{.}\FunctionTok{Run}\OperatorTok{(}\FunctionTok{async} \OperatorTok{()} \OperatorTok{=\textgreater{}}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ result }\OperatorTok{=}\NormalTok{ await }\FunctionTok{LoadAsync}\OperatorTok{(}\NormalTok{ct}\OperatorTok{).}\FunctionTok{ConfigureAwait}\OperatorTok{(}\KeywordTok{false}\OperatorTok{);}
\NormalTok{    uiContext}\OperatorTok{?.}\FunctionTok{Post}\OperatorTok{(}\NormalTok{\_ }\OperatorTok{=\textgreater{}}\NormalTok{ ViewModel}\OperatorTok{.}\FunctionTok{Result} \OperatorTok{=}\NormalTok{ result}\OperatorTok{,} \KeywordTok{null}\OperatorTok{);}
\OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

When you intentionally want to stay on a background thread, use
\texttt{ConfigureAwait(false)} to avoid marshaling back.

\subsection{2. Async workflow pattern
(ViewModel)}\label{async-workflow-pattern-viewmodel}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ WorkViewModel }\OperatorTok{:}\NormalTok{ ObservableObject}
\OperatorTok{\{}
    \KeywordTok{private}\NormalTok{ CancellationTokenSource}\OperatorTok{?}\NormalTok{ \_cts}\OperatorTok{;}
    \KeywordTok{private} \DataTypeTok{double}\NormalTok{ \_progress}\OperatorTok{;}
    \KeywordTok{private} \DataTypeTok{string}\NormalTok{ \_status }\OperatorTok{=} \StringTok{"Idle"}\OperatorTok{;}
    \KeywordTok{private} \DataTypeTok{bool}\NormalTok{ \_isBusy}\OperatorTok{;}

    \KeywordTok{public} \DataTypeTok{double}\NormalTok{ Progress }\OperatorTok{\{}\NormalTok{ get }\OperatorTok{=\textgreater{}}\NormalTok{ \_progress}\OperatorTok{;}\NormalTok{ set }\OperatorTok{=\textgreater{}} \FunctionTok{SetProperty}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_progress}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);} \OperatorTok{\}}
    \KeywordTok{public} \DataTypeTok{string}\NormalTok{ Status }\OperatorTok{\{}\NormalTok{ get }\OperatorTok{=\textgreater{}}\NormalTok{ \_status}\OperatorTok{;}\NormalTok{ set }\OperatorTok{=\textgreater{}} \FunctionTok{SetProperty}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_status}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);} \OperatorTok{\}}
    \KeywordTok{public} \DataTypeTok{bool}\NormalTok{ IsBusy }\OperatorTok{\{}\NormalTok{ get }\OperatorTok{=\textgreater{}}\NormalTok{ \_isBusy}\OperatorTok{;}\NormalTok{ set }\OperatorTok{=\textgreater{}} \FunctionTok{SetProperty}\OperatorTok{(}\KeywordTok{ref}\NormalTok{ \_isBusy}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);} \OperatorTok{\}}

    \KeywordTok{public}\NormalTok{ RelayCommand StartCommand }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}
    \KeywordTok{public}\NormalTok{ RelayCommand CancelCommand }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}

    \KeywordTok{public} \FunctionTok{WorkViewModel}\OperatorTok{()}
    \OperatorTok{\{}
\NormalTok{        StartCommand }\OperatorTok{=} \KeywordTok{new} \FunctionTok{RelayCommand}\OperatorTok{(}\NormalTok{async \_ }\OperatorTok{=\textgreater{}}\NormalTok{ await }\FunctionTok{StartAsync}\OperatorTok{(),}\NormalTok{ \_ }\OperatorTok{=\textgreater{}} \OperatorTok{!}\NormalTok{IsBusy}\OperatorTok{);}
\NormalTok{        CancelCommand }\OperatorTok{=} \KeywordTok{new} \FunctionTok{RelayCommand}\OperatorTok{(}\NormalTok{\_ }\OperatorTok{=\textgreater{}}\NormalTok{ \_cts}\OperatorTok{?.}\FunctionTok{Cancel}\OperatorTok{(),}\NormalTok{ \_ }\OperatorTok{=\textgreater{}}\NormalTok{ IsBusy}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{private}\NormalTok{ async Task }\FunctionTok{StartAsync}\OperatorTok{()}
    \OperatorTok{\{}
\NormalTok{        IsBusy }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
\NormalTok{        \_cts }\OperatorTok{=} \KeywordTok{new} \FunctionTok{CancellationTokenSource}\OperatorTok{();}
        \DataTypeTok{var}\NormalTok{ progress }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Progress}\OperatorTok{\textless{}}\DataTypeTok{double}\OperatorTok{\textgreater{}(}\NormalTok{value }\OperatorTok{=\textgreater{}}\NormalTok{ Progress }\OperatorTok{=}\NormalTok{ value }\OperatorTok{*} \DecValTok{100}\OperatorTok{);}

        \KeywordTok{try}
        \OperatorTok{\{}
\NormalTok{            Status }\OperatorTok{=} \StringTok{"Processing..."}\OperatorTok{;}
\NormalTok{            await }\FunctionTok{FakeWorkAsync}\OperatorTok{(}\NormalTok{progress}\OperatorTok{,}\NormalTok{ \_cts}\OperatorTok{.}\FunctionTok{Token}\OperatorTok{);}
\NormalTok{            Status }\OperatorTok{=} \StringTok{"Completed"}\OperatorTok{;}
        \OperatorTok{\}}
        \KeywordTok{catch} \OperatorTok{(}\NormalTok{OperationCanceledException}\OperatorTok{)}
        \OperatorTok{\{}
\NormalTok{            Status }\OperatorTok{=} \StringTok{"Canceled"}\OperatorTok{;}
        \OperatorTok{\}}
        \KeywordTok{catch} \OperatorTok{(}\NormalTok{Exception ex}\OperatorTok{)}
        \OperatorTok{\{}
\NormalTok{            Status }\OperatorTok{=}\NormalTok{ $}\StringTok{"Error: \{ex.Message\}"}\OperatorTok{;}
        \OperatorTok{\}}
        \KeywordTok{finally}
        \OperatorTok{\{}
\NormalTok{            IsBusy }\OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
\NormalTok{            \_cts }\OperatorTok{=} \KeywordTok{null}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \KeywordTok{private} \KeywordTok{static}\NormalTok{ async Task }\FunctionTok{FakeWorkAsync}\OperatorTok{(}\NormalTok{IProgress}\OperatorTok{\textless{}}\DataTypeTok{double}\OperatorTok{\textgreater{}}\NormalTok{ progress}\OperatorTok{,}\NormalTok{ CancellationToken ct}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{const} \DataTypeTok{int}\NormalTok{ total }\OperatorTok{=} \DecValTok{1000}\OperatorTok{;}
\NormalTok{        await Task}\OperatorTok{.}\FunctionTok{Run}\OperatorTok{(}\FunctionTok{async} \OperatorTok{()} \OperatorTok{=\textgreater{}}
        \OperatorTok{\{}
            \KeywordTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ total}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
            \OperatorTok{\{}
\NormalTok{                ct}\OperatorTok{.}\FunctionTok{ThrowIfCancellationRequested}\OperatorTok{();}
\NormalTok{                await Task}\OperatorTok{.}\FunctionTok{Delay}\OperatorTok{(}\DecValTok{2}\OperatorTok{,}\NormalTok{ ct}\OperatorTok{).}\FunctionTok{ConfigureAwait}\OperatorTok{(}\KeywordTok{false}\OperatorTok{);}
\NormalTok{                progress}\OperatorTok{.}\FunctionTok{Report}\OperatorTok{((}\NormalTok{i }\OperatorTok{+} \DecValTok{1}\OperatorTok{)} \OperatorTok{/} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\NormalTok{total}\OperatorTok{);}
            \OperatorTok{\}}
        \OperatorTok{\},}\NormalTok{ ct}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{Task.Run} offloads CPU work to the thread pool;
\texttt{ConfigureAwait(false)} keeps the inner loop on the background
thread. \texttt{Progress\textless{}T\textgreater{}} marshals results
back to UI thread automatically.

\subsection{3. UI binding (XAML)}\label{ui-binding-xaml}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{StackPanel}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ProgressBar}\OtherTok{ Minimum=}\StringTok{"0"}\OtherTok{ Maximum=}\StringTok{"100"}\OtherTok{ Value=}\StringTok{"\{Binding Progress\}"}\OtherTok{ IsIndeterminate=}\StringTok{"\{Binding IsBusy\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Status\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Start"}\OtherTok{ Command=}\StringTok{"\{Binding StartCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Cancel"}\OtherTok{ Command=}\StringTok{"\{Binding CancelCommand\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsection{4. HTTP networking patterns}\label{http-networking-patterns}

\subsubsection{4.1 HttpClient lifetime}\label{httpclient-lifetime}

Reuse HttpClient (per host/service) to avoid socket exhaustion. Inject
or hold static instance.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ ApiClient}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ HttpClient Instance }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\NormalTok{ HttpClient}
    \OperatorTok{\{}
\NormalTok{        Timeout }\OperatorTok{=}\NormalTok{ TimeSpan}\OperatorTok{.}\FunctionTok{FromSeconds}\OperatorTok{(}\DecValTok{30}\OperatorTok{)}
    \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{4.2 GET + JSON}\label{get-json}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public}\NormalTok{ async Task}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{?\textgreater{}}\NormalTok{ GetJsonAsync}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{\textgreater{}(}\DataTypeTok{string}\NormalTok{ url}\OperatorTok{,}\NormalTok{ CancellationToken ct}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{using} \DataTypeTok{var}\NormalTok{ resp }\OperatorTok{=}\NormalTok{ await ApiClient}\OperatorTok{.}\FunctionTok{Instance}\OperatorTok{.}\FunctionTok{GetAsync}\OperatorTok{(}\NormalTok{url}\OperatorTok{,}\NormalTok{ HttpCompletionOption}\OperatorTok{.}\FunctionTok{ResponseHeadersRead}\OperatorTok{,}\NormalTok{ ct}\OperatorTok{);}
\NormalTok{    resp}\OperatorTok{.}\FunctionTok{EnsureSuccessStatusCode}\OperatorTok{();}
\NormalTok{    await }\KeywordTok{using} \DataTypeTok{var}\NormalTok{ stream }\OperatorTok{=}\NormalTok{ await resp}\OperatorTok{.}\FunctionTok{Content}\OperatorTok{.}\FunctionTok{ReadAsStreamAsync}\OperatorTok{(}\NormalTok{ct}\OperatorTok{);}
    \KeywordTok{return}\NormalTok{ await JsonSerializer}\OperatorTok{.}\FunctionTok{DeserializeAsync}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{\textgreater{}(}\NormalTok{stream}\OperatorTok{,}\NormalTok{ cancellationToken}\OperatorTok{:}\NormalTok{ ct}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{4.3 POST JSON with retry}\label{post-json-with-retry}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public}\NormalTok{ async Task PostWithRetryAsync}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{\textgreater{}(}\DataTypeTok{string}\NormalTok{ url}\OperatorTok{,}\NormalTok{ T payload}\OperatorTok{,}\NormalTok{ CancellationToken ct}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ policy }\OperatorTok{=}\NormalTok{ Policy}
        \OperatorTok{.}\FunctionTok{Handle}\OperatorTok{\textless{}}\NormalTok{HttpRequestException}\OperatorTok{\textgreater{}()}
        \OperatorTok{.}\FunctionTok{Or}\OperatorTok{\textless{}}\NormalTok{TaskCanceledException}\OperatorTok{\textgreater{}()}
        \OperatorTok{.}\FunctionTok{WaitAndRetryAsync}\OperatorTok{(}\DecValTok{3}\OperatorTok{,}\NormalTok{ attempt }\OperatorTok{=\textgreater{}}\NormalTok{ TimeSpan}\OperatorTok{.}\FunctionTok{FromSeconds}\OperatorTok{(}\NormalTok{Math}\OperatorTok{.}\FunctionTok{Pow}\OperatorTok{(}\DecValTok{2}\OperatorTok{,}\NormalTok{ attempt}\OperatorTok{)));} \CommentTok{// exponential backoff}

\NormalTok{    await policy}\OperatorTok{.}\FunctionTok{ExecuteAsync}\OperatorTok{(}\NormalTok{async token }\OperatorTok{=\textgreater{}}
    \OperatorTok{\{}
        \KeywordTok{using} \DataTypeTok{var}\NormalTok{ response }\OperatorTok{=}\NormalTok{ await ApiClient}\OperatorTok{.}\FunctionTok{Instance}\OperatorTok{.}\FunctionTok{PostAsJsonAsync}\OperatorTok{(}\NormalTok{url}\OperatorTok{,}\NormalTok{ payload}\OperatorTok{,}\NormalTok{ token}\OperatorTok{);}
\NormalTok{        response}\OperatorTok{.}\FunctionTok{EnsureSuccessStatusCode}\OperatorTok{();}
    \OperatorTok{\},}\NormalTok{ ct}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Use \texttt{Polly} or custom retry logic. Timeouts and cancellation
tokens help stop hanging requests.

\subsubsection{4.4 Download with progress}\label{download-with-progress}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public}\NormalTok{ async Task }\FunctionTok{DownloadAsync}\OperatorTok{(}\NormalTok{Uri uri}\OperatorTok{,}\NormalTok{ IStorageFile destination}\OperatorTok{,}\NormalTok{ IProgress}\OperatorTok{\textless{}}\DataTypeTok{double}\OperatorTok{\textgreater{}}\NormalTok{ progress}\OperatorTok{,}\NormalTok{ CancellationToken ct}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{using} \DataTypeTok{var}\NormalTok{ response }\OperatorTok{=}\NormalTok{ await ApiClient}\OperatorTok{.}\FunctionTok{Instance}\OperatorTok{.}\FunctionTok{GetAsync}\OperatorTok{(}\NormalTok{uri}\OperatorTok{,}\NormalTok{ HttpCompletionOption}\OperatorTok{.}\FunctionTok{ResponseHeadersRead}\OperatorTok{,}\NormalTok{ ct}\OperatorTok{);}
\NormalTok{    response}\OperatorTok{.}\FunctionTok{EnsureSuccessStatusCode}\OperatorTok{();}

    \DataTypeTok{var}\NormalTok{ contentLength }\OperatorTok{=}\NormalTok{ response}\OperatorTok{.}\FunctionTok{Content}\OperatorTok{.}\FunctionTok{Headers}\OperatorTok{.}\FunctionTok{ContentLength}\OperatorTok{;}
\NormalTok{    await }\KeywordTok{using} \DataTypeTok{var}\NormalTok{ httpStream }\OperatorTok{=}\NormalTok{ await response}\OperatorTok{.}\FunctionTok{Content}\OperatorTok{.}\FunctionTok{ReadAsStreamAsync}\OperatorTok{(}\NormalTok{ct}\OperatorTok{);}
\NormalTok{    await }\KeywordTok{using} \DataTypeTok{var}\NormalTok{ fileStream }\OperatorTok{=}\NormalTok{ await destination}\OperatorTok{.}\FunctionTok{OpenWriteAsync}\OperatorTok{();}

    \DataTypeTok{var}\NormalTok{ buffer }\OperatorTok{=} \KeywordTok{new} \DataTypeTok{byte}\OperatorTok{[}\DecValTok{81920}\OperatorTok{];}
    \DataTypeTok{long}\NormalTok{ totalRead }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \DataTypeTok{int}\NormalTok{ read}\OperatorTok{;}
    \KeywordTok{while} \OperatorTok{((}\NormalTok{read }\OperatorTok{=}\NormalTok{ await httpStream}\OperatorTok{.}\FunctionTok{ReadAsync}\OperatorTok{(}\NormalTok{buffer}\OperatorTok{.}\FunctionTok{AsMemory}\OperatorTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ buffer}\OperatorTok{.}\FunctionTok{Length}\OperatorTok{),}\NormalTok{ ct}\OperatorTok{))} \OperatorTok{\textgreater{}} \DecValTok{0}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        await fileStream}\OperatorTok{.}\FunctionTok{WriteAsync}\OperatorTok{(}\NormalTok{buffer}\OperatorTok{.}\FunctionTok{AsMemory}\OperatorTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ read}\OperatorTok{),}\NormalTok{ ct}\OperatorTok{);}
\NormalTok{        totalRead }\OperatorTok{+=}\NormalTok{ read}\OperatorTok{;}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{contentLength}\OperatorTok{.}\FunctionTok{HasValue}\OperatorTok{)}
\NormalTok{            progress}\OperatorTok{.}\FunctionTok{Report}\OperatorTok{(}\NormalTok{totalRead }\OperatorTok{/} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)}\NormalTok{contentLength}\OperatorTok{.}\FunctionTok{Value}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{5. Connectivity awareness}\label{connectivity-awareness}

Avalonia doesn't ship built-in connectivity events; rely on platform
APIs or ping endpoints.

\begin{itemize}
\tightlist
\item
  Desktop: use \texttt{System.Net.NetworkInformation.NetworkChange}
  events.
\item
  Mobile: Xamarin/MAUI style libraries or platform-specific checks.
\item
  Browser: \texttt{navigator.onLine} via JS interop.
\end{itemize}

Expose a service to signal connectivity changes to view models; keep
offline caching in mind.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{interface}\NormalTok{ INetworkStatusService}
\OperatorTok{\{}
\NormalTok{    IObservable}\OperatorTok{\textless{}}\DataTypeTok{bool}\OperatorTok{\textgreater{}}\NormalTok{ ConnectivityChanges }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ NetworkStatusService }\OperatorTok{:}\NormalTok{ INetworkStatusService}
\OperatorTok{\{}
    \KeywordTok{public}\NormalTok{ IObservable}\OperatorTok{\textless{}}\DataTypeTok{bool}\OperatorTok{\textgreater{}}\NormalTok{ ConnectivityChanges }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}}

    \KeywordTok{public} \FunctionTok{NetworkStatusService}\OperatorTok{()}
    \OperatorTok{\{}
\NormalTok{        ConnectivityChanges }\OperatorTok{=}\NormalTok{ Observable}
            \OperatorTok{.}\FunctionTok{FromEventPattern}\OperatorTok{\textless{}}\NormalTok{NetworkAvailabilityChangedEventHandler}\OperatorTok{,}\NormalTok{ NetworkAvailabilityEventArgs}\OperatorTok{\textgreater{}(}
\NormalTok{                handler }\OperatorTok{=\textgreater{}}\NormalTok{ NetworkChange}\OperatorTok{.}\FunctionTok{NetworkAvailabilityChanged} \OperatorTok{+=}\NormalTok{ handler}\OperatorTok{,}
\NormalTok{                handler }\OperatorTok{=\textgreater{}}\NormalTok{ NetworkChange}\OperatorTok{.}\FunctionTok{NetworkAvailabilityChanged} \OperatorTok{{-}=}\NormalTok{ handler}\OperatorTok{)}
            \OperatorTok{.}\FunctionTok{Select}\OperatorTok{(}\NormalTok{args }\OperatorTok{=\textgreater{}}\NormalTok{ args}\OperatorTok{.}\FunctionTok{EventArgs}\OperatorTok{.}\FunctionTok{IsAvailable}\OperatorTok{)}
            \OperatorTok{.}\FunctionTok{StartWith}\OperatorTok{(}\NormalTok{NetworkInterface}\OperatorTok{.}\FunctionTok{GetIsNetworkAvailable}\OperatorTok{());}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Register different implementations per target in DI (\texttt{\#if} or
platform-specific partial classes). On mobile, back the observable with
platform connectivity APIs; on WebAssembly, bridge to
\texttt{navigator.onLine} via JS interop. View models can subscribe once
and stay platform-agnostic.

\subsection{6. Background services \& scheduled
work}\label{background-services-scheduled-work}

For periodic tasks, use \texttt{DispatcherTimer} on UI thread or
\texttt{Task.Run} loops with delays.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ timer }\OperatorTok{=} \KeywordTok{new} \FunctionTok{DispatcherTimer}\OperatorTok{(}\NormalTok{TimeSpan}\OperatorTok{.}\FunctionTok{FromMinutes}\OperatorTok{(}\DecValTok{5}\OperatorTok{),}\NormalTok{ DispatcherPriority}\OperatorTok{.}\FunctionTok{Background}\OperatorTok{,} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ RefreshCommand}\OperatorTok{.}\FunctionTok{Execute}\OperatorTok{(}\KeywordTok{null}\OperatorTok{));}
\NormalTok{timer}\OperatorTok{.}\FunctionTok{Start}\OperatorTok{();}
\end{Highlighting}
\end{Shaded}

Long-running background work should check \texttt{CancellationToken}
frequently, especially when app might suspend (mobile).

\subsubsection{6.1 Orchestrating services across
targets}\label{orchestrating-services-across-targets}

For cross-platform apps, wrap periodic or startup work in services that
plug into each lifetime. Example using \texttt{IHostedService}
semantics:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{interface}\NormalTok{ IBackgroundTask}
\OperatorTok{\{}
\NormalTok{    Task }\FunctionTok{StartAsync}\OperatorTok{(}\NormalTok{CancellationToken token}\OperatorTok{);}
\NormalTok{    Task }\FunctionTok{StopAsync}\OperatorTok{(}\NormalTok{CancellationToken token}\OperatorTok{);}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ SyncBackgroundTask }\OperatorTok{:}\NormalTok{ IBackgroundTask}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ IDataSync \_sync}\OperatorTok{;}
    \KeywordTok{public} \FunctionTok{SyncBackgroundTask}\OperatorTok{(}\NormalTok{IDataSync sync}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_sync }\OperatorTok{=}\NormalTok{ sync}\OperatorTok{;}

    \KeywordTok{public}\NormalTok{ Task }\FunctionTok{StartAsync}\OperatorTok{(}\NormalTok{CancellationToken token}\OperatorTok{)}
        \OperatorTok{=\textgreater{}}\NormalTok{ Task}\OperatorTok{.}\FunctionTok{Run}\OperatorTok{(()} \OperatorTok{=\textgreater{}}\NormalTok{ \_sync}\OperatorTok{.}\FunctionTok{RunLoopAsync}\OperatorTok{(}\NormalTok{token}\OperatorTok{),}\NormalTok{ token}\OperatorTok{);}

    \KeywordTok{public}\NormalTok{ Task }\FunctionTok{StopAsync}\OperatorTok{(}\NormalTok{CancellationToken token}\OperatorTok{)}
        \OperatorTok{=\textgreater{}}\NormalTok{ \_sync}\OperatorTok{.}\FunctionTok{StopAsync}\OperatorTok{(}\NormalTok{token}\OperatorTok{);}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ BackgroundTaskExtensions}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static} \DataTypeTok{void} \FunctionTok{Attach}\OperatorTok{(}\KeywordTok{this}\NormalTok{ IBackgroundTask task}\OperatorTok{,}\NormalTok{ IApplicationLifetime lifetime}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{switch} \OperatorTok{(}\NormalTok{lifetime}\OperatorTok{)}
        \OperatorTok{\{}
            \KeywordTok{case}\NormalTok{ IClassicDesktopStyleApplicationLifetime desktop}\OperatorTok{:}
\NormalTok{                desktop}\OperatorTok{.}\FunctionTok{Startup} \OperatorTok{+=} \FunctionTok{async} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ await task}\OperatorTok{.}\FunctionTok{StartAsync}\OperatorTok{(}\NormalTok{CancellationToken}\OperatorTok{.}\FunctionTok{None}\OperatorTok{);}
\NormalTok{                desktop}\OperatorTok{.}\FunctionTok{Exit} \OperatorTok{+=} \FunctionTok{async} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ await task}\OperatorTok{.}\FunctionTok{StopAsync}\OperatorTok{(}\NormalTok{CancellationToken}\OperatorTok{.}\FunctionTok{None}\OperatorTok{);}
                \KeywordTok{break}\OperatorTok{;}
            \KeywordTok{case}\NormalTok{ ISingleViewApplicationLifetime singleView when singleView}\OperatorTok{.}\FunctionTok{MainView} \KeywordTok{is} \OperatorTok{\{} \OperatorTok{\}}\NormalTok{ view}\OperatorTok{:}
\NormalTok{                view}\OperatorTok{.}\FunctionTok{AttachedToVisualTree} \OperatorTok{+=} \FunctionTok{async} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ await task}\OperatorTok{.}\FunctionTok{StartAsync}\OperatorTok{(}\NormalTok{CancellationToken}\OperatorTok{.}\FunctionTok{None}\OperatorTok{);}
\NormalTok{                view}\OperatorTok{.}\FunctionTok{DetachedFromVisualTree} \OperatorTok{+=} \FunctionTok{async} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ await task}\OperatorTok{.}\FunctionTok{StopAsync}\OperatorTok{(}\NormalTok{CancellationToken}\OperatorTok{.}\FunctionTok{None}\OperatorTok{);}
                \KeywordTok{break}\OperatorTok{;}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Desktop lifetimes expose \texttt{Startup}/\texttt{Exit};
single-view/mobile lifetimes expose
\texttt{FrameworkInitializationCompleted}/\texttt{OnStopped}. Provide
adapters per lifetime so the task implementation stays portable, and
inject platform helpers (connectivity, storage) through interfaces.

\subsection{7. Reactive event streams}\label{reactive-event-streams}

\texttt{Observable.FromEventPattern} converts callbacks into composable
streams. Combine it with \texttt{DispatcherScheduler.Current} (from
System.Reactive) so observations switch back to the UI thread.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ pointerStream }\OperatorTok{=}\NormalTok{ Observable}
    \OperatorTok{.}\FunctionTok{FromEventPattern}\OperatorTok{\textless{}}\NormalTok{PointerEventArgs}\OperatorTok{\textgreater{}(}\NormalTok{handler }\OperatorTok{=\textgreater{}}\NormalTok{ control}\OperatorTok{.}\FunctionTok{PointerMoved} \OperatorTok{+=}\NormalTok{ handler}\OperatorTok{,}
\NormalTok{                                       handler }\OperatorTok{=\textgreater{}}\NormalTok{ control}\OperatorTok{.}\FunctionTok{PointerMoved} \OperatorTok{{-}=}\NormalTok{ handler}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{Select}\OperatorTok{(}\NormalTok{args }\OperatorTok{=\textgreater{}}\NormalTok{ args}\OperatorTok{.}\FunctionTok{EventArgs}\OperatorTok{.}\FunctionTok{GetPosition}\OperatorTok{(}\NormalTok{control}\OperatorTok{))}
    \OperatorTok{.}\FunctionTok{Throttle}\OperatorTok{(}\NormalTok{TimeSpan}\OperatorTok{.}\FunctionTok{FromMilliseconds}\OperatorTok{(}\DecValTok{50}\OperatorTok{))}
    \OperatorTok{.}\FunctionTok{ObserveOn}\OperatorTok{(}\NormalTok{DispatcherScheduler}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{point }\OperatorTok{=\textgreater{}}\NormalTok{ PointerPosition }\OperatorTok{=}\NormalTok{ point}\OperatorTok{);}

\NormalTok{Disposables}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{pointerStream}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This pattern keeps heavy processing (\texttt{Throttle}, network calls)
off the UI thread while delivering results back in order. For view
models, expose \texttt{IObservable\textless{}T\textgreater{}} properties
and let the view subscribe using \texttt{ReactiveUI.WhenAnyValue} or
manual subscriptions. \texttt{Disposables} here is a
\texttt{CompositeDisposable} that you dispose when the view/control
unloads.

\subsection{8. Testing background code}\label{testing-background-code}

Use \texttt{Task.Delay} injection or \texttt{ITestScheduler}
(ReactiveUI) to control time. For plain async code, wrap delays in an
interface to mock in tests.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{interface}\NormalTok{ IDelayProvider}
\OperatorTok{\{}
\NormalTok{    Task }\FunctionTok{Delay}\OperatorTok{(}\NormalTok{TimeSpan time}\OperatorTok{,}\NormalTok{ CancellationToken ct}\OperatorTok{);}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ DelayProvider }\OperatorTok{:}\NormalTok{ IDelayProvider}
\OperatorTok{\{}
    \KeywordTok{public}\NormalTok{ Task }\FunctionTok{Delay}\OperatorTok{(}\NormalTok{TimeSpan time}\OperatorTok{,}\NormalTok{ CancellationToken ct}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ Task}\OperatorTok{.}\FunctionTok{Delay}\OperatorTok{(}\NormalTok{time}\OperatorTok{,}\NormalTok{ ct}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Inject and replace with deterministic delays in tests.

\subsection{9. Browser (WebAssembly)
considerations}\label{browser-webassembly-considerations-1}

\begin{itemize}
\tightlist
\item
  HttpClient uses fetch; CORS applies.
\item
  WebSockets available via \texttt{ClientWebSocket} when allowed by
  browser.
\item
  Long-running loops should yield frequently
  (\texttt{await\ Task.Yield()}) to avoid blocking JS event loop.
\end{itemize}

\subsection{10. Practice exercises}\label{practice-exercises-11}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Build a data sync command that fetches JSON from an API, parses it,
  and updates view models without freezing UI.
\item
  Add cancellation and progress reporting to a file import feature
  (Chapter 16) using \texttt{IProgress\textless{}double\textgreater{}}.
\item
  Implement retry with exponential backoff around a flaky endpoint and
  show status messages when retries occur.
\item
  Detect connectivity loss and display an offline banner; queue commands
  to run when back online.
\item
  Transform pointer move events into an \texttt{Observable} pipeline
  with throttling and verify updates stay on the UI thread.
\item
  Write a unit test that confirms cancellation stops a long-running
  operation before completion.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-15}

\begin{itemize}
\tightlist
\item
  Dispatcher \& UI thread:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Threading/Dispatcher.cs}{\texttt{Dispatcher.cs}}
\item
  Priorities \& timers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Threading/DispatcherPriority.cs}{\texttt{DispatcherPriority.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Threading/DispatcherTimer.cs}{\texttt{DispatcherTimer.cs}}
\item
  Lifetimes:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs}{\texttt{IClassicDesktopStyleApplicationLifetime}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ISingleViewApplicationLifetime.cs}{\texttt{ISingleViewApplicationLifetime}}
\item
  Progress reporting:
  \href{https://learn.microsoft.com/dotnet/api/system.progress-1}{\texttt{Progress\textless{}T\textgreater{}}}
\item
  HttpClient guidance:
  \href{https://learn.microsoft.com/dotnet/fundamentals/networking/http/httpclient}{.NET
  HttpClient docs}
\item
  Cancellation tokens:
  \href{https://learn.microsoft.com/dotnet/standard/threading/cancellation-in-managed-threads}{.NET
  cancellation docs}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-15}

\begin{itemize}
\tightlist
\item
  Why does blocking the UI thread freeze the app? How do you keep it
  responsive?
\item
  How do you propagate cancellation through nested async calls?
\item
  Which HttpClient features help prevent hung requests?
\item
  How can you provide progress updates without touching
  \texttt{Dispatcher.UIThread} manually?
\item
  What adjustments are needed when running the same code on the browser?
\end{itemize}

What's next - Next: \href{Chapter18.md}{Chapter 18}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part IV — Cross‑platform deployment without headaches}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part IV — Cross‑platform deployment without headaches}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{18. Desktop targets: Windows, macOS,
Linux}\label{desktop-targets-windows-macos-linux}

Goal - Master Avalonia's desktop-specific features: window chrome,
transparency, DPI/multi-monitor handling, platform capabilities, and
packaging essentials. - Understand per-platform caveats so your desktop
app feels native on Windows, macOS, and Linux.

Why this matters - Desktop users expect native window behavior, correct
scaling, and integration with OS features (taskbar/dock, notifications).
- Avalonia abstracts the basics but you still need to apply
platform-specific tweaks.

Prerequisites - Chapter 4 (lifetimes), Chapter 12 (window navigation),
Chapter 13 (menus/dialogs), Chapter 16 (storage).

\subsection{1. Desktop backends at a
glance}\label{desktop-backends-at-a-glance}

Avalonia ships multiple desktop backends;
\texttt{AppBuilder.UsePlatformDetect()} selects the correct platform at
runtime. Understanding the differences helps when you tweak options or
debug native interop.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Platform
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Backend type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Namespace
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Notes
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Windows & \texttt{Win32Platform} & \texttt{Avalonia.Win32} & Win32
windowing with optional WinUI composition, ANGLE/OpenGL bridges, tray
icon helpers. \\
Windows/macOS & \texttt{AvaloniaNativePlatform} &
\texttt{Avalonia.Native} & Shared native host (AppKit on macOS). Used
for windowless scenarios and for macOS desktop builds. \\
Linux (X11) & \texttt{X11Platform} & \texttt{Avalonia.X11} & Traditional
X11 windowing; integrates with FreeDesktop protocols. \\
Linux portals & \texttt{FreeDesktopPlatform} &
\texttt{Avalonia.FreeDesktop} & Supplements X11/Wayland with portal
services (dialogs, notifications). \\
\end{longtable}

Startup options customize each backend:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{With}\OperatorTok{(}\KeywordTok{new}\NormalTok{ Win32PlatformOptions}
    \OperatorTok{\{}
\NormalTok{        RenderingMode }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{}\NormalTok{ Win32RenderingMode}\OperatorTok{.}\FunctionTok{AngleEgl}\OperatorTok{,}\NormalTok{ Win32RenderingMode}\OperatorTok{.}\FunctionTok{Software} \OperatorTok{\},}
\NormalTok{        CompositionMode }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{}\NormalTok{ Win32CompositionMode}\OperatorTok{.}\FunctionTok{WinUIComposition}\OperatorTok{,}\NormalTok{ Win32CompositionMode}\OperatorTok{.}\FunctionTok{RedirectionSurface} \OperatorTok{\},}
\NormalTok{        OverlayPopups }\OperatorTok{=} \KeywordTok{true}
    \OperatorTok{\})}
    \OperatorTok{.}\FunctionTok{With}\OperatorTok{(}\KeywordTok{new}\NormalTok{ MacOSPlatformOptions}
    \OperatorTok{\{}
\NormalTok{        DisableDefaultApplicationMenuItems }\OperatorTok{=} \KeywordTok{false}\OperatorTok{,}
\NormalTok{        ShowInDock }\OperatorTok{=} \KeywordTok{true}
    \OperatorTok{\})}
    \OperatorTok{.}\FunctionTok{With}\OperatorTok{(}\KeywordTok{new}\NormalTok{ X11PlatformOptions}
    \OperatorTok{\{}
\NormalTok{        RenderingMode }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{}\NormalTok{ X11RenderingMode}\OperatorTok{.}\FunctionTok{Glx}\OperatorTok{,}\NormalTok{ X11RenderingMode}\OperatorTok{.}\FunctionTok{Software} \OperatorTok{\},}
\NormalTok{        UseDBusMenu }\OperatorTok{=} \KeywordTok{true}\OperatorTok{,}
\NormalTok{        WmClass }\OperatorTok{=} \StringTok{"MyAvaloniaApp"}
    \OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

These options map to platform implementations in
\texttt{Avalonia.Win32}, \texttt{Avalonia.Native}, and
\texttt{Avalonia.X11}. Tune them when enabling extended client area,
portals, or GPU interop.

\subsection{2. Window fundamentals}\label{window-fundamentals}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{        x:Class=}\StringTok{"MyApp.MainWindow"}
\OtherTok{        Width=}\StringTok{"1024"}\OtherTok{ Height=}\StringTok{"720"}
\OtherTok{        CanResize=}\StringTok{"True"}
\OtherTok{        SizeToContent=}\StringTok{"Manual"}
\OtherTok{        WindowStartupLocation=}\StringTok{"CenterScreen"}
\OtherTok{        ShowInTaskbar=}\StringTok{"True"}
\OtherTok{        Topmost=}\StringTok{"False"}
\OtherTok{        Title=}\StringTok{"My App"}\NormalTok{\textgreater{}}

\NormalTok{\textless{}/}\KeywordTok{Window}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Properties: - \texttt{WindowState}: Normal, Minimized, Maximized,
FullScreen. - \texttt{CanResize}, \texttt{CanMinimize},
\texttt{CanMaximize} control system caption buttons. -
\texttt{SizeToContent}: \texttt{Manual}, \texttt{Width},
\texttt{Height}, \texttt{WidthAndHeight} (works best before window is
shown). - \texttt{WindowStartupLocation}: \texttt{Manual} (default),
\texttt{CenterScreen}, \texttt{CenterOwner}. - \texttt{ShowInTaskbar}:
show/hide taskbar/dock icon. - \texttt{Topmost}: keep above other
windows.

Persist position/size between runs:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnOpened}\OperatorTok{(}\NormalTok{EventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnOpened}\OperatorTok{(}\NormalTok{e}\OperatorTok{);}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{LocalSettings}\OperatorTok{.}\FunctionTok{TryReadWindowPlacement}\OperatorTok{(}\KeywordTok{out} \DataTypeTok{var}\NormalTok{ placement}\OperatorTok{))}
    \OperatorTok{\{}
\NormalTok{        Position }\OperatorTok{=}\NormalTok{ placement}\OperatorTok{.}\FunctionTok{Position}\OperatorTok{;}
\NormalTok{        Width }\OperatorTok{=}\NormalTok{ placement}\OperatorTok{.}\FunctionTok{Width}\OperatorTok{;}
\NormalTok{        Height }\OperatorTok{=}\NormalTok{ placement}\OperatorTok{.}\FunctionTok{Height}\OperatorTok{;}
\NormalTok{        WindowState }\OperatorTok{=}\NormalTok{ placement}\OperatorTok{.}\FunctionTok{State}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnClosing}\OperatorTok{(}\NormalTok{WindowClosingEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnClosing}\OperatorTok{(}\NormalTok{e}\OperatorTok{);}
\NormalTok{    LocalSettings}\OperatorTok{.}\FunctionTok{WriteWindowPlacement}\OperatorTok{(}\KeywordTok{new}\NormalTok{ WindowPlacement}
    \OperatorTok{\{}
\NormalTok{        Position }\OperatorTok{=}\NormalTok{ Position}\OperatorTok{,}
\NormalTok{        Width }\OperatorTok{=}\NormalTok{ Width}\OperatorTok{,}
\NormalTok{        Height }\OperatorTok{=}\NormalTok{ Height}\OperatorTok{,}
\NormalTok{        State }\OperatorTok{=}\NormalTok{ WindowState}
    \OperatorTok{\});}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{3. Custom title bars and
chrome}\label{custom-title-bars-and-chrome}

\texttt{SystemDecorations="None"} removes native chrome; use
extend-client-area hints for custom title bars.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window}\OtherTok{ SystemDecorations=}\StringTok{"None"}
\OtherTok{        ExtendClientAreaToDecorationsHint=}\StringTok{"True"}
\OtherTok{        ExtendClientAreaChromeHints=}\StringTok{"PreferSystemChrome"}
\OtherTok{        ExtendClientAreaTitleBarHeightHint=}\StringTok{"32"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Border}\OtherTok{ Background=}\StringTok{"\#1F2937"}\OtherTok{ Height=}\StringTok{"32"}\OtherTok{ VerticalAlignment=}\StringTok{"Top"}
\OtherTok{            PointerPressed=}\StringTok{"TitleBar\_PointerPressed"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Margin=}\StringTok{"12,0"}\OtherTok{ VerticalAlignment=}\StringTok{"Center"}\OtherTok{ Spacing=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"My App"}\OtherTok{ Foreground=}\StringTok{"White"}\NormalTok{/\textgreater{}}

\NormalTok{        \textless{}}\KeywordTok{Border}\OtherTok{ x:Name=}\StringTok{"CloseButton"}\OtherTok{ Width=}\StringTok{"32"}\OtherTok{ Height=}\StringTok{"24"}\OtherTok{ Background=}\StringTok{"Transparent"}
\OtherTok{                PointerPressed=}\StringTok{"CloseButton\_PointerPressed"}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{Path}\OtherTok{ Stroke=}\StringTok{"White"}\OtherTok{ StrokeThickness=}\StringTok{"2"}\OtherTok{ Data=}\StringTok{"M2,2 L10,10 M10,2 L2,10"}\OtherTok{ HorizontalAlignment=}\StringTok{"Center"}\OtherTok{ VerticalAlignment=}\StringTok{"Center"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Window}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private} \DataTypeTok{void} \FunctionTok{TitleBar\_PointerPressed}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ PointerPressedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{GetCurrentPoint}\OperatorTok{(}\KeywordTok{this}\OperatorTok{).}\FunctionTok{Properties}\OperatorTok{.}\FunctionTok{IsLeftButtonPressed}\OperatorTok{)}
        \FunctionTok{BeginMoveDrag}\OperatorTok{(}\NormalTok{e}\OperatorTok{);}
\OperatorTok{\}}

\KeywordTok{private} \DataTypeTok{void} \FunctionTok{CloseButton\_PointerPressed}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ PointerPressedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \FunctionTok{Close}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Provide hover/pressed styles for buttons.
\item
  Add keyboard/screen reader support (AutomationProperties).
\end{itemize}

\subsection{4. Window transparency \&
effects}\label{window-transparency-effects}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window}\OtherTok{ TransparencyLevelHint=}\StringTok{"Mica, AcrylicBlur, Blur, Transparent"}\NormalTok{\textgreater{}}

\NormalTok{\textless{}/}\KeywordTok{Window}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{TransparencyLevelHint }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]}
\OperatorTok{\{}
\NormalTok{    WindowTransparencyLevel}\OperatorTok{.}\FunctionTok{Mica}\OperatorTok{,}
\NormalTok{    WindowTransparencyLevel}\OperatorTok{.}\FunctionTok{AcrylicBlur}\OperatorTok{,}
\NormalTok{    WindowTransparencyLevel}\OperatorTok{.}\FunctionTok{Blur}\OperatorTok{,}
\NormalTok{    WindowTransparencyLevel}\OperatorTok{.}\FunctionTok{Transparent}
\OperatorTok{\};}

\KeywordTok{this}\OperatorTok{.}\FunctionTok{GetObservable}\OperatorTok{(}\NormalTok{TopLevel}\OperatorTok{.}\FunctionTok{ActualTransparencyLevelProperty}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{level }\OperatorTok{=\textgreater{}}\NormalTok{ Debug}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\NormalTok{$}\StringTok{"Transparency: \{level\}"}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Platform support summary (subject to OS version, composition mode): -
Windows 10/11: Transparent, Blur, AcrylicBlur, Mica (Win11). - macOS:
Transparent, Blur (vibrancy). - Linux (compositor dependent):
Transparent, Blur.

Design for fallback: ActualTransparencyLevel may be
\texttt{None}--ensure backgrounds look good without blur.

\subsection{5. Screens, DPI, and scaling}\label{screens-dpi-and-scaling}

\begin{itemize}
\tightlist
\item
  \texttt{Screens}: enumerate monitors (\texttt{Screens.All},
  \texttt{Screens.Primary}).
\item
  \texttt{Screen.WorkingArea}: available area excluding taskbar/dock.
\item
  \texttt{Screen.Scaling}: per-monitor scale.
\item
  \texttt{Window.DesktopScaling}: DIP to physical pixel ratio for
  positioning.
\item
  \texttt{TopLevel.RenderScaling}: DPI scaling for rendering (affects
  pixel alignment).
\end{itemize}

Center on active screen:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnOpened}\OperatorTok{(}\NormalTok{EventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnOpened}\OperatorTok{(}\NormalTok{e}\OperatorTok{);}
    \DataTypeTok{var}\NormalTok{ currentScreen }\OperatorTok{=}\NormalTok{ Screens}\OperatorTok{?.}\FunctionTok{ScreenFromWindow}\OperatorTok{(}\KeywordTok{this}\OperatorTok{)} \OperatorTok{??}\NormalTok{ Screens}\OperatorTok{?.}\FunctionTok{Primary}\OperatorTok{;}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{currentScreen }\KeywordTok{is} \KeywordTok{null}\OperatorTok{)}
        \KeywordTok{return}\OperatorTok{;}

    \DataTypeTok{var}\NormalTok{ frameSize }\OperatorTok{=}\NormalTok{ PixelSize}\OperatorTok{.}\FunctionTok{FromSize}\OperatorTok{(}\NormalTok{ClientSize}\OperatorTok{,}\NormalTok{ DesktopScaling}\OperatorTok{);}
    \DataTypeTok{var}\NormalTok{ target }\OperatorTok{=}\NormalTok{ currentScreen}\OperatorTok{.}\FunctionTok{WorkingArea}\OperatorTok{.}\FunctionTok{CenterRect}\OperatorTok{(}\NormalTok{frameSize}\OperatorTok{);}
\NormalTok{    Position }\OperatorTok{=}\NormalTok{ target}\OperatorTok{.}\FunctionTok{Position}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Handle scaling changes when moving between monitors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ScalingChanged }\OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}
\OperatorTok{\{}
    \CommentTok{// Renderer scaling updated; adjust cached bitmaps if necessary.}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

\subsection{6. Platform integration}\label{platform-integration}

\subsubsection{6.1 Windows}\label{windows-1}

\begin{itemize}
\tightlist
\item
  Taskbar/dock menus: use Jump Lists via \texttt{System.Windows.Shell}
  interop or community packages.
\item
  Notifications: \texttt{WindowNotificationManager} or Windows toast
  (via WinRT APIs).
\item
  Acrylic/Mica: require Windows 10 or 11; fallback on earlier versions.
\item
  System backdrops: set \texttt{TransparencyLevelHint} and ensure the OS
  supports it; consider theme-aware backgrounds.
\item
  \texttt{Win32PlatformOptions} exposes rendering toggles
  (\texttt{RenderingMode}, \texttt{CompositionMode},
  \texttt{OverlayPopups}). Keep \texttt{Software} in the list as a
  fallback for Remote Desktop.
\item
  Use \texttt{TryGetPlatformHandle()} to retrieve HWNDs when integrating
  with native libraries; avoid depending on internal \texttt{WindowImpl}
  types.
\end{itemize}

\subsubsection{6.2 macOS}\label{macos-1}

\begin{itemize}
\tightlist
\item
  Menu bar: use \texttt{NativeMenuBar} (Chapter 13).
\item
  Dock menu: \texttt{NativeMenuBar.Menu} can include items that appear
  in dock menu.
\item
  Application events (Quit, About): integrate with
  \texttt{AvaloniaNativeMenuCommands} or handle native application
  events.
\item
  Fullscreen: Mac expects toggle via green traffic-light button;
  \texttt{WindowState.FullScreen} works, but ensure custom chrome still
  accessible.
\item
  \texttt{MacOSPlatformOptions} lets you hide dock icons, disable the
  default menu items, or reuse an existing \texttt{NSApplication}
  delegate.
\item
  Pair \texttt{AvaloniaNativeRenderingMode} with a \texttt{UseSkia}
  configuration so you always include \texttt{Software} fallback
  alongside \texttt{Metal}/\texttt{OpenGl} for older GPUs.
\end{itemize}

\subsubsection{6.3 Linux}\label{linux}

\begin{itemize}
\tightlist
\item
  Variety of window managers; test SystemDecorations/ExtendClientArea on
  GNOME/KDE.
\item
  Transparency requires compositor (e.g., Mutter, KWin). Provide
  fallback.
\item
  Fractional scaling support varies; check \texttt{RenderScaling} for
  the active monitor.
\item
  Packaging (Flatpak, Snap, AppImage) may affect file dialog behavior
  (portal APIs).
\item
  \texttt{X11PlatformOptions} controls GLX/EGL fallbacks, DBus menus,
  and IME support; pair it with Avalonia's FreeDesktop portal helpers
  when running inside Flatpak/Snap.
\item
  Use \texttt{WmClass} (on \texttt{X11PlatformOptions}) to integrate
  with desktop launchers and icon themes.
\end{itemize}

\subsection{7. Rendering \& GPU
selection}\label{rendering-gpu-selection}

Avalonia renders through Skia; each backend exposes toggles for GPU
acceleration and composition. Tune them to balance visuals versus
compatibility.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Platform
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Rendering options
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
When to change
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Windows (\texttt{Win32PlatformOptions}) & \texttt{RenderingMode}
(\texttt{AngleEgl}, \texttt{Wgl}, \texttt{Vulkan}, \texttt{Software}),
\texttt{CompositionMode} (\texttt{WinUIComposition}, etc.),
\texttt{GraphicsAdapterSelectionCallback},
\texttt{WinUICompositionBackdropCornerRadius} & Choose ANGLE + WinUI for
blur effects, fall back to software for remote desktops, pick dedicated
GPU in multi-adapter rigs. \\
macOS (\texttt{AvaloniaNativePlatformOptions}) & \texttt{RenderingMode}
(Metal, OpenGL, Software) & Prefer Metal on modern macOS; include
Software as fallback for virtual machines. \\
Linux (\texttt{X11PlatformOptions}) & \texttt{RenderingMode}
(\texttt{Glx}, \texttt{Egl}, \texttt{Vulkan}, \texttt{Software}),
\texttt{GlxRendererBlacklist}, \texttt{UseDBusMenu},
\texttt{UseDBusFilePicker} & Disable GLX on problematic drivers, force
software when GPU drivers are unstable. \\
\end{longtable}

\texttt{UseSkia} accepts \texttt{SkiaOptions} for further tuning:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{With}\OperatorTok{(}\KeywordTok{new}\NormalTok{ SkiaOptions}
    \OperatorTok{\{}
\NormalTok{        MaxGpuResourceSizeBytes }\OperatorTok{=} \DecValTok{128} \OperatorTok{*} \DecValTok{1024} \OperatorTok{*} \DecValTok{1024}\OperatorTok{,} \CommentTok{// cap VRAM usage}
\NormalTok{        UseOpacitySaveLayer }\OperatorTok{=} \KeywordTok{true}
    \OperatorTok{\})}
    \OperatorTok{.}\FunctionTok{UseSkia}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{LogToTrace}\OperatorTok{();}
\end{Highlighting}
\end{Shaded}

Inside a window you can inspect the actual implementation for
diagnostics:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \OperatorTok{(}\FunctionTok{TryGetPlatformHandle}\OperatorTok{()} \KeywordTok{is} \OperatorTok{\{}\NormalTok{ Handle}\OperatorTok{:} \DataTypeTok{var}\NormalTok{ hwnd}\OperatorTok{,}\NormalTok{ HandleDescriptor}\OperatorTok{:} \StringTok{"HWND"} \OperatorTok{\})}
\NormalTok{    Debug}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\NormalTok{$}\StringTok{"HWND: 0x\{hwnd.ToInt64():X\}"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Log area \texttt{Avalonia.Rendering.Platform} reports which backend was
selected; capture it during startup when debugging GPU-related issues.

\subsection{8. Packaging \& deployment
overview}\label{packaging-deployment-overview}

\begin{itemize}
\tightlist
\item
  Windows: \texttt{dotnet\ publish\ -r\ win-x64\ -\/-self-contained} or
  MSIX via
  \texttt{dotnet\ publish\ /p:PublishTrimmed=false\ /p:WindowsPackageType=msix}.
  Bundle ANGLE DLLs (\texttt{libEGL.dll}, \texttt{libGLESv2.dll}) and
  \texttt{d3dcompiler\_47.dll} when using GPU composition; ship
  \texttt{vc\_redist} prerequisites for older OS versions.
\item
  macOS: \texttt{.app} bundle; codesign and notarize for distribution
  (\texttt{dotnet\ publish\ -r\ osx-x64\ -\/-self-contained} followed by
  bundle packaging via Avalonia templates or scripts). Include
  \texttt{libAvaloniaNative.dylib}, ensure \texttt{Info.plist} declares
  \texttt{NSHighResolutionCapable}, and register custom URL schemes if
  you rely on \texttt{ILauncher}.
\item
  Linux: produce .deb/.rpm, AppImage, or Flatpak; ensure dependencies
  (\texttt{libAvaloniaNative.so}, libSkia) are present. Flatpak portals
  rely on \texttt{xdg-desktop-portal}; declare it as a runtime
  dependency and verify DBus access so storage pickers keep working.
\end{itemize}

Reference docs: Avalonia publishing guide
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/docs/publish.md}{docs/publish.md}).

\subsection{9. Multiple window management
tips}\label{multiple-window-management-tips}

\begin{itemize}
\tightlist
\item
  Track open windows via \texttt{ApplicationLifetime.Windows} (desktop
  only).
\item
  Use \texttt{IClassicDesktopStyleApplicationLifetime.Exit} to exit the
  app.
\item
  Owner/child relationships ensure modality, centering, and Z-order
  (Chapter 12).
\item
  Provide ``Move to Next Monitor'' command by cycling through
  \texttt{Screens.All} and setting \texttt{Position} accordingly.
\end{itemize}

\subsection{10. Troubleshooting}\label{troubleshooting-2}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Issue
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Fix
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Window blurry on high DPI & Use vector assets; adjust RenderScaling;
ensure \texttt{UseCompositor} is default \\
Transparency ignored & Check ActualTransparencyLevel; verify OS support;
remove conflicting settings \\
Custom chrome drag fails & Ensure \texttt{BeginMoveDrag} only on left
button down; avoid starting drag from interactive controls \\
Incorrect monitor on startup & Set \texttt{WindowStartupLocation} or
compute position using \texttt{Screens} before showing window \\
Linux packaging fails & Include \texttt{libAvaloniaNative.so}
dependencies; use Avalonia Debian/RPM packaging scripts \\
\end{longtable}

\subsection{11. Practice exercises}\label{practice-exercises-12}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Build a window with custom title bar, including minimize, maximize,
  close, and move/resize handles.
\item
  Request Mica/Acrylic, detect fallback, and apply theme-specific
  backgrounds for each transparency level.
\item
  Implement a ``Move to Next Monitor'' command cycling through available
  screens.
\item
  Persist window placement (position/size/state) to disk and restore on
  startup.
\item
  Log which backend (\texttt{Win32RenderingMode},
  \texttt{X11RenderingMode}, etc.) starts under different option
  combinations and document the impact on transparency and input
  latency.
\item
  Create deployment artifacts: MSIX (Windows), .app (macOS), and
  AppImage/Flatpak (Linux) for a simple app.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-16}

\begin{itemize}
\tightlist
\item
  Window \& TopLevel:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Window.cs}{\texttt{Window.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TopLevel.cs}{\texttt{TopLevel.cs}}
\item
  Transparency enums:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/WindowTransparencyLevel.cs}{\texttt{WindowTransparencyLevel.cs}}
\item
  Screens API:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Screens.cs}{\texttt{Screens.cs}}
\item
  Extend client area hints:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Window.cs}{\texttt{Window.cs}
  lines around ExtendClientArea properties}
\item
  Desktop lifetime:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs}{\texttt{ClassicDesktopStyleApplicationLifetime.cs}}
\item
  Backend options:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Windows/Avalonia.Win32/Win32PlatformOptions.cs}{\texttt{Win32PlatformOptions}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Native/AvaloniaNativePlatformExtensions.cs}{\texttt{AvaloniaNativePlatformExtensions}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.X11/X11Platform.cs}{\texttt{X11Platform.cs}}
\item
  Skia configuration:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Skia/Avalonia.Skia/SkiaOptions.cs}{\texttt{SkiaOptions}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-16}

\begin{itemize}
\tightlist
\item
  How do you request and detect the achieved transparency level on each
  platform?
\item
  What steps are needed to build a custom title bar that supports drag
  and resize?
\item
  How do you center a window on the active monitor using
  \texttt{Screens} and scaling info?
\item
  What packaging options are available per desktop platform?
\item
  Which option sets control rendering fallbacks on Windows and Linux
  backends?
\end{itemize}

What's next - Next: \href{Chapter19.md}{Chapter 19}

\newpage

\subsection{19. Mobile targets: Android and
iOS}\label{mobile-targets-android-and-ios}

Goal - Configure, build, and run Avalonia apps on Android and iOS using
the single-project workflow. - Understand \texttt{AvaloniaActivity},
\texttt{AvaloniaApplication}, and \texttt{AvaloniaAppDelegate} lifetimes
so your shared code boots correctly on each platform. - Integrate
platform services (back button, clipboard, storage, notifications) while
respecting safe areas, touch input, and trimming constraints.

Why this matters - Mobile devices have different UI expectations (single
window, touch, safe areas, OS-managed lifecycle). - Avalonia lets you
share code across desktop and mobile, but you must adjust hosting
lifetimes, navigation, and platform service wiring.

Prerequisites - Chapter 12 (lifetimes/navigation), Chapter 16 (storage
provider), Chapter 17 (async/networking).

\subsection{1. Projects and workload
setup}\label{projects-and-workload-setup}

Install .NET workloads and mobile SDKs:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\# Android}
\FunctionTok{sudo}\NormalTok{ dotnet workload install android}

\CommentTok{\#\# iOS (macOS only)}
\FunctionTok{sudo}\NormalTok{ dotnet workload install ios}

\CommentTok{\#\# Optional: wasm{-}tools for browser}
\FunctionTok{sudo}\NormalTok{ dotnet workload install wasm{-}tools}
\end{Highlighting}
\end{Shaded}

Check workloads with \texttt{dotnet\ workload\ list}.

Project structure: - Shared project (e.g., \texttt{MyApp}): Avalonia
cross-platform code. - Platform heads (Android, iOS): host the Avalonia
app, provide manifests, icons, metadata.

\texttt{dotnet\ new\ avalonia.app\ -\/-multiplatform} creates the shared
project plus heads (\texttt{MyApp.Android}, \texttt{MyApp.iOS}, optional
\texttt{MyApp.Browser}). The Android head references
\texttt{Avalonia.Android} (which contains \texttt{AvaloniaActivity} and
\texttt{AvaloniaApplication}); the iOS head references
\texttt{Avalonia.iOS} (which contains \texttt{AvaloniaAppDelegate}).

Keep trimming/linker settings in \texttt{Directory.Build.props} so
shared code doesn't lose reflection-heavy ViewModels. Example additions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{PropertyGroup}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TrimMode}\NormalTok{\textgreater{}partial\textless{}/}\KeywordTok{TrimMode}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{IlcInvariantGlobalization}\NormalTok{\textgreater{}true\textless{}/}\KeywordTok{IlcInvariantGlobalization}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{PublishTrimmed}\NormalTok{\textgreater{}true\textless{}/}\KeywordTok{PublishTrimmed}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{PropertyGroup}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Use \texttt{TrimmerRootAssembly} or \texttt{DynamicDependency}
attributes if you depend on reflection-heavy frameworks (e.g.,
ReactiveUI). Test Release builds on devices early to catch linker
issues.

\subsection{2. Single-view lifetime}\label{single-view-lifetime}

\texttt{ISingleViewApplicationLifetime} hosts one root view. Configure
in \texttt{App.OnFrameworkInitializationCompleted} (Chapter 4 showed
desktop branch).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ services }\OperatorTok{=} \FunctionTok{ConfigureServices}\OperatorTok{();}

    \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ ISingleViewApplicationLifetime singleView}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        singleView}\OperatorTok{.}\FunctionTok{MainView} \OperatorTok{=}\NormalTok{ services}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{ShellView}\OperatorTok{\textgreater{}();}
    \OperatorTok{\}}
    \KeywordTok{else} \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ IClassicDesktopStyleApplicationLifetime desktop}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        desktop}\OperatorTok{.}\FunctionTok{MainWindow} \OperatorTok{=}\NormalTok{ services}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{MainWindow}\OperatorTok{\textgreater{}();}
    \OperatorTok{\}}

    \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{ShellView} is a \texttt{UserControl} with mobile-friendly layout
and navigation.

Hot reload: on Android, Rider/Visual Studio can use .NET Hot Reload
against \texttt{MyApp.Android}. For XAML hot reload in Previewer, add
\texttt{\textless{}ItemGroup\textgreater{}\textless{}XamlIlAssemblyInfo\textgreater{}true\textless{}/XamlIlAssemblyInfo\textgreater{}\textless{}/ItemGroup\textgreater{}}
to the shared project and keep the head running via
\texttt{dotnet\ build\ -t:Run}.

\subsection{3. Mobile navigation
patterns}\label{mobile-navigation-patterns}

Use view-model-first navigation (Chapter 12) but ensure a visible Back
control.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{UserControl}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}\OtherTok{ x:Class=}\StringTok{"MyApp.Views.ShellView"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Grid}\OtherTok{ RowDefinitions=}\StringTok{"Auto,*"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"8"}\OtherTok{ Margin=}\StringTok{"16"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Back"}
\OtherTok{              Command=}\StringTok{"\{Binding BackCommand\}"}
\OtherTok{              IsVisible=}\StringTok{"\{Binding CanGoBack\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Title\}"}\OtherTok{ FontSize=}\StringTok{"20"}\OtherTok{ VerticalAlignment=}\StringTok{"Center"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TransitioningContentControl}\OtherTok{ Grid.Row=}\StringTok{"1"}\OtherTok{ Content=}\StringTok{"\{Binding Current\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Grid}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{UserControl}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{ShellViewModel} keeps a stack of view models and implements
\texttt{BackCommand}/\texttt{NavigateTo}. Hook Android back button (Next
section) to \texttt{BackCommand} and mirror the same logic inside
\texttt{AvaloniaAppDelegate} to react to swipe-back gestures on iOS.

\subsection{4. Safe areas and input
insets}\label{safe-areas-and-input-insets}

Phones have notches and OS-controlled bars. Use \texttt{IInsetsManager}
to apply safe-area padding.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{partial} \KeywordTok{class}\NormalTok{ ShellView }\OperatorTok{:}\NormalTok{ UserControl}
\OperatorTok{\{}
    \KeywordTok{public} \FunctionTok{ShellView}\OperatorTok{()}
    \OperatorTok{\{}
        \FunctionTok{InitializeComponent}\OperatorTok{();}
        \KeywordTok{this}\OperatorTok{.}\FunctionTok{AttachedToVisualTree} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_\_}\OperatorTok{)} \OperatorTok{=\textgreater{}}
        \OperatorTok{\{}
            \DataTypeTok{var}\NormalTok{ top }\OperatorTok{=}\NormalTok{ TopLevel}\OperatorTok{.}\FunctionTok{GetTopLevel}\OperatorTok{(}\KeywordTok{this}\OperatorTok{);}
            \DataTypeTok{var}\NormalTok{ insets }\OperatorTok{=}\NormalTok{ top}\OperatorTok{?.}\FunctionTok{InsetsManager}\OperatorTok{;}
            \KeywordTok{if} \OperatorTok{(}\NormalTok{insets }\KeywordTok{is} \KeywordTok{null}\OperatorTok{)} \KeywordTok{return}\OperatorTok{;}

            \DataTypeTok{void} \FunctionTok{ApplyInsets}\OperatorTok{()}
            \OperatorTok{\{}
\NormalTok{                RootPanel}\OperatorTok{.}\FunctionTok{Padding} \OperatorTok{=} \KeywordTok{new} \FunctionTok{Thickness}\OperatorTok{(}
\NormalTok{                    insets}\OperatorTok{.}\FunctionTok{SafeAreaPadding}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{,}
\NormalTok{                    insets}\OperatorTok{.}\FunctionTok{SafeAreaPadding}\OperatorTok{.}\FunctionTok{Top}\OperatorTok{,}
\NormalTok{                    insets}\OperatorTok{.}\FunctionTok{SafeAreaPadding}\OperatorTok{.}\FunctionTok{Right}\OperatorTok{,}
\NormalTok{                    insets}\OperatorTok{.}\FunctionTok{SafeAreaPadding}\OperatorTok{.}\FunctionTok{Bottom}\OperatorTok{);}
            \OperatorTok{\}}

            \FunctionTok{ApplyInsets}\OperatorTok{();}
\NormalTok{            insets}\OperatorTok{.}\FunctionTok{Changed} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_\_}\OperatorTok{)} \OperatorTok{=\textgreater{}} \FunctionTok{ApplyInsets}\OperatorTok{();}
        \OperatorTok{\};}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Soft keyboard (IME) adjustments: subscribe to
\texttt{TopLevel.InputPane.Showing/Hiding} and adjust margins above
keyboard.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ pane }\OperatorTok{=}\NormalTok{ top}\OperatorTok{?.}\FunctionTok{InputPane}\OperatorTok{;}
\KeywordTok{if} \OperatorTok{(}\NormalTok{pane }\KeywordTok{is}\NormalTok{ not }\KeywordTok{null}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    pane}\OperatorTok{.}\FunctionTok{Showing} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ args}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ RootPanel}\OperatorTok{.}\FunctionTok{Margin} \OperatorTok{=} \KeywordTok{new} \FunctionTok{Thickness}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ args}\OperatorTok{.}\FunctionTok{OccludedRect}\OperatorTok{.}\FunctionTok{Height}\OperatorTok{);}
\NormalTok{    pane}\OperatorTok{.}\FunctionTok{Hiding} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_\_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ RootPanel}\OperatorTok{.}\FunctionTok{Margin} \OperatorTok{=} \KeywordTok{new} \FunctionTok{Thickness}\OperatorTok{(}\DecValTok{0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Touch input specifics: prefer gesture recognizers (\texttt{Tapped},
\texttt{DoubleTapped}, \texttt{PointerGestureRecognizer}) over mouse
events, and test with real hardware---emulators may not surface haptics
or multi-touch.

\subsection{5. Platform head
customization}\label{platform-head-customization}

\subsubsection{5.1 Android head
(MyApp.Android)}\label{android-head-myapp.android}

\begin{itemize}
\tightlist
\item
  \texttt{MainActivity.cs} inherits from \texttt{AvaloniaActivity}.
  Override \texttt{AppBuilder\ CustomizeAppBuilder(AppBuilder\ builder)}
  to inject logging or DI.
\item
  \texttt{MyApplication.cs} can inherit from
  \texttt{AvaloniaApplication} to bootstrap services before the activity
  creates the view.
\item
  \texttt{AndroidManifest.xml}: declare permissions (\texttt{INTERNET},
  \texttt{READ\_EXTERNAL\_STORAGE}), orientation, minimum SDK.
\item
  App icons/splash: \texttt{Resources/mipmap-*},
  \texttt{Resources/xml/splashscreen.xml} for Android 12+ splash.
\item
  Enable fast deployment/device hot reload by setting
  \texttt{\textless{}AndroidEnableProfiler\textgreater{}true\textless{}/AndroidEnableProfiler\textgreater{}}
  in Debug configuration.
\item
  Intercept hardware Back button by overriding \texttt{OnBackPressed} or
  using
  \texttt{AvaloniaLocator.Current.GetService\textless{}IMobileNavigation\textgreater{}()}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnBackPressed}\OperatorTok{()}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(!}\NormalTok{AvaloniaApp}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{?.}\FunctionTok{TryGoBack}\OperatorTok{()} \OperatorTok{??} \KeywordTok{true}\OperatorTok{)}
        \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnBackPressed}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{TryGoBack} calls into shared navigation service and returns true
if you consumed the event. To embed Avalonia inside an existing native
activity, host \texttt{AvaloniaView} inside a layout and call
\texttt{AvaloniaView.Initialize(this,\ AppBuilder.Configure\textless{}App\textgreater{}()...)}.

\subsubsection{5.2 iOS head (MyApp.iOS)}\label{ios-head-myapp.ios}

\begin{itemize}
\tightlist
\item
  \texttt{AppDelegate.cs} inherits from \texttt{AvaloniaAppDelegate}.
  Override \texttt{CustomizeAppBuilder} to inject services or register
  platform-specific singletons.
\item
  \texttt{Program.cs} wraps
  \texttt{UIApplication.Main(args,\ null,\ typeof(AppDelegate))} so the
  delegate boots Avalonia.
\item
  \texttt{Info.plist}: permissions (e.g., camera), orientation, status
  bar style.
\item
  Launch screen via \texttt{LaunchScreen.storyboard} or SwiftUI
  resources in Xcode.
\item
  Use \texttt{AvaloniaViewController} to embed Avalonia content inside
  UIKit navigation stacks or tab controllers.
\end{itemize}

Handle universal links or background tasks by bridging to shared
services in \texttt{AppDelegate}. For swipe-back gestures, implement
\texttt{TryGoBack} inside \texttt{AvaloniaNavigationController} or
intercept \texttt{UINavigationControllerDelegate} callbacks.

\subsubsection{5.3 Sharing services across
heads}\label{sharing-services-across-heads}

Inject platform implementations for \texttt{IClipboard},
\texttt{IStorageProvider}, notifications, and share targets via
dependency injection. Register them in
\texttt{AvaloniaLocator.CurrentMutable} inside
\texttt{CustomizeAppBuilder} to keep shared code unaware of
head-specific services.

\subsection{6. Permissions \& storage}\label{permissions-storage}

\begin{itemize}
\tightlist
\item
  StorageProvider works but returns sandboxed streams. Request platform
  permissions:

  \begin{itemize}
  \tightlist
  \item
    Android: declare
    \texttt{\textless{}uses-permission\ android:name="android.permission.READ\_EXTERNAL\_STORAGE"/\textgreater{}}
    and use runtime requests.
  \item
    iOS: add entries to Info.plist (e.g.,
    \texttt{NSPhotoLibraryUsageDescription}).
  \end{itemize}
\item
  Consider packaging specific data (e.g., from \texttt{AppBundle})
  instead of relying on arbitrary file system access.
\item
  Use \texttt{EssentialsPermissions} helper libraries
  carefully---Release builds with trimming must preserve permission
  classes. Validate by running \texttt{dotnet\ publish\ -c\ Release} on
  device/emulator.
\item
  Push notifications and background fetch require platform services:
  expose custom interfaces (e.g., \texttt{IPushNotificationService})
  that platform heads implement and inject into shared locator.
\end{itemize}

\subsection{7. Touch and gesture design}\label{touch-and-gesture-design}

\begin{itemize}
\tightlist
\item
  Ensure controls are at least 44x44 DIP.
\item
  Provide ripple/highlight states for buttons (Fluent theme handles
  this). Avoid hover-only interactions.
\item
  Use \texttt{Tapped}/\texttt{DoubleTapped} events for simple gestures;
  \texttt{PointerGestureRecognizer} for advanced ones.
\item
  Keep layout responsive: use \texttt{TopLevel.Screen} to detect
  orientation/size classes and expose them via your view models.
\end{itemize}

\subsection{8. Performance \& profiling}\label{performance-profiling}

\begin{itemize}
\tightlist
\item
  Keep navigation stacks small; heavy animations may impact lower-end
  devices.
\item
  Profile with Android Studio's profiler / Xcode Instruments for CPU,
  memory, GPU.
\item
  When using \texttt{Task.Run}, consider battery impact; use async I/O
  where possible.
\item
  Enable GPU frame stats with \texttt{adb\ shell\ dumpsys\ gfxinfo} or
  Xcode's Metal throughput counters to detect rendering bottlenecks.
\end{itemize}

\subsection{9. Packaging and deployment}\label{packaging-and-deployment}

\subsubsection{Android}\label{android}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ MyApp.Android}
\CommentTok{\#\# Debug build to device}
\ExtensionTok{msbuild}\NormalTok{ /t:Run /p:Configuration=Debug}

\CommentTok{\#\# Release APK/AAB}
\ExtensionTok{msbuild}\NormalTok{ /t:Publish /p:Configuration=Release /p:AndroidPackageFormat=aab}
\end{Highlighting}
\end{Shaded}

Sign with keystore for app store.

\subsubsection{iOS}\label{ios}

\begin{itemize}
\tightlist
\item
  Use Xcode to build and deploy to simulator/device.
  \texttt{dotnet\ build\ -t:Run\ -f\ net8.0-ios} works on macOS with
  Xcode installed.
\item
  Provisioning profiles \& certificates required for devices/app store.
\item
  Linker errors often show up only in Release; enable
  \texttt{-\/-warnaserror} on linker warnings to catch missing
  assemblies early.
\end{itemize}

\subsubsection{Optional: Tizen}\label{optional-tizen}

Avalonia's Tizen backend (\texttt{Avalonia.Tizen}) targets smart
TVs/wearables. The structure mirrors Android/iOS: implement a Tizen
\texttt{Program.cs} that calls
\texttt{AppBuilder.Configure\textless{}App\textgreater{}().UseTizen\textless{}TizenApplication\textgreater{}()}
and handles platform storage/permissions via Tizen APIs.

\subsection{10. Browser compatibility
(bonus)}\label{browser-compatibility-bonus}

Mobile code often reuses single-view logic for WebAssembly. Check
\texttt{ApplicationLifetime} for \texttt{BrowserSingleViewLifetime} and
swap to a \texttt{ShellView}. Storage/clipboard behave like Chapter 16
with browser limitations.

\subsection{11. Practice exercises}\label{practice-exercises-13}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Configure the Android/iOS heads and run the app on emulator/simulator
  with a shared \texttt{ShellView}.
\item
  Implement a navigation service with back stack and wire Android back
  button to it.
\item
  Adjust safe-area padding and keyboard insets for a login screen
  (Inputs remain visible when keyboard shows).
\item
  Add file pickers via \texttt{StorageProvider} and test on device
  (consider permission prompts).
\item
  Package a release build (.aab for Android, .ipa for iOS), validate
  icons/splash screens, and confirm Release trimming did not strip
  services.
\item
  (Stretch) Embed Avalonia inside a native screen (\texttt{AvaloniaView}
  on Android, \texttt{AvaloniaViewController} on iOS) and pass data
  between native and Avalonia layers.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-17}

\begin{itemize}
\tightlist
\item
  Android hosting:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Android/Avalonia.Android/AvaloniaActivity.cs}{\texttt{AvaloniaActivity}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Android/Avalonia.Android/AvaloniaApplication.cs}{\texttt{AvaloniaApplication}}
\item
  iOS hosting:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/iOS/Avalonia.iOS/AvaloniaAppDelegate.cs}{\texttt{AvaloniaAppDelegate}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/iOS/Avalonia.iOS/AvaloniaViewController.cs}{\texttt{AvaloniaViewController}}
\item
  Single-view lifetime:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/SingleViewApplicationLifetime.cs}{\texttt{SingleViewApplicationLifetime.cs}}
\item
  Insets and input pane:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Platform/IInsetsManager.cs}{\texttt{IInsetsManager}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Platform/IInputPane.cs}{\texttt{IInputPane}}
\item
  Platform services:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/AvaloniaLocator.cs}{\texttt{AvaloniaLocator}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Input/IClipboard.cs}{\texttt{IClipboard}}
\item
  Tizen backend:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Tizen}{\texttt{Avalonia.Tizen}}
\item
  Mobile samples:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples/ControlCatalog.Android}{\texttt{samples/ControlCatalog.Android}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples/ControlCatalog.iOS}{\texttt{samples/ControlCatalog.iOS}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-17}

\begin{itemize}
\tightlist
\item
  How does the navigation pattern differ between desktop and mobile? How
  do you surface back navigation?
\item
  How do you ensure inputs remain visible when the on-screen keyboard
  appears?
\item
  What permission declarations are required for file access on
  Android/iOS?
\item
  Where in the platform heads do you configure icons, splash screens,
  and orientation?
\end{itemize}

What's next - Next: \href{Chapter20.md}{Chapter 20}

\newpage

\subsection{20. Browser (WebAssembly)
target}\label{browser-webassembly-target}

Goal - Run your Avalonia app in the browser using WebAssembly (WASM)
with minimal changes to shared code. - Understand browser-specific
lifetimes, hosting options, rendering modes, and platform limitations
(files, networking, threading, DOM interop). - Debug, profile, and
deploy a browser build with confidence.

Why this matters - Web delivery eliminates install friction for demos,
tooling, and dashboards. - Browser rules (sandboxing, CORS, user
gestures) require tweaks compared to desktop/mobile, and understanding
how Avalonia binds to the JS runtime keeps those differences manageable.

Prerequisites - Chapter 19 (single-view navigation), Chapter 16 (storage
provider), Chapter 17 (async/networking).

\subsection{1. Project structure and
setup}\label{project-structure-and-setup}

Install \texttt{wasm-tools} workload:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sudo}\NormalTok{ dotnet workload install wasm{-}tools}
\end{Highlighting}
\end{Shaded}

A multi-target solution has: - Shared project (\texttt{MyApp}): Avalonia
code. - Browser head (\texttt{MyApp.Browser}): hosts the app
(\texttt{Program.cs}, \texttt{index.html}, static assets).

Avalonia template
(\texttt{dotnet\ new\ avalonia.app\ -\/-multiplatform}) can create the
browser head for you. \texttt{MyApp.Browser} references
\texttt{Avalonia.Browser}, which wraps the WebAssembly host
(\texttt{BrowserAppBuilder}, \texttt{BrowserSingleViewLifetime},
\texttt{BrowserNativeControlHost}).

When adding the head manually, target \texttt{net8.0-browserwasm},
configure
\texttt{\textless{}WasmMainJSPath\textgreater{}wwwroot/main.js\textless{}/WasmMainJSPath\textgreater{}},
and keep trimming hints (e.g.,
\texttt{\textless{}InvariantGlobalization\textgreater{}true\textless{}/InvariantGlobalization\textgreater{}}).
Browser heads use the NativeAOT toolchain; Release builds can set
\texttt{\textless{}PublishAot\textgreater{}true\textless{}/PublishAot\textgreater{}}
for faster startup and smaller payloads.

\subsection{2. Start the browser app}\label{start-the-browser-app}

\texttt{StartBrowserAppAsync} attaches Avalonia to a DOM element by ID.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Browser}\OperatorTok{;}

\KeywordTok{internal} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ Program}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{static}\NormalTok{ AppBuilder }\FunctionTok{BuildAvaloniaApp}\OperatorTok{()}
        \OperatorTok{=\textgreater{}}\NormalTok{ AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
            \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
            \OperatorTok{.}\FunctionTok{LogToTrace}\OperatorTok{();}

    \KeywordTok{public} \KeywordTok{static}\NormalTok{ Task }\FunctionTok{Main}\OperatorTok{(}\DataTypeTok{string}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)}
        \OperatorTok{=\textgreater{}} \FunctionTok{BuildAvaloniaApp}\OperatorTok{()}
            \OperatorTok{.}\FunctionTok{StartBrowserAppAsync}\OperatorTok{(}\StringTok{"out"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Ensure host HTML contains
\texttt{\textless{}div\ id="out"\textgreater{}\textless{}/div\textgreater{}}.

For advanced embedding, use \texttt{BrowserAppBuilder} directly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{await BrowserAppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{SetupBrowserAppAsync}\OperatorTok{(}\NormalTok{options }\OperatorTok{=\textgreater{}}
    \OperatorTok{\{}
\NormalTok{        options}\OperatorTok{.}\FunctionTok{MainAssembly} \OperatorTok{=} \KeywordTok{typeof}\OperatorTok{(}\NormalTok{App}\OperatorTok{).}\FunctionTok{Assembly}\OperatorTok{;}
\NormalTok{        options}\OperatorTok{.}\FunctionTok{AppBuilder} \OperatorTok{=}\NormalTok{ AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}().}\FunctionTok{LogToTrace}\OperatorTok{();}
\NormalTok{        options}\OperatorTok{.}\FunctionTok{Selector} \OperatorTok{=} \StringTok{"\#out"}\OperatorTok{;}
    \OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

\texttt{SetupBrowserAppAsync} lets you delay instantiation (wait for
configuration, auth, etc.) or mount multiple roots in different DOM
nodes.

\subsection{3. Single view lifetime}\label{single-view-lifetime-1}

Browser uses \texttt{ISingleViewApplicationLifetime} (same as mobile).
Configure in \texttt{App.OnFrameworkInitializationCompleted}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{()}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ ISingleViewApplicationLifetime singleView}\OperatorTok{)}
\NormalTok{        singleView}\OperatorTok{.}\FunctionTok{MainView} \OperatorTok{=} \KeywordTok{new}\NormalTok{ ShellView }\OperatorTok{\{}\NormalTok{ DataContext }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ShellViewModel}\OperatorTok{()} \OperatorTok{\};}
    \KeywordTok{else} \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ IClassicDesktopStyleApplicationLifetime desktop}\OperatorTok{)}
\NormalTok{        desktop}\OperatorTok{.}\FunctionTok{MainWindow} \OperatorTok{=} \KeywordTok{new}\NormalTok{ MainWindow }\OperatorTok{\{}\NormalTok{ DataContext }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ShellViewModel}\OperatorTok{()} \OperatorTok{\};}

    \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Navigation patterns from Chapter 19 apply (content control with back
stack).

\subsection{4. Rendering options}\label{rendering-options}

Configure \texttt{BrowserPlatformOptions} to choose rendering mode and
polyfills.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{await }\FunctionTok{BuildAvaloniaApp}\OperatorTok{().}\FunctionTok{StartBrowserAppAsync}\OperatorTok{(}
    \StringTok{"out"}\OperatorTok{,}
    \KeywordTok{new}\NormalTok{ BrowserPlatformOptions}
    \OperatorTok{\{}
\NormalTok{        RenderingMode }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]}
        \OperatorTok{\{}
\NormalTok{            BrowserRenderingMode}\OperatorTok{.}\FunctionTok{WebGL2}\OperatorTok{,}
\NormalTok{            BrowserRenderingMode}\OperatorTok{.}\FunctionTok{WebGL1}\OperatorTok{,}
\NormalTok{            BrowserRenderingMode}\OperatorTok{.}\FunctionTok{Software2D}
        \OperatorTok{\},}
\NormalTok{        RegisterAvaloniaServiceWorker }\OperatorTok{=} \KeywordTok{true}\OperatorTok{,}
\NormalTok{        AvaloniaServiceWorkerScope }\OperatorTok{=} \StringTok{"/"}\OperatorTok{,}
\NormalTok{        PreferFileDialogPolyfill }\OperatorTok{=} \KeywordTok{false}\OperatorTok{,}
\NormalTok{        PreferManagedThreadDispatcher }\OperatorTok{=} \KeywordTok{true}
    \OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  WebGL2: best performance (default when supported).
\item
  WebGL1: fallback for older browsers.
\item
  Software2D: ultimate fallback (slower).
\item
  Service worker: required for save-file polyfill; serve over
  HTTPS/localhost.
\item
  \texttt{PreferManagedThreadDispatcher}: run dispatcher on worker
  thread when WASM threading enabled (requires server sending COOP/COEP
  headers).
\item
  \texttt{PreferFileDialogPolyfill}: toggle between File System Access
  API and download/upload fallback for unsupported browsers.
\end{itemize}

\subsection{5. Storage and file dialogs}\label{storage-and-file-dialogs}

\texttt{IStorageProvider} uses the File System Access API when
available; otherwise a polyfill (service worker + download anchor)
handles saves.

Limitations: - Browsers require user gestures (click) to open dialogs. -
File handles may not persist between sessions; use IDs and re-request
access if needed. - No direct file system access outside the user-chosen
handles.

Example save using polyfill-friendly code (Chapter 16 shows full
pattern). Test with/without service worker to ensure both paths work.

\subsection{6. Clipboard \& drag-drop}\label{clipboard-drag-drop}

Clipboard operations require user gestures and may only support text
formats. - \texttt{Clipboard.SetTextAsync} works after user interaction
(button click). - Advanced formats require clipboard permissions or
aren't supported.

Drag/drop from browser to app is supported, but dragging files out of
the app is limited by browser APIs.

\subsection{7. Networking \& CORS}\label{networking-cors}

\begin{itemize}
\tightlist
\item
  HttpClient uses \texttt{fetch}. All requests obey CORS. Configure
  server with correct \texttt{Access-Control-Allow-*} headers.
\item
  WebSockets supported via \texttt{ClientWebSocket} if server enables
  them.
\item
  HTTPS recommended; some APIs (clipboard, file access) require secure
  context.
\item
  \texttt{HttpClient} respects browser caching rules. Adjust
  \texttt{Cache-Control} headers or add cache-busting query parameters
  during development to avoid stale responses.
\end{itemize}

\subsection{8. JavaScript interop}\label{javascript-interop}

Call JS via \texttt{window.JSObject} or \texttt{JSRuntime} helpers
(Avalonia.Browser exposes interop helpers). Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Browser}\OperatorTok{.}\FunctionTok{Interop}\OperatorTok{;}

\NormalTok{await JSRuntime}\OperatorTok{.}\FunctionTok{InvokeVoidAsync}\OperatorTok{(}\StringTok{"console.log"}\OperatorTok{,} \StringTok{"Hello from Avalonia"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Use interop to integrate with existing web components or to access Web
APIs not wrapped by Avalonia.

To host native DOM content inside Avalonia, use
\texttt{BrowserNativeControlHost} with a \texttt{JSObjectControlHandle}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ handle }\OperatorTok{=}\NormalTok{ await JSRuntime}\OperatorTok{.}\FunctionTok{CreateControlHandleAsync}\OperatorTok{(}\StringTok{"div"}\OperatorTok{,} \KeywordTok{new} \OperatorTok{\{}\NormalTok{ @class }\OperatorTok{=} \StringTok{"web{-}frame"} \OperatorTok{\});}
\DataTypeTok{var}\NormalTok{ host }\OperatorTok{=} \KeywordTok{new}\NormalTok{ BrowserNativeControlHost }\OperatorTok{\{}\NormalTok{ Handle }\OperatorTok{=}\NormalTok{ handle }\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

This enables hybrid UI scenarios (rich HTML editors, video elements)
while keeping sizing/layout under Avalonia control.

\subsection{9. Hosting in Blazor
(optional)}\label{hosting-in-blazor-optional}

\texttt{Avalonia.Browser.Blazor} lets you embed Avalonia controls in a
Blazor app. Example sample: \texttt{ControlCatalog.Browser.Blazor}. Use
when you need Blazor's routing/layout but Avalonia UI inside components.

\subsection{10. Hosting strategies}\label{hosting-strategies}

\begin{itemize}
\tightlist
\item
  Static hosting: publish bundle to \texttt{AppBundle} and serve from
  any static host (GitHub Pages, S3 + CloudFront, Azure Static Web
  Apps). Ensure service worker scope matches site root.
\item
  ASP.NET Core: use \texttt{MapFallbackToFile("index.html")} or
  \texttt{UseBlazorFrameworkFiles()} to serve the bundle from a Minimal
  API or MVC backend.
\item
  Reverse proxies: configure caching (Brotli, gzip) and set
  \texttt{Cross-Origin-Embedder-Policy}/\texttt{Cross-Origin-Opener-Policy}
  headers when enabling multithreaded WASM.
\end{itemize}

During development, \texttt{dotnet\ run} on the browser head launches a
Kestrel server with live reload and proxies console logs back to the
terminal.

\subsection{11. Debugging and
diagnostics}\label{debugging-and-diagnostics}

\begin{itemize}
\tightlist
\item
  Inspector: use browser devtools (F12). Evaluate DOM, watch console
  logs.
\item
  Source maps: publish with \texttt{dotnet\ publish\ -c\ Debug} to get
  wasm debugging symbols for supported browsers.
\item
  Logging: \texttt{AppBuilder.LogToTrace()} outputs to console.
\item
  Performance: use Performance tab to profile frames, memory, CPU.
\item
  Pass \texttt{-\/-logger:WebAssembly} to \texttt{dotnet\ run} for
  runtime messages (assembly loading, exception details).
\item
  Use \texttt{wasm-tools\ wasm-strip} or \texttt{wasm-tools\ wasm-opt}
  (installed via \texttt{dotnet\ wasm\ build-tools\ -\/-install}) to
  analyze and reduce bundle sizes.
\end{itemize}

\subsection{12. Performance tips}\label{performance-tips}

\begin{itemize}
\tightlist
\item
  Measure download size: inspect \texttt{AppBundle}, track
  \texttt{.wasm}, \texttt{.dat}, and compressed assets.
\item
  Prefer compiled bindings and avoid reflection-heavy converters to keep
  the IL linker effective.
\item
  Enable multithreading (COOP/COEP headers) when animations or
  background tasks stutter; Avalonia will schedule the render loop on a
  dedicated worker thread.
\item
  Integrate \texttt{BrowserSystemNavigationManager} with your navigation
  service so browser back/forward controls work as expected.
\end{itemize}

\subsection{13. Deployment}\label{deployment}

Publish the browser head:

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{cd}\NormalTok{ MyApp.Browser}
\CommentTok{\#\# Debug}
\ExtensionTok{dotnet}\NormalTok{ run}
\CommentTok{\#\# Release bundle}
\ExtensionTok{dotnet}\NormalTok{ publish }\AttributeTok{{-}c}\NormalTok{ Release}
\end{Highlighting}
\end{Shaded}

Output under \texttt{bin/Release/net8.0/browser-wasm/AppBundle}. Serve
via static web server (ASP.NET, Node, Nginx, GitHub Pages). Ensure
service worker scope matches hosting path.

Remember to enable compression (Brotli) for faster load times.

\subsection{14. Platform limitations}\label{platform-limitations}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Browser behavior
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Windows/Dialogs & Single view only; no OS windows, tray icons, native
menus \\
File system & User-selection only via pickers; no arbitrary file
access \\
Threading & Multi-threaded WASM requires server headers (COOP/COEP) and
browser support \\
Clipboard & Requires user gesture; limited formats \\
Notifications & Use Web Notifications API via JS interop \\
Storage & LocalStorage/IndexedDB via JS interop for persistence \\
\end{longtable}

Design for progressive enhancement: provide alternative flows if feature
unsupported.

\subsection{15. Practice exercises}\label{practice-exercises-14}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a browser head and run the app in Chrome/Firefox, verifying
  rendering fallbacks.
\item
  Implement file export via \texttt{IStorageProvider} and test save
  polyfill with service worker enabled/disabled.
\item
  Add logging to report \texttt{BrowserPlatformOptions.RenderingMode}
  and \texttt{ActualTransparencyLevel} (should be \texttt{None}).
\item
  Integrate a JavaScript API (e.g., Web Notifications) via interop and
  show a notification after user action.
\item
  Publish a release build and deploy to a static host (GitHub Pages or
  local web server), verifying service worker scope and COOP/COEP
  headers.
\item
  Use \texttt{wasm-tools\ wasm-strip} (or \texttt{wasm-opt}) to inspect
  bundle size before/after trimming and record the change.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-18}

\begin{itemize}
\tightlist
\item
  Browser app builder:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserAppBuilder.cs}{\texttt{BrowserAppBuilder.cs}}
\item
  DOM interop:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/Interop/JSObjectControlHandle.cs}{\texttt{JSObjectControlHandle.cs}}
\item
  Browser lifetime:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserSingleViewLifetime.cs}{\texttt{BrowserSingleViewLifetime.cs}}
\item
  Native control host:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserNativeControlHost.cs}{\texttt{BrowserNativeControlHost.cs}}
\item
  Storage provider:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/Storage/BrowserStorageProvider.cs}{\texttt{BrowserStorageProvider.cs}}
\item
  System navigation manager:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserSystemNavigationManager.cs}{\texttt{BrowserSystemNavigationManager.cs}}
\item
  Input pane \& insets:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserInputPane.cs}{\texttt{BrowserInputPane.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserInsetsManager.cs}{\texttt{BrowserInsetsManager.cs}}
\item
  Blazor integration:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Browser/Avalonia.Browser.Blazor}{\texttt{Avalonia.Browser.Blazor}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-18}

\begin{itemize}
\tightlist
\item
  How do you configure rendering fallbacks for the browser target?
\item
  What limitations exist for file access and how does the polyfill help?
\item
  Which headers or hosting requirements enable WASM multi-threading? Why
  might you set \texttt{PreferManagedThreadDispatcher}?
\item
  How do CORS rules affect HttpClient calls in the browser?
\item
  What deployment steps are required to serve a browser bundle with
  service worker support and COOP/COEP headers?
\end{itemize}

What's next - Next: \href{Chapter21.md}{Chapter 21}

\newpage

\subsection{21. Headless and testing}\label{headless-and-testing}

Goal - Test Avalonia UI components without a display server using
\texttt{Avalonia.Headless}
(\texttt{AvaloniaHeadlessPlatformExtensions.UseHeadless}). - Simulate
user input, capture rendered frames, and integrate UI tests into CI
(xUnit, NUnit, other frameworks). - Organize your test strategy: view
models, control-level tests, visual regression, automation, fast
feedback.

Why this matters - UI you can't test will regress. Headless testing runs
anywhere (CI, Docker) and stays deterministic. - Automated UI tests
catch regressions in bindings, styles, commands, and layout quickly.

Prerequisites - Chapter 11 (MVVM patterns), Chapter 17 (async patterns),
Chapter 16 (storage) for file-based assertions.

\subsection{1. Packages and setup}\label{packages-and-setup}

Add packages to your test project: - \texttt{Avalonia.Headless} -
\texttt{Avalonia.Headless.XUnit} or \texttt{Avalonia.Headless.NUnit} -
\texttt{Avalonia.Skia} (only if you need rendered frames)

\subsubsection{\texorpdfstring{xUnit setup
(\texttt{AssemblyInfo.cs})}{xUnit setup (AssemblyInfo.cs)}}\label{xunit-setup-assemblyinfo.cs}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Headless}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Headless}\OperatorTok{.}\FunctionTok{XUnit}\OperatorTok{;}

\OperatorTok{[}\NormalTok{assembly}\OperatorTok{:} \FunctionTok{AvaloniaTestApplication}\OperatorTok{(}\KeywordTok{typeof}\OperatorTok{(}\NormalTok{TestApp}\OperatorTok{))]}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ TestApp }\OperatorTok{:}\NormalTok{ Application}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ AppBuilder }\FunctionTok{BuildAvaloniaApp}\OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{TestApp}\OperatorTok{\textgreater{}()}
        \OperatorTok{.}\FunctionTok{UseHeadless}\OperatorTok{(}\KeywordTok{new}\NormalTok{ AvaloniaHeadlessPlatformOptions}
        \OperatorTok{\{}
\NormalTok{            UseHeadlessDrawing }\OperatorTok{=} \KeywordTok{true}\OperatorTok{,} \CommentTok{// set false + UseSkia for frame capture}
\NormalTok{            UseCpuDisabledRenderLoop }\OperatorTok{=} \KeywordTok{true}
        \OperatorTok{\})}
        \OperatorTok{.}\FunctionTok{AfterSetup}\OperatorTok{(}\NormalTok{\_ }\OperatorTok{=\textgreater{}}\NormalTok{ Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{VerifyAccess}\OperatorTok{());}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{UseHeadlessDrawing\ =\ true} skips Skia (fast). For pixel tests,
set false and call \texttt{.UseSkia()}.

\subsubsection{NUnit setup}\label{nunit-setup}

Use \texttt{{[}AvaloniaTestApp{]}} attribute (from
\texttt{Avalonia.Headless.NUnit}) and the provided
\texttt{AvaloniaTestFixture} base.

\subsection{2. Writing a simple headless
test}\label{writing-a-simple-headless-test}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ TextBoxTests}
\OperatorTok{\{}
    \OperatorTok{[}\NormalTok{AvaloniaFact}\OperatorTok{]}
    \KeywordTok{public}\NormalTok{ async Task }\FunctionTok{TextBox\_Receives\_Typed\_Text}\OperatorTok{()}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ textBox }\OperatorTok{=} \KeywordTok{new}\NormalTok{ TextBox }\OperatorTok{\{}\NormalTok{ Width }\OperatorTok{=} \DecValTok{200}\OperatorTok{,}\NormalTok{ Height }\OperatorTok{=} \DecValTok{24} \OperatorTok{\};}
        \DataTypeTok{var}\NormalTok{ window }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Window }\OperatorTok{\{}\NormalTok{ Content }\OperatorTok{=}\NormalTok{ textBox }\OperatorTok{\};}
\NormalTok{        window}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{();}

        \CommentTok{// Focus on UI thread}
\NormalTok{        await Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{InvokeAsync}\OperatorTok{(()} \OperatorTok{=\textgreater{}}\NormalTok{ textBox}\OperatorTok{.}\FunctionTok{Focus}\OperatorTok{());}

\NormalTok{        window}\OperatorTok{.}\FunctionTok{KeyTextInput}\OperatorTok{(}\StringTok{"Avalonia"}\OperatorTok{);}
\NormalTok{        AvaloniaHeadlessPlatform}\OperatorTok{.}\FunctionTok{ForceRenderTimerTick}\OperatorTok{();}

\NormalTok{        Assert}\OperatorTok{.}\FunctionTok{Equal}\OperatorTok{(}\StringTok{"Avalonia"}\OperatorTok{,}\NormalTok{ textBox}\OperatorTok{.}\FunctionTok{Text}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Helpers from \texttt{Avalonia.Headless} add extension methods to
\texttt{TopLevel}/\texttt{Window} (\texttt{KeyTextInput},
\texttt{KeyPress}, \texttt{MouseDown}, etc.). Always call
\texttt{ForceRenderTimerTick()} after inputs to flush layout/bindings.

\subsection{3. Simulating pointer input}\label{simulating-pointer-input}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\NormalTok{ AvaloniaFact }\OperatorTok{]}
\KeywordTok{public}\NormalTok{ async Task }\FunctionTok{Button\_Click\_Executes\_Command}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ commandExecuted }\OperatorTok{=} \KeywordTok{false}\OperatorTok{;}
    \DataTypeTok{var}\NormalTok{ button }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Button}
    \OperatorTok{\{}
\NormalTok{        Width }\OperatorTok{=} \DecValTok{100}\OperatorTok{,}
\NormalTok{        Height }\OperatorTok{=} \DecValTok{30}\OperatorTok{,}
\NormalTok{        Content }\OperatorTok{=} \StringTok{"Click me"}\OperatorTok{,}
\NormalTok{        Command }\OperatorTok{=}\NormalTok{ ReactiveCommand}\OperatorTok{.}\FunctionTok{Create}\OperatorTok{(()} \OperatorTok{=\textgreater{}}\NormalTok{ commandExecuted }\OperatorTok{=} \KeywordTok{true}\OperatorTok{)}
    \OperatorTok{\};}

    \DataTypeTok{var}\NormalTok{ window }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Window }\OperatorTok{\{}\NormalTok{ Content }\OperatorTok{=}\NormalTok{ button }\OperatorTok{\};}
\NormalTok{    window}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{();}

\NormalTok{    await Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{InvokeAsync}\OperatorTok{(()} \OperatorTok{=\textgreater{}}\NormalTok{ button}\OperatorTok{.}\FunctionTok{Focus}\OperatorTok{());}
\NormalTok{    window}\OperatorTok{.}\FunctionTok{MouseDown}\OperatorTok{(}\NormalTok{button}\OperatorTok{.}\FunctionTok{Bounds}\OperatorTok{.}\FunctionTok{Center}\OperatorTok{,}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}
\NormalTok{    window}\OperatorTok{.}\FunctionTok{MouseUp}\OperatorTok{(}\NormalTok{button}\OperatorTok{.}\FunctionTok{Bounds}\OperatorTok{.}\FunctionTok{Center}\OperatorTok{,}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}
\NormalTok{    AvaloniaHeadlessPlatform}\OperatorTok{.}\FunctionTok{ForceRenderTimerTick}\OperatorTok{();}

\NormalTok{    Assert}\OperatorTok{.}\FunctionTok{True}\OperatorTok{(}\NormalTok{commandExecuted}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{Bounds.Center} obtains center point from
\texttt{Control.Bounds}. For container-based coordinates, offset
appropriately.

\subsection{4. Frame capture \& visual
regression}\label{frame-capture-visual-regression}

Configure Skia rendering in test app builder:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static}\NormalTok{ AppBuilder }\FunctionTok{BuildAvaloniaApp}\OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{TestApp}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UseSkia}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{UseHeadless}\OperatorTok{(}\KeywordTok{new}\NormalTok{ AvaloniaHeadlessPlatformOptions}
    \OperatorTok{\{}
\NormalTok{        UseHeadlessDrawing }\OperatorTok{=} \KeywordTok{false}\OperatorTok{,}
\NormalTok{        UseCpuDisabledRenderLoop }\OperatorTok{=} \KeywordTok{true}
    \OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

Capture frames:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\NormalTok{ AvaloniaFact }\OperatorTok{]}
\KeywordTok{public} \DataTypeTok{void} \FunctionTok{Border\_Renders\_Correct\_Size}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ border }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Border}
    \OperatorTok{\{}
\NormalTok{        Width }\OperatorTok{=} \DecValTok{200}\OperatorTok{,}
\NormalTok{        Height }\OperatorTok{=} \DecValTok{100}\OperatorTok{,}
\NormalTok{        Background }\OperatorTok{=}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{Red}
    \OperatorTok{\};}

    \DataTypeTok{var}\NormalTok{ window }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Window }\OperatorTok{\{}\NormalTok{ Content }\OperatorTok{=}\NormalTok{ border }\OperatorTok{\};}
\NormalTok{    window}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{();}
\NormalTok{    AvaloniaHeadlessPlatform}\OperatorTok{.}\FunctionTok{ForceRenderTimerTick}\OperatorTok{();}

    \KeywordTok{using} \DataTypeTok{var}\NormalTok{ frame }\OperatorTok{=}\NormalTok{ window}\OperatorTok{.}\FunctionTok{GetLastRenderedFrame}\OperatorTok{();}
\NormalTok{    Assert}\OperatorTok{.}\FunctionTok{Equal}\OperatorTok{(}\DecValTok{200}\OperatorTok{,}\NormalTok{ frame}\OperatorTok{.}\FunctionTok{Size}\OperatorTok{.}\FunctionTok{Width}\OperatorTok{);}
\NormalTok{    Assert}\OperatorTok{.}\FunctionTok{Equal}\OperatorTok{(}\DecValTok{100}\OperatorTok{,}\NormalTok{ frame}\OperatorTok{.}\FunctionTok{Size}\OperatorTok{.}\FunctionTok{Height}\OperatorTok{);}

    \CommentTok{// Optional: save to disk for debugging}
    \CommentTok{// frame.Save("border.png");}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Compare pixels to baseline image using e.g., \texttt{ImageMagick} or
custom diff with tolerance. Keep baselines per theme/resolution to avoid
false positives.

If you need Avalonia to drive the render loop before reading pixels,
call \texttt{CaptureRenderedFrame()} instead of
\texttt{GetLastRenderedFrame()}---it schedules a composition pass and
forces a render tick. This mirrors what desktop renderers do when they
flush the \texttt{CompositionTarget}, keeping the snapshot pipeline
close to production.

\subsection{5. Organizing tests}\label{organizing-tests}

\begin{itemize}
\tightlist
\item
  \textbf{ViewModel tests}: no Avalonia dependencies; test commands and
  property changes (fastest).
\item
  \textbf{Control tests}: headless platform; simulate inputs to verify
  states.
\item
  \textbf{Visual regression}: limited number; capture frames and
  compare.
\item
  \textbf{Integration/E2E}: run full app with navigation; keep few due
  to complexity.
\end{itemize}

\subsection{6. Custom fixtures and automation
hooks}\label{custom-fixtures-and-automation-hooks}

\begin{itemize}
\tightlist
\item
  Build reusable fixtures around
  \texttt{HeadlessUnitTestSession.StartNew(typeof(App))} when you need
  deterministic startup logic outside the provided xUnit/NUnit
  attributes. Wrap it in \texttt{IAsyncLifetime} so tests share a
  dispatcher loop safely.
\item
  Register platform services for tests inside the session by entering an
  \texttt{AvaloniaLocator} scope and injecting fakes (e.g., mock
  \texttt{IClipboard}, stub \texttt{IStorageProvider}).
\item
  Expose convenience methods (e.g.,
  \texttt{ShowControlAsync\textless{}TControl\textgreater{}()}) that
  create a \texttt{Window}, attach the control, call
  \texttt{ForceRenderTimerTick}, and return the control for assertions.
\item
  For automation cues, use Avalonia's UI automation peers: call
  \texttt{AutomationPeer.CreatePeerForElement(control)} and assert
  patterns (\texttt{InvokePattern}, \texttt{ValuePattern}) without
  relying on visual tree traversal.
\item
  Study the headless unit tests in
  \texttt{external/Avalonia/tests/Avalonia.Headless.UnitTests} for
  patterns that wrap \texttt{AppBuilder} and expose helpers for reuse
  across cases.
\end{itemize}

\subsection{7. Advanced headless
scenarios}\label{advanced-headless-scenarios}

\subsubsection{7.1 VNC mode}\label{vnc-mode}

For debugging, you can run headless with a VNC server and observe the
UI.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UseHeadless}\OperatorTok{(}\KeywordTok{new}\NormalTok{ AvaloniaHeadlessPlatformOptions }\OperatorTok{\{}\NormalTok{ UseVnc }\OperatorTok{=} \KeywordTok{true}\OperatorTok{,}\NormalTok{ UseSkia }\OperatorTok{=} \KeywordTok{true} \OperatorTok{\})}
    \OperatorTok{.}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Connect with a VNC client to view frames and interact.

\subsubsection{7.2 Simulating time \&
timers}\label{simulating-time-timers}

Use \texttt{AvaloniaHeadlessPlatform.ForceRenderTimerTick()} to advance
timers. For \texttt{DispatcherTimer} or animations, call it repeatedly.

\subsubsection{7.3 File system in tests}\label{file-system-in-tests}

For file-based assertions, use in-memory streams or temp directories.
Avoid writing to the repo path; tests should be self-cleaning.

\subsection{8. Testing async flows}\label{testing-async-flows}

\begin{itemize}
\tightlist
\item
  Use \texttt{Dispatcher.UIThread.InvokeAsync} for UI updates.
\item
  Await tasks; avoid \texttt{.Result} or \texttt{.Wait()}.
\item
  To wait for state changes, poll with timeout:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{async Task }\FunctionTok{WaitForAsync}\OperatorTok{(}\NormalTok{Func}\OperatorTok{\textless{}}\DataTypeTok{bool}\OperatorTok{\textgreater{}}\NormalTok{ condition}\OperatorTok{,}\NormalTok{ TimeSpan timeout}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ deadline }\OperatorTok{=}\NormalTok{ DateTime}\OperatorTok{.}\FunctionTok{UtcNow} \OperatorTok{+}\NormalTok{ timeout}\OperatorTok{;}
    \KeywordTok{while} \OperatorTok{(!}\FunctionTok{condition}\OperatorTok{())}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{DateTime}\OperatorTok{.}\FunctionTok{UtcNow} \OperatorTok{\textgreater{}}\NormalTok{ deadline}\OperatorTok{)}
            \KeywordTok{throw} \KeywordTok{new} \FunctionTok{TimeoutException}\OperatorTok{(}\StringTok{"Condition not met"}\OperatorTok{);}
\NormalTok{        AvaloniaHeadlessPlatform}\OperatorTok{.}\FunctionTok{ForceRenderTimerTick}\OperatorTok{();}
\NormalTok{        await Task}\OperatorTok{.}\FunctionTok{Delay}\OperatorTok{(}\DecValTok{10}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{9. CI integration}\label{ci-integration}

\begin{itemize}
\tightlist
\item
  Headless tests run under \texttt{dotnet\ test} in GitHub Actions/Azure
  Pipelines/GitLab.
\item
  On Linux CI, no display server required (no \texttt{Xvfb}).
\item
  Provide environment variables or test-specific configuration as
  needed.
\item
  Collect snapshots as build artifacts when tests fail (optional).
\end{itemize}

\subsection{10. Practice exercises}\label{practice-exercises-15}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a headless test that types into a TextBox, presses Enter, and
  asserts a command executed.
\item
  Simulate a drag-and-drop using \texttt{DragDrop} helpers and confirm
  target list received data.
\item
  Capture a frame of an entire form and compare to a baseline image
  stored under \texttt{tests/BaselineImages}.
\item
  Create a test fixture that launches the app's main view, navigates to
  a secondary page, and verifies a label text.
\item
  Add headless tests to CI and configure the pipeline to upload snapshot
  diffs for failing cases.
\item
  Write an automation-focused test that inspects \texttt{AutomationPeer}
  patterns (Invoke/Value) to validate accessibility contracts alongside
  visual assertions.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-19}

\begin{itemize}
\tightlist
\item
  Headless platform setup:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Headless/Avalonia.Headless/AvaloniaHeadlessPlatform.cs}{\texttt{AvaloniaHeadlessPlatform.cs}}
\item
  Session control:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Headless/Avalonia.Headless/HeadlessUnitTestSession.cs}{\texttt{HeadlessUnitTestSession.cs}}
\item
  Input helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Headless/Avalonia.Headless/HeadlessWindowExtensions.cs}{\texttt{HeadlessWindowExtensions}}
\item
  Test adapters:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Headless/Avalonia.Headless.XUnit}{\texttt{Avalonia.Headless.XUnit}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Headless/Avalonia.Headless.NUnit}{\texttt{Avalonia.Headless.NUnit}}
\item
  Samples:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/tests/Avalonia.Headless.UnitTests}{\texttt{tests/Avalonia.Headless.UnitTests}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/tests/Avalonia.Headless.XUnit.UnitTests}{\texttt{tests/Avalonia.Headless.XUnit.UnitTests}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-19}

\begin{itemize}
\tightlist
\item
  How do you initialize the headless platform for xUnit? Which attribute
  is required?
\item
  How do you simulate keyboard and pointer input in headless tests?
\item
  What steps are needed to capture rendered frames? Why might you use
  them sparingly?
\item
  How can you run the headless platform visually (e.g., via VNC) for
  debugging?
\item
  How does your test strategy balance view model tests, control tests,
  and visual regression tests?
\item
  When would you reach for AutomationPeers in headless tests instead of
  asserting on visuals alone?
\end{itemize}

What's next - Next: \href{Chapter22.md}{Chapter 22}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part V — Rendering, tooling, optimization, and contributing}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part V — Rendering, tooling, optimization, and contributing}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{22. Rendering pipeline in plain
words}\label{rendering-pipeline-in-plain-words}

Goal - Understand how Avalonia turns your visual tree into frames across
every backend. - Know the responsibilities of the UI thread, render
loop, compositor, renderer, and GPU interface. - Learn how to tune
rendering with \texttt{SkiaOptions}, \texttt{RenderOptions}, timers, and
diagnostics tools.

Why this matters - Smooth, power-efficient UI depends on understanding
what triggers redraws and how Avalonia schedules work. - Debugging
rendering glitches is easier when you know each component's role.

Prerequisites - Chapter 17 (async/background) for thread awareness,
Chapter 18/19 (platform differences).

\subsection{1. Mental model}\label{mental-model}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{UI thread} builds and updates the visual tree
  (\texttt{Visual}s/\texttt{Control}s). When properties change, visuals
  mark themselves dirty (e.g., via \texttt{InvalidateVisual}).
\item
  \textbf{Scene graph} represents visuals and draw operations in a
  batched form (\texttt{SceneGraph.cs}).
\item
  \textbf{Compositor} commits scene graph updates to the render thread
  and keeps track of dirty rectangles.
\item
  \textbf{Render loop} (driven by an \texttt{IRenderTimer}) asks the
  renderer to draw frames while work is pending.
\item
  \textbf{Renderer} walks the scene graph, issues drawing commands, and
  marshals them to Skia or another backend.
\item
  \textbf{Skia/render interface} rasterizes shapes/text/images into GPU
  textures (or CPU bitmaps) before the platform swapchain presents the
  frame.
\end{enumerate}

Avalonia uses two main threads: UI thread and render thread. Keep the UI
thread free of long-running work so animations, input dispatch, and
composition stay responsive.

\subsection{2. UI thread: creating and invalidating
visuals}\label{ui-thread-creating-and-invalidating-visuals}

\begin{itemize}
\tightlist
\item
  \texttt{Visual}s have properties (\texttt{Bounds}, \texttt{Opacity},
  \texttt{Transform}, etc.) that trigger redraw when changed.
\item
  \texttt{InvalidateVisual()} marks a visual dirty. Most controls call
  this automatically when a property changes.
\item
  Layout changes may also mark visuals dirty (e.g., size change).
\end{itemize}

\subsection{3. Render thread and renderer
pipeline}\label{render-thread-and-renderer-pipeline}

\begin{itemize}
\tightlist
\item
  \texttt{IRenderer} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/IRenderer.cs}{\texttt{IRenderer.cs}})
  exposes methods:

  \begin{itemize}
  \tightlist
  \item
    \texttt{AddDirty(Visual\ visual)} --- mark dirty region.
  \item
    \texttt{Paint} --- handle paint request (e.g., OS says ``redraw
    now'').
  \item
    \texttt{Resized} --- update when target size changes.
  \item
    \texttt{Start}/\texttt{Stop} --- hook into render loop lifetime.
  \end{itemize}
\end{itemize}

Avalonia ships both \texttt{CompositingRenderer} (default) and
\texttt{DeferredRenderer}. The renderer uses dirty rectangles to redraw
minimal regions and produces scene graph nodes consumed by Skia.

\subsubsection{CompositionTarget}\label{compositiontarget}

\texttt{CompositionTarget} abstracts the surface being rendered. It
holds references to swapchains, frame buffers, and frame timing metrics.
You usually observe it through \texttt{IRenderer.Diagnostics} (frame
times, dirty rect counts) or via DevTools/remote diagnostics rather than
accessing the object directly.

\subsubsection{Immediate renderer}\label{immediate-renderer}

\texttt{ImmediateRenderer} renders a visual subtree synchronously into a
\texttt{DrawingContext}. Used for \texttt{RenderTargetBitmap},
\texttt{VisualBrush}, etc. Not used for normal window presentation.

\subsection{4. Compositor and render
loop}\label{compositor-and-render-loop}

The compositor orchestrates UI → render thread updates (see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/Composition/Compositor.cs}{\texttt{Compositor.cs}}).

\begin{itemize}
\tightlist
\item
  Batches (serialized UI tree updates) are committed to the render
  thread.
\item
  \texttt{RenderLoop} ticks at platform-defined cadence (vsync/animation
  timers). When there's dirty content or \texttt{CompositionTarget}
  animations, it schedules a frame.
\item
  Render loop ensures frames draw at stable cadence even if the UI
  thread is momentarily busy.
\end{itemize}

\subsubsection{Render timers}\label{render-timers}

\begin{itemize}
\tightlist
\item
  \texttt{IRenderTimer} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/IRenderTimer.cs}{\texttt{IRenderTimer.cs}})
  abstracts ticking. Implementations include
  \texttt{DefaultRenderTimer}, \texttt{DispatcherRenderTimer}, and
  headless timers used in tests.
\item
  Customize via
  \texttt{AppBuilder.UseRenderLoop(new\ RenderLoop(new\ DispatcherRenderTimer()))}
  to integrate external timing sources (e.g., game loops).
\item
  Timers raise \texttt{Tick} on the render thread. Avoid heavy work in
  handlers: queue work through the UI thread if necessary.
\end{itemize}

\subsubsection{Scene graph commits}\label{scene-graph-commits}

Each \texttt{RenderLoop} tick calls \texttt{Compositor.CommitScenes}.
The compositor transforms dirty visuals into render passes, prunes
unchanged branches, and tracks retained GPU resources for reuse across
frames.

\subsection{5. Backend selection and GPU
interfaces}\label{backend-selection-and-gpu-interfaces}

Avalonia targets multiple render interfaces via
\texttt{IRenderInterface}. Skia is the default implementation and
chooses GPU versus CPU paths per platform.

\subsubsection{Backend selection logic}\label{backend-selection-logic}

\begin{itemize}
\tightlist
\item
  Desktop defaults to GPU (OpenGL/ANGLE on Windows, OpenGL/Vulkan on
  Linux, Metal on macOS).
\item
  Mobile uses OpenGL ES (Android) or Metal (iOS/macOS Catalyst).
\item
  Browser compiles Skia to WebAssembly and falls back to
  WebGL2/WebGL1/software.
\item
  Server/headless falls back to CPU rendering.
\end{itemize}

Force a backend with
\texttt{UseSkia(new\ SkiaOptions\ \{\ RenderMode\ =\ RenderMode.Software\ \})}
or by setting \texttt{AVALONIA\_RENDERER} environment variable (e.g.,
\texttt{software}, \texttt{open\_gl}). Always pair overrides with tests
on target hardware.

\subsubsection{GPU resource management}\label{gpu-resource-management}

\begin{itemize}
\tightlist
\item
  \texttt{SkiaOptions} exposes GPU cache limits and toggles like
  \texttt{UseOpacitySaveLayer}.
\item
  \texttt{IRenderSurface} implementations (swapchains, framebuffers) own
  platform handles; leaks appear as rising
  \texttt{RendererDiagnostics.SceneGraphDirtyRectCount}.
\end{itemize}

\subsubsection{Skia configuration}\label{skia-configuration}

Avalonia uses Skia for cross-platform drawing: - GPU or CPU rendering
depending on platform capabilities. - GPU backend chosen automatically
(OpenGL, ANGLE, Metal, Vulkan, WebGL, etc.). -
\texttt{UseSkia(new\ SkiaOptions\ \{\ ...\ \})} in \texttt{AppBuilder}
to tune.

\subsubsection{SkiaOptions}\label{skiaoptions}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{UseSkia}\OperatorTok{(}\KeywordTok{new}\NormalTok{ SkiaOptions}
    \OperatorTok{\{}
\NormalTok{        MaxGpuResourceSizeBytes }\OperatorTok{=} \DecValTok{64L} \OperatorTok{*} \DecValTok{1024} \OperatorTok{*} \DecValTok{1024}\OperatorTok{,}
\NormalTok{        UseOpacitySaveLayer }\OperatorTok{=} \KeywordTok{false}
    \OperatorTok{\})}
    \OperatorTok{.}\FunctionTok{LogToTrace}\OperatorTok{();}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{MaxGpuResourceSizeBytes}: limit Skia resource cache.
\item
  \texttt{UseOpacitySaveLayer}: forces Skia to use save layers for
  opacity stacking (accuracy vs performance).
\end{itemize}

\subsection{6. RenderOptions (per
Visual)}\label{renderoptions-per-visual}

\texttt{RenderOptions} attached properties influence interpolation and
text rendering: - \texttt{BitmapInterpolationMode}: Low/Medium/High
quality vs default. - \texttt{BitmapBlendingMode}: blend mode for
images. - \texttt{TextRenderingMode}: Default, Antialias,
SubpixelAntialias, Aliased. - \texttt{EdgeMode}: Antialias vs Aliased
for geometry edges. - \texttt{RequiresFullOpacityHandling}: handle
complex opacity composition.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{RenderOptions}\OperatorTok{.}\FunctionTok{SetBitmapInterpolationMode}\OperatorTok{(}\NormalTok{image}\OperatorTok{,}\NormalTok{ BitmapInterpolationMode}\OperatorTok{.}\FunctionTok{HighQuality}\OperatorTok{);}
\NormalTok{RenderOptions}\OperatorTok{.}\FunctionTok{SetTextRenderingMode}\OperatorTok{(}\NormalTok{smallText}\OperatorTok{,}\NormalTok{ TextRenderingMode}\OperatorTok{.}\FunctionTok{Aliased}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

RenderOptions apply to a visual and flow down to children unless
overridden.

\subsection{7. When does a frame
render?}\label{when-does-a-frame-render}

\begin{itemize}
\tightlist
\item
  Property changes on visuals (brush, text, transform).
\item
  Layout updates affecting size/position.
\item
  Animations (composition or binding-driven) schedule continuous frames.
\item
  Input (pointer events) may cause immediate redraw (e.g., ripple
  effect).
\item
  External events: window resize, DPI change.
\end{itemize}

Prevent unnecessary redraws: - Avoid toggling properties frequently
without change. - Batch updates on UI thread; let binding/animation
handle smooth changes. - Free large bitmaps once no longer needed.

\subsection{8. Frame timing
instrumentation}\label{frame-timing-instrumentation}

\subsubsection{Renderer diagnostics}\label{renderer-diagnostics}

\begin{itemize}
\tightlist
\item
  Enable \texttt{RendererDiagnostics} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDiagnostics.cs}{\texttt{RendererDiagnostics.cs}})
  via \texttt{RenderRoot.Renderer.Diagnostics}. Metrics include dirty
  rectangle counts, render phase durations, and draw call tallies.
\item
  Pair diagnostics with \texttt{SceneInvalidated}/\texttt{RenderLoop}
  timestamps to push frame data into tracing systems such as
  \texttt{EventSource} or Prometheus exporters.
\end{itemize}

\subsubsection{DevTools}\label{devtools}

\begin{itemize}
\tightlist
\item
  Press \texttt{F12} to open DevTools.
\item
  \texttt{Diagnostics} panel toggles overlays and displays frame timing
  graphs.
\item
  \texttt{Rendering} view (when available) shows render loop cadence,
  render thread load, and GPU backend in use.
\end{itemize}

\subsubsection{Logging}\label{logging}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{LogToTrace}\OperatorTok{(}\NormalTok{LogEventLevel}\OperatorTok{.}\FunctionTok{Debug}\OperatorTok{,} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{}\NormalTok{ LogArea}\OperatorTok{.}\FunctionTok{Rendering}\OperatorTok{,}\NormalTok{ LogArea}\OperatorTok{.}\FunctionTok{Layout} \OperatorTok{\})}
    \OperatorTok{.}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Render overlays}\label{render-overlays}

\texttt{RendererDebugOverlays} (see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDebugOverlays.cs}{\texttt{RendererDebugOverlays.cs}})
enable overlays showing dirty rectangles, FPS, layout costs.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \OperatorTok{(}\NormalTok{TopLevel }\KeywordTok{is} \OperatorTok{\{}\NormalTok{ Renderer}\OperatorTok{:} \OperatorTok{\{} \OperatorTok{\}}\NormalTok{ renderer }\OperatorTok{\})}
\NormalTok{    renderer}\OperatorTok{.}\FunctionTok{DebugOverlays} \OperatorTok{=}\NormalTok{ RendererDebugOverlays}\OperatorTok{.}\FunctionTok{Fps} \OperatorTok{|}\NormalTok{ RendererDebugOverlays}\OperatorTok{.}\FunctionTok{LayoutTimeGraph}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Tools}\label{tools}

\begin{itemize}
\tightlist
\item
  Use .NET memory profiler or \texttt{dotnet-counters} to monitor GC
  while animating UI.
\item
  GPU profilers (RenderDoc) can capture Skia GPU commands (advanced
  scenario).
\item
  \texttt{Avalonia.Diagnostics.RenderingDebugOverlays} integrates with
  \texttt{Avalonia.Remote.Protocol}. Use \texttt{avalonia-devtools://}
  clients to stream metrics from remote devices (Chapter 24).
\end{itemize}

\subsection{9. Immediate rendering
utilities}\label{immediate-rendering-utilities}

\subsubsection{RenderTargetBitmap}\label{rendertargetbitmap}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ bitmap }\OperatorTok{=} \KeywordTok{new} \FunctionTok{RenderTargetBitmap}\OperatorTok{(}\KeywordTok{new} \FunctionTok{PixelSize}\OperatorTok{(}\DecValTok{300}\OperatorTok{,} \DecValTok{200}\OperatorTok{),} \KeywordTok{new} \FunctionTok{Vector}\OperatorTok{(}\DecValTok{96}\OperatorTok{,} \DecValTok{96}\OperatorTok{));}
\NormalTok{await bitmap}\OperatorTok{.}\FunctionTok{RenderAsync}\OperatorTok{(}\NormalTok{myControl}\OperatorTok{);}
\NormalTok{bitmap}\OperatorTok{.}\FunctionTok{Save}\OperatorTok{(}\StringTok{"snapshot.png"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Uses \texttt{ImmediateRenderer} to render a control off-screen.

\subsubsection{Drawing manually}\label{drawing-manually}

\texttt{DrawingContext} allows custom drawing via immediate renderer.

\subsection{10. Platform-specific notes}\label{platform-specific-notes}

\begin{itemize}
\tightlist
\item
  Windows: GPU backend typically ANGLE (OpenGL) or D3D via Skia;
  transparency support (Mica/Acrylic) may involve compositor-level
  effects.
\item
  macOS: uses Metal via Skia; retina scaling via \texttt{RenderScaling}.
\item
  Linux: OpenGL (or Vulkan) depending on driver; virtualization/backends
  vary.
\item
  Mobile: OpenGL ES on Android, Metal on iOS; consider battery impact
  when scheduling animations.
\item
  Browser: WebGL2/WebGL1/Software2D (Chapter 20); one-threaded unless
  WASM threading enabled.
\end{itemize}

\subsection{11. Practice exercises}\label{practice-exercises-16}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Replace the render timer with a custom \texttt{IRenderTimer}
  implementation and graph frame cadence using timestamps collected from
  \texttt{SceneInvalidated}.
\item
  Override \texttt{SkiaOptions.RenderMode} to force software rendering,
  then switch back to GPU; profile render time using overlays in both
  modes.
\item
  Capture frame diagnostics
  (\texttt{RendererDebugOverlays.LayoutTimeGraph\ \textbar{}\ RenderTimeGraph})
  during an animation and export metrics for analysis.
\item
  Instrument \texttt{RenderRoot.Renderer.Diagnostics} to log dirty
  rectangle counts when toggling \texttt{InvalidateVisual}; correlate
  with DevTools overlays.
\item
  Use DevTools remote transport to attach from another process (Chapter
  24) and verify frame timing matches local instrumentation.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-20}

\begin{itemize}
\tightlist
\item
  Renderer interface:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/IRenderer.cs}{\texttt{IRenderer.cs}}
\item
  Compositor:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/Composition/Compositor.cs}{\texttt{Compositor.cs}}
\item
  Scene graph:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/Composition/Drawing/RenderDataDrawingContext.cs}{\texttt{RenderDataDrawingContext.cs}}
\item
  Immediate renderer:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/ImmediateRenderer.cs}{\texttt{ImmediateRenderer.cs}}
\item
  Render loop:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RenderLoop.cs}{\texttt{RenderLoop.cs}}
\item
  Render timer abstraction:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/IRenderTimer.cs}{\texttt{IRenderTimer.cs}}
\item
  Render options:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/RenderOptions.cs}{\texttt{RenderOptions.cs}}
\item
  Skia options and platform interface:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Skia/Avalonia.Skia/SkiaOptions.cs}{\texttt{SkiaOptions.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Skia/Avalonia.Skia/PlatformRenderInterface.cs}{\texttt{PlatformRenderInterface.cs}}
\item
  Renderer diagnostics:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDiagnostics.cs}{\texttt{RendererDiagnostics.cs}}
\item
  Debug overlays:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDebugOverlays.cs}{\texttt{RendererDebugOverlays.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-20}

\begin{itemize}
\tightlist
\item
  What components run on the UI thread vs render thread?
\item
  How does \texttt{InvalidateVisual} lead to a new frame?
\item
  When would you adjust \texttt{SkiaOptions.MaxGpuResourceSizeBytes} vs
  \texttt{RenderOptions.BitmapInterpolationMode}?
\item
  What tools help you diagnose rendering bottlenecks?
\end{itemize}

What's next - Next: \href{Chapter23.md}{Chapter 23}

\newpage

\subsection{23. Custom drawing and custom
controls}\label{custom-drawing-and-custom-controls}

Goal - Decide when to custom draw (override \texttt{Render}) versus
build templated controls (pure XAML). - Master \texttt{DrawingContext},
invalidation (\texttt{AffectsRender}, \texttt{InvalidateVisual}), and
caching for performance. - Structure a restylable
\texttt{TemplatedControl}, expose properties, and support
theming/accessibility.

Why this matters - Charts, gauges, and other visuals often need custom
drawing. Understanding rendering and templating keeps your controls fast
and customizable. - Well-structured controls enable reuse and consistent
theming.

Prerequisites - Chapter 22 (rendering pipeline), Chapter 15
(accessibility), Chapter 16 (storage for exporting images if needed).

\subsection{1. Choosing an approach}\label{choosing-an-approach}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Scenario & Draw (override \texttt{Render}) & Template
(\texttt{ControlTemplate}) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Pixel-perfect graphics, charts & {[}x{]} & \\
Animations driven by drawing primitives & {[}x{]} & \\
Standard widgets composed of existing controls & & {[}x{]} \\
Consumer needs to restyle via XAML & & {[}x{]} \\
Complex interaction per element (buttons in control) & & {[}x{]} \\
\end{longtable}

Hybrid: templated control containing a custom-drawn child for
performance-critical surface.

\subsection{2. Invalidation basics}\label{invalidation-basics}

\begin{itemize}
\tightlist
\item
  \texttt{InvalidateVisual()} schedules redraw.
\item
  Register property changes via
  \texttt{AffectsRender\textless{}TControl\textgreater{}(property1,\ ...)}
  in static constructor to auto-invalidate on property change.
\item
  For layout changes, use \texttt{InvalidateMeasure} similarly (handled
  automatically for \texttt{StyledProperty}s registered with
  \texttt{AffectsMeasure}).
\end{itemize}

\subsection{3. DrawingContext
essentials}\label{drawingcontext-essentials}

\texttt{DrawingContext} primitives: -
\texttt{DrawGeometry(brush,\ pen,\ geometry)} -
\texttt{DrawRectangle}/\texttt{DrawEllipse} -
\texttt{DrawImage(image,\ sourceRect,\ destRect)} -
\texttt{DrawText(formattedText,\ origin)} - \texttt{PushClip},
\texttt{PushOpacity}, \texttt{PushOpacityMask}, \texttt{PushTransform}
-- use in \texttt{using} blocks to auto-pop state.

Example pattern:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{Render}\OperatorTok{(}\NormalTok{DrawingContext ctx}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{base}\OperatorTok{.}\FunctionTok{Render}\OperatorTok{(}\NormalTok{ctx}\OperatorTok{);}
    \KeywordTok{using} \OperatorTok{(}\NormalTok{ctx}\OperatorTok{.}\FunctionTok{PushClip}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Rect}\OperatorTok{(}\NormalTok{Bounds}\OperatorTok{.}\FunctionTok{Size}\OperatorTok{)))}
    \OperatorTok{\{}
\NormalTok{        ctx}\OperatorTok{.}\FunctionTok{DrawRectangle}\OperatorTok{(}\NormalTok{Brushes}\OperatorTok{.}\FunctionTok{Black}\OperatorTok{,} \KeywordTok{null}\OperatorTok{,}\NormalTok{ Bounds}\OperatorTok{);}
\NormalTok{        ctx}\OperatorTok{.}\FunctionTok{DrawText}\OperatorTok{(}\NormalTok{\_formattedText}\OperatorTok{,} \KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{10}\OperatorTok{));}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{4. Template lifecycle, presenters, and template
results}\label{template-lifecycle-presenters-and-template-results}

\begin{itemize}
\tightlist
\item
  \texttt{TemplatedControl} raises \texttt{TemplateApplied} when the
  \texttt{ControlTemplate} is inflated. Override
  \texttt{OnApplyTemplate(TemplateAppliedEventArgs\ e)} to wire named
  parts via \texttt{e.NameScope}.
\item
  Templates compiled from XAML return a
  \texttt{TemplateResult\textless{}Control\textgreater{}} behind the
  scenes (\texttt{ControlTemplate.Build}). It carries a
  \texttt{NameScope} so you can fetch presenters
  (\texttt{e.NameScope.Find\textless{}ContentPresenter\textgreater{}("PART\_Content")}).
\item
  Common presenters include \texttt{ContentPresenter},
  \texttt{ItemsPresenter}, \texttt{ScrollContentPresenter}, and
  \texttt{ToggleSwitchPresenter}. They bridge templated surfaces with
  logical children (content, items, scrollable regions).
\item
  Use \texttt{TemplateApplied} to subscribe to events on named parts,
  but always detach previous handlers before attaching new ones to
  prevent leaks.
\end{itemize}

Example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnApplyTemplate}\OperatorTok{(}\NormalTok{TemplateAppliedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnApplyTemplate}\OperatorTok{(}\NormalTok{e}\OperatorTok{);}
\NormalTok{    \_toggleRoot}\OperatorTok{?.}\FunctionTok{PointerPressed} \OperatorTok{{-}=}\NormalTok{ OnToggle}\OperatorTok{;}
\NormalTok{    \_toggleRoot }\OperatorTok{=}\NormalTok{ e}\OperatorTok{.}\FunctionTok{NameScope}\OperatorTok{.}\FunctionTok{Find}\OperatorTok{\textless{}}\NormalTok{Border}\OperatorTok{\textgreater{}(}\StringTok{"PART\_ToggleRoot"}\OperatorTok{);}
\NormalTok{    \_toggleRoot}\OperatorTok{?.}\FunctionTok{PointerPressed} \OperatorTok{+=}\NormalTok{ OnToggle}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

For library-ready controls publish a \texttt{ControlTheme} default
template so consumers can restyle without copying large XAML fragments.

\subsection{5. Example: Sparkline (custom
draw)}\label{example-sparkline-custom-draw}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ Sparkline }\OperatorTok{:}\NormalTok{ Control}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static} \KeywordTok{readonly}\NormalTok{ StyledProperty}\OperatorTok{\textless{}}\NormalTok{IReadOnlyList}\OperatorTok{\textless{}}\DataTypeTok{double}\OperatorTok{\textgreater{}?\textgreater{}}\NormalTok{ ValuesProperty }\OperatorTok{=}
\NormalTok{        AvaloniaProperty}\OperatorTok{.}\FunctionTok{Register}\OperatorTok{\textless{}}\NormalTok{Sparkline}\OperatorTok{,}\NormalTok{ IReadOnlyList}\OperatorTok{\textless{}}\DataTypeTok{double}\OperatorTok{\textgreater{}?\textgreater{}(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{Values}\OperatorTok{));}

    \KeywordTok{public} \KeywordTok{static} \KeywordTok{readonly}\NormalTok{ StyledProperty}\OperatorTok{\textless{}}\NormalTok{IBrush}\OperatorTok{\textgreater{}}\NormalTok{ StrokeProperty }\OperatorTok{=}
\NormalTok{        AvaloniaProperty}\OperatorTok{.}\FunctionTok{Register}\OperatorTok{\textless{}}\NormalTok{Sparkline}\OperatorTok{,}\NormalTok{ IBrush}\OperatorTok{\textgreater{}(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{Stroke}\OperatorTok{),}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{DeepSkyBlue}\OperatorTok{);}

    \KeywordTok{public} \KeywordTok{static} \KeywordTok{readonly}\NormalTok{ StyledProperty}\OperatorTok{\textless{}}\DataTypeTok{double}\OperatorTok{\textgreater{}}\NormalTok{ StrokeThicknessProperty }\OperatorTok{=}
\NormalTok{        AvaloniaProperty}\OperatorTok{.}\FunctionTok{Register}\OperatorTok{\textless{}}\NormalTok{Sparkline}\OperatorTok{,} \DataTypeTok{double}\OperatorTok{\textgreater{}(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{StrokeThickness}\OperatorTok{),} \FloatTok{2.0}\OperatorTok{);}

    \KeywordTok{static} \FunctionTok{Sparkline}\OperatorTok{()}
    \OperatorTok{\{}
\NormalTok{        AffectsRender}\OperatorTok{\textless{}}\NormalTok{Sparkline}\OperatorTok{\textgreater{}(}\NormalTok{ValuesProperty}\OperatorTok{,}\NormalTok{ StrokeProperty}\OperatorTok{,}\NormalTok{ StrokeThicknessProperty}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{public}\NormalTok{ IReadOnlyList}\OperatorTok{\textless{}}\DataTypeTok{double}\OperatorTok{\textgreater{}?}\NormalTok{ Values}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}} \FunctionTok{GetValue}\OperatorTok{(}\NormalTok{ValuesProperty}\OperatorTok{);}
\NormalTok{        set }\OperatorTok{=\textgreater{}} \FunctionTok{SetValue}\OperatorTok{(}\NormalTok{ValuesProperty}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{public}\NormalTok{ IBrush Stroke}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}} \FunctionTok{GetValue}\OperatorTok{(}\NormalTok{StrokeProperty}\OperatorTok{);}
\NormalTok{        set }\OperatorTok{=\textgreater{}} \FunctionTok{SetValue}\OperatorTok{(}\NormalTok{StrokeProperty}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{double}\NormalTok{ StrokeThickness}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}} \FunctionTok{GetValue}\OperatorTok{(}\NormalTok{StrokeThicknessProperty}\OperatorTok{);}
\NormalTok{        set }\OperatorTok{=\textgreater{}} \FunctionTok{SetValue}\OperatorTok{(}\NormalTok{StrokeThicknessProperty}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{Render}\OperatorTok{(}\NormalTok{DrawingContext ctx}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{base}\OperatorTok{.}\FunctionTok{Render}\OperatorTok{(}\NormalTok{ctx}\OperatorTok{);}
        \DataTypeTok{var}\NormalTok{ values }\OperatorTok{=}\NormalTok{ Values}\OperatorTok{;}
        \DataTypeTok{var}\NormalTok{ bounds }\OperatorTok{=}\NormalTok{ Bounds}\OperatorTok{;}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{values }\KeywordTok{is} \KeywordTok{null} \OperatorTok{||}\NormalTok{ values}\OperatorTok{.}\FunctionTok{Count} \OperatorTok{\textless{}} \DecValTok{2} \OperatorTok{||}\NormalTok{ bounds}\OperatorTok{.}\FunctionTok{Width} \OperatorTok{\textless{}=} \DecValTok{0} \OperatorTok{||}\NormalTok{ bounds}\OperatorTok{.}\FunctionTok{Height} \OperatorTok{\textless{}=} \DecValTok{0}\OperatorTok{)}
            \KeywordTok{return}\OperatorTok{;}

        \DataTypeTok{double}\NormalTok{ min }\OperatorTok{=}\NormalTok{ values}\OperatorTok{.}\FunctionTok{Min}\OperatorTok{();}
        \DataTypeTok{double}\NormalTok{ max }\OperatorTok{=}\NormalTok{ values}\OperatorTok{.}\FunctionTok{Max}\OperatorTok{();}
        \DataTypeTok{double}\NormalTok{ range }\OperatorTok{=}\NormalTok{ Math}\OperatorTok{.}\FunctionTok{Max}\OperatorTok{(}\FloatTok{1e{-}9}\OperatorTok{,}\NormalTok{ max }\OperatorTok{{-}}\NormalTok{ min}\OperatorTok{);}

        \KeywordTok{using} \DataTypeTok{var}\NormalTok{ geometry }\OperatorTok{=} \KeywordTok{new} \FunctionTok{StreamGeometry}\OperatorTok{();}
        \KeywordTok{using} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ gctx }\OperatorTok{=}\NormalTok{ geometry}\OperatorTok{.}\FunctionTok{Open}\OperatorTok{())}
        \OperatorTok{\{}
            \KeywordTok{for} \OperatorTok{(}\DataTypeTok{int}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ values}\OperatorTok{.}\FunctionTok{Count}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++)}
            \OperatorTok{\{}
                \DataTypeTok{double}\NormalTok{ t }\OperatorTok{=}\NormalTok{ i }\OperatorTok{/} \OperatorTok{(}\DataTypeTok{double}\OperatorTok{)(}\NormalTok{values}\OperatorTok{.}\FunctionTok{Count} \OperatorTok{{-}} \DecValTok{1}\OperatorTok{);}
                \DataTypeTok{double}\NormalTok{ x }\OperatorTok{=}\NormalTok{ bounds}\OperatorTok{.}\FunctionTok{X} \OperatorTok{+}\NormalTok{ t }\OperatorTok{*}\NormalTok{ bounds}\OperatorTok{.}\FunctionTok{Width}\OperatorTok{;}
                \DataTypeTok{double}\NormalTok{ yNorm }\OperatorTok{=} \OperatorTok{(}\NormalTok{values}\OperatorTok{[}\NormalTok{i}\OperatorTok{]} \OperatorTok{{-}}\NormalTok{ min}\OperatorTok{)} \OperatorTok{/}\NormalTok{ range}\OperatorTok{;}
                \DataTypeTok{double}\NormalTok{ y }\OperatorTok{=}\NormalTok{ bounds}\OperatorTok{.}\FunctionTok{Y} \OperatorTok{+} \OperatorTok{(}\DecValTok{1} \OperatorTok{{-}}\NormalTok{ yNorm}\OperatorTok{)} \OperatorTok{*}\NormalTok{ bounds}\OperatorTok{.}\FunctionTok{Height}\OperatorTok{;}
                \KeywordTok{if} \OperatorTok{(}\NormalTok{i }\OperatorTok{==} \DecValTok{0}\OperatorTok{)}
\NormalTok{                    gctx}\OperatorTok{.}\FunctionTok{BeginFigure}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{),}\NormalTok{ isFilled}\OperatorTok{:} \KeywordTok{false}\OperatorTok{);}
                \KeywordTok{else}
\NormalTok{                    gctx}\OperatorTok{.}\FunctionTok{LineTo}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{));}
            \OperatorTok{\}}
\NormalTok{            gctx}\OperatorTok{.}\FunctionTok{EndFigure}\OperatorTok{(}\KeywordTok{false}\OperatorTok{);}
        \OperatorTok{\}}

        \DataTypeTok{var}\NormalTok{ pen }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Pen}\OperatorTok{(}\NormalTok{Stroke}\OperatorTok{,}\NormalTok{ StrokeThickness}\OperatorTok{);}
\NormalTok{        ctx}\OperatorTok{.}\FunctionTok{DrawGeometry}\OperatorTok{(}\KeywordTok{null}\OperatorTok{,}\NormalTok{ pen}\OperatorTok{,}\NormalTok{ geometry}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Usage:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{local:Sparkline}\OtherTok{ Width=}\StringTok{"160"}\OtherTok{ Height=}\StringTok{"36"}\OtherTok{ Values=}\StringTok{"3,7,4,8,12"}\OtherTok{ StrokeThickness=}\StringTok{"2"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Performance tips}\label{performance-tips-1}

\begin{itemize}
\tightlist
\item
  Avoid allocations inside \texttt{Render}. Cache \texttt{Pen},
  \texttt{FormattedText} when possible.
\item
  Use \texttt{StreamGeometry} and reuse if values rarely change (rebuild
  when invalidated).
\end{itemize}

\subsection{6. Templated control example:
Badge}\label{templated-control-example-badge}

Create \texttt{Badge\ :\ TemplatedControl} with properties
(\texttt{Content}, \texttt{Background}, \texttt{Foreground},
\texttt{CornerRadius}, \texttt{MaxWidth}, etc.). Default style in
\texttt{Styles.axaml}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ControlTheme}\OtherTok{ TargetType=}\StringTok{"local:Badge"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Template"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ControlTemplate}\OtherTok{ TargetType=}\StringTok{"local:Badge"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Border}\OtherTok{ x:Name=}\StringTok{"PART\_Border"}
\OtherTok{              Background=}\StringTok{"\{TemplateBinding Background\}"}
\OtherTok{              CornerRadius=}\StringTok{"\{TemplateBinding CornerRadius\}"}
\OtherTok{              Padding=}\StringTok{"6,0"}
\OtherTok{              MinHeight=}\StringTok{"16"}\OtherTok{ MinWidth=}\StringTok{"20"}
\OtherTok{              HorizontalAlignment=}\StringTok{"Left"}
\OtherTok{              VerticalAlignment=}\StringTok{"Top"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{ContentPresenter}\OtherTok{ x:Name=}\StringTok{"PART\_Content"}
\OtherTok{                          Content=}\StringTok{"\{TemplateBinding Content\}"}
\OtherTok{                          HorizontalAlignment=}\StringTok{"Center"}
\OtherTok{                          VerticalAlignment=}\StringTok{"Center"}
\OtherTok{                          Foreground=}\StringTok{"\{TemplateBinding Foreground\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{ControlTemplate}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Setter}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Background"}\OtherTok{ Value=}\StringTok{"\#E53935"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Foreground"}\OtherTok{ Value=}\StringTok{"White"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"CornerRadius"}\OtherTok{ Value=}\StringTok{"8"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"FontSize"}\OtherTok{ Value=}\StringTok{"12"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"HorizontalAlignment"}\OtherTok{ Value=}\StringTok{"Left"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ControlTheme}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

In code, capture named parts once the template applies:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ Badge }\OperatorTok{:}\NormalTok{ TemplatedControl}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static} \KeywordTok{readonly}\NormalTok{ StyledProperty}\OperatorTok{\textless{}}\DataTypeTok{object}\OperatorTok{?\textgreater{}}\NormalTok{ ContentProperty }\OperatorTok{=}
\NormalTok{        AvaloniaProperty}\OperatorTok{.}\FunctionTok{Register}\OperatorTok{\textless{}}\NormalTok{Badge}\OperatorTok{,} \DataTypeTok{object}\OperatorTok{?\textgreater{}(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{Content}\OperatorTok{));}

\NormalTok{    Border}\OperatorTok{?}\NormalTok{ \_border}\OperatorTok{;}

    \KeywordTok{public} \DataTypeTok{object}\OperatorTok{?}\NormalTok{ Content}
    \OperatorTok{\{}
\NormalTok{        get }\OperatorTok{=\textgreater{}} \FunctionTok{GetValue}\OperatorTok{(}\NormalTok{ContentProperty}\OperatorTok{);}
\NormalTok{        set }\OperatorTok{=\textgreater{}} \FunctionTok{SetValue}\OperatorTok{(}\NormalTok{ContentProperty}\OperatorTok{,}\NormalTok{ value}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnApplyTemplate}\OperatorTok{(}\NormalTok{TemplateAppliedEventArgs e}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnApplyTemplate}\OperatorTok{(}\NormalTok{e}\OperatorTok{);}
\NormalTok{        \_border }\OperatorTok{=}\NormalTok{ e}\OperatorTok{.}\FunctionTok{NameScope}\OperatorTok{.}\FunctionTok{Find}\OperatorTok{\textless{}}\NormalTok{Border}\OperatorTok{\textgreater{}(}\StringTok{"PART\_Border"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Expose additional state through \texttt{StyledProperty}s so themes and
animations can target them.

\subsection{7. Visual states and control
themes}\label{visual-states-and-control-themes}

\begin{itemize}
\tightlist
\item
  Use \texttt{PseudoClasses} (e.g.,
  \texttt{PseudoClasses.Set(":badge-has-content",\ true)}) to signal
  template states that styles can observe.
\item
  Combine \texttt{PseudoClasses} with \texttt{Transitions} or
  \texttt{Animations} to create hover/pressed effects without rewriting
  templates.
\item
  Ship alternate appearances via additional \texttt{ControlTheme}
  resources referencing the same \texttt{TemplatedControl} type.
\item
  For re-usable primitive parts, create internal \texttt{Visual}
  subclasses (e.g., \texttt{BadgeGlyph}) and expose them as named
  template parts.
\end{itemize}

\subsection{8. Accessibility \& input}\label{accessibility-input}

\begin{itemize}
\tightlist
\item
  Set \texttt{Focusable} as appropriate; override
  \texttt{OnPointerPressed}/\texttt{OnKeyDown} for interaction or to
  update pseudo classes.
\item
  Expose automation metadata via \texttt{AutomationProperties.Name},
  \texttt{HelpText}, or custom \texttt{AutomationPeer} for drawn
  controls.
\item
  Override \texttt{OnCreateAutomationPeer} when your control represents
  a unique semantic (\texttt{BadgeAutomationPeer} describing count,
  severity).
\end{itemize}

\subsection{9. Measure/arrange}\label{measurearrange}

Custom controls should override
\texttt{MeasureOverride}/\texttt{ArrangeOverride} when size depends on
content/drawing.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{protected} \KeywordTok{override}\NormalTok{ Size }\FunctionTok{MeasureOverride}\OperatorTok{(}\NormalTok{Size availableSize}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ values }\OperatorTok{=}\NormalTok{ Values}\OperatorTok{;}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{values }\KeywordTok{is} \KeywordTok{null} \OperatorTok{||}\NormalTok{ values}\OperatorTok{.}\FunctionTok{Count} \OperatorTok{==} \DecValTok{0}\OperatorTok{)}
        \KeywordTok{return}\NormalTok{ Size}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{;}
    \KeywordTok{return} \KeywordTok{new} \FunctionTok{Size}\OperatorTok{(}\NormalTok{Math}\OperatorTok{.}\FunctionTok{Min}\OperatorTok{(}\NormalTok{availableSize}\OperatorTok{.}\FunctionTok{Width}\OperatorTok{,} \DecValTok{120}\OperatorTok{),}\NormalTok{ Math}\OperatorTok{.}\FunctionTok{Min}\OperatorTok{(}\NormalTok{availableSize}\OperatorTok{.}\FunctionTok{Height}\OperatorTok{,} \DecValTok{36}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{TemplatedControl} handles measurement via its template (border +
content). For custom-drawn controls, define desired size heuristics.

\subsection{10. Rendering to bitmaps /
exporting}\label{rendering-to-bitmaps-exporting}

Use \texttt{RenderTargetBitmap} for saving custom visuals:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ rtb }\OperatorTok{=} \KeywordTok{new} \FunctionTok{RenderTargetBitmap}\OperatorTok{(}\KeywordTok{new} \FunctionTok{PixelSize}\OperatorTok{(}\DecValTok{200}\OperatorTok{,} \DecValTok{100}\OperatorTok{),} \KeywordTok{new} \FunctionTok{Vector}\OperatorTok{(}\DecValTok{96}\OperatorTok{,} \DecValTok{96}\OperatorTok{));}
\NormalTok{await rtb}\OperatorTok{.}\FunctionTok{RenderAsync}\OperatorTok{(}\NormalTok{sparkline}\OperatorTok{);}
\NormalTok{await }\KeywordTok{using} \DataTypeTok{var}\NormalTok{ stream }\OperatorTok{=}\NormalTok{ File}\OperatorTok{.}\FunctionTok{OpenWrite}\OperatorTok{(}\StringTok{"spark.png"}\OperatorTok{);}
\NormalTok{await rtb}\OperatorTok{.}\FunctionTok{SaveAsync}\OperatorTok{(}\NormalTok{stream}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Use \texttt{RenderOptions} to adjust interpolation for exported graphics
if needed.

\subsection{11. Combining drawing \& template
(hybrid)}\label{combining-drawing-template-hybrid}

Example: \texttt{ChartControl} template contains toolbar (Buttons,
ComboBox) and a custom \texttt{ChartCanvas} child that handles
drawing/selection. - Template XAML composes layout. - Drawn child
handles heavy rendering \& direct pointer handling. - Chart exposes
data/selection via view models.

\subsection{12. Troubleshooting \& best
practices}\label{troubleshooting-best-practices}

\begin{itemize}
\tightlist
\item
  Flickering or wrong clip: ensure you clip to \texttt{Bounds} using
  \texttt{PushClip} when necessary.
\item
  Aliasing issues: adjust \texttt{RenderOptions.SetEdgeMode} and align
  lines to device pixels (e.g., \texttt{Math.Round(x)\ +\ 0.5} for 1px
  strokes at 1.0 scale).
\item
  Performance: profile by measuring allocations, consider caching
  \texttt{StreamGeometry}/\texttt{FormattedText}.
\item
  Template issues: ensure template names line up with
  \texttt{TemplateBinding}; use DevTools -\textgreater{}
  \texttt{Style\ Inspector} to check which template applies.
\end{itemize}

\subsection{13. Practice exercises}\label{practice-exercises-17}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Build a templated notification badge that swaps between ``pill'' and
  ``dot'' visuals by toggling \texttt{PseudoClasses} within
  \texttt{OnApplyTemplate}.
\item
  Embed a custom drawn sparkline into that badge (composed via
  \texttt{RenderTargetBitmap} or direct drawing) and expose it as a
  named part in the template.
\item
  Implement \texttt{OnCreateAutomationPeer} so assistive tech can report
  badge count and severity; verify with the accessibility tree in
  DevTools.
\item
  Use DevTools \texttt{Logical\ Tree} to confirm your presenter
  hierarchy (content vs drawn part) matches expectations and retains
  bindings when themes change.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-21}

\begin{itemize}
\tightlist
\item
  Visual/render infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Visual.cs}{\texttt{Visual.cs}}
\item
  DrawingContext API:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/DrawingContext.cs}{\texttt{DrawingContext.cs}}
\item
  StreamGeometry:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/Geometry/StreamGeometryContextImpl.cs}{\texttt{StreamGeometryContextImpl}}
\item
  Template loading:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/Templates/ControlTemplate.cs}{\texttt{ControlTemplate.cs}}
\item
  Template applied hook:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Primitives/TemplateAppliedEventArgs.cs}{\texttt{TemplateAppliedEventArgs.cs}}
\item
  Name scopes:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/NameScope.cs}{\texttt{NameScope.cs}}
\item
  Templated control base:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Primitives/TemplatedControl.cs}{\texttt{TemplatedControl.cs}}
\item
  Control theme infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/ControlTheme.cs}{\texttt{ControlTheme.cs}}
\item
  Pseudo classes:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/StyledElement.cs}{\texttt{StyledElement.cs}}
\item
  Automation peers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Automation/Peers/ControlAutomationPeer.cs}{\texttt{ControlAutomationPeer.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-21}

\begin{itemize}
\tightlist
\item
  When do you override \texttt{Render} versus \texttt{ControlTemplate}?
\item
  How does \texttt{AffectsRender} simplify invalidation?
\item
  What caches can you introduce to prevent allocations in
  \texttt{Render}?
\item
  How do you expose accessibility information for drawn controls?
\item
  How can consumers restyle your templated control without touching C\#?
\end{itemize}

What's next - Next: \href{Chapter24.md}{Chapter 24}

\newpage

\subsection{24. Performance, diagnostics, and
DevTools}\label{performance-diagnostics-and-devtools}

Goal - Diagnose and fix Avalonia performance issues using measurement,
logging, DevTools, and overlays. - Focus on the usual suspects:
non-virtualized lists, layout churn, binding storms, expensive
rendering. - Build repeatable measurement habits (Release builds, small
reproducible tests).

Why this matters - ``UI feels slow'' is common feedback. Without data,
fixes are guesswork. - Avalonia provides built-in diagnostics (DevTools,
overlays) and logging hooks--learn to leverage them.

Prerequisites - Chapter 22 (rendering pipeline), Chapter 17 (async
patterns), Chapter 16 (custom controls and lists).

\subsection{1. Measure before changing
anything}\label{measure-before-changing-anything}

\begin{itemize}
\tightlist
\item
  Run in Release (\texttt{dotnet\ run\ -c\ Release}). JIT optimizations
  affect responsiveness.
\item
  Use a small repro: isolate the view or control and reproduce with
  minimal data before optimizing.
\item
  Use high-resolution timers only around suspect code sections; avoid
  timing entire app startup on the first pass.
\item
  Change one variable at a time and re-measure to confirm impact.
\end{itemize}

\subsection{2. Logging}\label{logging-1}

Enable logging per area using \texttt{AppBuilder} extensions (see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/LoggingExtensions.cs}{\texttt{LoggingExtensions.cs}}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
    \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{LogToTrace}\OperatorTok{(}\NormalTok{LogEventLevel}\OperatorTok{.}\FunctionTok{Information}\OperatorTok{,} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{}\NormalTok{ LogArea}\OperatorTok{.}\FunctionTok{Binding}\OperatorTok{,}\NormalTok{ LogArea}\OperatorTok{.}\FunctionTok{Layout}\OperatorTok{,}\NormalTok{ LogArea}\OperatorTok{.}\FunctionTok{Render}\OperatorTok{,}\NormalTok{ LogArea}\OperatorTok{.}\FunctionTok{Property} \OperatorTok{\})}
    \OperatorTok{.}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Areas: see \texttt{Avalonia.Logging.LogArea} (\texttt{Binding},
  \texttt{Layout}, \texttt{Render}, \texttt{Property}, \texttt{Control},
  etc.).
\item
  Reduce noise by lowering level (\texttt{Warning}) or limiting areas
  once you identify culprit.
\item
  Optionally log to file via \texttt{LogToTextWriter}.
\end{itemize}

\subsection{3. DevTools (F12)}\label{devtools-f12}

Attach DevTools after app initialization:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{()}
\OperatorTok{\{}
    \CommentTok{// configure windows/root view}
    \KeywordTok{this}\OperatorTok{.}\FunctionTok{AttachDevTools}\OperatorTok{();}
    \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Supports options:
\texttt{AttachDevTools(new\ DevToolsOptions\ \{\ StartupScreenIndex\ =\ 1\ \})}
for multi-monitor setups.

\subsubsection{DevTools tour}\label{devtools-tour}

\begin{itemize}
\tightlist
\item
  \textbf{Visual Tree}: inspect hierarchy, properties, pseudo-classes,
  and layout bounds.
\item
  \textbf{Logical Tree}: understand DataContext/template relationships.
\item
  \textbf{Layout Explorer}: measure/arrange info, constraints, actual
  sizes.
\item
  \textbf{Events}: view event flow; detect repeated pointer/keyboard
  events.
\item
  \textbf{Styles \& Resources}: view applied styles/resources; test
  pseudo-class states.
\item
  \textbf{Hotkeys/Settings}: adjust F12 gesture.
\end{itemize}

Use the target picker to select elements on screen and inspect
descendants/ancestors.

\subsection{4. Renderer diagnostics API}\label{renderer-diagnostics-api}

\begin{itemize}
\tightlist
\item
  Every \texttt{TopLevel} exposes \texttt{IRenderer\ Diagnostics}.
  Subscribe to \texttt{PropertyChanged} to stream overlay toggles or
  other diagnostics to logs, counters, or dashboards.
\item
  Toggle overlays without opening DevTools: set
  \texttt{renderer.Diagnostics.DebugOverlays} from code or
  configuration.
\item
  Hook \texttt{SceneInvalidated} when you need per-frame insight into
  which rectangles triggered redraws. Pair this with your own timers to
  understand long layout/render passes.
\item
  Enable \texttt{LogArea.Composition} in logging when you need to
  correlate compositor operations (scene graph updates, render thread
  work) with on-screen symptoms.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ System}\OperatorTok{.}\FunctionTok{Diagnostics}\OperatorTok{;}

\KeywordTok{if} \OperatorTok{(}\NormalTok{TopLevel }\KeywordTok{is} \OperatorTok{\{}\NormalTok{ Renderer}\OperatorTok{:} \OperatorTok{\{} \OperatorTok{\}}\NormalTok{ renderer }\OperatorTok{\})}
\OperatorTok{\{}
\NormalTok{    renderer}\OperatorTok{.}\FunctionTok{SceneInvalidated} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}}
    \OperatorTok{\{}
\NormalTok{        Debug}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\NormalTok{$}\StringTok{"Invalidated \{e.Rect\}"}\OperatorTok{);}
    \OperatorTok{\};}

\NormalTok{    renderer}\OperatorTok{.}\FunctionTok{Diagnostics}\OperatorTok{.}\FunctionTok{PropertyChanged} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{PropertyName} \OperatorTok{==} \FunctionTok{nameof}\OperatorTok{(}\NormalTok{RendererDiagnostics}\OperatorTok{.}\FunctionTok{DebugOverlays}\OperatorTok{))}
        \OperatorTok{\{}
\NormalTok{            Debug}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\NormalTok{$}\StringTok{"Overlays now: \{renderer.Diagnostics.DebugOverlays\}"}\OperatorTok{);}
        \OperatorTok{\}}
    \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{5. Debug overlays
(\texttt{RendererDebugOverlays})}{5. Debug overlays (RendererDebugOverlays)}}\label{debug-overlays-rendererdebugoverlays}

Access via DevTools ``Diagnostics'' pane or programmatically:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \OperatorTok{(}\KeywordTok{this}\OperatorTok{.}\FunctionTok{ApplicationLifetime} \KeywordTok{is}\NormalTok{ IClassicDesktopStyleApplicationLifetime desktop}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    desktop}\OperatorTok{.}\FunctionTok{MainWindow}\OperatorTok{.}\FunctionTok{AttachedToVisualTree} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_\_}\OperatorTok{)} \OperatorTok{=\textgreater{}}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{desktop}\OperatorTok{.}\FunctionTok{MainWindow}\OperatorTok{?.}\FunctionTok{Renderer} \KeywordTok{is} \OperatorTok{\{} \OperatorTok{\}}\NormalTok{ renderer}\OperatorTok{)}
\NormalTok{            renderer}\OperatorTok{.}\FunctionTok{DebugOverlays} \OperatorTok{=}\NormalTok{ RendererDebugOverlays}\OperatorTok{.}\FunctionTok{Fps} \OperatorTok{|}\NormalTok{ RendererDebugOverlays}\OperatorTok{.}\FunctionTok{DirtyRects}\OperatorTok{;}
    \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Overlays include: - \texttt{Fps} -- frames per second. -
\texttt{DirtyRects} -- regions redrawn each frame. -
\texttt{LayoutTimeGraph} -- layout duration per frame. -
\texttt{RenderTimeGraph} -- render duration per frame.

Interpretation: - Large dirty rects = huge redraw areas; find what
invalidates entire window. - LayoutTime spikes = heavy measure/arrange;
check Layout Explorer to spot bottleneck. - RenderTime spikes =
expensive drawing (big bitmaps, custom rendering).

\subsection{\texorpdfstring{6. Remote diagnostics
(\texttt{Avalonia.Remote.Protocol})}{6. Remote diagnostics (Avalonia.Remote.Protocol)}}\label{remote-diagnostics-avalonia.remote.protocol}

\begin{itemize}
\tightlist
\item
  Remote DevTools streams frames and inspection data over the transports
  defined in \texttt{Avalonia.Remote.Protocol} (BSON/TCP by default).
\item
  Use \texttt{Avalonia.Controls.Remote.RemoteServer} with a
  \texttt{BsonTcpTransport} to expose an interactive surface when
  debugging devices without a local inspector (mobile, kiosk). Connect
  using an Avalonia DevTools client (dotnet \texttt{avalonia} tool or
  IDE integration) pointing at \texttt{tcp-bson://host:port}.
\item
  Messages such as \texttt{TransportMessages.cs} describe the payloads
  (frame buffers, input, diagnostics). Extend them if you build custom
  tooling.
\item
  Remote sessions respect overlay and logging flags, so enabling
  \texttt{RendererDebugOverlays} locally will surface in the remote
  stream as well.
\item
  For secure deployments, wrap \texttt{TcpTransportBase} in an
  authenticated tunnel (SSH port forward, reverse proxy) and disable
  remote servers in production builds.
\end{itemize}

\subsection{7. Performance checklist}\label{performance-checklist}

Lists \& templates - Use virtualization
(\texttt{VirtualizingStackPanel}) for list controls. - Keep item
templates light; avoid nested panels and convert heavy converters to
cached data. - Pre-compute value strings/colors in view models to avoid
per-frame conversion.

Layout \& binding - Minimize property changes that re-trigger layout of
large trees. - Avoid swapping entire templates when simple property
changes suffice. - Watch for binding storms (log
\texttt{LogArea.Binding}). Debounce or use state flags.

Rendering - Use vector assets where possible; for bitmaps, match display
resolution. - Set \texttt{RenderOptions.BitmapInterpolationMode} for
scaling to avoid blurry or overly expensive scaling. - Cache expensive
geometries (\texttt{StreamGeometry}), \texttt{FormattedText}, etc.

Async \& threading - Move heavy work off UI thread (async/await,
\texttt{Task.Run} for CPU-bound tasks). - Use
\texttt{IProgress\textless{}T\textgreater{}} to report progress instead
of manual UI thread dispatch.

Profiling - Use \texttt{.NET} profilers (dotTrace, PerfView,
dotnet-trace) to capture CPU/memory. - For GPU, use platform tools if
necessary (RenderDoc for GL/DirectX when supported).

\subsection{8. Considerations per
platform}\label{considerations-per-platform}

\begin{itemize}
\tightlist
\item
  Windows: ensure GPU acceleration enabled; check drivers. Acrylic/Mica
  can cost extra GPU time.
\item
  macOS: retina scaling multiplies pixel counts; ensure vector assets
  and efficient drawing.
\item
  Linux: varying window managers/compositors. If using software
  rendering, expect lower FPS--optimize accordingly.
\item
  Mobile \& Browser: treat CPU/GPU resources as more limited; avoid
  constant redraw loops.
\end{itemize}

\subsection{9. Automation \& CI}\label{automation-ci}

\begin{itemize}
\tightlist
\item
  Combine unit tests with headless UI tests (Chapter 21).
\item
  Create regression tests for performance-critical features (measure
  time for known operations, fail if above threshold).
\item
  Capture baseline metrics (FPS, load time) and compare across commits;
  tools like BenchmarkDotNet can help (for logic-level measurements).
\end{itemize}

\subsection{10. Workflow summary}\label{workflow-summary}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Reproduce in Release with logging disabled -\textgreater{} measure
  baseline.
\item
  Enable DevTools overlays (FPS, dirty rects, layout/render graphs)
  -\textgreater{} identify pattern.
\item
  Enable targeted logging (Binding/Layout/Render) -\textgreater{}
  correlate with overlays.
\item
  Apply fix (virtualization, caching, reducing layout churn)
\item
  Re-measure with overlays/logs to confirm improvements.
\item
  Capture notes and, if beneficial, automate tests for future
  regressions.
\end{enumerate}

\subsection{11. Practice exercises}\label{practice-exercises-18}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Attach DevTools, toggle
  \texttt{RendererDebugOverlays.Fps\ \textbar{}\ LayoutTimeGraph}, and
  record metrics before/after enabling virtualization in a long list.
\item
  Capture binding noise by raising \texttt{LogArea.Binding} to
  \texttt{Debug}, then fix the source and verify the log stream quiets
  down.
\item
  Spin up a \texttt{RemoteServer} with \texttt{BsonTcpTransport},
  connect using an Avalonia DevTools client (dotnet \texttt{avalonia}
  tool or IDE integration), and confirm overlays/logging data mirror the
  local session.
\item
  Profile the same interaction with \texttt{dotnet-trace} and align CPU
  spikes with render diagnostics to validate the chosen fix.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-22}

\begin{itemize}
\tightlist
\item
  DevTools attach helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Diagnostics/DevToolsExtensions.cs}{\texttt{DevToolsExtensions.cs}}
\item
  DevTools view models (toggling overlays):
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Diagnostics/Diagnostics/ViewModels/MainViewModel.cs}{\texttt{MainViewModel.cs}}
\item
  Renderer diagnostics:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDiagnostics.cs}{\texttt{RendererDiagnostics.cs}}
\item
  Renderer overlays:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDebugOverlays.cs}{\texttt{RendererDebugOverlays.cs}}
\item
  Logging infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Logging/LogArea.cs}{\texttt{LogArea}}
\item
  RenderOptions (quality settings):
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/RenderOptions.cs}{\texttt{RenderOptions.cs}}
\item
  Layout diagnostics:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/LayoutHelper.cs}{\texttt{LayoutHelper}}
\item
  Remote transport messages:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Remote.Protocol/TransportMessages.cs}{\texttt{TransportMessages.cs}}
\item
  Remote server host:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Remote/RemoteServer.cs}{\texttt{RemoteServer.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-22}

\begin{itemize}
\tightlist
\item
  Why must performance measurements be done in Release builds?
\item
  Which overlay would you enable to track layout time spikes? What about
  render time spikes?
\item
  How do DevTools and logging complement each other?
\item
  List three common causes of UI lag and their fixes.
\item
  How would you automate detection of a performance regression?
\end{itemize}

What's next - Next: \href{Chapter25.md}{Chapter 25}

\newpage

\subsection{25. Design-time tooling and the XAML
Previewer}\label{design-time-tooling-and-the-xaml-previewer}

Goal - Use Avalonia's XAML Previewer (designer) effectively in VS,
Rider, and VS Code. - Feed realistic sample data and preview
styles/resources without running your full backend. - Understand design
mode plumbing, avoid previewer crashes, and sharpen your design
workflow.

Why this matters - Fast iteration on UI keeps you productive. The
previewer drastically reduces build/run cycles if you set it up
correctly. - Design-time data prevents ``black boxes'' in the previewer
and reveals layout problems early.

Prerequisites - Familiarity with XAML bindings (Chapter 8) and templates
(Chapter 23).

\subsection{1. Previewer pipeline and
transport}\label{previewer-pipeline-and-transport}

IDE hosts spawn a preview process that loads your view or resource
dictionary over the remote protocol. \texttt{DesignWindowLoader} spins
up \texttt{RemoteDesignerEntryPoint}, which compiles your project with
the design configuration, loads the control, then streams rendered
frames back to the IDE through
\texttt{Avalonia.Remote.Protocol.DesignMessages}.

Key components: -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Design.cs}{\texttt{Design.cs}}
toggles design mode (\texttt{Design.IsDesignMode}) and surfaces attached
properties consumed only by the previewer. -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.DesignerSupport/DesignWindowLoader.cs}{\texttt{DesignWindowLoader}}
boots the preview process, configures the runtime XAML loader, and
registers services. -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.DesignerSupport/PreviewerWindowImpl.cs}{\texttt{PreviewerWindowImpl}}
hosts the live surface, translating remote transport messages into
frames. -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.DesignerSupport/Remote/RemoteDesignerEntryPoint.cs}{\texttt{RemoteDesignerEntryPoint}}
sets up \texttt{RuntimeXamlLoader} and dependency injection so types
resolve the same way they will at runtime.

Because the previewer compiles your project, build errors surface
exactly as in \texttt{dotnet\ build}. Keep \texttt{AvaloniaResource}
items and generated code in sync or the previewer will refuse to load.

\subsection{\texorpdfstring{2. Mock data with
\texttt{Design.DataContext}}{2. Mock data with Design.DataContext}}\label{mock-data-with-design.datacontext}

Provide lightweight POCOs or design view models for preview without
touching production services.

Sample POCO:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{namespace}\NormalTok{ MyApp}\OperatorTok{.}\FunctionTok{Design}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ SamplePerson}
\OperatorTok{\{}
    \KeywordTok{public} \DataTypeTok{string}\NormalTok{ Name }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \KeywordTok{set}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \StringTok{"Ada Lovelace"}\OperatorTok{;}
    \KeywordTok{public} \DataTypeTok{string}\NormalTok{ Email }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \KeywordTok{set}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \StringTok{"ada@example.com"}\OperatorTok{;}
    \KeywordTok{public} \DataTypeTok{int}\NormalTok{ Age }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \KeywordTok{set}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \DecValTok{37}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Usage in XAML:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{UserControl}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{             xmlns:x=}\StringTok{"http://schemas.microsoft.com/winfx/2006/xaml"}
\OtherTok{             xmlns:design=}\StringTok{"clr{-}namespace:Avalonia.Controls;assembly=Avalonia.Controls"}
\OtherTok{             xmlns:samples=}\StringTok{"clr{-}namespace:MyApp.Design"}\OtherTok{ x:Class=}\StringTok{"MyApp.Views.ProfileView"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{design:Design.DataContext}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{samples:SamplePerson}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{design:Design.DataContext}\NormalTok{\textgreater{}}

\NormalTok{  \textless{}}\KeywordTok{StackPanel}\OtherTok{ Spacing=}\StringTok{"12"}\OtherTok{ Margin=}\StringTok{"16"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Classes=}\StringTok{"h1"}\OtherTok{ Text=}\StringTok{"\{Binding Name\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Email\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Age: \{Binding Age\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{UserControl}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

At runtime the transformer removes \texttt{Design.DataContext}; real
view models take over. For complex forms, expose design view models with
stub services but avoid heavy logic. When you need multiple sample
contexts, expose them as static properties on a design-time provider
class and bind with \texttt{\{x:Static\}}.

\subsubsection{Design.IsDesignMode
checks}\label{design.isdesignmode-checks}

Guard expensive operations:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \OperatorTok{(}\NormalTok{Design}\OperatorTok{.}\FunctionTok{IsDesignMode}\OperatorTok{)}
    \KeywordTok{return}\OperatorTok{;} \CommentTok{// skip service setup, timers, network}
\end{Highlighting}
\end{Shaded}

Place guards in view constructors, \texttt{OnApplyTemplate}, or view
model initialization.

\subsection{\texorpdfstring{3. Design.Width/Height \&
\texttt{DesignStyle}}{3. Design.Width/Height \& DesignStyle}}\label{design.widthheight-designstyle}

Set design canvas size:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{StackPanel}\OtherTok{ design:Design.Width=}\StringTok{"320"}
\OtherTok{            design:Design.Height=}\StringTok{"480"}
\OtherTok{            design:Design.DesignStyle=}\StringTok{"\{StaticResource DesignOutlineStyle\}"}\NormalTok{\textgreater{}}

\NormalTok{\textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{DesignStyle} can add dashed borders or backgrounds for preview
only (define style in resources).

Example design style:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Style}\OtherTok{ x:Key=}\StringTok{"DesignOutlineStyle"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Border.BorderThickness"}\OtherTok{ Value=}\StringTok{"1"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Border.BorderBrush"}\OtherTok{ Value=}\StringTok{"\#808080"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{4. Preview resource dictionaries with
\texttt{Design.PreviewWith}}{4. Preview resource dictionaries with Design.PreviewWith}}\label{preview-resource-dictionaries-with-design.previewwith}

Previewing a dictionary or style requires a host control:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ResourceDictionary}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}
\OtherTok{                    xmlns:design=}\StringTok{"clr{-}namespace:Avalonia.Controls;assembly=Avalonia.Controls"}
\OtherTok{                    xmlns:views=}\StringTok{"clr{-}namespace:MyApp.Views"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{design:Design.PreviewWith}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Border}\OtherTok{ Padding=}\StringTok{"16"}\OtherTok{ Background=}\StringTok{"\#1f2937"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{StackPanel}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{views:Badge}\OtherTok{ Content=}\StringTok{"1"}\OtherTok{ Classes=}\StringTok{"success"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{views:Badge}\OtherTok{ Content=}\StringTok{"Warning"}\OtherTok{ Classes=}\StringTok{"warning"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{design:Design.PreviewWith}\NormalTok{\textgreater{}}


\NormalTok{\textless{}/}\KeywordTok{ResourceDictionary}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{PreviewWith} ensures the previewer renders the host when you
open the dictionary alone.

\subsection{5. Inspect previewer logs and compilation
errors}\label{inspect-previewer-logs-and-compilation-errors}

\begin{itemize}
\tightlist
\item
  Visual Studio and Rider show previewer logs in the dedicated
  ``Avalonia Previewer'' tool window; VS Code prints to the Output panel
  (\texttt{Avalonia\ Previewer} channel).
\item
  Logs come from \texttt{DesignMessages}; look for \texttt{JsonRpcError}
  entries when bindings fail---those line numbers map to generated XAML.
\item
  If compilation fails, open the temporary build directory path printed
  in the log. Running \texttt{dotnet\ build\ /p:Configuration=Design}
  replicates the preview build.
\item
  Enable \texttt{Diagnostics\ -\textgreater{}\ Capture\ frames} to
  export a \texttt{.png} snapshot of the preview surface when you
  troubleshoot rendering glitches.
\end{itemize}

\subsection{6. Extend design-time
services}\label{extend-design-time-services}

\texttt{RemoteDesignerEntryPoint} registers services in a tiny IoC
container separate from your production DI. Override or extend them by
wiring a helper that only executes when \texttt{Design.IsDesignMode} is
true:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Controls}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ DesignTimeServices}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static} \DataTypeTok{void} \FunctionTok{Register}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(!}\NormalTok{Design}\OperatorTok{.}\FunctionTok{IsDesignMode}\OperatorTok{)}
            \KeywordTok{return}\OperatorTok{;}

\NormalTok{        AvaloniaLocator}\OperatorTok{.}\FunctionTok{CurrentMutable}
            \OperatorTok{.}\FunctionTok{Bind}\OperatorTok{\textless{}}\NormalTok{INavigationService}\OperatorTok{\textgreater{}()}
            \OperatorTok{.}\FunctionTok{ToConstant}\OperatorTok{(}\KeywordTok{new} \FunctionTok{FakeNavigationService}\OperatorTok{());}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Call \texttt{DesignTimeServices.Register();} inside
\texttt{BuildAvaloniaApp().AfterSetup(...)} so the previewer receives
the fake services without altering production setup. Use this pattern to
swap HTTP clients, repositories, or configuration with in-memory fakes
while keeping runtime untouched.

\subsection{7. IDE-specific tips}\label{ide-specific-tips}

\subsubsection{Visual Studio}\label{visual-studio-1}

\begin{itemize}
\tightlist
\item
  Ensure ``Avalonia Previewer'' extension is installed.
\item
  F12 toggles DevTools; \texttt{Alt+Space} opens previewer hotkeys.
\item
  If previewer doesn't refresh, rebuild project; VS sometimes caches the
  design assembly.
\item
  Enable verbose logs via
  \texttt{Previewer\ -\textgreater{}\ Options\ -\textgreater{}\ Enable\ Diagnostics}
  to capture transport traces when the preview window stays blank.
\end{itemize}

\subsubsection{Rider}\label{rider-1}

\begin{itemize}
\tightlist
\item
  Avalonia plugin required; previewer window shows automatically when
  editing XAML.
\item
  Use the data context drop-down to quickly switch between sample
  contexts if multiple available.
\item
  Rider caches preview assemblies under
  \texttt{\%LOCALAPPDATA\%/Avalonia}. Use ``Invalidate caches'' if you
  ship new resource dictionaries and the previewer shows stale data.
\end{itemize}

\subsubsection{VS Code}\label{vs-code-1}

\begin{itemize}
\tightlist
\item
  Avalonia \texttt{.vsix} extension hosts the previewer through the
  dotnet CLI; keep the extension and SDK workloads in sync.
\item
  Run \texttt{dotnet\ workload\ install\ wasm-tools} (previewer uses
  WASM-hosted renderer). Use the
  \texttt{Avalonia\ Previewer:\ Show\ Log} command if the embedded
  browser surface fails.
\end{itemize}

General - Keep constructors light; heavy constructors crash previewer. -
Use \texttt{Design.DataContext} to avoid hitting DI container or real
services. - Split complex layouts into smaller user controls and preview
them individually.

\subsection{8. Troubleshooting \& best
practices}\label{troubleshooting-best-practices-1}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Issue
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Fix
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Previewer blank/crashes & Guard code with \texttt{Design.IsDesignMode};
simplify layout; ensure no blocking calls in constructor \\
Design-only styles appear at runtime & \texttt{Design.*} stripped at
runtime; if they leak, inspect generated \texttt{.g.cs} to confirm
transformer ran \\
Resource dictionary preview fails & Add \texttt{Design.PreviewWith};
ensure resources compiled (check \texttt{AvaloniaResource} includes) \\
Sample data not showing & Confirm namespace mapping correct, sample
object constructs without exceptions, and preview log shows
\texttt{DataContext} attachment \\
Slow preview & Remove animations/effects temporarily; large data sets or
virtualization can slow preview host \\
Transport errors (\texttt{SocketException}) & Restart previewer.
Firewalls can block the loopback port used by
\texttt{Avalonia.Remote.Protocol} \\
\end{longtable}

\subsection{9. Automation}\label{automation}

\begin{itemize}
\tightlist
\item
  Document designer defaults using \texttt{README} for your UI project.
  Include instructions for sample data.
\item
  Use git hooks/CI to catch accidental runtime usages of
  \texttt{Design.*}. For instance, forbid \texttt{Design.IsDesignMode}
  checks in release-critical code by scanning for patterns if needed.
\item
  Add an automated smoke test that loads critical views with
  \texttt{Design.IsDesignModeProperty} set to true via
  \texttt{RuntimeXamlLoader} to detect regressions before IDE users do.
\end{itemize}

\subsection{10. Practice exercises}\label{practice-exercises-19}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add \texttt{Design.DataContext} to a complex form, providing realistic
  sample data (names, email, totals). Ensure preview shows formatted
  values.
\item
  Set \texttt{Design.Width/Height} to 360x720 for a mobile view; use
  \texttt{Design.DesignStyle} to highlight layout boundaries.
\item
  Create a resource dictionary for badges; use
  \texttt{Design.PreviewWith} to render multiple badge variants
  side-by-side.
\item
  Open the previewer diagnostics window, reproduce a binding failure,
  and note how \texttt{DesignMessages} trace the failing binding path.
\item
  Guard service initialization with \texttt{if\ (Design.IsDesignMode)}
  and confirm preview load improves.
\item
  Bonus: implement a design-only service override and register it from
  \texttt{BuildAvaloniaApp().AfterSetup(...)}.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-23}

\begin{itemize}
\tightlist
\item
  Design property helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Design.cs}{\texttt{Design.cs}}
\item
  Preview transport wiring:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.DesignerSupport/DesignWindowLoader.cs}{\texttt{DesignWindowLoader.cs}}
\item
  Previewer bootstrapping:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.DesignerSupport/Remote/RemoteDesignerEntryPoint.cs}{\texttt{RemoteDesignerEntryPoint.cs}}
\item
  Design-time property transformer:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml.Loader/CompilerExtensions/Transformers/AvaloniaXamlIlDesignPropertiesTransformer.cs}{\texttt{AvaloniaXamlIlDesignPropertiesTransformer.cs}}
\item
  Previewer window implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.DesignerSupport/Remote/PreviewerWindowImpl.cs}{\texttt{PreviewerWindowImpl.cs}}
\item
  Protocol messages:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Remote.Protocol/DesignMessages.cs}{\texttt{Avalonia.Remote.Protocol/DesignMessages.cs}}
\item
  Samples: ControlCatalog resources demonstrate
  \texttt{Design.PreviewWith} usage
  (\texttt{samples/ControlCatalog/Styles/...})
\end{itemize}

\subsection{Check yourself}\label{check-yourself-23}

\begin{itemize}
\tightlist
\item
  How do you provide sample data without running production services?
\item
  How do you prevent design-only code from running in production?
\item
  When do you use \texttt{Design.PreviewWith}?
\item
  What are the most common previewer crashes and how do you avoid them?
\end{itemize}

What's next - Next: \href{Chapter26.md}{Chapter 26}

\newpage

\subsection{26. Build, publish, and
deploy}\label{build-publish-and-deploy}

Goal - Produce distributable builds for every platform Avalonia supports
(desktop, mobile, browser). - Understand .NET publish options
(framework-dependent vs self-contained, single-file, ReadyToRun,
trimming). - Package and ship your app (MSIX, DMG, AppImage, AAB/IPA,
browser bundles) and automate via CI/CD.

Why this matters - Reliable builds avoid ``works on my machine''
syndrome. - Choosing the right publish options balances size, startup
time, and compatibility.

Prerequisites - Chapters 18-20 for platform nuances, Chapter 17 for
async/networking (relevant to release builds).

\subsection{1. Build vs publish}\label{build-vs-publish}

\begin{itemize}
\tightlist
\item
  \texttt{dotnet\ build}: compiles assemblies, typically run for local
  development.
\item
  \texttt{dotnet\ publish}: creates a self-contained folder/app ready to
  run on target machines (Optionally includes .NET runtime).
\item
  Always test in \texttt{Release} configuration:
  \texttt{dotnet\ publish\ -c\ Release}.
\end{itemize}

\subsection{2. Avalonia build tooling \& project file
essentials}\label{avalonia-build-tooling-project-file-essentials}

Avalonia ships MSBuild targets that compile XAML and pack resources
alongside your assemblies. Understanding them keeps design-time and
publish-time behavior in sync.

\begin{itemize}
\tightlist
\item
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Build.Tasks/CompileAvaloniaXamlTask.cs}{\texttt{CompileAvaloniaXamlTask}}
  runs during \texttt{BeforeCompile} to turn \texttt{.axaml} into
  generated \texttt{.g.cs}. If a publish build reports missing generated
  files, confirm the Avalonia NuGet packages are referenced and the
  project imports \texttt{Avalonia.props/targets}.
\item
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Build.Tasks/AvaloniaResource.cs}{\texttt{AvaloniaResource}}
  items embed static content. Include them explicitly so publish outputs
  contain everything:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ItemGroup}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{AvaloniaResource}\OtherTok{ Include=}\StringTok{"Assets/**"}\NormalTok{ /\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{AvaloniaResource}\OtherTok{ Include=}\StringTok{"Themes/**/*.axaml"}\NormalTok{ /\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ItemGroup}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Shared targets such as
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/build/BuildTargets.targets}{\texttt{build/BuildTargets.targets}}
  tweak platform packaging. Review them before overriding publish
  stages.
\item
  Use property flags like
  \texttt{\textless{}AvaloniaUseCompiledBindings\textgreater{}true\textless{}/AvaloniaUseCompiledBindings\textgreater{}}
  consistently across Debug/Release so the previewer and publish builds
  agree.
\item
  For custom steps (version stamping, signing) extend
  \texttt{Target\ Name="AfterPublish"} or a Directory.Build.targets
  file; Avalonia emits its files before your target runs, so you can
  safely zip or notarize afterward.
\end{itemize}

\subsection{3. Runtime identifiers
(RIDs)}\label{runtime-identifiers-rids}

Common RIDs: - Windows: \texttt{win-x64}, \texttt{win-arm64}. - macOS:
\texttt{osx-x64} (Intel), \texttt{osx-arm64} (Apple Silicon),
\texttt{osx.12-arm64} (specific OS version), etc. - Linux:
\texttt{linux-x64}, \texttt{linux-arm64} (distribution-neutral), or
distro-specific RIDs (\texttt{linux-musl-x64}). - Android:
\texttt{android-arm64}, \texttt{android-x86}, etc. (handled in platform
head). - iOS: \texttt{ios-arm64}, \texttt{iossimulator-x64}. - Browser
(WASM): \texttt{browser-wasm} (handled by browser head).

\subsection{4. Publish configurations}\label{publish-configurations}

\subsubsection{Framework-dependent (requires installed .NET
runtime)}\label{framework-dependent-requires-installed-.net-runtime}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet}\NormalTok{ publish }\AttributeTok{{-}c}\NormalTok{ Release }\AttributeTok{{-}r}\NormalTok{ win{-}x64 }\AttributeTok{{-}{-}self{-}contained}\NormalTok{ false}
\end{Highlighting}
\end{Shaded}

Smaller download; target machine must have matching .NET runtime. Good
for enterprise scenarios.

\subsubsection{Self-contained (bundled
runtime)}\label{self-contained-bundled-runtime}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet}\NormalTok{ publish }\AttributeTok{{-}c}\NormalTok{ Release }\AttributeTok{{-}r}\NormalTok{ osx{-}arm64 }\AttributeTok{{-}{-}self{-}contained}\NormalTok{ true}
\end{Highlighting}
\end{Shaded}

Larger download; runs on machines without .NET. Standard for consumer
apps.

\subsubsection{Single-file}\label{single-file}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet}\NormalTok{ publish }\AttributeTok{{-}c}\NormalTok{ Release }\AttributeTok{{-}r}\NormalTok{ linux{-}x64 /p:SelfContained=true /p:PublishSingleFile=true}
\end{Highlighting}
\end{Shaded}

Creates one executable (plus a few native libraries depending on
platform). Avalonia may extract resources native libs to temp; test
startup.

\subsubsection{ReadyToRun}\label{readytorun}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet}\NormalTok{ publish }\AttributeTok{{-}c}\NormalTok{ Release }\AttributeTok{{-}r}\NormalTok{ win{-}x64 /p:SelfContained=true /p:PublishReadyToRun=true}
\end{Highlighting}
\end{Shaded}

Precompiles IL to native code; faster cold start at cost of larger size.
Measure before deciding.

\subsubsection{Trimming (advanced)}\label{trimming-advanced}

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{dotnet}\NormalTok{ publish }\AttributeTok{{-}c}\NormalTok{ Release }\AttributeTok{{-}r}\NormalTok{ osx{-}arm64 /p:SelfContained=true /p:PublishTrimmed=true}
\end{Highlighting}
\end{Shaded}

Aggressive size reduction; risky because Avalonia/XAML relies on
reflection. Requires careful annotation/preservation with
\texttt{DynamicDependency} or \texttt{ILLinkTrim} files. Start without
trimming; enable later with thorough testing.

\subsubsection{Publish options matrix
(example)}\label{publish-options-matrix-example}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Option & Pros & Cons \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Framework-dependent & Small & Requires runtime install \\
Self-contained & Runs anywhere & Larger downloads \\
Single-file & Simple distribution & Extracts natives; more memory \\
ReadyToRun & Faster cold start & Larger size \\
Trimmed & Smaller & Risk of missing types \\
\end{longtable}

\subsection{5. Output directories and manifest
validation}\label{output-directories-and-manifest-validation}

Publish outputs to
\texttt{bin/Release/\textless{}TFramework\textgreater{}/\textless{}RID\textgreater{}/publish}.

Examples: - \texttt{bin/Release/net8.0/win-x64/publish} -
\texttt{bin/Release/net8.0/linux-x64/publish} -
\texttt{bin/Release/net8.0/osx-arm64/publish}

Verify resources (images, fonts) present; confirm
\texttt{AvaloniaResource} includes them. Use
\texttt{dotnet\ publish\ /bl:publish.binlog} and inspect the binlog with
MSBuild Structured Log to confirm each resource path is copied.

\begin{itemize}
\tightlist
\item
  Check the generated \texttt{appsettings.json},
  \texttt{MyApp.runtimeconfig.json}, and \texttt{.deps.json} to ensure
  trimming or single-file options didn't remove dependencies.
\item
  For RID-specific bundles, review the platform manifests (e.g.,
  \texttt{MyApp.app/Contents/Info.plist}, \texttt{MyApp.msix}) before
  shipping.
\end{itemize}

\subsection{6. Asset packing and
resources}\label{asset-packing-and-resources}

\begin{itemize}
\tightlist
\item
  Group related resources into folders and wildcard them via
  \texttt{AvaloniaResource\ Include="Assets/Icons/**/*"}. The build task
  preserves folder structure when copying to publish output.
\item
  Embedded assets larger than a few MB (videos, large fonts) can remain
  external files by setting
  \texttt{\textless{}CopyToOutputDirectory\textgreater{}PreserveNewest\textless{}/CopyToOutputDirectory\textgreater{}}
  alongside \texttt{AvaloniaResource}. That avoids bloating assemblies
  and keeps startup fast.
\item
  When you refactor project layout, set explicit logical paths:
  \texttt{\textless{}AvaloniaResource\ Update="Assets/logo.svg"\ LogicalPath="resm:MyApp.Assets.logo.svg"\textgreater{}}.
  Logical paths become the keys your app uses with \texttt{AssetLoader}.
\item
  Hook a custom
  \texttt{Target\ Name="VerifyAvaloniaResources"\ AfterTargets="ResolveAvaloniaResource"}
  to ensure required files exist; failing early prevents subtle runtime
  crashes after publish.
\end{itemize}

\subsection{7. Platform packaging}\label{platform-packaging}

\subsubsection{Windows}\label{windows-2}

\begin{itemize}
\tightlist
\item
  Basic distribution: zip the publish folder or single-file EXE.
\item
  MSIX: use \texttt{dotnet\ publish\ /p:WindowsPackageType=msix} or MSIX
  packaging tool. Enables automatic updates, store distribution.
\item
  MSI/Wix: for enterprise installs.
\item
  Code signing recommended (Authenticode certificate) to avoid
  SmartScreen warnings.
\end{itemize}

\subsubsection{macOS}\label{macos-2}

\begin{itemize}
\tightlist
\item
  Create \texttt{.app} bundle with
  \texttt{Avalonia.DesktopRuntime.MacOS} packaging scripts.
\item
  Code sign and notarize: use Apple Developer ID certificate,
  \texttt{codesign}, \texttt{xcrun\ altool}/\texttt{notarytool}.
\item
  Provide DMG for distribution.
\end{itemize}

\subsubsection{Linux}\label{linux-1}

\begin{itemize}
\tightlist
\item
  Zip/tarball publish folder with run script.
\item
  AppImage: use \texttt{Avalonia.AppTemplate.AppImage} or AppImage
  tooling to bundle.
\item
  Flatpak: create manifest (flatpak-builder). Ensure dependencies
  included via \texttt{org.freedesktop.Platform} runtime.
\item
  Snap: use \texttt{snapcraft.yaml} to bundle.
\end{itemize}

\subsubsection{Android}\label{android-1}

\begin{itemize}
\tightlist
\item
  Platform head (\texttt{MyApp.Android}) builds APK/AAB using Android
  tooling.
\item
  Publish release AAB and sign with keystore
  (\texttt{./gradlew\ bundleRelease} or \texttt{dotnet\ publish} using
  .NET Android tooling).
\item
  Upload to Google Play or sideload.
\end{itemize}

\subsubsection{iOS}\label{ios-1}

\begin{itemize}
\tightlist
\item
  Platform head (\texttt{MyApp.iOS}) builds .ipa using Xcode or
  \texttt{dotnet\ publish\ -f\ net8.0-ios\ -c\ Release} with workload.
\item
  Requires macOS, Xcode, signing certificates, provisioning profiles.
\item
  Deploy to App Store via Transporter/Xcode.
\end{itemize}

\subsubsection{Browser (WASM)}\label{browser-wasm}

\begin{itemize}
\tightlist
\item
  \texttt{dotnet\ publish\ -c\ Release} in browser head
  (\texttt{MyApp.Browser}). Output in
  \texttt{bin/Release/net8.0/browser-wasm/AppBundle}.
\item
  Deploy to static host (GitHub Pages, S3, etc.). Use service worker for
  caching if desired.
\end{itemize}

\subsection{8. Automation (CI/CD)}\label{automation-cicd}

\begin{itemize}
\tightlist
\item
  Use GitHub Actions/Azure Pipelines/GitLab CI to run
  \texttt{dotnet\ publish} per target.
\item
  Example GitHub Actions matrix aligned with Avalonia's build tasks:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{jobs}\KeywordTok{:}
\AttributeTok{  }\FunctionTok{publish}\KeywordTok{:}
\AttributeTok{    }\FunctionTok{runs{-}on}\KeywordTok{:}\AttributeTok{ $\{\{ matrix.os \}\}}
\AttributeTok{    }\FunctionTok{strategy}\KeywordTok{:}
\AttributeTok{      }\FunctionTok{matrix}\KeywordTok{:}
\AttributeTok{        }\FunctionTok{include}\KeywordTok{:}
\AttributeTok{          }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{os}\KeywordTok{:}\AttributeTok{ windows{-}latest}
\AttributeTok{            }\FunctionTok{rid}\KeywordTok{:}\AttributeTok{ win{-}x64}
\AttributeTok{          }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{os}\KeywordTok{:}\AttributeTok{ macos{-}latest}
\AttributeTok{            }\FunctionTok{rid}\KeywordTok{:}\AttributeTok{ osx{-}arm64}
\AttributeTok{          }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{os}\KeywordTok{:}\AttributeTok{ ubuntu{-}latest}
\AttributeTok{            }\FunctionTok{rid}\KeywordTok{:}\AttributeTok{ linux{-}x64}
\AttributeTok{    }\FunctionTok{steps}\KeywordTok{:}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{uses}\KeywordTok{:}\AttributeTok{ actions/checkout@v4}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{uses}\KeywordTok{:}\AttributeTok{ actions/setup{-}dotnet@v4}
\AttributeTok{        }\FunctionTok{with}\KeywordTok{:}
\AttributeTok{          }\FunctionTok{dotnet{-}version}\KeywordTok{:}\AttributeTok{ }\StringTok{\textquotesingle{}8.0.x\textquotesingle{}}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ Restore workloads}
\AttributeTok{        }\FunctionTok{run}\KeywordTok{:}\AttributeTok{ dotnet workload restore}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ Publish}
\FunctionTok{        run}\KeywordTok{: }\CharTok{|}
\NormalTok{          dotnet publish src/MyApp/MyApp.csproj \textbackslash{}}
\NormalTok{            {-}c Release \textbackslash{}}
\NormalTok{            {-}r $\{\{ matrix.rid \}\} \textbackslash{}}
\NormalTok{            {-}{-}self{-}contained true \textbackslash{}}
\NormalTok{            /p:PublishSingleFile=true \textbackslash{}}
\NormalTok{            /p:InformationalVersion=$\{\{ github.sha \}\}}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ Collect binlog on failure}
\AttributeTok{        }\FunctionTok{if}\KeywordTok{:}\AttributeTok{ failure()}
\AttributeTok{        }\FunctionTok{run}\KeywordTok{:}\AttributeTok{ dotnet publish src/MyApp/MyApp.csproj {-}c Release {-}r $\{\{ matrix.rid \}\} /bl:publish{-}$\{\{ matrix.rid \}\}.binlog}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{uses}\KeywordTok{:}\AttributeTok{ actions/upload{-}artifact@v4}
\AttributeTok{        }\FunctionTok{with}\KeywordTok{:}
\AttributeTok{          }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ myapp{-}$\{\{ matrix.rid \}\}}
\AttributeTok{          }\FunctionTok{path}\KeywordTok{:}\AttributeTok{ src/MyApp/bin/Release/net8.0/$\{\{ matrix.rid \}\}/publish}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ Upload binlog}
\AttributeTok{        }\FunctionTok{if}\KeywordTok{:}\AttributeTok{ failure()}
\AttributeTok{        }\FunctionTok{uses}\KeywordTok{:}\AttributeTok{ actions/upload{-}artifact@v4}
\AttributeTok{        }\FunctionTok{with}\KeywordTok{:}
\AttributeTok{          }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ publish{-}logs{-}$\{\{ matrix.rid \}\}}
\AttributeTok{          }\FunctionTok{path}\KeywordTok{:}\AttributeTok{ publish{-}$\{\{ matrix.rid \}\}.binlog}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Add packaging steps (MSIX, DMG) via platform-specific actions/tools.
\item
  Sign artifacts in CI where possible (store certificates securely).
\item
  Azure Pipelines alternative: copy patterns from
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/azure-pipelines.yml}{\texttt{azure-pipelines.yml}}
  to reuse matrix publishing, signing, and artifact staging.
\item
  For custom MSBuild integration, define
  \texttt{Target\ Name="SignArtifacts"\ AfterTargets="Publish"} or
  \texttt{AfterTargets="BundleApp"} in \texttt{Directory.Build.targets}
  so both local builds and CI run the same packaging hooks.
\end{itemize}

\subsection{9. Verification checklist}\label{verification-checklist}

\begin{itemize}
\tightlist
\item
  Run published app on real machines/VMs for each RID.
\item
  Check fonts, DPI, plugins, network resources.
\item
  Validate updates to config/resources; ensure relative paths work from
  publish folder.
\item
  If using trimming, run automated UITests (Chapter 21) and manual smoke
  tests.
\item
  Run \texttt{dotnet\ publish} with \texttt{-\/-self-contained}
  false/true to compare sizes and startup times; pick best trade-off.
\item
  Capture a SHA/hash of the publish folder (or installer) and include it
  in release notes so users can verify downloads.
\end{itemize}

\subsection{10. Troubleshooting}\label{troubleshooting-3}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Problem
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Fix
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Missing native libs on Linux & Install required packages
(\texttt{libicu}, \texttt{fontconfig}, \texttt{libx11}, etc.). Document
dependencies. \\
Startup crash only in Release & Enable logging to file; check for
missing assets; ensure \texttt{AvaloniaResource} includes. \\
High CPU at startup & Investigate ReadyToRun vs normal build; pre-load
data asynchronously vs synchronously. \\
Code signing errors (macOS/Windows) & Confirm certificates,
entitlements, notarization steps. \\
Publisher mismatch (store upload) & Align package IDs, manifest metadata
with store requirements. \\
\texttt{CompileAvaloniaXamlTask} failure & Clean \texttt{obj/}, fix XAML
build errors, and examine the \texttt{/bl} binlog to inspect generated
task arguments. \\
Native dependency failure (Skia/WASM) & Use
\texttt{ldd}/\texttt{otool}/\texttt{wasm-ld} reports to list missing
libraries; bundle them or switch to self-contained publishes. \\
\end{longtable}

\subsection{11. Practice exercises}\label{practice-exercises-20}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Publish self-contained builds for \texttt{win-x64},
  \texttt{osx-arm64}, \texttt{linux-x64}. Run each and note
  size/performance differences.
\item
  Enable \texttt{PublishSingleFile} and \texttt{PublishReadyToRun} for
  one target; compare startup time and size.
\item
  Experiment with trimming on a small sample; protect reflective types
  with \texttt{DynamicDependency} or \texttt{ILLinkTrim} descriptors and
  verify at runtime.
\item
  Set up a GitHub Actions workflow to publish RID-specific artifacts,
  collect binlogs on failure, and attach a checksum file.
\item
  Optional: create MSIX (Windows) or DMG (macOS) packages, sign them,
  and run locally to test installation/updates.
\item
  Bonus: add a custom MSBuild target that zips the publish folder and
  uploads a checksum to your CI artifacts.
\end{enumerate}

\subsection{Look under the hood (source \&
docs)}\label{look-under-the-hood-source-docs}

\begin{itemize}
\tightlist
\item
  Build docs:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/docs/build.md}{\texttt{docs/build.md}}
\item
  XAML compiler task:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Build.Tasks/CompileAvaloniaXamlTask.cs}{\texttt{CompileAvaloniaXamlTask.cs}}
\item
  Resource pipeline:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Build.Tasks/AvaloniaResource.cs}{\texttt{AvaloniaResource.cs}}
\item
  Shared targets:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/build/BuildTargets.targets}{\texttt{build/BuildTargets.targets}}
\item
  Samples for packaging patterns:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples/ControlCatalog}{\texttt{samples/ControlCatalog}}
\item
  CI reference:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/azure-pipelines.yml}{\texttt{azure-pipelines.yml}}
\item
  .NET publish docs:
  \href{https://learn.microsoft.com/dotnet/core/tools/dotnet-publish}{dotnet
  publish reference}
\item
  App packaging: Microsoft MSIX docs, Apple code signing docs,
  AppImage/Flatpak/Snap guidelines.
\end{itemize}

\subsection{Check yourself}\label{check-yourself-24}

\begin{itemize}
\tightlist
\item
  What's the difference between framework-dependent and self-contained
  publishes? When do you choose each?
\item
  How do single-file, ReadyToRun, and trimming impact size/performance?
\item
  Which MSBuild tasks make sure \texttt{.axaml} files and resources
  reach your publish output?
\item
  Which RIDs are needed for your user base?
\item
  What packaging format suits your distribution channel (installer, app
  store, raw executable)?
\item
  How can CI/CD automate builds and packaging per platform?
\end{itemize}

What's next - Next: \href{Chapter27.md}{Chapter 27}

\newpage

\subsection{27. Read the source, contribute, and
grow}\label{read-the-source-contribute-and-grow}

Goal - Navigate the Avalonia repo confidently, understand how to
build/test locally, and contribute fixes, features, docs, or samples. -
Step into framework sources while debugging your app, and know how to
file issues or PRs effectively. - Stay engaged with the community to
keep learning.

Why this matters - Framework knowledge deepens your debugging skills and
shapes better app architecture. - Contributions improve the ecosystem
and strengthen your expertise.

Prerequisites - Familiarity with Git, .NET tooling
(\texttt{dotnet\ build/publish/test}).

\subsection{1. Repository tour}\label{repository-tour}

Avalonia repo highlights: - Core source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src}{\texttt{src/}}
contains assemblies such as \texttt{Avalonia.Base},
\texttt{Avalonia.Controls}, \texttt{Avalonia.Markup.Xaml}, platform
heads, and backend integrations (\texttt{Skia}, \texttt{WinUI},
browser). - Tests:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/tests}{\texttt{tests/}}
mixes unit tests, headless UI tests, integration tests, and rendering
verification harnesses. Tests often reveal intended behavior and edge
cases. - Samples:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples}{\texttt{samples/}}
hosts ControlCatalog, BindingDemo, and scenario-driven apps. They double
as regression repros. - Tooling:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/build}{\texttt{build/}}
and
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/build/NukeBuild}{\texttt{build/NukeBuild}}
power CI, packaging, and developer workflows. - Docs:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/docs}{\texttt{docs/}}
complements the separate
\href{https://github.com/AvaloniaUI/avalonia-docs}{avalonia-docs} site.
- Contributor policy:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/CONTRIBUTING.md}{\texttt{CONTRIBUTING.md}},
coding conventions, and \texttt{.editorconfig} enforce consistent style
(spacing, naming) across submissions.

\subsection{2. Building the framework
locally}\label{building-the-framework-locally}

Scripts in repo root: - \texttt{build.ps1} (Windows), \texttt{build.sh}
(Unix), \texttt{build.cmd}. - These restore NuGet packages, compile, run
tests (optionally), and produce packages. - The repo also ships
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/build/NukeBuild}{\texttt{build/NukeBuild}}.
Run \texttt{dotnet\ run\ -\/-project\ build/NukeBuild} or
\texttt{.\textbackslash{}build.ps1\ -\/-target\ Test} to execute curated
pipelines (\texttt{Compile}, \texttt{Test}, \texttt{Package}, etc.)
identical to CI.

Manual build:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\#\# Restore dependencies}
\ExtensionTok{dotnet}\NormalTok{ restore Avalonia.sln}

\CommentTok{\#\# Build core}
\BuiltInTok{cd}\NormalTok{ src/Avalonia.Controls}
\ExtensionTok{dotnet}\NormalTok{ build }\AttributeTok{{-}c}\NormalTok{ Debug}

\CommentTok{\#\# Run tests}
\BuiltInTok{cd}\NormalTok{ tests/Avalonia.Headless.UnitTests}
\ExtensionTok{dotnet}\NormalTok{ test }\AttributeTok{{-}c}\NormalTok{ Release}

\CommentTok{\#\# Run sample}
\BuiltInTok{cd}\NormalTok{ samples/ControlCatalog}
 \ExtensionTok{dotnet}\NormalTok{ run}
\end{Highlighting}
\end{Shaded}

Follow \texttt{docs/build.md} for environment requirements.

\subsection{3. Testing strategy
overview}\label{testing-strategy-overview}

Avalonia's quality gates rely on multiple test layers: - Unit tests
(\texttt{tests/Avalonia.Base.UnitTests}, etc.) validate core property
system, styling, and helper utilities. - Headless interaction tests
(\texttt{tests/Avalonia.Headless.UnitTests}) simulate input/rendering
without a visible window. - Integration/UI tests leverage the
\texttt{Avalonia.IntegrationTests.Appium} harness for cross-platform
smoke tests. - Performance benchmarks (look under
\texttt{tests/Avalonia.Benchmarks}) measure layout, rendering, and
binding regressions.

When contributing, prefer adding or updating the test nearest to the
code you touch. For visual bugs, a headless interaction test plus a
ControlCatalog sample usually gives maintainers confidence.

\subsection{4. Reading source with
purpose}\label{reading-source-with-purpose}

Common entry points: - Controls/styling: \texttt{src/Avalonia.Controls/}
(Control classes, templates, themes). - Layout:
\texttt{src/Avalonia.Base/Layout/} (Measurement/arrange logic). -
Rendering: \texttt{src/Avalonia.Base/Rendering/},
\texttt{src/Skia/Avalonia.Skia/}. - Input:
\texttt{src/Avalonia.Base/Input/} (Pointer, keyboard, gesture
recognizers).

Use IDE features (Go to Definition, Find Usages) to jump between user
code and framework internals.

\subsection{5. Debugging into Avalonia}\label{debugging-into-avalonia}

\begin{itemize}
\tightlist
\item
  Enable symbol loading for Avalonia assemblies. NuGet packages ship
  SourceLink metadata---turn on ``Load symbols from Microsoft symbol
  servers'' (VS) or configure Rider's symbol caches so \texttt{.pdb}
  files download automatically.
\item
  Add a fallback source path pointing at your local clone
  (\texttt{external/Avalonia/src}) to guarantee line numbers match when
  you build from source.
\item
  Set breakpoints in your app, step into framework code to inspect
  layout/renderer behavior. Combine with DevTools overlays to correlate
  visual state with code paths.
\item
  When debugging ControlCatalog or your own sample against a local
  build, reference the project outputs directly (\texttt{dotnet\ pack} +
  \texttt{nuget\ add\ source}) so you test the same bits you'll propose
  in a PR.
\end{itemize}

\subsection{6. Filing issues}\label{filing-issues}

Best practice checklist: - Minimal reproducible sample (GitHub repo,
.zip, or steps to recreate with ControlCatalog). - Include platform(s),
.NET version, Avalonia version, self-contained vs framework-dependent. -
Summarize expected vs actual behavior. Provide logs
(Binding/Layout/Render) or screenshot/video when relevant. - Tag
regression vs new bug; mention if release-only or debug-only.

\subsection{7. Contributing pull
requests}\label{contributing-pull-requests}

Steps: 1. Check CONTRIBUTING.md for branching/style. 2. Fork repo,
create feature branch. 3. Implement change (small, focused scope). 4.
Add/update tests under \texttt{tests/} (headless tests for controls,
unit tests for logic). 5. Run \texttt{dotnet\ build} and
\texttt{dotnet\ test} (or
\texttt{.\textbackslash{}build.ps1\ -\/-target\ Test} /
\texttt{nuke\ Test}). 6. Update docs/samples if behavior changed. 7.
Submit PR with clear description, referencing issue IDs/sites. 8.
Respond to feedback promptly.

\subsubsection{Writing tests}\label{writing-tests}

\begin{itemize}
\tightlist
\item
  Use headless tests for visual/interaction behavior (Chapter 21 covers
  pattern).
\item
  Add regression tests for fixed bugs to prevent future breakage.
\item
  Consider measuring performance (BenchmarkDotNet) if change affects
  rendering/layout.
\end{itemize}

\subsubsection{Doc-only or sample-only
PRs}\label{doc-only-or-sample-only-prs}

\begin{itemize}
\tightlist
\item
  Target \texttt{avalonia-docs} or \texttt{docs/} when API behavior
  changes. Reference the code PR in your documentation PR so reviewers
  can coordinate releases.
\item
  For book/doc updates that do not touch runtime code, label the PR
  \texttt{Documentation} and mention ``no runtime changes'' in the
  description; CI can skip heavy legs when reviewers apply the label.
\item
  Keep screenshots or GIFs small and check them into
  \texttt{docs/images/} or the appropriate sample folder. Update
  markdown links accordingly.
\end{itemize}

\subsection{8. Docs \& sample
contributions}\label{docs-sample-contributions}

\begin{itemize}
\tightlist
\item
  Docs source:
  \href{https://github.com/AvaloniaUI/avalonia-docs}{avalonia-docs
  repository}. Preview the site locally with \texttt{npm\ install} +
  \texttt{npm\ start} to validate links before submitting.
\item
  In-repo docs under \texttt{docs/} explain build and architecture
  topics; align book/new content with these guides.
\item
  Samples: add new sample to \texttt{samples/} illustrating advanced
  patterns or new controls. Update \texttt{samples/README.md} when you
  add something new.
\item
  Keep docs in sync with code changes for features/bug fixes and
  cross-link PRs so reviewers merge them together.
\end{itemize}

\subsection{9. Community \& learning}\label{community-learning}

\begin{itemize}
\tightlist
\item
  GitHub discussions:
  \href{https://github.com/AvaloniaUI/Avalonia/discussions}{AvaloniaUI
  discussions}.
\item
  Discord community: link in README.
\item
  Follow release notes and blog posts for new features (subscribe to
  repo releases).
\item
  Speak at meetups, write blog posts, or answer questions to grow
  visibility and knowledge.
\end{itemize}

\subsection{10. Sustainable contribution
workflow}\label{sustainable-contribution-workflow}

Checklist before submitting work: - {[} {]} Reproduced issue with
minimal sample. - {[} {]} Wrote or updated tests covering change. - {[}
{]} Verified on all affected platforms
(Windows/macOS/Linux/Mobile/Browser where applicable). - {[} {]}
Performance measured if relevant. - {[} {]} Docs/samples updated.

\subsection{11. Practice exercises}\label{practice-exercises-21}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Clone the Avalonia repo and run
  \texttt{.\textbackslash{}build.ps1\ -\/-target\ Compile} (or
  \texttt{dotnet\ run\ -\/-project\ build/NukeBuild\ Compile}). Verify
  the build succeeds and inspect the generated artifacts.
\item
  Launch ControlCatalog from the sample folder, then step into the code
  for one control you use frequently.
\item
  Configure symbol/source mapping in your IDE and step into
  \texttt{TextBlock} rendering while running ControlCatalog.
\item
  File a sample issue in a sandbox repo (practice minimal repro).
  Outline expected vs actual behavior clearly.
\item
  Write a headless unit test for a simple control (e.g., verifying a
  custom control draws expected output) and run it locally.
\item
  Draft a doc-only PR in \texttt{avalonia-docs} describing a workflow
  you improved (link back to the code sample or issue).
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-24}

\begin{itemize}
\tightlist
\item
  Repo root:
  \href{https://github.com/AvaloniaUI/Avalonia}{github.com/AvaloniaUI/Avalonia}
\item
  Build scripts:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/build.ps1}{\texttt{build.ps1}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/build.sh}{\texttt{build.sh}}
\item
  NUKE entry point:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/build/NukeBuild}{\texttt{build/NukeBuild}}
\item
  Tests index:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/tests}{\texttt{tests/}}
\item
  Sample gallery:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples}{\texttt{samples/}}
\item
  Issue templates: \texttt{.github/ISSUE\_TEMPLATE} directory
  (bug/feature request).
\item
  PR template: \texttt{.github/pull\_request\_template.md}.
\end{itemize}

\subsection{Check yourself}\label{check-yourself-25}

\begin{itemize}
\tightlist
\item
  Where do you find tests or samples relevant to a control you're
  debugging?
\item
  How do you step into Avalonia sources from your app?
\item
  What makes a strong issue/PR description?
\item
  How can you contribute documentation or samples beyond code?
\item
  When would you reach for the NUKE build scripts instead of calling
  \texttt{dotnet\ build} directly?
\item
  Which community channels help you stay informed about releases and
  roadmap?
\end{itemize}

What's next - Next: \href{Chapter28.md}{Chapter28}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part VI — Advanced interactivity, markup, and platform integration}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part VI — Advanced interactivity, markup, and platform integration}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{28. Advanced input system and
interactivity}\label{advanced-input-system-and-interactivity}

Goal - Coordinate pointer, keyboard, gamepad/remote, and text input so
complex UI stays responsive. - Build custom gestures and capture
strategies that feel natural across mouse, touch, and pen. - Keep
advanced interactions accessible by mirroring behaviour across input
modalities and IME scenarios.

Why this matters - Modern apps must work with touch, pen, mouse,
keyboard, remotes, and assistive tech simultaneously. - Avalonia's input
stack is highly extensible; understanding the pipeline prevents subtle
bugs (ghost captures, lost focus, broken gestures). - When you marry
gestures with automation, you avoid excluding keyboard- or
screen-reader-only users.

Prerequisites - Chapter 9 (commands, events, and user input) for
routed-event basics. - Chapter 15 (accessibility) to validate
keyboard/automation parity. - Chapter 23 (custom controls) if you plan
to surface bespoke surfaces that drive input directly.

\subsection{1. How Avalonia routes
input}\label{how-avalonia-routes-input}

Avalonia turns OS-specific events into a three-stage pipeline
(\texttt{InputManager.ProcessInput}).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Raw input} arrives as \texttt{RawInputEventArgs} (mouse,
  touch, pen, keyboard, gamepad). Each \texttt{IRenderRoot} has devices
  that call \texttt{Device.ProcessRawEvent}.
\item
  \textbf{Pre-process observers}
  (\texttt{InputManager.Instance?.PreProcess}) can inspect or cancel
  before routing. Use this sparingly for diagnostics, not business
  logic.
\item
  \textbf{Device routing} converts raw data into routed events
  (\texttt{PointerPressedEvent}, \texttt{KeyDownEvent},
  \texttt{TextInputMethodClientRequestedEvent}).
\item
  \textbf{Process/PostProcess observers} see events after
  routing---handy for analytics or global shortcuts.
\end{enumerate}

Because the input manager lives in \texttt{AvaloniaLocator}, you can
temporarily subscribe:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ IDisposable}\OperatorTok{?}\NormalTok{ sub }\OperatorTok{=}\NormalTok{ InputManager}\OperatorTok{.}\FunctionTok{Instance}\OperatorTok{?}
    \OperatorTok{.}\FunctionTok{PreProcess}\OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{raw }\OperatorTok{=\textgreater{}}\NormalTok{ \_log}\OperatorTok{.}\FunctionTok{Debug}\OperatorTok{(}\StringTok{"Raw input \{Device\} \{Type\}"}\OperatorTok{,}\NormalTok{ raw}\OperatorTok{.}\FunctionTok{Device}\OperatorTok{,}\NormalTok{ raw}\OperatorTok{.}\FunctionTok{RoutedEvent}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Remember to dispose subscriptions; the pipeline never terminates while
the app runs.

\subsection{2. Pointer fundamentals and event
order}\label{pointer-fundamentals-and-event-order}

\texttt{InputElement} exposes pointer events (bubble strategy by
default).

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Event
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Trigger
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Key data
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{PointerEntered} / \texttt{PointerExited} & Pointer crosses
hit-test boundary & \texttt{Pointer.Type}, \texttt{KeyModifiers},
\texttt{Pointer.IsPrimary} \\
\texttt{PointerPressed} & Button/contact press &
\texttt{PointerUpdateKind}, \texttt{PointerPointProperties},
\texttt{ClickCount} in \texttt{PointerPressedEventArgs} \\
\texttt{PointerMoved} & Pointer moves while inside or captured &
\texttt{GetPosition}, \texttt{GetIntermediatePoints} \\
\texttt{PointerWheelChanged} & Mouse wheel / precision scroll &
\texttt{Vector\ delta}, \texttt{PointerPoint.Properties} \\
\texttt{PointerReleased} & Button/contact release &
\texttt{Pointer.IsPrimary}, \texttt{Pointer.Captured} \\
\texttt{PointerCaptureLost} & Capture re-routed, element removed, or
pointer disposed & \texttt{PointerCaptureLostEventArgs.Pointer} \\
\end{longtable}

Event routing is tunable:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnInitialized}\OperatorTok{()}
\OperatorTok{\{}
    \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnInitialized}\OperatorTok{();}
    \FunctionTok{AddHandler}\OperatorTok{(}\NormalTok{PointerPressedEvent}\OperatorTok{,}\NormalTok{ OnPreviewPressed}\OperatorTok{,}\NormalTok{ handledEventsToo}\OperatorTok{:} \KeywordTok{true}\OperatorTok{);}
    \FunctionTok{AddHandler}\OperatorTok{(}\NormalTok{PointerPressedEvent}\OperatorTok{,}\NormalTok{ OnPressed}\OperatorTok{,}\NormalTok{ routingStrategies}\OperatorTok{:}\NormalTok{ RoutingStrategies}\OperatorTok{.}\FunctionTok{Tunnel} \OperatorTok{|}\NormalTok{ RoutingStrategies}\OperatorTok{.}\FunctionTok{Bubble}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Use tunnel handlers (\texttt{RoutingStrategies.Tunnel}) for global
shortcuts (e.g., closing flyouts). Keep bubbling logic per control.

\subsubsection{Working with pointer
positions}\label{working-with-pointer-positions}

\begin{itemize}
\tightlist
\item
  \texttt{e.GetPosition(this)} projects coordinates into any visual's
  space; pass \texttt{null} for top-level coordinates.
\item
  \texttt{e.GetIntermediatePoints(this)} yields historical
  samples---crucial for smoothing freehand ink.
\item
  \texttt{PointerPoint.Properties} exposes pressure, tilt, contact
  rectangles, and button states. Always verify availability
  (\texttt{Pointer.Type\ ==\ PointerType.Pen} before reading pressure).
\end{itemize}

\subsection{3. Pointer capture and lifetime
handling}\label{pointer-capture-and-lifetime-handling}

Capturing sends subsequent input to an element regardless of pointer
location---vital for drags.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnPointerPressed}\OperatorTok{(}\NormalTok{PointerPressedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{Pointer}\OperatorTok{.}\FunctionTok{Type} \OperatorTok{==}\NormalTok{ PointerType}\OperatorTok{.}\FunctionTok{Touch}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        e}\OperatorTok{.}\FunctionTok{Pointer}\OperatorTok{.}\FunctionTok{Capture}\OperatorTok{(}\KeywordTok{this}\OperatorTok{);}
\NormalTok{        \_dragStart }\OperatorTok{=}\NormalTok{ e}\OperatorTok{.}\FunctionTok{GetPosition}\OperatorTok{(}\KeywordTok{this}\OperatorTok{);}
\NormalTok{        e}\OperatorTok{.}\FunctionTok{Handled} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}

\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnPointerReleased}\OperatorTok{(}\NormalTok{PointerReleasedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\FunctionTok{ReferenceEquals}\OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{Pointer}\OperatorTok{.}\FunctionTok{Captured}\OperatorTok{,} \KeywordTok{this}\OperatorTok{))}
    \OperatorTok{\{}
\NormalTok{        e}\OperatorTok{.}\FunctionTok{Pointer}\OperatorTok{.}\FunctionTok{Capture}\OperatorTok{(}\KeywordTok{null}\OperatorTok{);}
        \FunctionTok{CompleteDrag}\OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{GetPosition}\OperatorTok{(}\KeywordTok{this}\OperatorTok{));}
\NormalTok{        e}\OperatorTok{.}\FunctionTok{Handled} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Key rules: - Always release capture (\texttt{Capture(null)}) on
completion or cancellation. - Watch \texttt{PointerCaptureLost}---it
fires if the element leaves the tree or another control steals capture.
- Don't forget to handle the gesture recognizer case: if a recognizer
captures the pointer, your control stops receiving \texttt{PointerMoved}
events until capture returns. - When chaining capture up the tree
(\texttt{Control} → \texttt{Window}), consider
\texttt{e.Pointer.Capture(this)} in the top-level to avoid anomalies
when children are removed mid-gesture.

\subsection{4. Multi-touch, pen, and high-precision
data}\label{multi-touch-pen-and-high-precision-data}

Avalonia assigns unique IDs per contact (\texttt{Pointer.Id}) and marks
a primary contact (\texttt{Pointer.IsPrimary}). Keep per-pointer state
in a dictionary:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Dictionary}\OperatorTok{\textless{}}\DataTypeTok{int}\OperatorTok{,}\NormalTok{ PointerTracker}\OperatorTok{\textgreater{}}\NormalTok{ \_active }\OperatorTok{=} \KeywordTok{new}\OperatorTok{();}

\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnPointerPressed}\OperatorTok{(}\NormalTok{PointerPressedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    \_active}\OperatorTok{[}\NormalTok{e}\OperatorTok{.}\FunctionTok{Pointer}\OperatorTok{.}\FunctionTok{Id}\OperatorTok{]} \OperatorTok{=} \KeywordTok{new} \FunctionTok{PointerTracker}\OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{Pointer}\OperatorTok{.}\FunctionTok{Type}\OperatorTok{,}\NormalTok{ e}\OperatorTok{.}\FunctionTok{GetPosition}\OperatorTok{(}\KeywordTok{this}\OperatorTok{));}
    \FunctionTok{UpdateManipulation}\OperatorTok{();}
\OperatorTok{\}}

\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnPointerReleased}\OperatorTok{(}\NormalTok{PointerReleasedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    \_active}\OperatorTok{.}\FunctionTok{Remove}\OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{Pointer}\OperatorTok{.}\FunctionTok{Id}\OperatorTok{);}
    \FunctionTok{UpdateManipulation}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Pen-specific data lives in \texttt{PointerPoint.Properties}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ sample }\OperatorTok{=}\NormalTok{ e}\OperatorTok{.}\FunctionTok{GetCurrentPoint}\OperatorTok{(}\KeywordTok{this}\OperatorTok{);}
\DataTypeTok{float}\NormalTok{ pressure }\OperatorTok{=}\NormalTok{ sample}\OperatorTok{.}\FunctionTok{Properties}\OperatorTok{.}\FunctionTok{Pressure}\OperatorTok{;} \CommentTok{// 0{-}1}
\DataTypeTok{bool}\NormalTok{ isEraser }\OperatorTok{=}\NormalTok{ sample}\OperatorTok{.}\FunctionTok{Properties}\OperatorTok{.}\FunctionTok{IsEraser}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Touch sends a contact rectangle (\texttt{ContactRect}) you can use for
palm rejection or handle-size aware UI.

\subsection{5. Gesture recognizers in
depth}\label{gesture-recognizers-in-depth}

Two gesture models coexist:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Predefined routed events} in \texttt{Avalonia.Input.Gestures}
  (\texttt{Tapped}, \texttt{DoubleTapped}, \texttt{RightTapped}). Attach
  with \texttt{Gestures.AddDoubleTappedHandler} or \texttt{AddHandler}.
\item
  \textbf{Composable recognizers}
  (\texttt{InputElement.GestureRecognizers}) for continuous gestures
  (pinch, pull-to-refresh, scroll).
\end{enumerate}

To attach built-in recognizers:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{GestureRecognizers}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\KeywordTok{new}\NormalTok{ PinchGestureRecognizer}
\OperatorTok{\{}
    \CommentTok{// Your subclasses can expose properties via styled setters}
\OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

Creating your own recognizer lets you coordinate multiple pointers and
maintain internal state:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ PressAndHoldRecognizer }\OperatorTok{:}\NormalTok{ GestureRecognizer}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static} \KeywordTok{readonly}\NormalTok{ RoutedEvent}\OperatorTok{\textless{}}\NormalTok{RoutedEventArgs}\OperatorTok{\textgreater{}}\NormalTok{ PressAndHoldEvent }\OperatorTok{=}
\NormalTok{        RoutedEvent}\OperatorTok{.}\FunctionTok{Register}\OperatorTok{\textless{}}\NormalTok{InputElement}\OperatorTok{,}\NormalTok{ RoutedEventArgs}\OperatorTok{\textgreater{}(}
            \FunctionTok{nameof}\OperatorTok{(}\NormalTok{PressAndHoldEvent}\OperatorTok{),}\NormalTok{ RoutingStrategies}\OperatorTok{.}\FunctionTok{Bubble}\OperatorTok{);}

    \KeywordTok{public}\NormalTok{ TimeSpan Threshold }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \KeywordTok{set}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=}\NormalTok{ TimeSpan}\OperatorTok{.}\FunctionTok{FromMilliseconds}\OperatorTok{(}\DecValTok{600}\OperatorTok{);}

    \KeywordTok{private}\NormalTok{ CancellationTokenSource}\OperatorTok{?}\NormalTok{ \_hold}\OperatorTok{;}
    \KeywordTok{private}\NormalTok{ Point \_pressOrigin}\OperatorTok{;}

    \KeywordTok{protected} \KeywordTok{override}\NormalTok{ async }\DataTypeTok{void} \FunctionTok{PointerPressed}\OperatorTok{(}\NormalTok{PointerPressedEventArgs e}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{Target }\KeywordTok{is}\NormalTok{ not Visual visual}\OperatorTok{)}
            \KeywordTok{return}\OperatorTok{;}

\NormalTok{        \_pressOrigin }\OperatorTok{=}\NormalTok{ e}\OperatorTok{.}\FunctionTok{GetPosition}\OperatorTok{(}\NormalTok{visual}\OperatorTok{);}
        \FunctionTok{Capture}\OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{Pointer}\OperatorTok{);}

\NormalTok{        \_hold }\OperatorTok{=} \KeywordTok{new} \FunctionTok{CancellationTokenSource}\OperatorTok{();}
        \KeywordTok{try}
        \OperatorTok{\{}
\NormalTok{            await Task}\OperatorTok{.}\FunctionTok{Delay}\OperatorTok{(}\NormalTok{Threshold}\OperatorTok{,}\NormalTok{ \_hold}\OperatorTok{.}\FunctionTok{Token}\OperatorTok{);}
\NormalTok{            Target}\OperatorTok{?.}\FunctionTok{RaiseEvent}\OperatorTok{(}\KeywordTok{new} \FunctionTok{RoutedEventArgs}\OperatorTok{(}\NormalTok{PressAndHoldEvent}\OperatorTok{));}
        \OperatorTok{\}}
        \KeywordTok{catch} \OperatorTok{(}\NormalTok{TaskCanceledException}\OperatorTok{)}
        \OperatorTok{\{}
            \CommentTok{// Swallow cancellation when pointer moves or releases early.}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{PointerMoved}\OperatorTok{(}\NormalTok{PointerEventArgs e}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{Target }\KeywordTok{is}\NormalTok{ not Visual visual }\OperatorTok{||}\NormalTok{ \_hold }\KeywordTok{is} \KeywordTok{null} \OperatorTok{||}\NormalTok{ \_hold}\OperatorTok{.}\FunctionTok{IsCancellationRequested}\OperatorTok{)}
            \KeywordTok{return}\OperatorTok{;}

        \DataTypeTok{var}\NormalTok{ current }\OperatorTok{=}\NormalTok{ e}\OperatorTok{.}\FunctionTok{GetPosition}\OperatorTok{(}\NormalTok{visual}\OperatorTok{);}
        \KeywordTok{if} \OperatorTok{((}\NormalTok{current }\OperatorTok{{-}}\NormalTok{ \_pressOrigin}\OperatorTok{).}\FunctionTok{Length} \OperatorTok{\textgreater{}} \DecValTok{8}\OperatorTok{)}
\NormalTok{            \_hold}\OperatorTok{.}\FunctionTok{Cancel}\OperatorTok{();}
    \OperatorTok{\}}

    \KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{PointerReleased}\OperatorTok{(}\NormalTok{PointerReleasedEventArgs e}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_hold}\OperatorTok{?.}\FunctionTok{Cancel}\OperatorTok{();}
    \KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{PointerCaptureLost}\OperatorTok{(}\NormalTok{IPointer pointer}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_hold}\OperatorTok{?.}\FunctionTok{Cancel}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Register the routed event (\texttt{PressAndHoldEvent}) on your control
and listen just like other events. Note the call to
\texttt{Capture(e.Pointer)} which also calls
\texttt{PreventGestureRecognition()} to stop competing recognizers.

\subsubsection{Manipulation gestures and
inertia}\label{manipulation-gestures-and-inertia}

Avalonia exposes higher-level manipulation data through gesture
recognizers so you do not have to rebuild velocity tracking yourself.

\begin{itemize}
\tightlist
\item
  \texttt{ScrollGestureRecognizer} raises
  \texttt{ScrollGestureEventArgs} with linear deltas and
  velocities---ideal for kinetic scrolling or canvas panning.
\item
  \texttt{PinchGestureRecognizer} produces \texttt{PinchEventArgs} that
  report scale, rotation, and centroid changes for zoom surfaces.
\item
  \texttt{PullGestureRecognizer} keeps track of displacement against a
  threshold (\texttt{PullGestureRecognizer.TriggerDistance}) so you can
  drive pull-to-refresh visuals without reimplementing spring physics.
\item
  Internally, each recognizer uses \texttt{VelocityTracker} to compute
  momentum; you can hook \texttt{GestureRecognizer.Completed} to project
  inertia with your own easing.
\end{itemize}

Attach event handlers directly on the recognizer when you need raw data:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ scroll }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ScrollGestureRecognizer}\OperatorTok{();}
\NormalTok{scroll}\OperatorTok{.}\FunctionTok{Scroll} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_viewport }\OperatorTok{+=}\NormalTok{ e}\OperatorTok{.}\FunctionTok{DeltaTranslation}\OperatorTok{;}
\NormalTok{scroll}\OperatorTok{.}\FunctionTok{Inertia} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ e}\OperatorTok{)} \OperatorTok{=\textgreater{}} \FunctionTok{StartInertiaAnimation}\OperatorTok{(}\NormalTok{e}\OperatorTok{.}\FunctionTok{Velocity}\OperatorTok{);}
\NormalTok{GestureRecognizers}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{scroll}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Manipulation events coexist with pointer events. Mark the gesture event
as handled when you consume it so the default scroll viewer does not
fight your logic. For custom behaviors (elastic edges, snap points),
tune \texttt{ScrollGestureRecognizer.IsContinuous},
\texttt{ScrollGestureRecognizer.CanHorizontallyScroll}, and
\texttt{ScrollGestureRecognizer.CanVerticallyScroll} to match your
layout.

\subsection{6. Designing complex pointer
experiences}\label{designing-complex-pointer-experiences}

Strategies for common scenarios:

\begin{itemize}
\tightlist
\item
  \textbf{Drag handles on templated controls:} capture the pointer in
  the handle \texttt{Thumb}, raise a routed \texttt{DragDelta} event,
  and update layout in response. Release capture in
  \texttt{PointerReleased} and \texttt{PointerCaptureLost}.
\item
  \textbf{Drawing canvases:} store sampled points per pointer ID, use
  \texttt{GetIntermediatePoints} for smooth curves, and throttle
  invalidation with \texttt{DispatcherTimer} to keep the UI responsive.
\item
  \textbf{Canvas panning + zooming:} differentiate gestures by pointer
  count---single pointer pans, two pointers feed
  \texttt{PinchGestureRecognizer} for zoom. Combine with
  \texttt{MatrixTransform} on the content.
\item
  \textbf{Edge swipe or pull-to-refresh:} use
  \texttt{PullGestureRecognizer} with \texttt{PullDirection} to
  recognise deflection and expose progress to the view model.
\item
  \textbf{Hover tooltips:} \texttt{PointerEntered} kicks off a timer,
  \texttt{PointerExited} cancels it; inspect
  \texttt{e.GetCurrentPoint(this).Properties.PointerUpdateKind} to
  ignore quick flicks.
\end{itemize}

Platform differences worth noting: - \textbf{Windows/macOS/Linux} share
pointer semantics, but only touch-capable hardware raises
\texttt{PointerType.Touch}. Guard pen-specific paths behind
\texttt{Pointer.Type\ ==\ PointerType.Pen} because Linux/X11 backends
can omit advanced pen properties. - \textbf{Mobile backends}
(Android/iOS) dispatch multi-touch contacts without a mouse concept;
ensure commands have keyboard fallbacks if you reuse the view for
desktop. - \textbf{Browser (WASM)} lacks raw access to OS cursors and
some pen metrics; \texttt{PointerPoint.Properties.Pressure} may always
be \texttt{1.0}. - \textbf{Tizen} requires declaring the
\texttt{http://tizen.org/privilege/haptic} privilege before you can
trigger haptics from pull or press gestures.

\subsection{7. Keyboard navigation, focus, and
shortcuts}\label{keyboard-navigation-focus-and-shortcuts}

Avalonia's focus engine is pluggable.

\begin{itemize}
\tightlist
\item
  Each \texttt{TopLevel} exposes a \texttt{FocusManager} (via
  \texttt{(this.GetVisualRoot()\ as\ IInputRoot)?.FocusManager}) that
  drives tab order (\texttt{TabIndex}, \texttt{IsTabStop}).
\item
  \texttt{IKeyboardNavigationHandler} orchestrates directional nav;
  register your own implementation before building the app,
  e.g.~\texttt{AvaloniaLocator.CurrentMutable.Bind\textless{}IKeyboardNavigationHandler\textgreater{}().ToSingleton\textless{}CustomHandler\textgreater{}();}.
\item
  \texttt{XYFocus} attached properties override directional targets for
  gamepad/remote scenarios:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{StackPanel}
\OtherTok{    input:XYFocus.Up=}\StringTok{"\{Binding ElementName=SearchBox\}"}
\OtherTok{    input:XYFocus.NavigationModes=}\StringTok{"Keyboard,Gamepad"}\NormalTok{ /\textgreater{}}
\end{Highlighting}
\end{Shaded}

Key bindings complement commands without requiring specific controls:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{KeyBindings}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\KeywordTok{new}\NormalTok{ KeyBinding}
\OperatorTok{\{}
\NormalTok{    Gesture }\OperatorTok{=} \KeywordTok{new} \FunctionTok{KeyGesture}\OperatorTok{(}\NormalTok{Key}\OperatorTok{.}\FunctionTok{N}\OperatorTok{,}\NormalTok{ KeyModifiers}\OperatorTok{.}\FunctionTok{Control} \OperatorTok{|}\NormalTok{ KeyModifiers}\OperatorTok{.}\FunctionTok{Shift}\OperatorTok{),}
\NormalTok{    Command }\OperatorTok{=}\NormalTok{ ViewModel}\OperatorTok{.}\FunctionTok{NewNoteCommand}
\OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

\texttt{HotKeyManager} subscribes globally:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{HotKeyManager}\OperatorTok{.}\FunctionTok{SetHotKey}\OperatorTok{(}\KeywordTok{this}\OperatorTok{,}\NormalTok{ KeyGesture}\OperatorTok{.}\FunctionTok{Parse}\OperatorTok{(}\StringTok{"F2"}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Ensure the target control implements \texttt{ICommandSource} or
\texttt{IClickableControl}; Avalonia wires the gesture into the
containing \texttt{TopLevel} and executes the command or raises
\texttt{Click}.

Ensure focus cues remain visible: call \texttt{NavigationMethod.Tab}
when moving focus programmatically so keyboard users see an adorner.

\subsection{8. Gamepad, remote, and spatial
focus}\label{gamepad-remote-and-spatial-focus}

When Avalonia detects non-keyboard key devices, it sets
\texttt{KeyDeviceType} on key events. Use
\texttt{FocusManager.GetFocusManager(this)?.Focus(elem,\ NavigationMethod.Directional,\ modifiers)}
to respect D-Pad navigation.

Configure XY focus per visual:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Property
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{XYFocus.Up/Down/Left/Right} & Explicit neighbours when layout is
irregular \\
\texttt{XYFocus.NavigationModes} & Enable keyboard, gamepad, remote
individually \\
\texttt{XYFocus.LeftNavigationStrategy} & Choose default algorithm
(closest edge, projection, navigation axis) \\
\end{longtable}

For dense grids (e.g., TV apps), set
\texttt{XYFocus.NavigationModes="Gamepad,Remote"} and assign explicit
neighbours to avoid diagonal jumps. Pair with \texttt{KeyBindings} for
shortcuts like \texttt{Back} or \texttt{Menu} buttons on controllers
(map gamepad keys via key modifiers on the key event).

Where hardware exposes haptic feedback (mobile, TV remotes), query the
platform implementation with
\texttt{TopLevel.PlatformImpl?.TryGetFeature\textless{}TFeature\textgreater{}()}.
Some backends surface rumble/vibration helpers; when none are available,
fall back gracefully so keyboard-only users are not blocked.

\subsection{9. Text input services and IME
integration}\label{text-input-services-and-ime-integration}

Text input flows through \texttt{InputMethod},
\texttt{TextInputMethodClient}, and \texttt{TextInputOptions}.

\begin{itemize}
\tightlist
\item
  \texttt{TextInputOptions} attached properties describe desired
  keyboard UI.
\item
  \texttt{TextInputMethodClient} adapts a text view to IMEs (caret
  rectangle, surrounding text, reconversion).
\item
  \texttt{InputMethod.GetIsInputMethodEnabled} lets you disable the IME
  for password fields.
\end{itemize}

Set options in XAML:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TextBox}
\OtherTok{    Text=}\StringTok{""}
\OtherTok{    input:TextInputOptions.ContentType=}\StringTok{"Email"}
\OtherTok{    input:TextInputOptions.ReturnKeyType=}\StringTok{"Send"}
\OtherTok{    input:TextInputOptions.ShowSuggestions=}\StringTok{"True"}
\OtherTok{    input:TextInputOptions.IsSensitive=}\StringTok{"False"}\NormalTok{ /\textgreater{}}
\end{Highlighting}
\end{Shaded}

When you implement custom text surfaces (code editors, chat bubbles):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Implement \texttt{TextInputMethodClient} to expose text range, caret
  rect, and surrounding text.
\item
  Handle \texttt{TextInputMethodClientRequested} in your control to
  supply the client.
\item
  Call \texttt{InputMethod.SetIsInputMethodEnabled(this,\ true)} and
  update the client's \texttt{TextViewVisual} so IME windows track the
  caret.
\item
  On geometry changes, raise
  \texttt{TextInputMethodClient.CursorRectangleChanged} so the backend
  updates composition windows.
\end{enumerate}

Remember to honor \texttt{TextInputOptions.IsSensitive}---set it when
editing secrets so onboard keyboards hide predictions.

\subsection{10. Accessibility and multi-modal
parity}\label{accessibility-and-multi-modal-parity}

Advanced interactions must fall back to keyboard and automation:

\begin{itemize}
\tightlist
\item
  Offer parallel commands (\texttt{KeyBindings}, buttons) for
  pointer-only gestures.
\item
  When adding custom gestures, raise semantic routed events (e.g.,
  \texttt{CopyRequested}) so automation peers can invoke them.
\item
  Keep automation peers updated
  (\texttt{AutomationProperties.ControlType},
  \texttt{AutomationProperties.IsControlElement}) when capture changes
  visual state.
\item
  Respect \texttt{FocusManager} decisions---never suppress focus
  adorners merely because a pointer started the interaction.
\item
  Use \texttt{InputMethod.SetIsInputMethodEnabled} and
  \texttt{TextInputOptions} to support assistive text input (switch
  control, dictation).
\end{itemize}

\subsection{11. Multi-modal input lab
(practice)}\label{multi-modal-input-lab-practice}

Create a playground that exercises every surface:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Project setup}: scaffold
  \texttt{dotnet\ new\ avalonia.mvvm\ -n\ InputLab}. Add a
  \texttt{CanvasView} control hosting drawing, a side panel for logs,
  and a bottom toolbar.
\item
  \textbf{Pointer canvas}: capture touch/pen input, buffer points per
  pointer ID, and render trails using
  \texttt{DrawingContext.DrawGeometry}. Display pressure as stroke
  thickness.
\item
  \textbf{Custom gesture}: add the \texttt{PressAndHoldRecognizer}
  (above) to show context commands after 600 ms. Hook the resulting
  routed event to toggle a radial menu.
\item
  \textbf{Pinch \& scroll}: attach \texttt{PinchGestureRecognizer} and
  \texttt{ScrollGestureRecognizer} to pan/zoom the canvas. Update a
  \texttt{MatrixTransform} as gesture delta arrives.
\item
  \textbf{Keyboard navigation}: define \texttt{KeyBindings} for
  \texttt{Ctrl+Z}, \texttt{Ctrl+Shift+Z}, and arrow-key panning. Update
  \texttt{XYFocus} properties so D-Pad moves between toolbar buttons.
\item
  \textbf{Gamepad test}: using a controller or emulator, verify focus
  flows across the UI. Log \texttt{KeyDeviceType} in \texttt{KeyDown} to
  confirm Avalonia recognises it as Gamepad.
\item
  \textbf{IME sandbox}: place a chat-style \texttt{TextBox} with
  \texttt{TextInputOptions.ReturnKeyType="Send"}, plus a custom
  \texttt{MentionTextBox} implementing \texttt{TextInputMethodClient} to
  surface inline completions.
\item
  \textbf{Accessibility pass}: ensure every action has a keyboard
  alternative, set automation names on dynamically created controls, and
  test the capture cycle with screen reader cursor.
\item
  \textbf{Diagnostics}: subscribe to
  \texttt{InputManager.Instance?.Process} and log pointer ID, update
  kind, and capture target into a side list for debugging.
\end{enumerate}

Document findings in README (which gestures compete, how capture behaves
on focus loss) so the team can adjust default UX.

\subsection{12. Troubleshooting \& best
practices}\label{troubleshooting-best-practices-2}

\begin{itemize}
\tightlist
\item
  \textbf{Missing pointer events}: ensure \texttt{IsHitTestVisible} is
  true and that no transparent sibling intercepts input. For overlays,
  set \texttt{IsHitTestVisible="False"}.
\item
  \textbf{Stuck capture}: always release capture during
  \texttt{PointerCaptureLost} and when the control unloads. Wrap capture
  in \texttt{try/finally} on operations that may throw.
\item
  \textbf{Gesture conflicts}: call
  \texttt{e.PreventGestureRecognition()} when manual pointer logic
  should trump recognizers---or avoid attaching recognizers to nested
  elements.
\item
  \textbf{High-DPI offsets}: convert to screen coordinates using
  \texttt{Visual.PointToScreen} when working across popups; pointer
  positions are per-visual, not global.
\item
  \textbf{Keyboard focus lost after drag}: store
  \texttt{(this.GetVisualRoot()\ as\ IInputRoot)?.FocusManager?.GetFocusedElement()}
  before capture and restore it when the operation completes to preserve
  keyboard flow.
\item
  \textbf{IME composition rectangles misplaced}: update
  \texttt{TextInputMethodClient.TextViewVisual} whenever layout changes;
  failing to do so leaves composition windows floating in the old
  position.
\end{itemize}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-25}

\begin{itemize}
\tightlist
\item
  Pointer lifecycle:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/Pointer.cs}{\texttt{Pointer.cs}}
\item
  Pointer events \& properties:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/PointerEventArgs.cs}{\texttt{PointerEventArgs.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/PointerPoint.cs}{\texttt{PointerPoint.cs}}
\item
  Gesture infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/GestureRecognizer.cs}{\texttt{GestureRecognizer.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/Gestures.cs}{\texttt{Gestures.cs}}
\item
  Continuous gestures:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/ScrollGestureRecognizer.cs}{\texttt{ScrollGestureRecognizer.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/PinchGestureRecognizer.cs}{\texttt{PinchGestureRecognizer.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/PullGestureRecognizer.cs}{\texttt{PullGestureRecognizer.cs}}
\item
  Keyboard \& XY navigation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/IKeyboardNavigationHandler.cs}{\texttt{IKeyboardNavigationHandler.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/Navigation/XYFocus.Properties.cs}{\texttt{XYFocus.Properties.cs}}
\item
  Device data:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyEventArgs.cs}{\texttt{KeyEventArgs.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyDeviceType.cs}{\texttt{KeyDeviceType.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TouchDevice.cs}{\texttt{TouchDevice.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/PenDevice.cs}{\texttt{PenDevice.cs}}
\item
  Text input pipeline:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputOptions.cs}{\texttt{TextInputOptions.cs}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/InputMethodManager.cs}{\texttt{TextInputMethodManager.cs}}
\item
  Input manager stages:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/InputManager.cs}{\texttt{InputManager.cs}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-26}

\begin{itemize}
\tightlist
\item
  How do tunnelling handlers differ from bubbling handlers when mixing
  pointer capture and gestures?
\item
  Which \texttt{PointerPointProperties} matter for pen input and how do
  you guard against unsupported platforms?
\item
  What steps are required to surface a custom
  \texttt{TextInputMethodClient} in your control?
\item
  How can you ensure a drag interaction remains keyboard-accessible?
\item
  When would you replace the default
  \texttt{IKeyboardNavigationHandler}?
\end{itemize}

What's next - Next: \href{Chapter29.md}{Chapter29}

\newpage

\subsection{29. Animations, transitions, and
composition}\label{animations-transitions-and-composition}

Goal - Shape motion with Avalonia's keyframe animations, property
transitions, and composition effects. - Decide when to stay in the
styling layer versus dropping to the compositor for GPU-driven effects.
- Orchestrate smooth navigation and reactive UI feedback without
sacrificing performance.

Why this matters - Motion guides attention, expresses hierarchy, and
communicates state changes; Avalonia gives you several layers to
accomplish that. - Choosing the right animation surface (XAML,
transitions, or composition) avoids wasted CPU, jank, and
hard-to-maintain code. - Composition unlocks scenarios---material blurs,
connected animations, fluid navigation---that are hard to express with
traditional rendering.

Prerequisites - Chapter 22 (Rendering pipeline) for the frame loop and
renderer semantics. - Chapter 23 (Custom drawing) for custom visuals
that you might animate. - Chapter 8 (Data binding) for reactive
triggers, and Chapter 24 (Diagnostics) for measuring performance.

\subsection{1. Keyframe animation building
blocks}\label{keyframe-animation-building-blocks}

Avalonia's declarative animation stack lives in
\texttt{Avalonia.Animation.Animation} and friends. Every control derives
from \texttt{Animatable}, so you can plug animations into styles or run
them directly in code.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Concept
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Highlights
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Timeline & \texttt{Animation} (\texttt{Animation.cs}) &
\texttt{Duration}, \texttt{Delay}, \texttt{IterationCount},
\texttt{PlaybackDirection}, \texttt{FillMode}, \texttt{SpeedRatio} \\
Track & \texttt{KeyFrame} (\texttt{KeyFrames.cs}) & Specifies a cue
(\texttt{0\%}..\texttt{100\%}) with one or more \texttt{Setter}s \\
Interpolation & \texttt{Animator\textless{}T\textgreater{}}
(\texttt{Animators/DoubleAnimator.cs}, etc.) & Avalonia ships animators
for primitives, transforms, brushes, shadows \\
Easing & \texttt{Easing} (\texttt{Animation/Easings/*}) & Over 30 easing
curves, plus \texttt{SplineEasing} for custom cubic Bezier \\
Clock & \texttt{IClock} / \texttt{Clock} (\texttt{Clock.cs}) & Drives
animations, default is the global clock \\
\end{longtable}

A minimal style animation:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Window}\OtherTok{ xmlns=}\StringTok{"https://github.com/avaloniaui"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Window.Styles}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Style}\OtherTok{ Selector=}\StringTok{"Rectangle.alert"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Fill"}\OtherTok{ Value=}\StringTok{"Red"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Style.Animations}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{Animation}\OtherTok{ Duration=}\StringTok{"0:0:0.6"}
\OtherTok{                   IterationCount=}\StringTok{"INFINITE"}
\OtherTok{                   PlaybackDirection=}\StringTok{"Alternate"}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{KeyFrame}\OtherTok{ Cue=}\StringTok{"0\%"}\NormalTok{\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Opacity"}\OtherTok{ Value=}\StringTok{"0.4"}\NormalTok{/\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"RenderTransform.ScaleX"}\OtherTok{ Value=}\StringTok{"1"}\NormalTok{/\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"RenderTransform.ScaleY"}\OtherTok{ Value=}\StringTok{"1"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}/}\KeywordTok{KeyFrame}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{KeyFrame}\OtherTok{ Cue=}\StringTok{"100\%"}\NormalTok{\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Opacity"}\OtherTok{ Value=}\StringTok{"1"}\NormalTok{/\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"RenderTransform.ScaleX"}\OtherTok{ Value=}\StringTok{"1.05"}\NormalTok{/\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"RenderTransform.ScaleY"}\OtherTok{ Value=}\StringTok{"1.05"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}/}\KeywordTok{KeyFrame}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{Animation}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{Style.Animations}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Window.Styles}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Window}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Key points: - \texttt{Animation.IterationCount="INFINITE"} loops
forever; avoid pairing with \texttt{Animation.RunAsync} (throws by
design). - \texttt{FillMode} controls which keyframe value sticks
before/after the timeline. Use \texttt{FillMode="Both"} for a resting
value. - You can scope animations to a resource dictionary and reference
them by \texttt{\{StaticResource\}} from templates or code.

\subsection{2. Controlling playback from
code}\label{controlling-playback-from-code}

\texttt{Animation.RunAsync} and \texttt{Animation.Apply} let you start,
await, or conditionally run animations from code-behind or view models
(\texttt{Animation.cs}, \texttt{RunAsync}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ ToastController}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Animation \_slideIn}\OperatorTok{;}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Animation \_slideOut}\OperatorTok{;}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Border \_host}\OperatorTok{;}

    \KeywordTok{public} \FunctionTok{ToastController}\OperatorTok{(}\NormalTok{Border host}\OperatorTok{,}\NormalTok{ Animation slideIn}\OperatorTok{,}\NormalTok{ Animation slideOut}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        \_host }\OperatorTok{=}\NormalTok{ host}\OperatorTok{;}
\NormalTok{        \_slideIn }\OperatorTok{=}\NormalTok{ slideIn}\OperatorTok{;}
\NormalTok{        \_slideOut }\OperatorTok{=}\NormalTok{ slideOut}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{public}\NormalTok{ async Task }\FunctionTok{ShowAsync}\OperatorTok{(}\NormalTok{CancellationToken token}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        await \_slideIn}\OperatorTok{.}\FunctionTok{RunAsync}\OperatorTok{(}\NormalTok{\_host}\OperatorTok{,}\NormalTok{ token}\OperatorTok{);} \CommentTok{// awaits completion}
\NormalTok{        await Task}\OperatorTok{.}\FunctionTok{Delay}\OperatorTok{(}\NormalTok{TimeSpan}\OperatorTok{.}\FunctionTok{FromSeconds}\OperatorTok{(}\DecValTok{3}\OperatorTok{),}\NormalTok{ token}\OperatorTok{);}
\NormalTok{        await \_slideOut}\OperatorTok{.}\FunctionTok{RunAsync}\OperatorTok{(}\NormalTok{\_host}\OperatorTok{,}\NormalTok{ token}\OperatorTok{);} \CommentTok{// reuse the same host, different cues}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Behind the scenes \texttt{RunAsync} applies the animation with an
\texttt{IClock} (defaults to \texttt{Clock.GlobalClock}) and completes
when the last animator reports completion. Create the
\texttt{\_slideOut} animation by cloning \texttt{\_slideIn}, switching
its cues, or temporarily setting
\texttt{PlaybackDirection\ =\ PlaybackDirection.Reverse} before calling
\texttt{RunAsync}.

Reactive triggers map easily to animations by using
\texttt{Apply(control,\ clock,\ IObservable\textless{}bool\textgreater{}\ match,\ Action\ onComplete)}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ animation }\OperatorTok{=} \OperatorTok{(}\NormalTok{Animation}\OperatorTok{)}\NormalTok{Resources}\OperatorTok{[}\StringTok{"HighlightAnimation"}\OperatorTok{];}
\DataTypeTok{var}\NormalTok{ match }\OperatorTok{=}\NormalTok{ viewModel}\OperatorTok{.}\FunctionTok{WhenAnyValue}\OperatorTok{(}\NormalTok{vm }\OperatorTok{=\textgreater{}}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{IsDirty}\OperatorTok{);}
\DataTypeTok{var}\NormalTok{ subscription }\OperatorTok{=}\NormalTok{ animation}\OperatorTok{.}\FunctionTok{Apply}\OperatorTok{(}\NormalTok{border}\OperatorTok{,} \KeywordTok{null}\OperatorTok{,}\NormalTok{ match}\OperatorTok{,} \KeywordTok{null}\OperatorTok{);}
\NormalTok{\_disposables}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{subscription}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  The observable controls when the animation should run (\texttt{true}
  pulses start it, \texttt{false} cancels).
\item
  Supply your own \texttt{Clock} to coordinate multiple animations
  (e.g., \texttt{new\ Clock(globalClock)} with \texttt{PlayState.Pause}
  to scrub).
\item
  Use the cancellation overload to stop animating when the control
  unloads or the view model changes.
\end{itemize}

\subsection{3. Implicit transitions and styling
triggers}\label{implicit-transitions-and-styling-triggers}

For property tweaks (hover states, theme switches)
\texttt{Animatable.Transitions} (\texttt{Animatable.cs}) is lighter
weight than keyframes. A \texttt{Transition\textless{}T\textgreater{}}
blends from the old value to a new one automatically.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Button}\OtherTok{ Classes=}\StringTok{"primary"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Button.Transitions}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Transitions}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{DoubleTransition}\OtherTok{ Property=}\StringTok{"Opacity"}\OtherTok{ Duration=}\StringTok{"0:0:0.150"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{TransformOperationsTransition}\OtherTok{ Property=}\StringTok{"RenderTransform"}\OtherTok{ Duration=}\StringTok{"0:0:0.200"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Transitions}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Button.Transitions}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Button}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Rules of thumb: - Transitions cannot target direct properties
(validation happens in \texttt{Transitions.cs}). Use styled properties
or wrappers. - Attach them at the control level
(\texttt{Button.Transitions}) or in a style
(\texttt{\textless{}Setter\ Property="Transitions"\textgreater{}}). -
Combine with selectors to drive implicit animation from pseudo-classes:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Style}\OtherTok{ Selector=}\StringTok{"Button:pointerover"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Opacity"}\OtherTok{ Value=}\StringTok{"1"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"RenderTransform"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Setter.Value}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{ScaleTransform}\OtherTok{ ScaleX=}\StringTok{"1.02"}\OtherTok{ ScaleY=}\StringTok{"1.02"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Setter.Value}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Setter}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

When the property switches, the matching
\texttt{Transition\textless{}T\textgreater{}} eases between the two
values. Avalonia ships transitions for numeric types, brushes,
thickness, transforms, box shadows, and more
(\texttt{Animation/Transitions/*.cs}).

\subsubsection{Animator-driven
transitions}\label{animator-driven-transitions}

\texttt{AnimatorDrivenTransition} lets you reuse keyframe logic as an
implicit transition. Add an \texttt{Animation} to \texttt{Transition} by
setting \texttt{Property} and plugging a custom
\texttt{Animator\textless{}T\textgreater{}} if you need non-linear
interpolation or multi-stop blends.

\subsection{4. Page transitions and content
choreography}\label{page-transitions-and-content-choreography}

Navigation surfaces (\texttt{TransitioningContentControl},
\texttt{Frame}, \texttt{NavigationView}) rely on
\texttt{IPageTransition} (\texttt{PageSlide.cs}, \texttt{CrossFade.cs}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TransitioningContentControl}\OtherTok{ Content=}\StringTok{"\{Binding CurrentPage\}"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TransitioningContentControl.PageTransition}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{CompositePageTransition}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{CompositePageTransition.PageTransitions}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{PageSlide}\OtherTok{ Duration=}\StringTok{"0:0:0.25"}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Offset=}\StringTok{"32"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{CrossFade}\OtherTok{ Duration=}\StringTok{"0:0:0.20"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{CompositePageTransition.PageTransitions}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{CompositePageTransition}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{TransitioningContentControl.PageTransition}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{TransitioningContentControl}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{PageSlide} shifts content in/out; set \texttt{Orientation} and
  \texttt{Offset} to control direction.
\item
  \texttt{CrossFade} fades the outgoing and incoming visuals.
\item
  Compose transitions with \texttt{CompositePageTransition} to layer
  multiple effects.
\item
  Listen to \texttt{TransitioningContentControl.TransitionCompleted} to
  dispose view models or preload the next page.
\end{itemize}

For navigation stacks, pair page transitions with parameterized
view-model lifetimes so you can cancel transitions on route changes
(\texttt{TransitioningContentControl.cs}).

\subsection{5. Reactive animation flows}\label{reactive-animation-flows}

Because each animation pipes through
\texttt{IObservable\textless{}bool\textgreater{}} internally, you can
stitch motion into reactive pipelines:

\begin{itemize}
\tightlist
\item
  \texttt{match} observables allow gating by business rules (focus
  state, validation errors, elapsed time).
\item
  Use
  \texttt{Animation.Apply(control,\ clock,\ observable,\ onComplete)} to
  bind to \texttt{WhenAnyValue}, \texttt{Observable.Interval}, or custom
  subjects.
\item
  Compose animations: the returned \texttt{IDisposable} unsubscribes
  transitions when your view deactivates (critical for
  \texttt{Animatable.DisableTransitions}).
\end{itemize}

Example: flash a text box when validation fails, but only once every
second.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ throttle }\OperatorTok{=}\NormalTok{ validationFailures}
    \OperatorTok{.}\FunctionTok{Select}\OperatorTok{(}\NormalTok{\_ }\OperatorTok{=\textgreater{}} \KeywordTok{true}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{Throttle}\OperatorTok{(}\NormalTok{TimeSpan}\OperatorTok{.}\FunctionTok{FromSeconds}\OperatorTok{(}\DecValTok{1}\OperatorTok{))}
    \OperatorTok{.}\FunctionTok{StartWith}\OperatorTok{(}\KeywordTok{false}\OperatorTok{);}
\NormalTok{animation}\OperatorTok{.}\FunctionTok{Apply}\OperatorTok{(}\NormalTok{textBox}\OperatorTok{,} \KeywordTok{null}\OperatorTok{,}\NormalTok{ throttle}\OperatorTok{,} \KeywordTok{null}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsection{6. Composition vs classic
rendering}\label{composition-vs-classic-rendering}

Avalonia's compositor (\texttt{Compositor.cs}) mirrors the Windows
Composition model: a scene graph of \texttt{CompositionVisual} objects
runs on a dedicated thread and talks directly to GPU backends.
Advantages:

\begin{itemize}
\tightlist
\item
  Animations stay smooth even when the UI thread is busy.
\item
  Effects (blur, shadows, opacity masks) render in hardware.
\item
  You can build visuals that never appear in the standard logical tree
  (overlays, particles, diagnostics).
\end{itemize}

Getting the compositor:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ elementVisual }\OperatorTok{=}\NormalTok{ ElementComposition}\OperatorTok{.}\FunctionTok{GetElementVisual}\OperatorTok{(}\NormalTok{myControl}\OperatorTok{);}
\DataTypeTok{var}\NormalTok{ compositor }\OperatorTok{=}\NormalTok{ elementVisual}\OperatorTok{?.}\FunctionTok{Compositor}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

You can inject custom visuals under an existing control:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ compositor }\OperatorTok{=}\NormalTok{ ElementComposition}\OperatorTok{.}\FunctionTok{GetElementVisual}\OperatorTok{(}\NormalTok{host}\OperatorTok{)!.}\FunctionTok{Compositor}\OperatorTok{;}
\DataTypeTok{var}\NormalTok{ root }\OperatorTok{=}\NormalTok{ ElementComposition}\OperatorTok{.}\FunctionTok{GetElementVisual}\OperatorTok{(}\NormalTok{host}\OperatorTok{)} \KeywordTok{as}\NormalTok{ CompositionContainerVisual}\OperatorTok{;}

\DataTypeTok{var}\NormalTok{ sprite }\OperatorTok{=}\NormalTok{ compositor}\OperatorTok{.}\FunctionTok{CreateSolidColorVisual}\OperatorTok{();}
\NormalTok{sprite}\OperatorTok{.}\FunctionTok{Color} \OperatorTok{=}\NormalTok{ Colors}\OperatorTok{.}\FunctionTok{DeepSkyBlue}\OperatorTok{;}
\NormalTok{sprite}\OperatorTok{.}\FunctionTok{Size} \OperatorTok{=} \KeywordTok{new} \FunctionTok{Vector2}\OperatorTok{((}\DataTypeTok{float}\OperatorTok{)}\NormalTok{host}\OperatorTok{.}\FunctionTok{Bounds}\OperatorTok{.}\FunctionTok{Width}\OperatorTok{,} \DecValTok{4}\OperatorTok{);}
\NormalTok{sprite}\OperatorTok{.}\FunctionTok{Offset} \OperatorTok{=} \KeywordTok{new} \FunctionTok{Vector3}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \OperatorTok{(}\DataTypeTok{float}\OperatorTok{)}\NormalTok{host}\OperatorTok{.}\FunctionTok{Bounds}\OperatorTok{.}\FunctionTok{Height} \OperatorTok{{-}} \DecValTok{4}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
\NormalTok{root}\OperatorTok{!.}\FunctionTok{Children}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{sprite}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

When mixing visuals, ensure they come from the same \texttt{Compositor}
instance (\texttt{ElementCompositionPreview.cs}).

\subsubsection{Composition target and hit
testing}\label{composition-target-and-hit-testing}

\texttt{CompositionTarget} (\texttt{CompositionTarget.cs}) owns the
visual tree that the compositor renders. It handles hit testing,
coordinate transforms, and redraw scheduling. Most apps use the
compositor implicitly via the built-in renderer, but custom hosts (e.g.,
embedding Avalonia) can create their own target
(\texttt{Compositor.CreateCompositionTarget}).

\subsubsection{Composition brushes, effects, and
materials}\label{composition-brushes-effects-and-materials}

The compositor supports more than simple solids:

\begin{itemize}
\tightlist
\item
  \texttt{CompositionColorBrush} and \texttt{CompositionGradientBrush}
  mirror familiar WPF/UWP concepts and can be animated directly on the
  render thread.
\item
  \texttt{CompositionEffectBrush} applies blend modes and image effects
  defined in \texttt{Composition.Effects}. Use it to build blur/glow
  pipelines without blocking the UI thread.
\item
  \texttt{CompositionExperimentalAcrylicVisual} ships a ready-made
  fluent-style acrylic material. Combine it with backdrop animations for
  frosted surfaces.
\item
  \texttt{CompositionDrawListVisual} lets you record drawing commands
  once and replay them efficiently; great for particle systems or
  dashboards.
\end{itemize}

Use \texttt{Compositor.TryCreateBlurEffect()} (platform-provided
helpers) to probe support before enabling expensive effects. Not every
backend exposes every effect type; guard features behind capability
checks.

\subsubsection{Backend considerations}\label{backend-considerations}

Composition runs on different engines per platform:

\begin{itemize}
\tightlist
\item
  \textbf{Windows} defaults to Direct3D via Angle; transparency and
  acrylic require desktop composition (check
  \texttt{DwmIsCompositionEnabled}).
\item
  \textbf{macOS/iOS} lean on Metal; some blend modes fall back to
  software when Metal is unavailable.
\item
  \textbf{Linux/X11} routes through OpenGL or Vulkan depending on the
  build; verify \texttt{TransparencyLevel} and composition availability
  via \texttt{X11Globals.IsCompositionEnabled}.
\item
  \textbf{Browser} currently renders via WebGL and omits
  composition-only APIs. Always branch your motion layer so WebAssembly
  users still see essential transitions.
\end{itemize}

When features are missing, prefer classic transitions so the experience
remains functional.

\subsection{7. Composition animations and implicit
animations}\label{composition-animations-and-implicit-animations}

Composition animations live in
\texttt{Avalonia.Rendering.Composition.Animations}:

\begin{itemize}
\tightlist
\item
  \texttt{ExpressionAnimation} lets you drive properties with formulas
  (e.g., parallax, inverse transforms).
\item
  \texttt{KeyFrameAnimation} offers high-frequency GPU keyframes.
\item
  \texttt{ImplicitAnimationCollection} attaches animations to property
  names and fires when the property changes
  (\texttt{CompositionObject.ImplicitAnimations}).
\end{itemize}

Example: create a parallax highlight that lags slightly behind its host.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ compositor }\OperatorTok{=}\NormalTok{ ElementComposition}\OperatorTok{.}\FunctionTok{GetElementVisual}\OperatorTok{(}\NormalTok{header}\OperatorTok{)!.}\FunctionTok{Compositor}\OperatorTok{;}
\DataTypeTok{var}\NormalTok{ hostVisual }\OperatorTok{=}\NormalTok{ ElementComposition}\OperatorTok{.}\FunctionTok{GetElementVisual}\OperatorTok{(}\NormalTok{header}\OperatorTok{)!;}

\DataTypeTok{var}\NormalTok{ glow }\OperatorTok{=}\NormalTok{ compositor}\OperatorTok{.}\FunctionTok{CreateSolidColorVisual}\OperatorTok{();}
\NormalTok{glow}\OperatorTok{.}\FunctionTok{Color} \OperatorTok{=}\NormalTok{ Colors}\OperatorTok{.}\FunctionTok{Gold}\OperatorTok{;}
\NormalTok{glow}\OperatorTok{.}\FunctionTok{Size} \OperatorTok{=} \KeywordTok{new} \FunctionTok{Vector2}\OperatorTok{((}\DataTypeTok{float}\OperatorTok{)}\NormalTok{header}\OperatorTok{.}\FunctionTok{Bounds}\OperatorTok{.}\FunctionTok{Width}\OperatorTok{,} \DecValTok{4}\OperatorTok{);}
\NormalTok{ElementComposition}\OperatorTok{.}\FunctionTok{SetElementChildVisual}\OperatorTok{(}\NormalTok{header}\OperatorTok{,}\NormalTok{ glow}\OperatorTok{);}

\DataTypeTok{var}\NormalTok{ parallax }\OperatorTok{=}\NormalTok{ compositor}\OperatorTok{.}\FunctionTok{CreateExpressionAnimation}\OperatorTok{(}\StringTok{"Vector3(host.Offset.X * 0.05, host.Offset.Y * 0.05, 0)"}\OperatorTok{);}
\NormalTok{parallax}\OperatorTok{.}\FunctionTok{SetReferenceParameter}\OperatorTok{(}\StringTok{"host"}\OperatorTok{,}\NormalTok{ hostVisual}\OperatorTok{);}
\NormalTok{parallax}\OperatorTok{.}\FunctionTok{Target} \OperatorTok{=} \FunctionTok{nameof}\OperatorTok{(}\NormalTok{CompositionVisual}\OperatorTok{.}\FunctionTok{Offset}\OperatorTok{);}
\NormalTok{glow}\OperatorTok{.}\FunctionTok{StartAnimation}\OperatorTok{(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{CompositionVisual}\OperatorTok{.}\FunctionTok{Offset}\OperatorTok{),}\NormalTok{ parallax}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

For property-driven motion, use implicit animations: create an
\texttt{ImplicitAnimationCollection}, add an animation keyed by the
composition property name (for example
\texttt{nameof(CompositionVisual.Opacity)}), then assign the collection
to \texttt{visual.ImplicitAnimations}. Each time that property changes,
the compositor automatically plays the animation using
\texttt{this.FinalValue} inside the expression to reference the target
value (\texttt{ImplicitAnimationCollection.cs}).

\texttt{StartAnimation} pushes the animation to the render thread. Use
\texttt{CompositionAnimationGroup} to start multiple animations
atomically, and \texttt{Compositor.RequestCommitAsync()} to flush
batched changes before measuring results.

\subsection{8. Performance and
diagnostics}\label{performance-and-diagnostics}

\begin{itemize}
\tightlist
\item
  Prefer animating transforms (\texttt{RenderTransform},
  \texttt{Opacity}) over layout-affecting properties (\texttt{Width},
  \texttt{Height}). Layout invalidation happens on the UI thread and can
  stutter.
\item
  Reuse animation instances; parsing keyframes or easings each time
  allocates. Store them as static resources.
\item
  Disable transitions when loading data-heavy lists to avoid dozens of
  simultaneous animations (\texttt{Animatable.DisableTransitions}).
  Re-enable after the initial bind.
\item
  For composition, batch changes and let
  \texttt{Compositor.RequestCommitAsync()} coalesce writes instead of
  spamming per-frame updates.
\item
  Use \texttt{RendererDiagnostics} overlays (Chapter 24) to spot dropped
  frames and long render passes. Composition visuals show up as separate
  layers, so you can verify they batch correctly.
\item
  Brush transitions fall back to discrete jumps for incompatible brush
  types (\texttt{BrushTransition.cs}). Verify gradients or image brushes
  blend the way you expect.
\end{itemize}

\subsection{9. Practice lab: motion
system}\label{practice-lab-motion-system}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Explicit keyframes} -- Build a reusable animation resource
  that pulses a \texttt{NotificationBanner}, then start it from a view
  model with \texttt{RunAsync}. Add cancellation so repeated
  notifications restart smoothly.
\item
  \textbf{Implicit hover transitions} -- Define a \texttt{Transitions}
  block for cards in a dashboard: fade elevation shadows, scale the card
  slightly, and update \texttt{TranslateTransform.Y}. Drive the
  transitions purely from pseudo-classes.
\item
  \textbf{Navigation choreography} -- Wrap your page host in a
  \texttt{TransitioningContentControl}. Combine \texttt{PageSlide} with
  \texttt{CrossFade}, listen for \texttt{TransitionCompleted}, and
  cancel transitions when the navigation stack pops quickly.
\item
  \textbf{Composition parallax} -- Build a composition child visual that
  lags behind its host using an expression animation, then snap it back
  with an implicit animation when pointer capture is lost.
\item
  \textbf{Diagnostics} -- Toggle renderer diagnostics overlays, capture
  a short trace, and confirm that the animations remain smooth when
  background tasks run.
\end{enumerate}

Document timing curves, easing choices, and any performance issues so
the team can iterate on the experience.

\subsection{10. Troubleshooting \& best
practices}\label{troubleshooting-best-practices-3}

\begin{itemize}
\tightlist
\item
  Animation not firing? Ensure the target property is styled (not
  direct) and the selector matches the control. For composition, check
  the animation \texttt{Target} matches the composition property name
  (case-sensitive).
\item
  Looped animations via \texttt{RunAsync} throw---drive infinite loops
  with \texttt{Apply} or manual scheduler instead.
\item
  Transitions chaining oddly? They trigger per property; animating both
  \texttt{RenderTransform} and its sub-properties simultaneously causes
  conflicts. Use a single \texttt{TransformOperationsTransition} to
  animate complex transforms.
\item
  Composition visuals disappear after resizing? Update \texttt{Size} and
  \texttt{Offset} whenever the host control's bounds change, then call
  \texttt{Compositor.RequestCommitAsync()} to flush.
\item
  Hot reload spawns multiple composition visuals? Remove the old child
  visual (\texttt{Children.Remove}) before adding a new one, or cache
  the sprite in the control instance.
\end{itemize}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-26}

\begin{itemize}
\tightlist
\item
  Animation timeline \& playback:
  \texttt{external/Avalonia/src/Avalonia.Base/Animation/Animation.cs}
\item
  Property transitions:
  \texttt{external/Avalonia/src/Avalonia.Base/Animation/Transitions.cs}
\item
  Page transitions:
  \texttt{external/Avalonia/src/Avalonia.Base/Animation/PageSlide.cs},
  \texttt{external/Avalonia/src/Avalonia.Base/Animation/CrossFade.cs}
\item
  Composition gateway:
  \texttt{external/Avalonia/src/Avalonia.Base/Rendering/Composition/Compositor.cs},
  \texttt{external/Avalonia/src/Avalonia.Base/Rendering/Composition/CompositionTarget.cs}
\item
  Composition effects \& materials:
  \texttt{external/Avalonia/src/Avalonia.Base/Rendering/Composition/CompositionDrawListVisual.cs},
  \texttt{external/Avalonia/src/Avalonia.Base/Rendering/Composition/CompositionExperimentalAcrylicVisual.cs},
  \texttt{external/Avalonia/src/Avalonia.Base/Rendering/Composition/Expressions/ExpressionAnimation.cs}
\item
  Implicit composition animations:
  \texttt{external/Avalonia/src/Avalonia.Base/Rendering/Composition/CompositionObject.cs}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-27}

\begin{itemize}
\tightlist
\item
  When would you pick a \texttt{DoubleTransition} over a keyframe
  animation, and why does that matter for layout cost?
\item
  How do \texttt{IterationCount}, \texttt{FillMode}, and
  \texttt{PlaybackDirection} interact to determine an animation's
  resting value?
\item
  What are the risks of animating direct properties, and how does
  Avalonia guard against them?
\item
  How do you attach a composition child visual so it uses the same
  compositor as the host control?
\item
  What steps ensure a navigation animation cancels cleanly when the
  route changes mid-flight?
\end{itemize}

What's next - Next: \href{Chapter30.md}{Chapter30}

\newpage

\subsection{30. Markup, XAML compiler, and
extensibility}\label{markup-xaml-compiler-and-extensibility}

Goal - Understand how Avalonia turns \texttt{.axaml} files into IL,
resources, and runtime objects. - Choose between compiled and runtime
XAML loading, and configure each for trimming, design-time, and
diagnostics. - Extend the markup language with custom namespaces, markup
extensions, and services without breaking tooling.

Why this matters - XAML is your declarative UI language; mastering its
toolchain keeps builds fast and error messages actionable. - Compiled
XAML (XamlIl) affects startup time, binary size, trimming, and hot
reload behaviour. - Custom markup extensions, namespace maps, and
runtime loaders enable reusable component libraries and advanced
scenarios (dynamic schemas, plug-ins).

Prerequisites - Chapter 02 (project setup) for templates and build
targets. - Chapter 07 (styles and selectors) and Chapter 10 (resources)
for consuming XAML assets. - Chapter 08 (bindings) for compiled binding
references.

\subsection{1. The XAML asset pipeline}\label{the-xaml-asset-pipeline}

When you add \texttt{.axaml} files, the SDK-driven build uses two
MSBuild tasks from \texttt{Avalonia.Build.Tasks}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{\texttt{GenerateAvaloniaResources}}
  (\texttt{external/Avalonia/src/Avalonia.Build.Tasks/GenerateAvaloniaResourcesTask.cs})

  \begin{itemize}
  \tightlist
  \item
    Runs before compilation. Packs every \texttt{AvaloniaResource} item
    into the \texttt{*.axaml} resource bundle (\texttt{avares://}).
  \item
    Parses each XAML file with \texttt{XamlFileInfo.Parse}, records
    \texttt{x:Class} entries, and writes
    \texttt{/!AvaloniaResourceXamlInfo} metadata so runtime lookups can
    map CLR types to resource URIs.
  \item
    Emits MSBuild diagnostics (\texttt{BuildEngine.LogError}) if it sees
    invalid XML or duplicate \texttt{x:Class} declarations.
  \end{itemize}
\item
  \textbf{\texttt{CompileAvaloniaXaml}}
  (\texttt{external/Avalonia/src/Avalonia.Build.Tasks/CompileAvaloniaXamlTask.cs})

  \begin{itemize}
  \tightlist
  \item
    Executes after C\# compilation. Loads the produced assembly and
    references via Mono.Cecil.
  \item
    Invokes \texttt{XamlCompilerTaskExecutor.Compile}, which runs the
    XamlIl compiler over each XAML resource, generates partial classes,
    compiled bindings, and lookup stubs under the
    \texttt{CompiledAvaloniaXaml} namespace, then rewrites the IL
    in-place.
  \item
    Writes the updated assembly (and optional reference assembly) to
    \texttt{\$(IntermediateOutputPath)}.
  \end{itemize}
\end{enumerate}

Key metadata: - \texttt{AvaloniaResource} item group entries exist by
default in SDK templates; make sure custom build steps preserve the
\texttt{AvaloniaCompileOutput} metadata so incremental builds work. -
Set
\texttt{\textless{}VerifyXamlIl\textgreater{}true\textless{}/VerifyXamlIl\textgreater{}}
to enable IL verification after compilation; this slows builds slightly
but catches invalid IL earlier. -
\texttt{\textless{}AvaloniaUseCompiledBindingsByDefault\textgreater{}true\textless{}/AvaloniaUseCompiledBindingsByDefault\textgreater{}}
opts every binding into compiled bindings unless opted out per markup
(see Chapter 08).

\subsection{2. Inside the XamlIl
compiler}\label{inside-the-xamlil-compiler}

XamlIl is Avalonia's LLVM-style pipeline built on XamlX:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Parsing} (\texttt{XamlX.Parsers}) transforms XAML into an AST
  (\texttt{XamlDocument}).
\item
  \textbf{Transform passes}
  (\texttt{Avalonia.Markup.Xaml.XamlIl.CompilerExtensions}) rewrite the
  tree, resolve namespaces (\texttt{XmlnsDefinitionAttribute}), expand
  markup extensions, and inline templates.
\item
  \textbf{IL emission} (\texttt{XamlCompilerTaskExecutor}) creates
  classes such as \texttt{CompiledAvaloniaXaml.!XamlLoader},
  \texttt{CompiledAvaloniaXaml.!AvaloniaResources}, and compiled binding
  factories.
\item
  \textbf{Runtime helpers}
  (\texttt{external/Avalonia/src/Markup/Avalonia.Markup.Xaml/XamlIl/Runtime/XamlIlRuntimeHelpers.cs})
  provide services for deferred templates, parent stacks, and resource
  resolution at runtime.
\end{enumerate}

Every \texttt{.axaml} file with \texttt{x:Class="Namespace.View"}
yields: - A partial class initializer calling
\texttt{AvaloniaXamlIlRuntimeXamlLoader}. This ensures your code-behind
\texttt{InitializeComponent()} wires the compiled tree. - Registration
in the resource map so
\texttt{AvaloniaXamlLoader.Load(new\ Uri("avares://..."))} can find the
compiled loader.

If you set
\texttt{\textless{}SkipXamlCompilation\textgreater{}true\textless{}/SkipXamlCompilation\textgreater{}},
the compiler bypasses IL generation; \texttt{AvaloniaXamlLoader} then
falls back to runtime parsing for each load (slower and
reflection-heavy, but useful during prototyping).

\subsection{3. Runtime loading and hot
reload}\label{runtime-loading-and-hot-reload}

\texttt{AvaloniaXamlLoader}
(\texttt{external/Avalonia/src/Markup/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs})
chooses between: - \textbf{Compiled XAML} -- looks for
\texttt{CompiledAvaloniaXaml.!XamlLoader.TryLoad(string)} in the owning
assembly and instantiates the pre-generated tree. - \textbf{Runtime
loader} -- if no compiled loader exists or when you invoke
\texttt{AvaloniaLocator.CurrentMutable.Register\textless{}IRuntimeXamlLoader\textgreater{}(...)}.
This constructs a \texttt{RuntimeXamlLoaderDocument} with your stream or
string, applies \texttt{RuntimeXamlLoaderConfiguration}, and parses with
PortableXaml + XamlIl runtime.

Runtime configuration knobs: - \texttt{UseCompiledBindingsByDefault}
toggles compiled binding behaviour when parsing at runtime. -
\texttt{DiagnosticHandler} lets you downgrade/upgrade runtime warnings
or feed them into telemetry. - \texttt{DesignMode} ensures design-time
services (\texttt{Design.IsDesignMode}, previews) do not execute app
logic.

Use cases for runtime loading: - Live preview / hot reload (IDE hosts
register their own \texttt{IRuntimeXamlLoader}). - Pluggable modules
that ship XAML as data (load from database, theme packages). - Unit
tests where compiling all XAML would slow loops; the headless test
adapters provide a runtime loader.

\subsection{4. Namespaces, schemas, and
lookup}\label{namespaces-schemas-and-lookup}

Avalonia uses \texttt{XmlnsDefinitionAttribute}
(\texttt{external/Avalonia/src/Avalonia.Base/Metadata/XmlnsDefinitionAttribute.cs})
to map XML namespaces to CLR namespaces. Assemblies such as
\texttt{Avalonia.Markup.Xaml} declare:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\NormalTok{assembly}\OperatorTok{:} \FunctionTok{XmlnsDefinition}\OperatorTok{(}\StringTok{"https://github.com/avaloniaui"}\OperatorTok{,} \StringTok{"Avalonia.Markup.Xaml.MarkupExtensions"}\OperatorTok{)]}
\end{Highlighting}
\end{Shaded}

Guidelines: - Add your own \texttt{{[}assembly:\ XmlnsDefinition{]}} for
component libraries so users can
\texttt{xmlns:controls="clr-namespace:MyApp.Controls"} or reuse the
default Avalonia URI. - Use \texttt{{[}assembly:\ XmlnsPrefix{]}} (also
in \texttt{Avalonia.Metadata}) to suggest a prefix for tooling. - Custom
types must be public and reside in an assembly referenced by the
consuming project; otherwise XamlIl will emit a type resolution error.

\texttt{IXamlTypeResolver} is available through the service provider
(\texttt{Extensions.ResolveType}). When you write custom markup
extensions, you can resolve types that respect \texttt{XmlnsDefinition}
mappings.

\subsection{5. Markup extensions and service
providers}\label{markup-extensions-and-service-providers}

All markup extensions inherit from
\texttt{Avalonia.Markup.Xaml.MarkupExtension}
(\texttt{MarkupExtension.cs}) and implement
\texttt{ProvideValue(IServiceProvider\ serviceProvider)}.

Avalonia supplies extensions such as \texttt{StaticResourceExtension},
\texttt{DynamicResourceExtension}, \texttt{CompiledBindingExtension},
and \texttt{OnPlatformExtension}
(\texttt{external/Avalonia/src/Markup/Avalonia.Markup.Xaml/MarkupExtensions/*}).
The service provider gives access to: - \texttt{INameScope} for named
elements. - \texttt{IAvaloniaXamlIlParentStackProvider} for parent
stacks (\texttt{Extensions.GetParents\textless{}T\textgreater{}()}). -
\texttt{IRootObjectProvider}, \texttt{IUriContext}, and design-time
services.

Custom markup extension example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ UppercaseExtension }\OperatorTok{:}\NormalTok{ MarkupExtension}
\OperatorTok{\{}
    \KeywordTok{public} \DataTypeTok{string}\OperatorTok{?}\NormalTok{ Text }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \KeywordTok{set}\OperatorTok{;} \OperatorTok{\}}

    \KeywordTok{public} \KeywordTok{override} \DataTypeTok{object} \FunctionTok{ProvideValue}\OperatorTok{(}\NormalTok{IServiceProvider serviceProvider}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ source }\OperatorTok{=}\NormalTok{ Text }\OperatorTok{??}\NormalTok{ serviceProvider}\OperatorTok{.}\FunctionTok{GetDefaultAnchor}\OperatorTok{()} \KeywordTok{as}\NormalTok{ TextBlock}\OperatorTok{;}
        \KeywordTok{return}\NormalTok{ source }\KeywordTok{switch}
        \OperatorTok{\{}
            \DataTypeTok{string}\NormalTok{ s }\OperatorTok{=\textgreater{}}\NormalTok{ s}\OperatorTok{.}\FunctionTok{ToUpperInvariant}\OperatorTok{(),}
\NormalTok{            TextBlock block }\OperatorTok{=\textgreater{}}\NormalTok{ block}\OperatorTok{.}\FunctionTok{Text}\OperatorTok{?.}\FunctionTok{ToUpperInvariant}\OperatorTok{()} \OperatorTok{??} \DataTypeTok{string}\OperatorTok{.}\FunctionTok{Empty}\OperatorTok{,}
\NormalTok{            \_ }\OperatorTok{=\textgreater{}} \DataTypeTok{string}\OperatorTok{.}\FunctionTok{Empty}
        \OperatorTok{\};}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Usage in XAML:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{local:Uppercase Text=hello\}"}\NormalTok{/\textgreater{}}
\end{Highlighting}
\end{Shaded}

Tips: - Always guard against null \texttt{Text}; the extension may be
instantiated at parse time without parameters. - Use services (e.g.,
\texttt{serviceProvider.GetService\textless{}IServiceProvider\textgreater{}})
sparingly; they run on every instantiation. - For asynchronous or
deferred value creation, return a delegate implementing
\texttt{IProvideValueTarget} or use
\texttt{XamlIlRuntimeHelpers.DeferredTransformationFactoryV2}.

\subsection{6. Custom templates, resources, and compiled
bindings}\label{custom-templates-resources-and-compiled-bindings}

XamlIl optimises templates and bindings when you: - Declare controls
with \texttt{x:Class} so partial classes can inject compiled fields
(\texttt{InitializeComponent}). - Use \texttt{x:DataType} on
\texttt{DataTemplates} to enable compiled bindings with compile-time
type checking. - Add \texttt{x:CompileBindings="False"} on a scope if
you need fallback to classic binding for dynamic paths.

The compiler hoists resource dictionaries and template bodies into
factory methods, reducing runtime allocations. When you inspect
generated IL (use \texttt{ilspy}), you'll see
\texttt{new\ Func\textless{}IServiceProvider,\ object\textgreater{}(...)}
wrappers for control templates referencing
\texttt{XamlIlRuntimeHelpers.DeferredTransformationFactoryV2}.

\subsection{7. Debugging and
diagnostics}\label{debugging-and-diagnostics-1}

\begin{itemize}
\tightlist
\item
  Build errors referencing \texttt{AvaloniaXamlDiagnosticCodes} include
  the original file path; MSBuild surfaces them in IDEs with
  line/column.
\item
  Runtime \texttt{XamlLoadException} (\texttt{XamlLoadException.cs})
  indicates missing compiled loaders or invalid markup; the message
  suggests ensuring \texttt{x:Class} and \texttt{AvaloniaResource} build
  actions.
\item
  Enable verbose compiler exceptions with
  \texttt{\textless{}AvaloniaXamlIlVerboseOutput\textgreater{}true\textless{}/AvaloniaXamlIlVerboseOutput\textgreater{}}
  to print stack traces from the XamlIl pipeline.
\item
  Use \texttt{avalonia-preview} (design-time host) to spot issues with
  namespace resolution; the previewer logs originate from the runtime
  loader and respect
  \texttt{RuntimeXamlLoaderConfiguration.DiagnosticHandler}.
\end{itemize}

\subsection{8. Authoring workflow
checklist}\label{authoring-workflow-checklist}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Project file} -- confirm
  \texttt{\textless{}UseCompiledBindingsByDefault\textgreater{}} and
  \texttt{\textless{}VerifyXamlIl\textgreater{}} match your
  requirements.
\item
  \textbf{Namespaces} -- add \texttt{{[}assembly:\ XmlnsDefinition{]}}
  for every exported namespace; document the suggested prefix.
\item
  \textbf{Resources} -- place \texttt{.axaml} under the project root or
  set \texttt{Link} metadata so \texttt{GenerateAvaloniaResources}
  records the intended resource URI.
\item
  \textbf{InitializeComponent} -- always call it in partial classes;
  otherwise the compiled loader is never invoked.
\item
  \textbf{Testing} -- run unit tests with \texttt{AvaloniaHeadless}
  (Chapter 21) to exercise runtime loader paths without the full
  compositor.
\end{enumerate}

\subsection{9. Practice lab: extending the markup
toolchain}\label{practice-lab-extending-the-markup-toolchain}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Inspect build output} -- build your project with
  \texttt{dotnet\ build\ /bl}. Open the MSBuild log and confirm
  \texttt{GenerateAvaloniaResources} and \texttt{CompileAvaloniaXaml}
  run with the expected inputs.
\item
  \textbf{Add XML namespace mappings} -- create a component library,
  decorate it with
  \texttt{{[}assembly:\ XmlnsDefinition("https://schemas.myapp.com/ui",\ "MyApp.Controls"){]}},
  and consume it from a separate app.
\item
  \textbf{Create a markup extension} -- implement
  \texttt{\{local:Uppercase\}} as above, inject
  \texttt{IServiceProvider} utilities, and write tests that call
  \texttt{ProvideValue} with a fake service provider.
\item
  \textbf{Toggle compiled bindings} -- set
  \texttt{\textless{}AvaloniaUseCompiledBindingsByDefault\textgreater{}false\textgreater{}},
  then selectively enable compiled bindings in XAML with
  \texttt{\{x:CompileBindings\}} and observe the generated IL (via
  dotnet-monitor or ILSpy).
\item
  \textbf{Runtime loader experiment} -- register a custom
  \texttt{IRuntimeXamlLoader} in a test harness to load XAML from
  strings, flip \texttt{UseCompiledBindingsByDefault}, and log
  diagnostics through
  \texttt{RuntimeXamlLoaderConfiguration.DiagnosticHandler}.
\end{enumerate}

\subsection{10. Troubleshooting \& best
practices}\label{troubleshooting-best-practices-4}

\begin{itemize}
\tightlist
\item
  Build succeeds but UI is blank? Check that your \texttt{.axaml} file
  still has \texttt{x:Class} and \texttt{InitializeComponent} is called.
  Without it, the compiled loader never runs.
\item
  Duplicate \texttt{x:Class} errors: two XAML files declare the same CLR
  type; rename one or adjust the namespace. The compiler stops on
  duplicates to avoid ambiguous partial classes.
\item
  \texttt{XamlTypeResolutionException}: ensure the target assembly
  references the library exposing the type and that you provided an
  \texttt{XmlnsDefinition} mapping.
\item
  Missing resources at runtime (\texttt{avares://} fails): verify
  \texttt{AvaloniaResource} items exist and the resource path matches
  the URI (case-sensitive on Linux/macOS).
\item
  Large diff after build: compiled XAML rewrites the primary assembly;
  add \texttt{obj/*.dll} to \texttt{.gitignore} and avoid checking in
  intermediate outputs.
\item
  Hot reload issues: if you disable compiled XAML for faster iteration,
  remember to re-enable it before shipping to restore startup
  performance.
\end{itemize}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-27}

\begin{itemize}
\tightlist
\item
  Resource packer:
  \texttt{external/Avalonia/src/Avalonia.Build.Tasks/GenerateAvaloniaResourcesTask.cs}
\item
  XamlIl compiler driver:
  \texttt{external/Avalonia/src/Avalonia.Build.Tasks/CompileAvaloniaXamlTask.cs},
  \texttt{external/Avalonia/src/Avalonia.Build.Tasks/XamlCompilerTaskExecutor.cs}
\item
  Runtime loader:
  \texttt{external/Avalonia/src/Markup/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs},
  \texttt{RuntimeXamlLoaderDocument.cs}
\item
  Runtime helpers:
  \texttt{external/Avalonia/src/Markup/Avalonia.Markup.Xaml/XamlIl/Runtime/XamlIlRuntimeHelpers.cs}
\item
  Extensions \& services:
  \texttt{external/Avalonia/src/Markup/Avalonia.Markup.Xaml/Extensions.cs}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-28}

\begin{itemize}
\tightlist
\item
  What MSBuild tasks touch \texttt{.axaml} files, and what metadata do
  they emit?
\item
  How does XamlIl decide between compiled and runtime loading for a
  given URI?
\item
  Where would you place \texttt{{[}XmlnsDefinition{]}} attributes when
  publishing a control library?
\item
  How do you access the root object or parent stack from inside a markup
  extension?
\item
  What steps enable you to load XAML from a raw string while still using
  compiled bindings?
\end{itemize}

What's next - Next: \href{Chapter31.md}{Chapter31}

\newpage

\subsection{31. Extended control modules and component
gallery}\label{extended-control-modules-and-component-gallery}

Goal - Master specialized Avalonia controls that sit outside the
``common controls'' set: color pickers, pull-to-refresh, notifications,
date/time inputs, split buttons, and more. - Understand how these
modules are organized, what platform behaviours they rely on, and how to
style or automate them. - Build a reusable component gallery to showcase
advanced controls with theming and accessibility baked in.

Why this matters - These controls unlock polished, production-ready
experiences (dashboards, media apps, mobile refresh gestures) without
reinventing UI plumbing. - Many live in separate namespaces such as
\texttt{Avalonia.Controls.ColorPicker} or
\texttt{Avalonia.Controls.Notifications}; knowing what ships in the box
saves time. - Styling, automation, and platform quirks differ from core
controls---you need dedicated recipes to avoid regressions.

Prerequisites - Chapter 06 (controls tour) and Chapter 07 (styling) for
basic control usage. - Chapter 09 (input) and Chapter 15 (accessibility)
to reason about interactions. - Chapter 29 (animations) for transitional
polish.

\subsection{1. Survey of extended control
namespaces}\label{survey-of-extended-control-namespaces}

Avalonia groups advanced controls into focused namespaces:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Module
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Namespace
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Highlights
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Color editing & \texttt{Avalonia.Controls.ColorPicker} &
\texttt{ColorPicker}, \texttt{ColorView}, palette data, HSV/RGB
components \\
Refresh gestures & \texttt{Avalonia.Controls.PullToRefresh} &
\texttt{RefreshContainer}, \texttt{RefreshVisualizer},
\texttt{RefreshInfoProvider} \\
Notifications & \texttt{Avalonia.Controls.Notifications} &
\texttt{WindowNotificationManager}, \texttt{NotificationCard},
\texttt{INotification} \\
Date \& time & \texttt{Avalonia.Controls.DateTimePickers} &
\texttt{DatePicker}, \texttt{TimePicker}, presenters, culture support \\
Interactive navigation & \texttt{Avalonia.Controls.SplitView},
\texttt{Avalonia.Controls.SplitButton} & Collapsible panes, hybrid
buttons \\
Document text & \texttt{Avalonia.Controls.Documents} & Inline elements
(\texttt{Run}, \texttt{Bold}, \texttt{InlineUIContainer}) \\
Misc UX & \texttt{Avalonia.Controls.TransitioningContentControl},
\texttt{Avalonia.Controls.Notifications.ReversibleStackPanel},
\texttt{Avalonia.Controls.Primitives} helpers & \\
\end{longtable}

Each module ships styles in Fluent/Simple theme dictionaries. Include
the relevant \texttt{.axaml} resource dictionaries when building custom
themes.

\subsection{2. ColorPicker and color
workflows}\label{colorpicker-and-color-workflows}

\texttt{ColorPicker} extends \texttt{ColorView} by providing a preview
area and flyout editing UI (\texttt{ColorPicker.cs}). Key elements: -
Preview content via \texttt{Content}/\texttt{ContentTemplate} (defaults
to swatch + ARGB string). - Editing flyout hosts \texttt{ColorSpectrum},
sliders, and palette pickers. - Palettes live in
\texttt{ColorPalettes/*}---you can supply custom palettes or localize
names.

Usage snippet:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ColorPicker}\OtherTok{ SelectedColor=}\StringTok{"\{Binding AccentColor, Mode=TwoWay\}"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ColorPicker.ContentTemplate}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Horizontal"}\OtherTok{ Spacing=}\StringTok{"8"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{Border}\OtherTok{ Width=}\StringTok{"24"}\OtherTok{ Height=}\StringTok{"24"}\OtherTok{ Background=}\StringTok{"\{Binding\}"}\OtherTok{ CornerRadius=}\StringTok{"4"}\NormalTok{/\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Converter=\{StaticResource RgbFormatter\}\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{DataTemplate}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ColorPicker.ContentTemplate}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ColorPicker}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Tips: - Set \texttt{ColorPicker.FlyoutPlacement} (via template) to adapt
for touch vs desktop usage. - Hook \texttt{ColorView.ColorChanged} to
react immediately to slider changes (e.g., update live preview alt
text). - Add automation peers (\texttt{ColorPickerAutomationPeer}) if
you expose color selection to screen readers.

\subsection{3. Pull-to-refresh
infrastructure}\label{pull-to-refresh-infrastructure}

\texttt{RefreshContainer} wraps scrollable content and coordinates
\texttt{RefreshVisualizer} animations (\texttt{RefreshContainer.cs}).
Concepts: - \texttt{PullDirection} (top/bottom/left/right) chooses
gesture direction. - \texttt{RefreshRequested} event fires when the user
crosses the threshold. Use \texttt{RefreshCompletionDeferral} to await
async work. - \texttt{RefreshInfoProviderAdapter} adapts
\texttt{ScrollViewer} offsets to the visualizer; you can replace it for
custom panels.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{ptr:RefreshContainer}\OtherTok{ RefreshRequested=}\StringTok{"OnRefresh"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ptr:RefreshContainer.Visualizer}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ptr:RefreshVisualizer}\OtherTok{ Orientation=}\StringTok{"TopToBottom"}
\OtherTok{                            Content=}\StringTok{"\{DynamicResource PullHintTemplate\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ptr:RefreshContainer.Visualizer}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{ScrollViewer}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ItemsControl}\OtherTok{ ItemsSource=}\StringTok{"\{Binding FeedItems\}"}\NormalTok{/\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{ScrollViewer}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{ptr:RefreshContainer}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private}\NormalTok{ async }\DataTypeTok{void} \FunctionTok{OnRefresh}\OperatorTok{(}\DataTypeTok{object}\OperatorTok{?}\NormalTok{ sender}\OperatorTok{,}\NormalTok{ RefreshRequestedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{using} \DataTypeTok{var}\NormalTok{ deferral }\OperatorTok{=}\NormalTok{ e}\OperatorTok{.}\FunctionTok{GetDeferral}\OperatorTok{();}
\NormalTok{    await ViewModel}\OperatorTok{.}\FunctionTok{LoadLatestAsync}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Notes: - On desktop, pull gestures require touchpad/touch screen; keep a
manual refresh fallback (button) for mouse-only setups. - Provide
localized feedback via \texttt{RefreshVisualizer.StateChanged} (show
``Release to refresh'' vs ``Refreshing\ldots{}''). - For virtualization,
ensure the underlying \texttt{ItemsControl} defers updates until after
refresh completes so the visualizer can retract smoothly.

\subsection{4. Notifications and toast
UIs}\label{notifications-and-toast-uis}

\texttt{WindowNotificationManager} hosts toast-like notifications
overlaying a \texttt{TopLevel} (\texttt{WindowNotificationManager.cs}).
- Set \texttt{Position} (TopRight, BottomCenter, etc.) and
\texttt{MaxItems}. - Call \texttt{Show(INotification)} or
\texttt{Show(object)}; the manager wraps content in a
\texttt{NotificationCard} with pseudo-classes per
\texttt{NotificationType}. - Attach \texttt{WindowNotificationManager}
to your main window (\texttt{new\ WindowNotificationManager(this)} or
via XAML \texttt{NotificationLayer}).

Custom template example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{Style}\OtherTok{ Selector=}\StringTok{"NotificationCard"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Setter}\OtherTok{ Property=}\StringTok{"Template"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{Setter.Value}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{ControlTemplate}\OtherTok{ TargetType=}\StringTok{"NotificationCard"}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}}\KeywordTok{Border}\OtherTok{ Classes=}\StringTok{"toast"}\OtherTok{ CornerRadius=}\StringTok{"6"}\OtherTok{ Background=}\StringTok{"\{ThemeResource SurfaceBrush\}"}\NormalTok{\textgreater{}}
\NormalTok{          \textless{}}\KeywordTok{StackPanel}\OtherTok{ Orientation=}\StringTok{"Vertical"}\OtherTok{ Margin=}\StringTok{"12"}\NormalTok{\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Content.Title\}"}\OtherTok{ FontWeight=}\StringTok{"SemiBold"}\NormalTok{/\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"\{Binding Content.Message\}"}\OtherTok{ TextWrapping=}\StringTok{"Wrap"}\NormalTok{/\textgreater{}}
\NormalTok{            \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Dismiss"}\OtherTok{ Classes=}\StringTok{"subtle"}
\OtherTok{                    notifications:NotificationCard.CloseOnClick=}\StringTok{"True"}\NormalTok{/\textgreater{}}
\NormalTok{          \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{        \textless{}/}\KeywordTok{Border}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}/}\KeywordTok{ControlTemplate}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{Setter.Value}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{Setter}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{Style}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Considerations: - Provide keyboard dismissal: map \texttt{Esc} to close
the newest notification. - For MVVM, store \texttt{INotificationManager}
in DI so view models can raise toasts without referencing the view. - On
future platforms (mobile), swap to platform notification managers when
available.

\subsection{5. DatePicker/TimePicker for
forms}\label{datepickertimepicker-for-forms}

\texttt{DatePicker} and \texttt{TimePicker} share presenters and respect
culture-specific formats (\texttt{DatePicker.cs},
\texttt{TimePicker.cs}). - Properties: \texttt{SelectedDate},
\texttt{MinYear}, \texttt{MaxYear}, \texttt{DayVisible},
\texttt{MonthFormat}, \texttt{YearFormat}. - Template parts expose text
blocks and a popup presenter; override the template to customize layout.
- Two-way binding uses \texttt{DateTimeOffset?} (stay mindful of time
zones).

Validation strategies: - Use \texttt{Binding} with data annotations or
manual rules to block invalid ranges. - For forms, show hint text using
pseudo-class \texttt{:hasnodate} when \texttt{SelectedDate} is null. -
Provide automation names for the button and popup to assist screen
readers.

\subsubsection{Calendar control for
planners}\label{calendar-control-for-planners}

\texttt{Calendar} gives you a full month or decade view without the
flyout wrapper. - \texttt{DisplayMode} toggles Month, Year, or Decade
views---useful for date pickers embedded in dashboards. -
\texttt{SelectedDates} supports multi-selection when
\texttt{SelectionMode} is \texttt{MultipleRange}; bind it to a
collection for booking scenarios. - Handle \texttt{DisplayDateChanged}
to lazy-load data (appointments, deadlines) as the user browses months.
- Customize the template to expose additional adorners (badges,
tooltips). Keep \texttt{PART\_DaysPanel} and related names intact so the
control keeps functioning.

When you need both \texttt{Calendar} and \texttt{DatePicker}, reuse the
same \texttt{CalendarDatePicker} styles so typography and spacing stay
consistent.

\subsection{6. SplitView and navigation
panes}\label{splitview-and-navigation-panes}

\texttt{SplitView} builds side drawers with flexible display modes
(\texttt{SplitView.cs}). - \texttt{DisplayMode}: Overlay, Inline,
CompactOverlay, CompactInline. - \texttt{IsPaneOpen} toggles state;
handle \texttt{PaneOpening/PaneClosing} to intercept. -
\texttt{UseLightDismissOverlayMode} enables auto-dismiss when the user
clicks outside.

Usage example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{SplitView}\OtherTok{ IsPaneOpen=}\StringTok{"\{Binding IsMenuOpen, Mode=TwoWay\}"}
\OtherTok{           DisplayMode=}\StringTok{"CompactOverlay"}
\OtherTok{           PanePlacement=}\StringTok{"Left"}
\OtherTok{           CompactPaneLength=}\StringTok{"56"}
\OtherTok{           OpenPaneLength=}\StringTok{"240"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{SplitView.Pane}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Dashboard"}\OtherTok{ Command=}\StringTok{"\{Binding GoHome\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Reports"}\OtherTok{ Command=}\StringTok{"\{Binding GoReports\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{SplitView.Pane}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{Frame}\OtherTok{ Content=}\StringTok{"\{Binding CurrentPage\}"}\NormalTok{/\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{SplitView}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Tips: - On desktop, use keyboard shortcuts to toggle the pane (e.g.,
assign \texttt{HotKey} to \texttt{SplitButton} or global command). -
Manage focus: when the pane opens via keyboard, move focus to the first
focusable element; when closing, restore focus to the toggle. - Combine
with \texttt{TransitioningContentControl} (Chapter 29) for smooth page
transitions.

\subsubsection{TransitioningContentControl for dynamic
views}\label{transitioningcontentcontrol-for-dynamic-views}

\texttt{TransitioningContentControl} wraps a content presenter with
\texttt{IPageTransition} support. - Assign \texttt{PageTransition} in
XAML (slide, cross-fade, custom transitions) to animate view-model
swaps. - Hook \texttt{TransitionCompleted} to dispose old view models or
trigger analytics when navigation ends. - Pair with \texttt{SplitView}
or navigation shells to animate content panes independently of the
chrome.

For component galleries, use it to showcase before/after states or
responsive layouts without writing manual animation plumbing.

\subsection{7. SplitButton and
ToggleSplitButton}\label{splitbutton-and-togglesplitbutton}

\texttt{SplitButton} provides a main action plus a secondary flyout
(\texttt{SplitButton.cs}). - Primary click raises
\texttt{Click}/\texttt{Command}; the secondary button shows
\texttt{Flyout}. - Pseudo-classes \texttt{:flyout-open},
\texttt{:pressed}, \texttt{:checked} (for \texttt{ToggleSplitButton}). -
Works nicely with \texttt{MenuFlyout} for command lists or settings.

Example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{SplitButton}\OtherTok{ Content=}\StringTok{"Export"}
\OtherTok{             Command=}\StringTok{"\{Binding ExportAll\}"}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{SplitButton.Flyout}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{MenuFlyout}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"Export CSV"}\OtherTok{ Command=}\StringTok{"\{Binding ExportCsv\}"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{MenuItem}\OtherTok{ Header=}\StringTok{"Export JSON"}\OtherTok{ Command=}\StringTok{"\{Binding ExportJson\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{MenuFlyout}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{SplitButton.Flyout}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{SplitButton}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Ensure \texttt{Command.CanExecute} updates by binding to view model
state; \texttt{SplitButton} listens for \texttt{CanExecuteChanged} and
toggles \texttt{IsEnabled} accordingly.

\subsection{8. Notifications, documents, and media
surfaces}\label{notifications-documents-and-media-surfaces}

\begin{itemize}
\tightlist
\item
  \texttt{Inline}, \texttt{Run}, \texttt{Span}, and
  \texttt{InlineUIContainer} in \texttt{Avalonia.Controls.Documents} let
  you build rich text with embedded controls (useful for notifications
  or chat bubbles).
\item
  Use \texttt{InlineUIContainer} sparingly; it affects layout
  performance.
\item
  Combine \texttt{NotificationCard} with document inlines to highlight
  formatted content (bold text, links).
\end{itemize}

\texttt{MediaPlayerElement} (available when you reference the media
package) embeds audio/video playback with transport controls. - Bind
\texttt{Source} to URIs or streams; the element manages decoding via
platform backends (\texttt{Windows} uses Angle/DX, \texttt{Linux} goes
through FFmpeg when available). - Toggle
\texttt{AreTransportControlsEnabled} to show built-in play/pause UI; for
custom chrome, bind to \texttt{MediaPlayer} and drive commands yourself.
- Handle \texttt{MediaOpened}/\texttt{MediaEnded} to chain playlists or
update state. - On platforms without native codecs, surface fallbacks
(download prompts, external players) so the UI stays predictable.

\subsection{9. Building a component
gallery}\label{building-a-component-gallery}

Create a \texttt{ComponentGalleryWindow} that showcases each control
with explanations and theme toggles:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textless{}}\KeywordTok{TabControl}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TabItem}\OtherTok{ Header=}\StringTok{"Color"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{StackPanel}\OtherTok{ Spacing=}\StringTok{"16"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"ColorPicker"}\OtherTok{ FontWeight=}\StringTok{"SemiBold"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{ColorPicker}\OtherTok{ SelectedColor=}\StringTok{"\{Binding ThemeColor\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{TabItem}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TabItem}\OtherTok{ Header=}\StringTok{"Refresh"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{ptr:RefreshContainer}\OtherTok{ RefreshRequested=}\StringTok{"OnRefreshRequested"}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{ListBox}\OtherTok{ ItemsSource=}\StringTok{"\{Binding Items\}"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{ptr:RefreshContainer}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{TabItem}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}}\KeywordTok{TabItem}\OtherTok{ Header=}\StringTok{"Notifications"}\NormalTok{\textgreater{}}
\NormalTok{    \textless{}}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{Button}\OtherTok{ Content=}\StringTok{"Show success"}\OtherTok{ Click=}\StringTok{"OnShowSuccess"}\NormalTok{/\textgreater{}}
\NormalTok{      \textless{}}\KeywordTok{TextBlock}\OtherTok{ Text=}\StringTok{"Notifications appear top{-}right"}\NormalTok{/\textgreater{}}
\NormalTok{    \textless{}/}\KeywordTok{StackPanel}\NormalTok{\textgreater{}}
\NormalTok{  \textless{}/}\KeywordTok{TabItem}\NormalTok{\textgreater{}}
\NormalTok{\textless{}/}\KeywordTok{TabControl}\NormalTok{\textgreater{}}
\end{Highlighting}
\end{Shaded}

Best practices: - Offer theme toggle (Fluent light/dark) to reveal
styling differences. - Surface accessibility guidance (keyboard
shortcuts, screen reader notes) alongside each sample. - Provide code
snippets via \texttt{TextBlock} or copy buttons so teammates can reuse
patterns.

\subsection{10. Practice lab: responsibility
matrix}\label{practice-lab-responsibility-matrix}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Color workflows} -- Customize \texttt{ColorPicker} palettes,
  bind to view model state, and expose automation peers for UI tests.
\item
  \textbf{Mobile refresh} -- Implement \texttt{RefreshContainer} in a
  list, test on touch-enabled hardware, and add fallback commands for
  desktop.
\item
  \textbf{Toast scenarios} -- Build a notification service that queues
  messages and exposes dismissal commands, then craft styles for
  different severities.
\item
  \textbf{Dashboard shell} -- Combine \texttt{SplitView},
  \texttt{SplitButton}, and \texttt{TransitioningContentControl} to
  create a responsive navigation shell with keyboard and pointer parity.
\item
  \textbf{Component gallery} -- Document each control with design notes,
  theming tweaks, and automation IDs; integrate into project
  documentation.
\end{enumerate}

\subsection{Troubleshooting \& best
practices}\label{troubleshooting-best-practices-5}

\begin{itemize}
\tightlist
\item
  Many controls rely on template parts (\texttt{PART\_*}). When
  restyling, preserve these names or update code-behind references.
\item
  Notification overlays run on the UI thread; throttle or batch updates
  to avoid flooding \texttt{WindowNotificationManager} with dozens of
  toasts.
\item
  \texttt{RefreshContainer} needs a \texttt{ScrollViewer} or adapter
  implementing \texttt{IRefreshInfoProvider}; custom panels must adapt
  to supply offset data.
\item
  Date/time pickers use \texttt{DateTimeOffset}. When binding to
  \texttt{DateTime}, convert carefully to retain time zones.
\item
  SplitView on compact widths: watch out for layout loops if your pane
  content uses \texttt{HorizontalAlignment.Stretch}; consider fixed
  width.
\end{itemize}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-28}

\begin{itemize}
\tightlist
\item
  Color picker foundation:
  \texttt{external/Avalonia/src/Avalonia.Controls.ColorPicker/ColorPicker/ColorPicker.cs}
\item
  Pull-to-refresh:
  \texttt{external/Avalonia/src/Avalonia.Controls/PullToRefresh/RefreshContainer.cs}
\item
  Notifications:
  \texttt{external/Avalonia/src/Avalonia.Controls/Notifications/WindowNotificationManager.cs},
  \texttt{NotificationCard.cs}
\item
  Calendar \& date/time:
  \texttt{external/Avalonia/src/Avalonia.Controls/Calendar/Calendar.cs},
  \texttt{external/Avalonia/src/Avalonia.Controls/DateTimePickers/DatePicker.cs},
  \texttt{TimePicker.cs}
\item
  Split view/button:
  \texttt{external/Avalonia/src/Avalonia.Controls/SplitView/SplitView.cs},
  \texttt{external/Avalonia/src/Avalonia.Controls/SplitButton/SplitButton.cs}
\item
  Documents:
  \texttt{external/Avalonia/src/Avalonia.Controls/Documents/*}
\item
  Transitions host:
  \texttt{external/Avalonia/src/Avalonia.Controls/TransitioningContentControl.cs}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-29}

\begin{itemize}
\tightlist
\item
  Which namespace hosts \texttt{RefreshContainer}, and why does it need
  a \texttt{RefreshVisualizer}?
\item
  How does \texttt{WindowNotificationManager} limit concurrent
  notifications and close them programmatically?
\item
  What steps keep \texttt{DatePicker} in sync with \texttt{DateTime}
  view-model properties?
\item
  How do you style \texttt{SplitView} for light-dismiss overlay vs
  inline mode?
\item
  What belongs in a component gallery to help teammates reuse advanced
  controls?
\end{itemize}

What's next - Next: \href{Chapter32.md}{Chapter32}

\newpage

\subsection{32. Platform services, embedding, and native
interop}\label{platform-services-embedding-and-native-interop}

Goal - Integrate Avalonia with native hosts: Windows, macOS, X11,
browsers, mobile shells, and custom embedding scenarios. - Leverage
\texttt{NativeControlHost}, \texttt{EmbeddableControlRoot}, and platform
services (\texttt{IWindowingPlatform}, tray icons, system dialogs) to
build hybrid applications. - Understand remote protocols and thin-client
options to drive Avalonia content from external processes.

Why this matters - Many teams embed Avalonia inside existing apps
(Win32, WPF, WinForms), or host native controls inside Avalonia shells.
- Platform services expose tray icons, system navigation managers,
storage providers, and more. Using them correctly keeps UX idiomatic per
OS. - Remote rendering and embedding power tooling (previewers,
diagnostics, multi-process architectures).

Prerequisites - Chapter 12 (windows \& lifetimes) for top-level
concepts. - Chapter 18--20 (platform targets) for backend overviews. -
Chapter 32 builds on Chapter 29 (animations/composition) when
synchronizing native surfaces.

\subsection{1. Platform abstractions
overview}\label{platform-abstractions-overview}

Avalonia abstracts windowing via interfaces in
\texttt{Avalonia.Controls.Platform} and \texttt{Avalonia.Platform}:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Interface
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Location
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{IWindowingPlatform} &
\texttt{external/Avalonia/src/Avalonia.Controls/Platform/IWindowingPlatform.cs}
& Creates windows, embeddable top levels, tray icons \\
\texttt{INativeControlHostImpl} & platform backends (Win32, macOS, iOS,
Browser) & Hosts native HWND/NSView/UIViews inside Avalonia
(\texttt{NativeControlHost}) \\
\texttt{ITrayIconImpl} & backend-specific & Implements tray icons
(\texttt{PlatformManager.CreateTrayIcon}) \\
\texttt{IPlatformStorageProvider}, \texttt{ILauncher} &
\texttt{Avalonia.Platform.Storage} & File pickers, launchers across
platforms \\
\texttt{IApplicationPlatformEvents} &
\texttt{Avalonia.Controls.Platform} & System-level events (activation,
protocol handlers) \\
\end{longtable}

\texttt{PlatformManager} coordinates these services and surfaces
high-level helpers (tray icons, dialogs). Check
\texttt{TopLevel.PlatformImpl} to access backend-specific features.

\subsection{2. Hosting native controls inside
Avalonia}\label{hosting-native-controls-inside-avalonia}

\texttt{NativeControlHost}
(\texttt{external/Avalonia/src/Avalonia.Controls/NativeControlHost.cs})
lets you wrap native views:

\begin{itemize}
\tightlist
\item
  Override \texttt{CreateNativeControlCore(IPlatformHandle\ parent)} to
  instantiate native widgets (Win32 HWND, NSView, Android View).
\item
  Avalonia attaches/detaches the native control when the host
  enters/leaves the visual tree, using \texttt{INativeControlHostImpl}
  from the current \texttt{TopLevel}.
\item
  \texttt{TryUpdateNativeControlPosition} translates Avalonia bounds
  into platform coordinates and resizes the native child.
\end{itemize}

Example (Win32 HWND):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ Win32WebViewHost }\OperatorTok{:}\NormalTok{ NativeControlHost}
\OperatorTok{\{}
    \KeywordTok{protected} \KeywordTok{override}\NormalTok{ IPlatformHandle }\FunctionTok{CreateNativeControlCore}\OperatorTok{(}\NormalTok{IPlatformHandle parent}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ hwnd }\OperatorTok{=}\NormalTok{ Win32Interop}\OperatorTok{.}\FunctionTok{CreateWebView}\OperatorTok{(}\NormalTok{parent}\OperatorTok{.}\FunctionTok{Handle}\OperatorTok{);}
        \KeywordTok{return} \KeywordTok{new} \FunctionTok{PlatformHandle}\OperatorTok{(}\NormalTok{hwnd}\OperatorTok{,} \StringTok{"HWND"}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{DestroyNativeControlCore}\OperatorTok{(}\NormalTok{IPlatformHandle control}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        Win32Interop}\OperatorTok{.}\FunctionTok{DestroyWindow}\OperatorTok{(}\NormalTok{control}\OperatorTok{.}\FunctionTok{Handle}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Guidelines: - Ensure thread affinity: most native controls expect
creation/destruction on the UI thread. - Handle DPI changes by listening
to size changes (\texttt{BoundsProperty}) and calling the platform API
to adjust scaling. - Use \texttt{NativeControlHandleChanged} for interop
with additional APIs (e.g., hooking message loops). - For accessibility,
expose appropriate semantics; Avalonia's
\texttt{NativeControlHostAutomationPeer} helps but you may need custom
peers.

\subsection{3. Embedding Avalonia inside native
hosts}\label{embedding-avalonia-inside-native-hosts}

\texttt{EmbeddableControlRoot}
(\texttt{external/Avalonia/src/Avalonia.Controls/Embedding/EmbeddableControlRoot.cs})
wraps a \texttt{TopLevel} that can live in non-Avalonia environments:

\begin{itemize}
\tightlist
\item
  Construct with an \texttt{ITopLevelImpl} supplied by platform-specific
  hosts (\texttt{WinFormsAvaloniaControlHost}, \texttt{X11\ XEmbed},
  \texttt{Android\ AvaloniaView}, \texttt{iOS\ AvaloniaView}).
\item
  Call \texttt{Prepare()} to initialize the logical tree and run the
  initial layout pass.
\item
  Use \texttt{StartRendering}/\texttt{StopRendering} to control drawing
  when the host window shows/hides.
\item
  \texttt{EnforceClientSize} ensures Avalonia matches the host surface
  size; disable for custom measure logic.
\end{itemize}

Examples: - \textbf{WinForms}: \texttt{WinFormsAvaloniaControlHost}
hosts \texttt{EmbeddableControlRoot} inside Windows Forms. Remember to
call \texttt{InitAvalonia()} before creating controls. - \textbf{X11
embedding}: \texttt{XEmbedPlug} uses \texttt{EmbeddableControlRoot} to
embed into foreign X11 windows (tooling, remote previews). -
\textbf{Mobile views}: \texttt{Avalonia.Android.AvaloniaView} and
\texttt{Avalonia.iOS.AvaloniaView} wrap \texttt{EmbeddableControlRoot}
to integrate with native UI stacks.

Interop tips: - Manage lifecycle carefully: dispose the root when the
host closes to release GPU/threads. - Expose the \texttt{Content}
property to your native layer for dynamic view injection. - Bridge focus
and input: e.g., WinForms host sets \texttt{TabStop} and forwards focus
events to the Avalonia root.

\subsubsection{MicroCom bridges for Windows
interop}\label{microcom-bridges-for-windows-interop}

Avalonia relies on
\href{https://github.com/AvaloniaUI/MicroCom}{MicroCom} to generate
COM-compatible wrappers. When embedding on Windows (drag/drop, menus,
Win32 interop): - Use \texttt{Avalonia.MicroCom.CallbackBase} as the
base for custom COM callbacks; it handles reference counting and error
reporting. - \texttt{OleDropTarget} and native menu exporters in
\texttt{Avalonia.Win32} demonstrate wrapping Win32 interfaces without
hand-written COM glue. - When exposing Avalonia controls to native
hosts, keep MicroCom proxies alive for the lifetime of the host window
to avoid releasing underlying HWND/IDispatch too early.

You rarely need to touch MicroCom directly, but understanding it helps
when diagnosing drag/drop or accessibility issues on Windows.

\subsection{4. Remote rendering and
previews}\label{remote-rendering-and-previews}

Avalonia's remote protocol
(\texttt{external/Avalonia/src/Avalonia.Remote.Protocol}) powers the
XAML previewer and custom remoting scenarios.

\begin{itemize}
\tightlist
\item
  \texttt{RemoteServer}
  (\texttt{external/Avalonia/src/Avalonia.Controls/Remote/RemoteServer.cs})
  wraps an \texttt{EmbeddableControlRoot} backed by
  \texttt{RemoteServerTopLevelImpl}. It responds to transport messages
  (layout updates, pointer events) from a remote client.
\item
  Transports: BSON over TCP (\texttt{BsonTcpTransport}), streams
  (\texttt{BsonStreamTransport}), or custom
  \texttt{IAvaloniaRemoteTransportConnection} implementations.
\item
  Use \texttt{Avalonia.DesignerSupport} components to spin up preview
  hosts; they bind to \texttt{IWindowingPlatform} stubs suitable for
  design-time.
\item
  On the client side, \texttt{RemoteWidget} hosts the mirrored visual
  tree. It pairs with \texttt{RemoteServer} to marshal input/output.
\item
  Implement a custom \texttt{ITransport} when you need alternate
  channels (named pipes, WebSockets). The protocol is message-based, so
  you can plug in encryption or compression as needed.
\end{itemize}

Potential use cases: - Live XAML preview in IDEs (already shipped). -
Remote control panels (render UI in a service, interact via TCP). - UI
testing farms capturing frames via remote composition.

Security note: remote transports expose the UI tree---protect endpoints
if you ship this beyond trusted tooling.

\subsection{5. Tray icons, dialogs, and platform
services}\label{tray-icons-dialogs-and-platform-services}

\texttt{IWindowingPlatform.CreateTrayIcon()} supplies backend-specific
tray icon implementations. Use \texttt{PlatformManager.CreateTrayIcon()}
to instantiate one:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ trayIcon }\OperatorTok{=}\NormalTok{ PlatformManager}\OperatorTok{.}\FunctionTok{CreateTrayIcon}\OperatorTok{();}
\NormalTok{trayIcon}\OperatorTok{.}\FunctionTok{Icon} \OperatorTok{=} \KeywordTok{new} \FunctionTok{WindowIcon}\OperatorTok{(}\StringTok{"avares://Assets/tray.ico"}\OperatorTok{);}
\NormalTok{trayIcon}\OperatorTok{.}\FunctionTok{ToolTipText} \OperatorTok{=} \StringTok{"My App"}\OperatorTok{;}
\NormalTok{trayIcon}\OperatorTok{.}\FunctionTok{Menu} \OperatorTok{=} \KeywordTok{new}\NormalTok{ NativeMenu}
\OperatorTok{\{}
\NormalTok{    Items }\OperatorTok{=}
    \OperatorTok{\{}
        \KeywordTok{new} \FunctionTok{NativeMenuItem}\OperatorTok{(}\StringTok{"Show"}\OperatorTok{,} \OperatorTok{(}\NormalTok{sender}\OperatorTok{,}\NormalTok{ args}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ mainWindow}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{()),}
        \KeywordTok{new} \FunctionTok{NativeMenuItem}\OperatorTok{(}\StringTok{"Exit"}\OperatorTok{,} \OperatorTok{(}\NormalTok{sender}\OperatorTok{,}\NormalTok{ args}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ app}\OperatorTok{.}\FunctionTok{Shutdown}\OperatorTok{())}
    \OperatorTok{\}}
\OperatorTok{\};}
\NormalTok{trayIcon}\OperatorTok{.}\FunctionTok{IsVisible} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Other services: - \textbf{File pickers/storage}:
\texttt{StorageProvider} (Chapter 16) uses platform storage APIs; embed
scenarios must supply providers in DI. - \textbf{System dialogs}:
\texttt{SystemDialog} classes fallback to managed dialogs when native
APIs are unavailable. - \textbf{Application platform events}:
\texttt{IApplicationPlatformEvents} handles activation (protocol URLs,
file associations). Register via \texttt{AppBuilder} extensions. -
\textbf{System navigation}: On mobile, \texttt{SystemNavigationManager}
handles back-button events; ensure \texttt{UsePlatformDetect} registers
the appropriate lifetime. - \textbf{Window chrome}: \texttt{Window}
exposes \texttt{SystemDecorations},
\texttt{ExtendClientAreaToDecorationsHint},
\texttt{WindowTransparencyLevel}, and the \texttt{Chrome.WindowChrome}
helpers so you can blend custom title bars with OS hit testing. Always
provide resize grips and fall back to system chrome when composition is
disabled.

\subsection{6. Browser, Android, iOS
views}\label{browser-android-ios-views}

\begin{itemize}
\tightlist
\item
  \textbf{Browser}: \texttt{Avalonia.Browser.AvaloniaView} hosts
  \texttt{EmbeddableControlRoot} atop WebAssembly;
  \texttt{NativeControlHost} implementations for the browser route to JS
  interop.
\item
  \textbf{Android/iOS}: \texttt{AvaloniaView} provides native controls
  (Android View, iOS UIView) embedding Avalonia UI. Use
  \texttt{SingleViewLifetime} to tie app lifetimes to host platforms.
\item
  Expose Avalonia content to native navigation stacks, but run
  Avalonia's message loop (\texttt{AppBuilder.AndroidLifecycleEvents} /
  \texttt{AppBuilder.iOS}).
\end{itemize}

\subsection{7. Offscreen rendering and
interoperability}\label{offscreen-rendering-and-interoperability}

\texttt{OffscreenTopLevel}
(\texttt{external/Avalonia/src/Avalonia.Controls/Embedding/Offscreen/OffscreenTopLevel.cs})
allows rendering to a framebuffer without showing a window---useful for:
- Server-side rendering (generate bitmaps for PDFs, emails). - Unit
tests verifying layout/visual output. - Thumbnail generation for design
tools.

Pair with \texttt{RenderTargetBitmap} to save results.

\subsection{8. Practice lab: hybrid UI
playbook}\label{practice-lab-hybrid-ui-playbook}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Embed native control} -- Host a Win32 WebView or
  platform-specific map view inside Avalonia using
  \texttt{NativeControlHost}. Ensure resize and DPI updates work.
\item
  \textbf{Avalonia-in-native} -- Create a WinForms or WPF shell
  embedding \texttt{EmbeddableControlRoot}. Swap Avalonia content
  dynamically and synchronize focus/keyboard.
\item
  \textbf{Tray integration} -- Add a tray icon that controls window
  visibility and displays context menus. Test on Windows and Linux
  (AppIndicator fallback).
\item
  \textbf{Remote preview} -- Spin up \texttt{RemoteServer} with a TCP
  transport and connect using the Avalonia preview client to render a
  view remotely.
\item
  \textbf{Offscreen rendering} -- Render a control to bitmap using
  \texttt{OffscreenTopLevel} + \texttt{RenderTargetBitmap} and compare
  results in a unit test.
\end{enumerate}

Document interop boundaries (threading, disposal, event forwarding) for
your team.

\subsection{Troubleshooting \& best
practices}\label{troubleshooting-best-practices-6}

\begin{itemize}
\tightlist
\item
  Always dispose hosts (\texttt{EmbeddableControlRoot}, tray icons,
  remote transports) to release native resources.
\item
  Ensure Avalonia is initialized
  (\texttt{BuildAvaloniaApp().SetupWithoutStarting()}) before embedding
  in native shells.
\item
  Watch for DPI mismatches: use
  \texttt{TopLevel.PlatformImpl?.TryGetFeature\textless{}IDpiProvider\textgreater{}()}
  or subscribe to scaling changes.
\item
  For \texttt{NativeControlHost}, guard against parent changes; detach
  native handles during visual tree transitions to avoid orphaned HWNDs.
\item
  Remote transports may drop messages under heavy load---implement
  reconnection logic and validation.
\item
  On macOS, tray icons require the app to stay alive (use
  \texttt{NSApplication.ActivateIgnoringOtherApps} when needed).
\end{itemize}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-29}

\begin{itemize}
\tightlist
\item
  Native hosting:
  \texttt{external/Avalonia/src/Avalonia.Controls/NativeControlHost.cs}
\item
  Embedding root:
  \texttt{external/Avalonia/src/Avalonia.Controls/Embedding/EmbeddableControlRoot.cs}
\item
  Platform manager \& services:
  \texttt{external/Avalonia/src/Avalonia.Controls/Platform/PlatformManager.cs}
\item
  Remote protocol:
  \texttt{external/Avalonia/src/Avalonia.Controls/Remote/RemoteServer.cs},
  \texttt{external/Avalonia/src/Avalonia.Controls/Remote/RemoteWidget.cs},
  \texttt{external/Avalonia/src/Avalonia.Remote.Protocol/*}
\item
  Win32 platform:
  \texttt{external/Avalonia/src/Windows/Avalonia.Win32/Win32Platform.cs}
\item
  Browser/Android/iOS hosts:
  \texttt{external/Avalonia/src/Browser/Avalonia.Browser/AvaloniaView.cs},
  \texttt{external/Avalonia/src/Android/Avalonia.Android/AvaloniaView.cs},
  \texttt{external/Avalonia/src/iOS/Avalonia.iOS/AvaloniaView.cs}
\item
  MicroCom interop:
  \texttt{external/Avalonia/src/Avalonia.MicroCom/CallbackBase.cs},
  \texttt{external/Avalonia/src/Windows/Avalonia.Win32/OleDropTarget.cs}
\item
  Window chrome helpers:
  \texttt{external/Avalonia/src/Avalonia.Controls/Chrome/WindowChrome.cs},
  \texttt{external/Avalonia/src/Avalonia.Controls/Window.cs}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-30}

\begin{itemize}
\tightlist
\item
  How does \texttt{NativeControlHost} coordinate
  \texttt{INativeControlHostImpl} and what events trigger repositioning?
\item
  What steps are required to embed Avalonia inside an existing
  WinForms/WPF app?
\item
  Which services does \texttt{IWindowingPlatform} expose, and how do you
  use them to create tray icons or embeddable top levels?
\item
  How would you stream Avalonia UI to a remote client for live previews?
\item
  When rendering offscreen, which classes help you create an isolated
  top level and capture the framebuffer?
\end{itemize}

What's next - Next: \href{Chapter33.md}{Chapter33}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part VII — Code-first UI without XAML friction}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part VII — Code-first UI without XAML friction}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{33. Code-only startup and architecture
blueprint}\label{code-only-startup-and-architecture-blueprint}

Goal - Bootstrap Avalonia apps entirely from C\# so you can skip XAML
without losing features. - Structure resources, styles, and themes in
code-first projects that still feel modular. - Integrate dependency
injection, services, and lifetimes using the same primitives Avalonia's
XAML templates rely on internally.

Why this matters - Many teams prefer a single-language stack (pure C\#)
for greater refactorability, dynamic UI, or source generator workflows.
- Understanding the startup pipeline (\texttt{AppBuilder}, lifetimes,
\texttt{Application.RegisterServices}) lets you shape architecture to
match modular backends or plug-ins. - Code-first projects must
explicitly wire themes, resources, and styles---knowing the underlying
APIs prevents surprises when copying snippets from XAML-centric samples.

Prerequisites - Chapter 4 (startup and lifetimes) for the
\texttt{AppBuilder} pipeline. - Chapter 7 (styling) to recognize how
selectors, themes, and resources work. - Chapter 11 (MVVM) for
structuring view-models and locator patterns that code-first projects
often lean on.

\subsection{\texorpdfstring{1. Start from \texttt{Program.cs}:
configuring the builder
yourself}{1. Start from Program.cs: configuring the builder yourself}}\label{start-from-program.cs-configuring-the-builder-yourself}

Avalonia templates scaffold XAML, but the real work happens in
\texttt{Program.BuildAvaloniaApp()} (see
\texttt{external/Avalonia/src/Avalonia.Templates/}). Code-first apps use
the same \texttt{AppBuilder\textless{}TApp\textgreater{}} API.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Controls}\OperatorTok{.}\FunctionTok{ApplicationLifetimes}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{ReactiveUI}\OperatorTok{;} \CommentTok{// optional: add once for ReactiveUI{-}centric apps}

\KeywordTok{internal} \KeywordTok{static} \KeywordTok{class}\NormalTok{ Program}
\OperatorTok{\{}
    \OperatorTok{[}\NormalTok{STAThread}\OperatorTok{]}
    \KeywordTok{public} \KeywordTok{static} \DataTypeTok{void} \FunctionTok{Main}\OperatorTok{(}\DataTypeTok{string}\OperatorTok{[]}\NormalTok{ args}\OperatorTok{)}
    \OperatorTok{\{}
        \FunctionTok{BuildAvaloniaApp}\OperatorTok{()}
            \OperatorTok{.}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{private} \KeywordTok{static}\NormalTok{ AppBuilder }\FunctionTok{BuildAvaloniaApp}\OperatorTok{()}
        \OperatorTok{=\textgreater{}}\NormalTok{ AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
            \OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
            \OperatorTok{.}\FunctionTok{LogToTrace}\OperatorTok{()}
            \OperatorTok{.}\FunctionTok{With}\OperatorTok{(}\KeywordTok{new}\NormalTok{ Win32PlatformOptions}
            \OperatorTok{\{}
\NormalTok{                CompositionMode }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{}\NormalTok{ Win32CompositionMode}\OperatorTok{.}\FunctionTok{WinUIComposition} \OperatorTok{\}} \CommentTok{// example tweak}
            \OperatorTok{\})}
            \OperatorTok{.}\FunctionTok{With}\OperatorTok{(}\KeywordTok{new}\NormalTok{ X11PlatformOptions }\OperatorTok{\{}\NormalTok{ EnableIme }\OperatorTok{=} \KeywordTok{true} \OperatorTok{\})}
            \OperatorTok{.}\FunctionTok{With}\OperatorTok{(}\KeywordTok{new}\NormalTok{ AvaloniaNativePlatformOptions }\OperatorTok{\{}\NormalTok{ UseDeferredRendering }\OperatorTok{=} \KeywordTok{true} \OperatorTok{\})}
            \OperatorTok{.}\FunctionTok{UseSkia}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Key points from \texttt{AppBuilder.cs}: -
\texttt{Configure\textless{}App\textgreater{}()} wires Avalonia's
service locator (\texttt{AvaloniaLocator}) with the type parameter you
pass. - \texttt{UsePlatformDetect()} resolves the proper backend at
runtime. Replace it with \texttt{UseWin32()},
\texttt{UseAvaloniaNative()}, etc., to force a backend for tests. -
\texttt{.UseReactiveUI()} (from
\texttt{Avalonia.ReactiveUI/AppBuilderExtensions.cs}) registers
ReactiveUI's scheduler, command binding, and view locator glue---call it
in code-first projects that rely on \texttt{ReactiveCommand}. -
\texttt{.With\textless{}TOptions\textgreater{}()} registers
backend-specific option objects. Because you're not using
\texttt{App.axaml}, code is the only place to set them.

Remember you can split configuration across methods for clarity:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private} \KeywordTok{static}\NormalTok{ AppBuilder }\FunctionTok{ConfigurePlatforms}\OperatorTok{(}\NormalTok{AppBuilder builder}\OperatorTok{)}
    \OperatorTok{=\textgreater{}}\NormalTok{ builder}\OperatorTok{.}\FunctionTok{UsePlatformDetect}\OperatorTok{()}
              \OperatorTok{.}\FunctionTok{With}\OperatorTok{(}\KeywordTok{new}\NormalTok{ Win32PlatformOptions }\OperatorTok{\{}\NormalTok{ UseWgl }\OperatorTok{=} \KeywordTok{false} \OperatorTok{\})}
              \OperatorTok{.}\FunctionTok{With}\OperatorTok{(}\KeywordTok{new}\NormalTok{ AvaloniaNativePlatformOptions }\OperatorTok{\{}\NormalTok{ UseGpu }\OperatorTok{=} \KeywordTok{true} \OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

Chaining explicit helper methods keeps \texttt{BuildAvaloniaApp}
readable while preserving fluent semantics.

\subsection{\texorpdfstring{2. Crafting an \texttt{Application} subclass
without
XAML}{2. Crafting an Application subclass without XAML}}\label{crafting-an-application-subclass-without-xaml}

\texttt{Application} lives in
\texttt{external/Avalonia/src/Avalonia.Controls/Application.cs}. The
default XAML template overrides
\texttt{OnFrameworkInitializationCompleted()} after loading XAML. In
code-first scenarios you:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Override \texttt{Initialize()} to register styles/resources
  explicitly.
\item
  (Optionally) override \texttt{RegisterServices()} to set up dependency
  injection.
\item
  Override \texttt{OnFrameworkInitializationCompleted()} to set the root
  visual for the selected lifetime.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Controls}\OperatorTok{.}\FunctionTok{ApplicationLifetimes}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Markup}\OperatorTok{.}\FunctionTok{Xaml}\OperatorTok{.}\FunctionTok{Styling}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Themes}\OperatorTok{.}\FunctionTok{Fluent}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ App }\OperatorTok{:}\NormalTok{ Application}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{Initialize}\OperatorTok{()}
    \OperatorTok{\{}
\NormalTok{        Styles}\OperatorTok{.}\FunctionTok{Clear}\OperatorTok{();}

\NormalTok{        Styles}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\KeywordTok{new}\NormalTok{ FluentTheme}
        \OperatorTok{\{}
\NormalTok{            Mode }\OperatorTok{=}\NormalTok{ FluentThemeMode}\OperatorTok{.}\FunctionTok{Dark}
        \OperatorTok{\});}

\NormalTok{        Styles}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\KeywordTok{new} \FunctionTok{StyleInclude}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Uri}\OperatorTok{(}\StringTok{"avares://App/Styles"}\OperatorTok{))}
        \OperatorTok{\{}
\NormalTok{            Source }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Uri}\OperatorTok{(}\StringTok{"avares://App/Styles/Controls.axaml"}\OperatorTok{)} \CommentTok{// optional: you can still load XAML fragments}
        \OperatorTok{\});}

\NormalTok{        Styles}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\FunctionTok{CreateButtonStyle}\OperatorTok{());}

\NormalTok{        Resources}\OperatorTok{.}\FunctionTok{MergedDictionaries}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\FunctionTok{CreateAppResources}\OperatorTok{());}
    \OperatorTok{\}}

    \KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{RegisterServices}\OperatorTok{()}
    \OperatorTok{\{}
        \CommentTok{// called before Initialize(). Great spot for DI container wiring.}
\NormalTok{        AvaloniaLocator}\OperatorTok{.}\FunctionTok{CurrentMutable}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{\textless{}}\NormalTok{IMyService}\OperatorTok{\textgreater{}().}\FunctionTok{ToSingleton}\OperatorTok{\textless{}}\NormalTok{MyService}\OperatorTok{\textgreater{}();}
    \OperatorTok{\}}

    \KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ IClassicDesktopStyleApplicationLifetime desktop}\OperatorTok{)}
        \OperatorTok{\{}
\NormalTok{            desktop}\OperatorTok{.}\FunctionTok{MainWindow} \OperatorTok{=} \KeywordTok{new}\NormalTok{ MainWindow}
            \OperatorTok{\{}
\NormalTok{                DataContext }\OperatorTok{=} \KeywordTok{new} \FunctionTok{MainWindowViewModel}\OperatorTok{()}
            \OperatorTok{\};}
        \OperatorTok{\}}
        \KeywordTok{else} \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ ISingleViewApplicationLifetime singleView}\OperatorTok{)}
        \OperatorTok{\{}
\NormalTok{            singleView}\OperatorTok{.}\FunctionTok{MainView} \OperatorTok{=} \KeywordTok{new}\NormalTok{ HomeView}
            \OperatorTok{\{}
\NormalTok{                DataContext }\OperatorTok{=} \KeywordTok{new} \FunctionTok{HomeViewModel}\OperatorTok{()}
            \OperatorTok{\};}
        \OperatorTok{\}}

        \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{();}
    \OperatorTok{\}}

    \KeywordTok{private} \KeywordTok{static}\NormalTok{ Style }\FunctionTok{CreateButtonStyle}\OperatorTok{()}
        \OperatorTok{=\textgreater{}} \KeywordTok{new}\OperatorTok{(}\NormalTok{x }\OperatorTok{=\textgreater{}}\NormalTok{ x}\OperatorTok{.}\FunctionTok{OfType}\OperatorTok{\textless{}}\NormalTok{Button}\OperatorTok{\textgreater{}())}
        \OperatorTok{\{}
\NormalTok{            Setters }\OperatorTok{=}
            \OperatorTok{\{}
                \KeywordTok{new} \FunctionTok{Setter}\OperatorTok{(}\NormalTok{Button}\OperatorTok{.}\FunctionTok{CornerRadiusProperty}\OperatorTok{,} \KeywordTok{new} \FunctionTok{CornerRadius}\OperatorTok{(}\DecValTok{6}\OperatorTok{)),}
                \KeywordTok{new} \FunctionTok{Setter}\OperatorTok{(}\NormalTok{Button}\OperatorTok{.}\FunctionTok{PaddingProperty}\OperatorTok{,} \KeywordTok{new} \FunctionTok{Thickness}\OperatorTok{(}\DecValTok{16}\OperatorTok{,} \DecValTok{8}\OperatorTok{)),}
                \KeywordTok{new} \FunctionTok{Setter}\OperatorTok{(}\NormalTok{Button}\OperatorTok{.}\FunctionTok{ClassesProperty}\OperatorTok{,}\NormalTok{ Classes}\OperatorTok{.}\FunctionTok{Parse}\OperatorTok{(}\StringTok{"accent"}\OperatorTok{))}
            \OperatorTok{\}}
        \OperatorTok{\};}

    \KeywordTok{private} \KeywordTok{static}\NormalTok{ ResourceDictionary }\FunctionTok{CreateAppResources}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{return} \KeywordTok{new}\NormalTok{ ResourceDictionary}
        \OperatorTok{\{}
            \OperatorTok{[}\StringTok{"AccentBrush"}\OperatorTok{]} \OperatorTok{=} \KeywordTok{new} \FunctionTok{SolidColorBrush}\OperatorTok{(}\NormalTok{Color}\OperatorTok{.}\FunctionTok{Parse}\OperatorTok{(}\StringTok{"\#FF4F8EF7"}\OperatorTok{)),}
            \OperatorTok{[}\StringTok{"AccentForegroundBrush"}\OperatorTok{]} \OperatorTok{=}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{White}\OperatorTok{,}
            \OperatorTok{[}\StringTok{"BorderRadiusSmall"}\OperatorTok{]} \OperatorTok{=} \KeywordTok{new} \FunctionTok{CornerRadius}\OperatorTok{(}\DecValTok{4}\OperatorTok{)}
        \OperatorTok{\};}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Notes from source: - \texttt{Styles} is an
\texttt{IList\textless{}IStyle\textgreater{}} exposed by
\texttt{Application}. Clearing it ensures you start from a blank slate
(no default theme). Add \texttt{FluentTheme} or your own style tree. -
\texttt{StyleInclude} can still ingest axaml fragments---code-first
doesn't forbid XAML, it just avoids \texttt{Application.LoadComponent}.
- \texttt{RegisterServices()} is invoked early in
\texttt{AppBuilderBase\textless{}TApp\textgreater{}.Setup()} before the
app is instantiated. It's designed for code-first registration patterns.
- Always call \texttt{base.OnFrameworkInitializationCompleted()} to
ensure any registered \texttt{OnFrameworkInitializationCompleted}
handlers fire.

\subsection{3. Building windows and views directly in
C}\label{building-windows-and-views-directly-in-c}

When you skip XAML, every control tree is instantiated manually. You
can: - Derive from \texttt{Window}, \texttt{UserControl}, or
\texttt{ContentControl} and compose UI in the constructor. - Use factory
methods to build complex layouts. - Compose view-model bindings using
\texttt{Binding} objects or extension helpers.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ MainWindow }\OperatorTok{:}\NormalTok{ Window}
\OperatorTok{\{}
    \KeywordTok{public} \FunctionTok{MainWindow}\OperatorTok{()}
    \OperatorTok{\{}
\NormalTok{        Title }\OperatorTok{=} \StringTok{"Code{-}first Avalonia"}\OperatorTok{;}
\NormalTok{        Width }\OperatorTok{=} \DecValTok{800}\OperatorTok{;}
\NormalTok{        Height }\OperatorTok{=} \DecValTok{600}\OperatorTok{;}

\NormalTok{        Content }\OperatorTok{=} \FunctionTok{BuildLayout}\OperatorTok{();}
    \OperatorTok{\}}

    \KeywordTok{private} \KeywordTok{static}\NormalTok{ Control }\FunctionTok{BuildLayout}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{return} \KeywordTok{new}\NormalTok{ DockPanel}
        \OperatorTok{\{}
\NormalTok{            LastChildFill }\OperatorTok{=} \KeywordTok{true}\OperatorTok{,}
\NormalTok{            Children }\OperatorTok{=}
            \OperatorTok{\{}
                \FunctionTok{CreateHeader}\OperatorTok{(),}
                \FunctionTok{CreateBody}\OperatorTok{()}
            \OperatorTok{\}}
        \OperatorTok{\};}
    \OperatorTok{\}}

    \KeywordTok{private} \KeywordTok{static}\NormalTok{ Control }\FunctionTok{CreateHeader}\OperatorTok{()}
        \OperatorTok{=\textgreater{}} \KeywordTok{new}\NormalTok{ Border}
        \OperatorTok{\{}
\NormalTok{            Background }\OperatorTok{=} \OperatorTok{(}\NormalTok{IBrush}\OperatorTok{)}\NormalTok{Application}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{!.}\FunctionTok{Resources}\OperatorTok{[}\StringTok{"AccentBrush"}\OperatorTok{],}
\NormalTok{            Padding }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Thickness}\OperatorTok{(}\DecValTok{24}\OperatorTok{,} \DecValTok{16}\OperatorTok{),}
\NormalTok{            Child }\OperatorTok{=} \KeywordTok{new}\NormalTok{ TextBlock}
            \OperatorTok{\{}
\NormalTok{                Text }\OperatorTok{=} \StringTok{"Dashboard"}\OperatorTok{,}
\NormalTok{                FontSize }\OperatorTok{=} \DecValTok{22}\OperatorTok{,}
\NormalTok{                Foreground }\OperatorTok{=}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{White}\OperatorTok{,}
\NormalTok{                FontWeight }\OperatorTok{=}\NormalTok{ FontWeight}\OperatorTok{.}\FunctionTok{SemiBold}
            \OperatorTok{\}}
        \OperatorTok{\}.}\FunctionTok{DockTop}\OperatorTok{();}

    \KeywordTok{private} \KeywordTok{static}\NormalTok{ Control }\FunctionTok{CreateBody}\OperatorTok{()}
        \OperatorTok{=\textgreater{}} \KeywordTok{new}\NormalTok{ StackPanel}
        \OperatorTok{\{}
\NormalTok{            Margin }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Thickness}\OperatorTok{(}\DecValTok{24}\OperatorTok{),}
\NormalTok{            Spacing }\OperatorTok{=} \DecValTok{16}\OperatorTok{,}
\NormalTok{            Children }\OperatorTok{=}
            \OperatorTok{\{}
                \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Text }\OperatorTok{=} \StringTok{"Welcome!"}\OperatorTok{,}\NormalTok{ FontSize }\OperatorTok{=} \DecValTok{18} \OperatorTok{\},}
                \KeywordTok{new}\NormalTok{ Button}
                \OperatorTok{\{}
\NormalTok{                    Content }\OperatorTok{=} \StringTok{"Refresh"}\OperatorTok{,}
\NormalTok{                    Command }\OperatorTok{=}\NormalTok{ ReactiveCommand}\OperatorTok{.}\FunctionTok{Create}\OperatorTok{(()} \OperatorTok{=\textgreater{}}\NormalTok{ Debug}\OperatorTok{.}\FunctionTok{WriteLine}\OperatorTok{(}\StringTok{"Refresh requested"}\OperatorTok{))}
                \OperatorTok{\}}
            \OperatorTok{\}}
        \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Helper extension methods keep layout code tidy. You can author them in a
static class:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ DockPanelExtensions}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ T DockTop}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{\textgreater{}(}\KeywordTok{this}\NormalTok{ T control}\OperatorTok{)}\NormalTok{ where T }\OperatorTok{:}\NormalTok{ Control}
    \OperatorTok{\{}
\NormalTok{        DockPanel}\OperatorTok{.}\FunctionTok{SetDock}\OperatorTok{(}\NormalTok{control}\OperatorTok{,}\NormalTok{ Dock}\OperatorTok{.}\FunctionTok{Top}\OperatorTok{);}
        \KeywordTok{return}\NormalTok{ control}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Because you're constructing controls in code, you can register them with
the \texttt{NameScope} for later lookup:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ scope }\OperatorTok{=} \KeywordTok{new} \FunctionTok{NameScope}\OperatorTok{();}
\NormalTok{NameScope}\OperatorTok{.}\FunctionTok{SetNameScope}\OperatorTok{(}\KeywordTok{this}\OperatorTok{,}\NormalTok{ scope}\OperatorTok{);}

\DataTypeTok{var}\NormalTok{ statusText }\OperatorTok{=} \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Text }\OperatorTok{=} \StringTok{"Idle"} \OperatorTok{\};}
\NormalTok{scope}\OperatorTok{.}\FunctionTok{Register}\OperatorTok{(}\StringTok{"StatusText"}\OperatorTok{,}\NormalTok{ statusText}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

This matches \texttt{NameScope} behaviour from XAML (see
\texttt{external/Avalonia/src/Avalonia.Base/LogicalTree/NameScope.cs}).

\subsection{4. Binding, commands, and services without markup
extensions}\label{binding-commands-and-services-without-markup-extensions}

Code-first projects rely on the same binding engine, but you create
bindings manually or use compiled binding helpers.

\subsubsection{Creating bindings
programmatically}\label{creating-bindings-programmatically}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ textBox }\OperatorTok{=} \KeywordTok{new} \FunctionTok{TextBox}\OperatorTok{();}
\NormalTok{textBox}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{TextBox}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\StringTok{"Query"}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    Mode }\OperatorTok{=}\NormalTok{ BindingMode}\OperatorTok{.}\FunctionTok{TwoWay}\OperatorTok{,}
\NormalTok{    UpdateSourceTrigger }\OperatorTok{=}\NormalTok{ UpdateSourceTrigger}\OperatorTok{.}\FunctionTok{PropertyChanged}\OperatorTok{,}
\NormalTok{    ValidatesOnDataErrors }\OperatorTok{=} \KeywordTok{true}
\OperatorTok{\});}

\DataTypeTok{var}\NormalTok{ searchButton }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Button}
\OperatorTok{\{}
\NormalTok{    Content }\OperatorTok{=} \StringTok{"Search"}
\OperatorTok{\};}
\NormalTok{searchButton}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{Button}\OperatorTok{.}\FunctionTok{CommandProperty}\OperatorTok{,} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\StringTok{"SearchCommand"}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

\texttt{Binding} lives in
\texttt{external/Avalonia/src/Avalonia.Base/Data/Binding.cs}. Anything
you can express via \texttt{\{Binding\}} markup is available as
properties on this class. For compiled bindings, use
\texttt{CompiledBindingFactory} from \texttt{Avalonia.Data.Core}
directly:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ factory }\OperatorTok{=} \KeywordTok{new} \FunctionTok{CompiledBindingFactory}\OperatorTok{();}
\DataTypeTok{var}\NormalTok{ compiled }\OperatorTok{=}\NormalTok{ factory}\OperatorTok{.}\FunctionTok{Create}\OperatorTok{\textless{}}\DataTypeTok{object}\OperatorTok{,} \DataTypeTok{string}\OperatorTok{\textgreater{}(}
\NormalTok{    vmGetter}\OperatorTok{:} \KeywordTok{static}\NormalTok{ vm }\OperatorTok{=\textgreater{}} \OperatorTok{((}\NormalTok{SearchViewModel}\OperatorTok{)}\NormalTok{vm}\OperatorTok{).}\FunctionTok{Query}\OperatorTok{,}
\NormalTok{    vmSetter}\OperatorTok{:} \KeywordTok{static} \OperatorTok{(}\NormalTok{vm}\OperatorTok{,}\NormalTok{ value}\OperatorTok{)} \OperatorTok{=\textgreater{}} \OperatorTok{((}\NormalTok{SearchViewModel}\OperatorTok{)}\NormalTok{vm}\OperatorTok{).}\FunctionTok{Query} \OperatorTok{=}\NormalTok{ value}\OperatorTok{,}
\NormalTok{    name}\OperatorTok{:} \FunctionTok{nameof}\OperatorTok{(}\NormalTok{SearchViewModel}\OperatorTok{.}\FunctionTok{Query}\OperatorTok{),}
\NormalTok{    mode}\OperatorTok{:}\NormalTok{ BindingMode}\OperatorTok{.}\FunctionTok{TwoWay}\OperatorTok{);}

\NormalTok{textBox}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{TextBox}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,}\NormalTok{ compiled}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Services and dependency
injection}\label{services-and-dependency-injection}

Use \texttt{AvaloniaLocator.CurrentMutable} (defined in
\texttt{Application.RegisterServices}) to register services. For richer
DI, integrate libraries like
\texttt{Microsoft.Extensions.DependencyInjection}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{RegisterServices}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ services }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ServiceCollection}\OperatorTok{();}
\NormalTok{    services}\OperatorTok{.}\FunctionTok{AddSingleton}\OperatorTok{\textless{}}\NormalTok{IMyService}\OperatorTok{,}\NormalTok{ MyService}\OperatorTok{\textgreater{}();}
\NormalTok{    services}\OperatorTok{.}\FunctionTok{AddSingleton}\OperatorTok{\textless{}}\NormalTok{HomeViewModel}\OperatorTok{\textgreater{}();}

    \DataTypeTok{var}\NormalTok{ provider }\OperatorTok{=}\NormalTok{ services}\OperatorTok{.}\FunctionTok{BuildServiceProvider}\OperatorTok{();}

\NormalTok{    AvaloniaLocator}\OperatorTok{.}\FunctionTok{CurrentMutable}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{\textless{}}\NormalTok{IMyService}\OperatorTok{\textgreater{}().}\FunctionTok{ToSingleton}\OperatorTok{(()} \OperatorTok{=\textgreater{}}\NormalTok{ provider}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{IMyService}\OperatorTok{\textgreater{}());}
\NormalTok{    AvaloniaLocator}\OperatorTok{.}\FunctionTok{CurrentMutable}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{\textless{}}\NormalTok{HomeViewModel}\OperatorTok{\textgreater{}().}\FunctionTok{ToTransient}\OperatorTok{(()} \OperatorTok{=\textgreater{}}\NormalTok{ provider}\OperatorTok{.}\FunctionTok{GetRequiredService}\OperatorTok{\textless{}}\NormalTok{HomeViewModel}\OperatorTok{\textgreater{}());}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Later, resolve services via
\texttt{AvaloniaLocator.Current.GetService\textless{}HomeViewModel\textgreater{}()}
or inject them into controls. Because \texttt{RegisterServices} runs
before \texttt{Initialize}, you can use registered services while
building resources.

\subsection{5. Theming, resources, and modular
structure}\label{theming-resources-and-modular-structure}

Code-first theming revolves around \texttt{ResourceDictionary},
\texttt{Styles}, and \texttt{StyleInclude}.

\subsubsection{Centralize app resources}\label{centralize-app-resources}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private} \KeywordTok{static}\NormalTok{ ResourceDictionary }\FunctionTok{CreateAppResources}\OperatorTok{()}
\OperatorTok{\{}
    \KeywordTok{return} \KeywordTok{new}\NormalTok{ ResourceDictionary}
    \OperatorTok{\{}
\NormalTok{        MergedDictionaries }\OperatorTok{=}
        \OperatorTok{\{}
            \KeywordTok{new}\NormalTok{ ResourceDictionary}
            \OperatorTok{\{}
                \OperatorTok{[}\StringTok{"Spacing.Small"}\OperatorTok{]} \OperatorTok{=} \FloatTok{4.0}\OperatorTok{,}
                \OperatorTok{[}\StringTok{"Spacing.Medium"}\OperatorTok{]} \OperatorTok{=} \FloatTok{12.0}\OperatorTok{,}
                \OperatorTok{[}\StringTok{"Spacing.Large"}\OperatorTok{]} \OperatorTok{=} \FloatTok{24.0}
            \OperatorTok{\}}
        \OperatorTok{\},}
        \OperatorTok{[}\StringTok{"AccentBrush"}\OperatorTok{]} \OperatorTok{=}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{CornflowerBlue}\OperatorTok{,}
        \OperatorTok{[}\StringTok{"AccentForegroundBrush"}\OperatorTok{]} \OperatorTok{=}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{White}
    \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Use namespaced keys (\texttt{Spacing.Medium}) to avoid collisions. If
you rely on resizable themes, store them in a dedicated class:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ AppTheme}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ Styles Light }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\NormalTok{ Styles}
    \OperatorTok{\{}
        \KeywordTok{new}\NormalTok{ FluentTheme }\OperatorTok{\{}\NormalTok{ Mode }\OperatorTok{=}\NormalTok{ FluentThemeMode}\OperatorTok{.}\FunctionTok{Light} \OperatorTok{\},}
        \FunctionTok{CreateSharedStyles}\OperatorTok{()}
    \OperatorTok{\};}

    \KeywordTok{public} \KeywordTok{static}\NormalTok{ Styles Dark }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\NormalTok{ Styles}
    \OperatorTok{\{}
        \KeywordTok{new}\NormalTok{ FluentTheme }\OperatorTok{\{}\NormalTok{ Mode }\OperatorTok{=}\NormalTok{ FluentThemeMode}\OperatorTok{.}\FunctionTok{Dark} \OperatorTok{\},}
        \FunctionTok{CreateSharedStyles}\OperatorTok{()}
    \OperatorTok{\};}

    \KeywordTok{private} \KeywordTok{static}\NormalTok{ Styles }\FunctionTok{CreateSharedStyles}\OperatorTok{()}
        \OperatorTok{=\textgreater{}} \KeywordTok{new}\NormalTok{ Styles}
        \OperatorTok{\{}
            \KeywordTok{new} \FunctionTok{Style}\OperatorTok{(}\NormalTok{x }\OperatorTok{=\textgreater{}}\NormalTok{ x}\OperatorTok{.}\FunctionTok{OfType}\OperatorTok{\textless{}}\NormalTok{Window}\OperatorTok{\textgreater{}())}
            \OperatorTok{\{}
\NormalTok{                Setters }\OperatorTok{=}
                \OperatorTok{\{}
                    \KeywordTok{new} \FunctionTok{Setter}\OperatorTok{(}\NormalTok{Window}\OperatorTok{.}\FunctionTok{BackgroundProperty}\OperatorTok{,}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{Transparent}\OperatorTok{)}
                \OperatorTok{\}}
            \OperatorTok{\}}
        \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Switch themes at runtime:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \DataTypeTok{void} \FunctionTok{UseDarkTheme}\OperatorTok{()}
\OperatorTok{\{}
\NormalTok{    Application}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{!.}\FunctionTok{Styles}\OperatorTok{.}\FunctionTok{Clear}\OperatorTok{();}
    \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ style }\KeywordTok{in}\NormalTok{ AppTheme}\OperatorTok{.}\FunctionTok{Dark}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        Application}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{.}\FunctionTok{Styles}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{style}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Iterate the collection when swapping themes---\texttt{Styles} implements
\texttt{IEnumerable\textless{}IStyle\textgreater{}} so a simple
\texttt{foreach} keeps dependencies minimal. Remember to freeze brushes
(\texttt{Brushes.Transparent} is already frozen) when reusing them to
avoid unnecessary allocations.

\subsubsection{Organize modules by
feature}\label{organize-modules-by-feature}

A common pattern is to place each feature in its own namespace with: - A
factory method returning a \texttt{Control} (for pure code) or a partial
class if you mix \texttt{.axaml} for templates. - A \texttt{ViewModel}
class registered via DI. - Optional
\texttt{IStyle}/\texttt{ResourceDictionary} definitions encapsulated in
static classes.

Example folder layout:

\begin{verbatim}
src/
  Infrastructure/
    Services/
    Styles/
  Features/
    Dashboard/
      DashboardView.cs
      DashboardViewModel.cs
      DashboardStyles.cs
    Settings/
      SettingsView.cs
      SettingsViewModel.cs
\end{verbatim}

\texttt{DashboardStyles} might expose a \texttt{Styles} property you
merge into \texttt{Application.Styles}. Keep style/helper definitions
close to the controls they customize to maintain cohesion.

\subsection{6. Migrating from XAML to
code-first}\label{migrating-from-xaml-to-code-first}

To convert an existing XAML-based app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Copy property settings}: For each control, move attribute
  values into constructors or object initializers. Attached properties
  map to static setters (\texttt{Grid.SetColumn(button,\ 1)}).
\item
  \textbf{Convert bindings}: Replace \texttt{\{Binding\}} with
  \texttt{control.Bind(Property,\ new\ Binding("Path"))}. For
  \texttt{ElementName} references, call \texttt{NameScope.Register} and
  \texttt{FindControl}.
\item
  \textbf{Transform styles}: Use
  \texttt{new\ Style(x\ =\textgreater{}\ x.OfType\textless{}Button\textgreater{}().Class("accent"))}
  for selectors. Set \texttt{Setters} to match
  \texttt{\textless{}Setter\textgreater{}} elements.
\item
  \textbf{Load templates}: Where XAML used
  \texttt{\textless{}ControlTemplate\textgreater{}}, build
  \texttt{FuncControlTemplate}. The constructor signature matches the
  control type and returns the template content.
\item
  \textbf{Merge resources}: Replace
  \texttt{\textless{}ResourceDictionary.MergedDictionaries\textgreater{}}
  with \texttt{ResourceDictionary.MergedDictionaries.Add(...)}.
\item
  \textbf{Replace markup extensions}: Many map to APIs
  (\texttt{DynamicResource} → \texttt{DynamicResourceBindingExtensions},
  \texttt{StaticResource} → dictionary lookup). For \texttt{OnPlatform}
  or \texttt{OnFormFactor}, implement custom helper methods that return
  values based on \texttt{RuntimeInformation}.
\end{enumerate}

Testing after each step keeps parity. Avalonia DevTools still works with
code-first UI, so inspect logical/visual trees to confirm bindings and
styles resolved correctly.

\subsection{7. Practice lab}\label{practice-lab}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{From template to C\#} -- Scaffold a standard Avalonia MVVM
  template, then delete \texttt{App.axaml} and
  \texttt{MainWindow.axaml}. Recreate them as classes mirroring their
  original layout using C\# object initializers. Verify styles,
  resources, and data bindings behave identically using DevTools.
\item
  \textbf{Theme switcher} -- Implement light/dark \texttt{Styles} groups
  in code. Add a toggle button that swaps
  \texttt{Application.Current.Styles} and persists the choice using your
  service layer.
\item
  \textbf{DI-first startup} -- Register services in
  \texttt{RegisterServices()} using your preferred container. Resolve
  view-models in \texttt{OnFrameworkInitializationCompleted} rather than
  \texttt{new}, ensuring the container owns lifetimes.
\item
  \textbf{Factory-based navigation} -- Build a code-first navigation
  shell where pages are created via factories
  (\texttt{Func\textless{}Control\textgreater{}}). Inject factories
  through DI and demonstrate a plugin module adding new pages without
  touching XAML.
\item
  \textbf{Headless smoke test} -- Pair with Chapter 38 by writing a
  headless unit test that spins up your code-first app, navigates to a
  view, and asserts control properties to guarantee the code-only tree
  is intact.
\end{enumerate}

By mastering these patterns you gain confidence that Avalonia's
internals don't require XAML. The framework's property system, theming
engine, and lifetimes remain fully accessible from C\#, letting teams
tailor architecture to their tooling and review preferences.

What's next - Next: \href{Chapter34.md}{Chapter34}

\newpage

\subsection{34. Layouts and controls authored in pure
C}\label{layouts-and-controls-authored-in-pure-c}

Goal - Compose Avalonia visual trees entirely in code using layout
containers, attached properties, and fluent helpers. - Understand how
\texttt{AvaloniaObject} APIs (\texttt{SetValue},
\texttt{SetCurrentValue}, observers) replace attribute syntax when you
skip XAML. - Build reusable factory methods and extension helpers that
keep code-generated UI readable and testable.

Why this matters - Code-first teams still need the full power of
Avalonia's layout system: panels, attached properties, and templated
controls all live in namespaces you can reach from C\#. - Explicit
property APIs make dynamic UI safer---no magic strings or runtime
parsing, just compile-time members and analyzers. - Once you see how to
structure factories and name scopes, you can generate UI from data,
plug-ins, or source generators without sacrificing maintainability.

Prerequisites - Chapter 7 (styles) for context on how styles interact
with control trees. - Chapter 9 (input) if you plan to attach event
handlers in code-behind. - Chapter 33 (code-first startup) for
application scaffolding and DI patterns.

\subsection{\texorpdfstring{1. Layout primitives in code:
\texttt{StackPanel}, \texttt{Grid},
\texttt{DockPanel}}{1. Layout primitives in code: StackPanel, Grid, DockPanel}}\label{layout-primitives-in-code-stackpanel-grid-dockpanel}

Avalonia's panels live in
\texttt{external/Avalonia/src/Avalonia.Controls/}. Construct them
exactly as you would in XAML, but populate \texttt{Children} and set
properties directly.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ layout }\OperatorTok{=} \KeywordTok{new}\NormalTok{ StackPanel}
\OperatorTok{\{}
\NormalTok{    Orientation }\OperatorTok{=}\NormalTok{ Orientation}\OperatorTok{.}\FunctionTok{Vertical}\OperatorTok{,}
\NormalTok{    Spacing }\OperatorTok{=} \DecValTok{12}\OperatorTok{,}
\NormalTok{    Margin }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Thickness}\OperatorTok{(}\DecValTok{24}\OperatorTok{),}
\NormalTok{    Children }\OperatorTok{=}
    \OperatorTok{\{}
        \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Text }\OperatorTok{=} \StringTok{"Customer"} \OperatorTok{\},}
        \KeywordTok{new}\NormalTok{ TextBox }\OperatorTok{\{}\NormalTok{ Watermark }\OperatorTok{=} \StringTok{"Name"} \OperatorTok{\},}
        \KeywordTok{new}\NormalTok{ TextBox }\OperatorTok{\{}\NormalTok{ Watermark }\OperatorTok{=} \StringTok{"Email"} \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

\texttt{StackPanel}'s measure logic (see \texttt{StackPanel.cs})
respects \texttt{Spacing} and \texttt{Orientation}. Because you're in
code, you can wrap control creation in helper methods to keep
constructors clean:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{private} \KeywordTok{static}\NormalTok{ TextBox }\FunctionTok{CreateLabeledInput}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ label}\OperatorTok{,} \KeywordTok{out}\NormalTok{ TextBlock caption}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    caption }\OperatorTok{=} \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Text }\OperatorTok{=}\NormalTok{ label}\OperatorTok{,}\NormalTok{ FontWeight }\OperatorTok{=}\NormalTok{ FontWeight}\OperatorTok{.}\FunctionTok{SemiBold} \OperatorTok{\};}
    \KeywordTok{return} \KeywordTok{new}\NormalTok{ TextBox }\OperatorTok{\{}\NormalTok{ Margin }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Thickness}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{16}\OperatorTok{)} \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Grids without XAML
strings}\label{grids-without-xaml-strings}

\texttt{Grid} exposes \texttt{RowDefinitions}/\texttt{ColumnDefinitions}
collections of \texttt{RowDefinition}/\texttt{ColumnDefinition}. You add
definitions and set attached properties programmatically.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ grid }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Grid}
\OperatorTok{\{}
\NormalTok{    ColumnDefinitions }\OperatorTok{=}
    \OperatorTok{\{}
        \KeywordTok{new} \FunctionTok{ColumnDefinition}\OperatorTok{(}\NormalTok{GridLength}\OperatorTok{.}\FunctionTok{Auto}\OperatorTok{),}
        \KeywordTok{new} \FunctionTok{ColumnDefinition}\OperatorTok{(}\NormalTok{GridLength}\OperatorTok{.}\FunctionTok{Star}\OperatorTok{)}
    \OperatorTok{\},}
\NormalTok{    RowDefinitions }\OperatorTok{=}
    \OperatorTok{\{}
        \KeywordTok{new} \FunctionTok{RowDefinition}\OperatorTok{(}\NormalTok{GridLength}\OperatorTok{.}\FunctionTok{Auto}\OperatorTok{),}
        \KeywordTok{new} \FunctionTok{RowDefinition}\OperatorTok{(}\NormalTok{GridLength}\OperatorTok{.}\FunctionTok{Auto}\OperatorTok{),}
        \KeywordTok{new} \FunctionTok{RowDefinition}\OperatorTok{(}\NormalTok{GridLength}\OperatorTok{.}\FunctionTok{Star}\OperatorTok{)}
    \OperatorTok{\}}
\OperatorTok{\};}

\DataTypeTok{var}\NormalTok{ title }\OperatorTok{=} \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Text }\OperatorTok{=} \StringTok{"Orders"}\OperatorTok{,}\NormalTok{ FontSize }\OperatorTok{=} \DecValTok{22} \OperatorTok{\};} 
\NormalTok{Grid}\OperatorTok{.}\FunctionTok{SetColumnSpan}\OperatorTok{(}\NormalTok{title}\OperatorTok{,} \DecValTok{2}\OperatorTok{);}
\NormalTok{grid}\OperatorTok{.}\FunctionTok{Children}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{title}\OperatorTok{);}

\DataTypeTok{var}\NormalTok{ filterLabel }\OperatorTok{=} \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Text }\OperatorTok{=} \StringTok{"Status"} \OperatorTok{\};}
\NormalTok{Grid}\OperatorTok{.}\FunctionTok{SetRow}\OperatorTok{(}\NormalTok{filterLabel}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
\NormalTok{Grid}\OperatorTok{.}\FunctionTok{SetColumn}\OperatorTok{(}\NormalTok{filterLabel}\OperatorTok{,} \DecValTok{0}\OperatorTok{);}
\NormalTok{grid}\OperatorTok{.}\FunctionTok{Children}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{filterLabel}\OperatorTok{);}

\DataTypeTok{var}\NormalTok{ filterBox }\OperatorTok{=} \KeywordTok{new}\NormalTok{ ComboBox }\OperatorTok{\{}\NormalTok{ Items }\OperatorTok{=}\NormalTok{ Enum}\OperatorTok{.}\FunctionTok{GetValues}\OperatorTok{\textless{}}\NormalTok{OrderStatus}\OperatorTok{\textgreater{}()} \OperatorTok{\};}
\NormalTok{Grid}\OperatorTok{.}\FunctionTok{SetRow}\OperatorTok{(}\NormalTok{filterBox}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
\NormalTok{Grid}\OperatorTok{.}\FunctionTok{SetColumn}\OperatorTok{(}\NormalTok{filterBox}\OperatorTok{,} \DecValTok{1}\OperatorTok{);}
\NormalTok{grid}\OperatorTok{.}\FunctionTok{Children}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{filterBox}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Attached property methods (\texttt{Grid.SetRow},
\texttt{Grid.SetColumnSpan}) are static for clarity. Because they
ultimately call \texttt{AvaloniaObject.SetValue}, you can wrap them in
fluent helpers if you prefer chaining (example later in section 3).

\subsubsection{Dock layouts and last-child
filling}\label{dock-layouts-and-last-child-filling}

\texttt{DockPanel} (source: \texttt{DockPanel.cs}) uses the
\texttt{Dock} attached property. From code you set it with
\texttt{DockPanel.SetDock(control,\ Dock.Left)}.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ dock }\OperatorTok{=} \KeywordTok{new}\NormalTok{ DockPanel}
\OperatorTok{\{}
\NormalTok{    LastChildFill }\OperatorTok{=} \KeywordTok{true}\OperatorTok{,}
\NormalTok{    Children }\OperatorTok{=}
    \OperatorTok{\{}
        \FunctionTok{CreateSidebar}\OperatorTok{().}\FunctionTok{DockLeft}\OperatorTok{(),}
        \FunctionTok{CreateFooter}\OperatorTok{().}\FunctionTok{DockBottom}\OperatorTok{(),}
        \FunctionTok{CreateMainRegion}\OperatorTok{()}
    \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Implement \texttt{DockLeft()} as an extension to keep code terse:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ DockExtensions}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ T DockLeft}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{\textgreater{}(}\KeywordTok{this}\NormalTok{ T control}\OperatorTok{)}\NormalTok{ where T }\OperatorTok{:}\NormalTok{ Control}
    \OperatorTok{\{}
\NormalTok{        DockPanel}\OperatorTok{.}\FunctionTok{SetDock}\OperatorTok{(}\NormalTok{control}\OperatorTok{,}\NormalTok{ Dock}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}
        \KeywordTok{return}\NormalTok{ control}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{public} \KeywordTok{static}\NormalTok{ T DockBottom}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{\textgreater{}(}\KeywordTok{this}\NormalTok{ T control}\OperatorTok{)}\NormalTok{ where T }\OperatorTok{:}\NormalTok{ Control}
    \OperatorTok{\{}
\NormalTok{        DockPanel}\OperatorTok{.}\FunctionTok{SetDock}\OperatorTok{(}\NormalTok{control}\OperatorTok{,}\NormalTok{ Dock}\OperatorTok{.}\FunctionTok{Bottom}\OperatorTok{);}
        \KeywordTok{return}\NormalTok{ control}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

You own these helpers, so you can tailor them for your team's
conventions (dock with margins, apply classes, etc.).

\subsection{\texorpdfstring{2. Working with the property system:
\texttt{SetValue}, \texttt{SetCurrentValue},
observers}{2. Working with the property system: SetValue, SetCurrentValue, observers}}\label{working-with-the-property-system-setvalue-setcurrentvalue-observers}

Without XAML attribute syntax you interact with
\texttt{AvaloniaProperty} APIs directly. Every control inherits from
\texttt{AvaloniaObject} (\texttt{AvaloniaObject.cs}), which exposes:

\begin{itemize}
\tightlist
\item
  \texttt{SetValue(AvaloniaProperty\ property,\ object?\ value)} -- sets
  the property locally, raising change notifications and affecting
  bindings.
\item
  \texttt{SetCurrentValue(AvaloniaProperty\ property,\ object?\ value)}
  -- updates the effective value but preserves existing
  bindings/animations (great for programmatic defaults).
\item
  \texttt{GetObservable\textless{}T\textgreater{}(AvaloniaProperty\textless{}T\textgreater{})}
  -- returns an \texttt{IObservable\textless{}T?\textgreater{}} when you
  need to react to changes.
\end{itemize}

Example: highlight focused text boxes by toggling a pseudo-class while
keeping bindings intact.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ box }\OperatorTok{=} \KeywordTok{new} \FunctionTok{TextBox}\OperatorTok{();}
\NormalTok{box}\OperatorTok{.}\FunctionTok{GotFocus} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ box}\OperatorTok{.}\FunctionTok{PseudoClasses}\OperatorTok{.}\FunctionTok{Set}\OperatorTok{(}\StringTok{":focused"}\OperatorTok{,} \KeywordTok{true}\OperatorTok{);}
\NormalTok{box}\OperatorTok{.}\FunctionTok{LostFocus} \OperatorTok{+=} \OperatorTok{(}\NormalTok{\_}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ box}\OperatorTok{.}\FunctionTok{PseudoClasses}\OperatorTok{.}\FunctionTok{Set}\OperatorTok{(}\StringTok{":focused"}\OperatorTok{,} \KeywordTok{false}\OperatorTok{);}

\CommentTok{// Provide a default width but leave bindings alone}
\NormalTok{box}\OperatorTok{.}\FunctionTok{SetCurrentValue}\OperatorTok{(}\NormalTok{TextBox}\OperatorTok{.}\FunctionTok{WidthProperty}\OperatorTok{,} \DecValTok{240}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

To wire property observers, use \texttt{GetObservable} or
\texttt{GetPropertyChangedObservable} (for any property change):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{box}\OperatorTok{.}\FunctionTok{GetObservable}\OperatorTok{(}\NormalTok{TextBox}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{)}
   \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{text }\OperatorTok{=\textgreater{}}\NormalTok{ \_logger}\OperatorTok{.}\FunctionTok{Information}\OperatorTok{(}\StringTok{"Text changed to \{Text\}"}\OperatorTok{,}\NormalTok{ text}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

\texttt{GetObservable} is defined in \texttt{AvaloniaObject}. Remember
to dispose subscriptions when controls leave the tree---store
\texttt{IDisposable} tokens and call \texttt{Dispose} in your control's
\texttt{DetachedFromVisualTree} handler.

\subsubsection{Creating reusable property
helpers}\label{creating-reusable-property-helpers}

When repeating property patterns, encapsulate them:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ ControlHelpers}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ T WithMargin}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{\textgreater{}(}\KeywordTok{this}\NormalTok{ T control}\OperatorTok{,}\NormalTok{ Thickness margin}\OperatorTok{)}\NormalTok{ where T }\OperatorTok{:}\NormalTok{ Control}
    \OperatorTok{\{}
\NormalTok{        control}\OperatorTok{.}\FunctionTok{Margin} \OperatorTok{=}\NormalTok{ margin}\OperatorTok{;}
        \KeywordTok{return}\NormalTok{ control}\OperatorTok{;}
    \OperatorTok{\}}

    \KeywordTok{public} \KeywordTok{static}\NormalTok{ T Bind}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{,}\NormalTok{ TValue}\OperatorTok{\textgreater{}(}\KeywordTok{this}\NormalTok{ T control}\OperatorTok{,}\NormalTok{ AvaloniaProperty}\OperatorTok{\textless{}}\NormalTok{TValue}\OperatorTok{\textgreater{}}\NormalTok{ property}\OperatorTok{,}\NormalTok{ IBinding binding}\OperatorTok{)}
\NormalTok{        where T }\OperatorTok{:}\NormalTok{ AvaloniaObject}
    \OperatorTok{\{}
\NormalTok{        control}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{property}\OperatorTok{,}\NormalTok{ binding}\OperatorTok{);}
        \KeywordTok{return}\NormalTok{ control}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

These mirror markup extensions in code, making complex layouts more
declarative.

\subsection{3. Factories, builders, and fluent
composition}\label{factories-builders-and-fluent-composition}

Large code-first views benefit from factory methods that return
configured controls. Compose factories from smaller functions to keep
logic readable.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ DashboardViewFactory}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ Control }\FunctionTok{Create}\OperatorTok{(}\NormalTok{IDashboardViewModel vm}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{return} \KeywordTok{new}\NormalTok{ Grid}
        \OperatorTok{\{}
\NormalTok{            ColumnDefinitions }\OperatorTok{=}
            \OperatorTok{\{}
                \KeywordTok{new} \FunctionTok{ColumnDefinition}\OperatorTok{(}\NormalTok{GridLength}\OperatorTok{.}\FunctionTok{Star}\OperatorTok{),}
                \KeywordTok{new} \FunctionTok{ColumnDefinition}\OperatorTok{(}\NormalTok{GridLength}\OperatorTok{.}\FunctionTok{Star}\OperatorTok{)}
            \OperatorTok{\},}
\NormalTok{            Children }\OperatorTok{=}
            \OperatorTok{\{}
                \FunctionTok{CreateSummary}\OperatorTok{(}\NormalTok{vm}\OperatorTok{).}\FunctionTok{WithGridPosition}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{),}
                \FunctionTok{CreateChart}\OperatorTok{(}\NormalTok{vm}\OperatorTok{).}\FunctionTok{WithGridPosition}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{1}\OperatorTok{)}
            \OperatorTok{\}}
        \OperatorTok{\};}
    \OperatorTok{\}}

    \KeywordTok{private} \KeywordTok{static}\NormalTok{ Control }\FunctionTok{CreateSummary}\OperatorTok{(}\NormalTok{IDashboardViewModel vm}\OperatorTok{)}
        \OperatorTok{=\textgreater{}} \KeywordTok{new}\NormalTok{ Border}
        \OperatorTok{\{}
\NormalTok{            Padding }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Thickness}\OperatorTok{(}\DecValTok{24}\OperatorTok{),}
\NormalTok{            Child }\OperatorTok{=} \KeywordTok{new} \FunctionTok{TextBlock}\OperatorTok{().}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{TextBlock}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{vm}\OperatorTok{.}\FunctionTok{TotalSales}\OperatorTok{)))}
        \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{WithGridPosition} is a fluent helper you define:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ GridExtensions}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ T WithGridPosition}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{\textgreater{}(}\KeywordTok{this}\NormalTok{ T element}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ row}\OperatorTok{,} \DataTypeTok{int}\NormalTok{ column}\OperatorTok{)}\NormalTok{ where T }\OperatorTok{:}\NormalTok{ Control}
    \OperatorTok{\{}
\NormalTok{        Grid}\OperatorTok{.}\FunctionTok{SetRow}\OperatorTok{(}\NormalTok{element}\OperatorTok{,}\NormalTok{ row}\OperatorTok{);}
\NormalTok{        Grid}\OperatorTok{.}\FunctionTok{SetColumn}\OperatorTok{(}\NormalTok{element}\OperatorTok{,}\NormalTok{ column}\OperatorTok{);}
        \KeywordTok{return}\NormalTok{ element}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This approach keeps UI declarations near data bindings, reducing mental
overhead for reviewers.

\subsubsection{Repeating structures via LINQ or
loops}\label{repeating-structures-via-linq-or-loops}

Because you're in C\#, generate children dynamically:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ cards }\OperatorTok{=}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{Notifications}\OperatorTok{.}\FunctionTok{Select}\OperatorTok{((}\NormalTok{item}\OperatorTok{,}\NormalTok{ index}\OperatorTok{)} \OperatorTok{=\textgreater{}}
    \FunctionTok{CreateNotificationCard}\OperatorTok{(}\NormalTok{item}\OperatorTok{).}\FunctionTok{WithGridPosition}\OperatorTok{(}\NormalTok{index }\OperatorTok{/} \DecValTok{3}\OperatorTok{,}\NormalTok{ index }\OperatorTok{\%} \DecValTok{3}\OperatorTok{));}

\DataTypeTok{var}\NormalTok{ grid }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Grid}
\OperatorTok{\{}
\NormalTok{    ColumnDefinitions }\OperatorTok{=} \OperatorTok{\{} \KeywordTok{new} \FunctionTok{ColumnDefinition}\OperatorTok{(}\NormalTok{GridLength}\OperatorTok{.}\FunctionTok{Star}\OperatorTok{),} \KeywordTok{new} \FunctionTok{ColumnDefinition}\OperatorTok{(}\NormalTok{GridLength}\OperatorTok{.}\FunctionTok{Star}\OperatorTok{),} \KeywordTok{new} \FunctionTok{ColumnDefinition}\OperatorTok{(}\NormalTok{GridLength}\OperatorTok{.}\FunctionTok{Star}\OperatorTok{)} \OperatorTok{\}}
\OperatorTok{\};}

\KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ card }\KeywordTok{in}\NormalTok{ cards}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    grid}\OperatorTok{.}\FunctionTok{Children}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{card}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{Grid} measure logic handles dynamic counts; just ensure
\texttt{RowDefinitions} fits the generated children (add rows as needed
or rely on \texttt{GridLength.Auto}).

\subsubsection{Sharing styles between
factories}\label{sharing-styles-between-factories}

Factories can return both controls and supporting \texttt{Styles}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static}\NormalTok{ Styles DashboardStyles }\OperatorTok{\{} \KeywordTok{get}\OperatorTok{;} \OperatorTok{\}} \OperatorTok{=} \KeywordTok{new}\NormalTok{ Styles}
\OperatorTok{\{}
    \KeywordTok{new} \FunctionTok{Style}\OperatorTok{(}\NormalTok{x }\OperatorTok{=\textgreater{}}\NormalTok{ x}\OperatorTok{.}\FunctionTok{OfType}\OperatorTok{\textless{}}\NormalTok{TextBlock}\OperatorTok{\textgreater{}().}\FunctionTok{Class}\OperatorTok{(}\StringTok{"section{-}title"}\OperatorTok{))}
    \OperatorTok{\{}
\NormalTok{        Setters }\OperatorTok{=} \OperatorTok{\{} \KeywordTok{new} \FunctionTok{Setter}\OperatorTok{(}\NormalTok{TextBlock}\OperatorTok{.}\FunctionTok{FontSizeProperty}\OperatorTok{,} \DecValTok{18}\OperatorTok{),} \KeywordTok{new} \FunctionTok{Setter}\OperatorTok{(}\NormalTok{TextBlock}\OperatorTok{.}\FunctionTok{FontWeightProperty}\OperatorTok{,}\NormalTok{ FontWeight}\OperatorTok{.}\FunctionTok{SemiBold}\OperatorTok{)} \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Merge these into \texttt{Application.Current.Styles} in
\texttt{App.Initialize()} or on demand when the feature loads.

\subsection{\texorpdfstring{4. Managing \texttt{NameScope},
logical/visual trees, and
lookup}{4. Managing NameScope, logical/visual trees, and lookup}}\label{managing-namescope-logicalvisual-trees-and-lookup}

XAML automatically registers names in a \texttt{NameScope}. In
code-first views you create and assign it manually when you need element
lookup or \texttt{ElementName}-like references.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ scope }\OperatorTok{=} \KeywordTok{new} \FunctionTok{NameScope}\OperatorTok{();}
\DataTypeTok{var}\NormalTok{ container }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Grid}\OperatorTok{();}
\NormalTok{NameScope}\OperatorTok{.}\FunctionTok{SetNameScope}\OperatorTok{(}\NormalTok{container}\OperatorTok{,}\NormalTok{ scope}\OperatorTok{);}

\DataTypeTok{var}\NormalTok{ detailPanel }\OperatorTok{=} \KeywordTok{new}\NormalTok{ StackPanel }\OperatorTok{\{}\NormalTok{ Orientation }\OperatorTok{=}\NormalTok{ Orientation}\OperatorTok{.}\FunctionTok{Vertical} \OperatorTok{\};}
\NormalTok{scope}\OperatorTok{.}\FunctionTok{Register}\OperatorTok{(}\StringTok{"DetailPanel"}\OperatorTok{,}\NormalTok{ detailPanel}\OperatorTok{);}

\NormalTok{container}\OperatorTok{.}\FunctionTok{Children}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{detailPanel}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Later you can resolve controls with
\texttt{FindControl\textless{}T\textgreater{}}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ detail }\OperatorTok{=}\NormalTok{ container}\OperatorTok{.}\FunctionTok{FindControl}\OperatorTok{\textless{}}\NormalTok{StackPanel}\OperatorTok{\textgreater{}(}\StringTok{"DetailPanel"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{NameScope} implementation lives in
\texttt{external/Avalonia/src/Avalonia.Base/LogicalTree/NameScope.cs}.
Remember that nested scopes behave like XAML: children inherit the
nearest scope unless you assign a new one.

\subsubsection{Logical tree utilities}\label{logical-tree-utilities}

Avalonia's logical tree helpers (\texttt{LogicalTreeExtensions.cs}) are
just as useful without XAML. Use them to inspect or traverse the tree:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Control}\OperatorTok{?}\NormalTok{ parent }\OperatorTok{=}\NormalTok{ myControl}\OperatorTok{.}\FunctionTok{GetLogicalParent}\OperatorTok{();}
\NormalTok{IEnumerable}\OperatorTok{\textless{}}\NormalTok{IControl}\OperatorTok{\textgreater{}}\NormalTok{ children }\OperatorTok{=}\NormalTok{ myControl}\OperatorTok{.}\FunctionTok{GetLogicalChildren}\OperatorTok{().}\FunctionTok{OfType}\OperatorTok{\textless{}}\NormalTok{IControl}\OperatorTok{\textgreater{}();}
\end{Highlighting}
\end{Shaded}

This is handy when you dynamically add/remove controls and need to
ensure data contexts or resources flow correctly. To validate at
runtime, enable DevTools (\texttt{Avalonia.Diagnostics}) even in
code-only views---the visual tree is identical.

\subsection{5. Advanced controls entirely from
C}\label{advanced-controls-entirely-from-c}

\subsubsection{\texorpdfstring{\texttt{TabControl} and dynamic
pages}{TabControl and dynamic pages}}\label{tabcontrol-and-dynamic-pages}

\texttt{TabControl} expects \texttt{TabItem} children. Compose them
programmatically and bind headers/content.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ tabControl }\OperatorTok{=} \KeywordTok{new}\NormalTok{ TabControl}
\OperatorTok{\{}
\NormalTok{    Items }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]}
    \OperatorTok{\{}
        \KeywordTok{new}\NormalTok{ TabItem}
        \OperatorTok{\{}
\NormalTok{            Header }\OperatorTok{=} \StringTok{"Overview"}\OperatorTok{,}
\NormalTok{            Content }\OperatorTok{=} \KeywordTok{new}\NormalTok{ OverviewView }\OperatorTok{\{}\NormalTok{ DataContext }\OperatorTok{=}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{Overview} \OperatorTok{\}}
        \OperatorTok{\},}
        \KeywordTok{new}\NormalTok{ TabItem}
        \OperatorTok{\{}
\NormalTok{            Header }\OperatorTok{=} \StringTok{"Details"}\OperatorTok{,}
\NormalTok{            Content }\OperatorTok{=} \FunctionTok{CreateDetailsGrid}\OperatorTok{(}\NormalTok{vm}\OperatorTok{.}\FunctionTok{Details}\OperatorTok{)}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

If you prefer data-driven tabs, set \texttt{Items} to a collection of
view-models and provide \texttt{ItemTemplate} using
\texttt{FuncDataTemplate} (see Chapter 36 for full coverage). Even then,
you create the template in code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabControl}\OperatorTok{.}\FunctionTok{ItemTemplate} \OperatorTok{=} \KeywordTok{new}\NormalTok{ FuncDataTemplate}\OperatorTok{\textless{}}\NormalTok{IDetailViewModel}\OperatorTok{\textgreater{}((}\NormalTok{context}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}
    \KeywordTok{new}\NormalTok{ DetailView }\OperatorTok{\{}\NormalTok{ DataContext }\OperatorTok{=}\NormalTok{ context }\OperatorTok{\},}
\NormalTok{    supportsRecycling}\OperatorTok{:} \KeywordTok{true}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Lists with factories}\label{lists-with-factories}

\texttt{ItemsControl} and \texttt{ListBox} take \texttt{Items} plus
optional panel templates. Build the items panel in code to control
layout.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ list }\OperatorTok{=} \KeywordTok{new}\NormalTok{ ListBox}
\OperatorTok{\{}
\NormalTok{    ItemsPanel }\OperatorTok{=} \KeywordTok{new}\NormalTok{ FuncTemplate}\OperatorTok{\textless{}}\NormalTok{Panel}\OperatorTok{?\textgreater{}(()} \OperatorTok{=\textgreater{}} \KeywordTok{new}\NormalTok{ WrapPanel }\OperatorTok{\{}\NormalTok{ ItemWidth }\OperatorTok{=} \DecValTok{160}\OperatorTok{,}\NormalTok{ ItemHeight }\OperatorTok{=} \DecValTok{200} \OperatorTok{\}),}
\NormalTok{    Items }\OperatorTok{=}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{Products}\OperatorTok{.}\FunctionTok{Select}\OperatorTok{(}\NormalTok{p }\OperatorTok{=\textgreater{}} \FunctionTok{CreateProductCard}\OperatorTok{(}\NormalTok{p}\OperatorTok{))}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Here \texttt{FuncTemplate} comes from
\texttt{Avalonia.Controls.Templates} (source: \texttt{FuncTemplate.cs}).
It mirrors \texttt{\textless{}ItemsPanelTemplate\textgreater{}}.

\subsubsection{Popups and overlays}\label{popups-and-overlays}

Controls like \texttt{FlyoutBase} or \texttt{Popup} are fully accessible
in code. Example: attach a contextual menu.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ button }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Button }\OperatorTok{\{}\NormalTok{ Content }\OperatorTok{=} \StringTok{"Options"} \OperatorTok{\};}
\NormalTok{button}\OperatorTok{.}\FunctionTok{Flyout} \OperatorTok{=} \KeywordTok{new}\NormalTok{ MenuFlyout}
\OperatorTok{\{}
\NormalTok{    Items }\OperatorTok{=}
    \OperatorTok{\{}
        \KeywordTok{new}\NormalTok{ MenuItem }\OperatorTok{\{}\NormalTok{ Header }\OperatorTok{=} \StringTok{"Refresh"}\OperatorTok{,}\NormalTok{ Command }\OperatorTok{=}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{RefreshCommand} \OperatorTok{\},}
        \KeywordTok{new}\NormalTok{ MenuItem }\OperatorTok{\{}\NormalTok{ Header }\OperatorTok{=} \StringTok{"Export"}\OperatorTok{,}\NormalTok{ Command }\OperatorTok{=}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{ExportCommand} \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

The object initializer syntax keeps the code close to the equivalent
XAML while exposing full IntelliSense.

\subsection{6. Diagnostics and testing for code-first
layouts}\label{diagnostics-and-testing-for-code-first-layouts}

Because no XAML compilation step validates your layout, lean on: -
\textbf{Unit tests} using \texttt{Avalonia.Headless} to instantiate
controls and assert layout bounds. - \textbf{DevTools} to inspect the
visual tree ( launch via \texttt{AttachDevTools()} in debug builds ). -
\textbf{Logging} via property observers to catch binding mistakes early.

Example headless test snippet:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\NormalTok{Fact}\OperatorTok{]}
\KeywordTok{public} \DataTypeTok{void} \FunctionTok{Summary\_panel\_contains\_totals}\OperatorTok{()}
\OperatorTok{\{}
    \KeywordTok{using} \DataTypeTok{var}\NormalTok{ app }\OperatorTok{=} \FunctionTok{AvaloniaApp}\OperatorTok{();}

    \DataTypeTok{var}\NormalTok{ view }\OperatorTok{=}\NormalTok{ DashboardViewFactory}\OperatorTok{.}\FunctionTok{Create}\OperatorTok{(}\KeywordTok{new} \FunctionTok{FakeDashboardVm}\OperatorTok{());}
    \DataTypeTok{var}\NormalTok{ panel }\OperatorTok{=}\NormalTok{ view}\OperatorTok{.}\FunctionTok{GetLogicalDescendants}\OperatorTok{().}\FunctionTok{OfType}\OperatorTok{\textless{}}\NormalTok{TextBlock}\OperatorTok{\textgreater{}()}
        \OperatorTok{.}\FunctionTok{First}\OperatorTok{(}\NormalTok{t }\OperatorTok{=\textgreater{}}\NormalTok{ t}\OperatorTok{.}\FunctionTok{Classes}\OperatorTok{.}\FunctionTok{Contains}\OperatorTok{(}\StringTok{"total"}\OperatorTok{));}

\NormalTok{    panel}\OperatorTok{.}\FunctionTok{Text}\OperatorTok{.}\FunctionTok{Should}\OperatorTok{().}\FunctionTok{Be}\OperatorTok{(}\StringTok{"$42,000"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{GetLogicalDescendants} is defined in
\texttt{LogicalTreeExtensions}. Pair this with Chapter 38 for deeper
testing patterns.

\subsection{7. Practice lab}\label{practice-lab-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{StackPanel to Grid refactor} -- Start with a simple
  \texttt{StackPanel} form built in code. Refactor it to a \texttt{Grid}
  with columns and auto-sizing rows using only C\# helpers. Confirm
  layout parity via DevTools.
\item
  \textbf{Dashboard factory} -- Implement a
  \texttt{DashboardViewFactory} that returns a \texttt{Grid} with cards
  arranged dynamically based on a view-model collection. Add fluent
  helpers for grid position, dock, and margin management.
\item
  \textbf{Attached property assertions} -- Write a headless unit test
  that constructs your view, retrieves a control by name, and asserts
  attached properties (\texttt{Grid.GetRow}, \texttt{DockPanel.GetDock})
  to prevent regressions.
\item
  \textbf{Dynamic modules} -- Load modules at runtime that contribute
  layout fragments via \texttt{Func\textless{}Control\textgreater{}}.
  Merge their \texttt{Styles}/\texttt{ResourceDictionary} contributions
  when modules activate and remove them when deactivated.
\item
  \textbf{Performance profiling} -- Use \texttt{RenderTimerDiagnostics}
  from DevTools to monitor layout passes. Compare baseline vs.~dynamic
  code generation to ensure your factories don't introduce unnecessary
  measure/arrange churn.
\end{enumerate}

Mastering these patterns means you can weave Avalonia's layout system
into any C\#-driven architecture---no XAML required, just the underlying
property system and a toolbox of fluent helpers tailored to your
project.

What's next - Next: \href{Chapter35.md}{Chapter35}

\newpage

\subsection{35. Bindings, resources, and styles with fluent
APIs}\label{bindings-resources-and-styles-with-fluent-apis}

Goal - Compose data bindings, resource lookups, and styles from C\#
using the same primitives Avalonia's XAML markup wraps. - Harness
indexer paths, compiled bindings, and validation hooks when no markup
extensions are available. - Build reusable style/resource factories that
keep code-first projects organized and themeable.

Why this matters - Binding expressions and resource dictionaries power
MVVM regardless of markup language; code-first teams need ergonomic
patterns to mirror XAML equivalents. - Explicit APIs (\texttt{Binding},
\texttt{CompiledBindingFactory}, \texttt{IResourceHost}, \texttt{Style})
remove stringly-typed errors and enable richer refactoring tools. - Once
bindings and resources live in code, you can conditionally compose them,
share helper libraries, and unit test your infrastructure without XML
parsing.

Prerequisites - Chapter 7 (styling) and Chapter 10 (resources) to
understand the conceptual model. - Chapter 33 (code-only startup) for
service registration and theme initialization. - Chapter 34 (layout) for
structuring controls that consume bindings/styles.

\subsection{1. Binding essentials without
markup}\label{binding-essentials-without-markup}

Avalonia's binding engine is expressed via \texttt{Binding}
(\texttt{external/Avalonia/src/Avalonia.Base/Data/Binding.cs}).
Construct bindings with property paths, modes, converters, and
validation:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ binding }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\StringTok{"Customer.Name"}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    Mode }\OperatorTok{=}\NormalTok{ BindingMode}\OperatorTok{.}\FunctionTok{TwoWay}\OperatorTok{,}
\NormalTok{    UpdateSourceTrigger }\OperatorTok{=}\NormalTok{ UpdateSourceTrigger}\OperatorTok{.}\FunctionTok{PropertyChanged}\OperatorTok{,}
\NormalTok{    ValidatesOnExceptions }\OperatorTok{=} \KeywordTok{true}
\OperatorTok{\};}

\NormalTok{nameTextBox}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{TextBox}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,}\NormalTok{ binding}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{Bind} is an extension method on \texttt{AvaloniaObject} (see
\texttt{BindingExtensions}). The same API supports command bindings:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{saveButton}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{Button}\OperatorTok{.}\FunctionTok{CommandProperty}\OperatorTok{,} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\StringTok{"SaveCommand"}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

For one-time assignments, use \texttt{BindingMode.OneTime}. When you
need relative bindings (\texttt{RelativeSource} in XAML), use
\texttt{RelativeSource} objects:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ binding }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Binding}
\OperatorTok{\{}
\NormalTok{    RelativeSource }\OperatorTok{=} \KeywordTok{new} \FunctionTok{RelativeSource}\OperatorTok{(}\NormalTok{RelativeSourceMode}\OperatorTok{.}\FunctionTok{FindAncestor}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        AncestorType }\OperatorTok{=} \KeywordTok{typeof}\OperatorTok{(}\NormalTok{Window}\OperatorTok{)}
    \OperatorTok{\},}
\NormalTok{    Path }\OperatorTok{=} \FunctionTok{nameof}\OperatorTok{(}\NormalTok{Window}\OperatorTok{.}\FunctionTok{Title}\OperatorTok{)}
\OperatorTok{\};}

\NormalTok{header}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{TextBlock}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,}\NormalTok{ binding}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Indexer bindings from
code}\label{indexer-bindings-from-code}

Avalonia supports indexer paths (dictionary or list access) via the same
\texttt{Binding.Path} syntax used in XAML.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ statusText }\OperatorTok{=} \KeywordTok{new} \FunctionTok{TextBlock}\OperatorTok{();}
\NormalTok{statusText}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{TextBlock}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\StringTok{"Statuses[SelectedStatus]"}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Internally the binding engine uses \texttt{IndexerNode} (see
\texttt{ExpressionNodes}). You still get change notifications when the
indexer raises property change events (\texttt{INotifyPropertyChanged} +
\texttt{IndexerName}). For dynamic dictionaries, call
\texttt{RaisePropertyChanged("Item{[}{]}")} on changes.

\subsubsection{\texorpdfstring{Typed bindings with
\texttt{CompiledBindingFactory}}{Typed bindings with CompiledBindingFactory}}\label{typed-bindings-with-compiledbindingfactory}

Compiled bindings avoid reflection at runtime. Create a factory and
supply strongly-typed accessors, mirroring \texttt{\{CompiledBinding\}}
usage.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ factory }\OperatorTok{=} \KeywordTok{new} \FunctionTok{CompiledBindingFactory}\OperatorTok{();}
\DataTypeTok{var}\NormalTok{ compiled }\OperatorTok{=}\NormalTok{ factory}\OperatorTok{.}\FunctionTok{Create}\OperatorTok{\textless{}}\NormalTok{DashboardViewModel}\OperatorTok{,} \DataTypeTok{string}\OperatorTok{\textgreater{}(}
\NormalTok{    vmGetter}\OperatorTok{:} \KeywordTok{static}\NormalTok{ vm }\OperatorTok{=\textgreater{}}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{Header}\OperatorTok{,}
\NormalTok{    vmSetter}\OperatorTok{:} \KeywordTok{static} \OperatorTok{(}\NormalTok{vm}\OperatorTok{,}\NormalTok{ value}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{Header} \OperatorTok{=}\NormalTok{ value}\OperatorTok{,}
\NormalTok{    name}\OperatorTok{:} \FunctionTok{nameof}\OperatorTok{(}\NormalTok{DashboardViewModel}\OperatorTok{.}\FunctionTok{Header}\OperatorTok{),}
\NormalTok{    mode}\OperatorTok{:}\NormalTok{ BindingMode}\OperatorTok{.}\FunctionTok{TwoWay}\OperatorTok{);}

\NormalTok{headerText}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{TextBlock}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,}\NormalTok{ compiled}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{CompiledBindingFactory} resides in \texttt{Avalonia.Data.Core}.
Pass \texttt{BindingPriority} if you need to align with style triggers.
Because compiled bindings capture delegates, they work well with source
generators or analyzers.

\subsubsection{Binding helpers for fluent
composition}\label{binding-helpers-for-fluent-composition}

Create extension methods to reduce boilerplate:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ BindingHelpers}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ T BindValue}\OperatorTok{\textless{}}\NormalTok{T}\OperatorTok{,}\NormalTok{ TValue}\OperatorTok{\textgreater{}(}\KeywordTok{this}\NormalTok{ T control}\OperatorTok{,}\NormalTok{ AvaloniaProperty}\OperatorTok{\textless{}}\NormalTok{TValue}\OperatorTok{\textgreater{}}\NormalTok{ property}\OperatorTok{,} \DataTypeTok{string}\NormalTok{ path}\OperatorTok{,}
\NormalTok{        BindingMode mode }\OperatorTok{=}\NormalTok{ BindingMode}\OperatorTok{.}\FunctionTok{Default}\OperatorTok{)}\NormalTok{ where T }\OperatorTok{:}\NormalTok{ AvaloniaObject}
    \OperatorTok{\{}
\NormalTok{        control}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{property}\OperatorTok{,} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\NormalTok{path}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ Mode }\OperatorTok{=}\NormalTok{ mode }\OperatorTok{\});}
        \KeywordTok{return}\NormalTok{ control}\OperatorTok{;}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Use them when composing views:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ searchBox }\OperatorTok{=} \KeywordTok{new} \FunctionTok{TextBox}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{BindValue}\OperatorTok{(}\NormalTok{TextBox}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,} \FunctionTok{nameof}\OperatorTok{(}\NormalTok{SearchViewModel}\OperatorTok{.}\FunctionTok{Query}\OperatorTok{),}\NormalTok{ BindingMode}\OperatorTok{.}\FunctionTok{TwoWay}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsection{2. Validation, converters, and
multi-bindings}\label{validation-converters-and-multi-bindings}

\subsubsection{Validation feedback}\label{validation-feedback}

Avalonia surfaces validation errors via \texttt{BindingNotification}. In
code you set validation options on binding instances:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ amountBinding }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\StringTok{"Amount"}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    Mode }\OperatorTok{=}\NormalTok{ BindingMode}\OperatorTok{.}\FunctionTok{TwoWay}\OperatorTok{,}
\NormalTok{    ValidatesOnDataErrors }\OperatorTok{=} \KeywordTok{true}\OperatorTok{,}
\NormalTok{    ValidatesOnExceptions }\OperatorTok{=} \KeywordTok{true}
\OperatorTok{\};}
\NormalTok{amountTextBox}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{TextBox}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,}\NormalTok{ amountBinding}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Listen for errors using \texttt{BindingObserver} or property change
notifications on \texttt{DataValidationErrors} (see
\texttt{external/Avalonia/src/Avalonia.Controls/DataValidationErrors.cs}).
Example hooking into the attached property:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{amountTextBox}\OperatorTok{.}\FunctionTok{GetObservable}\OperatorTok{(}\NormalTok{DataValidationErrors}\OperatorTok{.}\FunctionTok{HasErrorsProperty}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{hasErrors }\OperatorTok{=\textgreater{}}\NormalTok{ amountTextBox}\OperatorTok{.}\FunctionTok{Classes}\OperatorTok{.}\FunctionTok{Set}\OperatorTok{(}\StringTok{":invalid"}\OperatorTok{,}\NormalTok{ hasErrors}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

\subsubsection{Converters and converter
parameters}\label{converters-and-converter-parameters}

Instantiate converters directly and assign them to
\texttt{Binding.Converter}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ converter }\OperatorTok{=} \KeywordTok{new} \FunctionTok{BooleanToVisibilityConverter}\OperatorTok{();}
\DataTypeTok{var}\NormalTok{ binding }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\StringTok{"IsBusy"}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    Converter }\OperatorTok{=}\NormalTok{ converter}
\OperatorTok{\};}

\NormalTok{spinner}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{IsVisibleProperty}\OperatorTok{,}\NormalTok{ binding}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

For inline converters, create lambda-based converter classes
implementing \texttt{IValueConverter}. In code-first setups you can keep
converter definitions close to usage.

\subsubsection{Multi-binding
composition}\label{multi-binding-composition}

\texttt{MultiBinding} lives in
\texttt{Avalonia.Base/Data/MultiBinding.cs}. Configure binding
collection and converters directly.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ multi }\OperatorTok{=} \KeywordTok{new}\NormalTok{ MultiBinding}
\OperatorTok{\{}
\NormalTok{    Bindings }\OperatorTok{=}
    \OperatorTok{\{}
        \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\StringTok{"FirstName"}\OperatorTok{),}
        \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\StringTok{"LastName"}\OperatorTok{)}
    \OperatorTok{\},}
\NormalTok{    Converter }\OperatorTok{=}\NormalTok{ FullNameConverter}\OperatorTok{.}\FunctionTok{Instance}
\OperatorTok{\};}

\NormalTok{fullNameText}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{TextBlock}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,}\NormalTok{ multi}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{FullNameConverter} implements \texttt{IMultiValueConverter}.
When multi-binding in code, consider static singletons to avoid
allocations.

\subsection{3. Commands and observables from
code}\label{commands-and-observables-from-code}

Avalonia command support is just binding to \texttt{ICommand}. With
code-first patterns, leverage \texttt{ReactiveCommand} or custom
commands while still using \texttt{Bind}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{refreshButton}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{Button}\OperatorTok{.}\FunctionTok{CommandProperty}\OperatorTok{,} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\StringTok{"RefreshCommand"}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

To observe property changes for reactive flows, use
\texttt{GetObservable} or \texttt{PropertyChanged} events. Combine with
\texttt{ReactiveUI} by using \texttt{WhenAnyValue} inside view
models---code-first views don't change this interop.

\subsection{4. Resource dictionaries and lookup
patterns}\label{resource-dictionaries-and-lookup-patterns}

\texttt{ResourceDictionary} is just a C\# collection (see
\texttt{external/Avalonia/src/Avalonia.Base/Controls/ResourceDictionary.cs}).
Create dictionaries and merge them programmatically.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ typographyResources }\OperatorTok{=} \KeywordTok{new}\NormalTok{ ResourceDictionary}
\OperatorTok{\{}
    \OperatorTok{[}\StringTok{"Heading.FontSize"}\OperatorTok{]} \OperatorTok{=} \FloatTok{24.0}\OperatorTok{,}
    \OperatorTok{[}\StringTok{"Body.FontSize"}\OperatorTok{]} \OperatorTok{=} \FloatTok{14.0}
\OperatorTok{\};}

\NormalTok{Application}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{!.}\FunctionTok{Resources}\OperatorTok{.}\FunctionTok{MergedDictionaries}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{typographyResources}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

For per-control resources:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ card }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Border}
\OperatorTok{\{}
\NormalTok{    Resources }\OperatorTok{=}
    \OperatorTok{\{}
        \OperatorTok{[}\StringTok{"CardBackground"}\OperatorTok{]} \OperatorTok{=}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{White}\OperatorTok{,}
        \OperatorTok{[}\StringTok{"CardShadow"}\OperatorTok{]} \OperatorTok{=} \KeywordTok{new}\NormalTok{ BoxShadow }\OperatorTok{\{}\NormalTok{ Color }\OperatorTok{=}\NormalTok{ Colors}\OperatorTok{.}\FunctionTok{Black}\OperatorTok{,}\NormalTok{ Opacity }\OperatorTok{=} \FloatTok{0.1}\OperatorTok{,}\NormalTok{ Blur }\OperatorTok{=} \DecValTok{8} \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

\texttt{Resources} property is itself a \texttt{ResourceDictionary}. Use
strongly-typed wrapper classes to centralize resource keys:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ ResourceKeys}
\OperatorTok{\{}
    \KeywordTok{public} \DataTypeTok{const} \DataTypeTok{string}\NormalTok{ AccentBrush }\OperatorTok{=} \FunctionTok{nameof}\OperatorTok{(}\NormalTok{AccentBrush}\OperatorTok{);}
    \KeywordTok{public} \DataTypeTok{const} \DataTypeTok{string}\NormalTok{ AccentForeground }\OperatorTok{=} \FunctionTok{nameof}\OperatorTok{(}\NormalTok{AccentForeground}\OperatorTok{);}
\OperatorTok{\}}

\DataTypeTok{var}\NormalTok{ accent }\OperatorTok{=} \OperatorTok{(}\NormalTok{IBrush}\OperatorTok{)}\NormalTok{Application}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{!.}\FunctionTok{Resources}\OperatorTok{[}\NormalTok{ResourceKeys}\OperatorTok{.}\FunctionTok{AccentBrush}\OperatorTok{];}
\end{Highlighting}
\end{Shaded}

Wrap lookups with helper methods to provide fallbacks:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static}\NormalTok{ TResource GetResource}\OperatorTok{\textless{}}\NormalTok{TResource}\OperatorTok{\textgreater{}(}\KeywordTok{this}\NormalTok{ IResourceHost host}\OperatorTok{,} \DataTypeTok{string}\NormalTok{ key}\OperatorTok{,}\NormalTok{ TResource fallback}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{return}\NormalTok{ host}\OperatorTok{.}\FunctionTok{TryFindResource}\OperatorTok{(}\NormalTok{key}\OperatorTok{,} \KeywordTok{out} \DataTypeTok{var}\NormalTok{ value}\OperatorTok{)} \OperatorTok{\&\&}\NormalTok{ value }\KeywordTok{is}\NormalTok{ TResource typed}
        \OperatorTok{?}\NormalTok{ typed}
        \OperatorTok{:}\NormalTok{ fallback}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{IResourceHost}/\texttt{IResourceProvider} interfaces are defined
in \texttt{Avalonia.Styling}. Controls implement them, so you can call
\texttt{control.TryFindResource} directly.

\subsection{5. Building styles fluently}\label{building-styles-fluently}

\texttt{Style} objects can be constructed with selectors and setters.
The selector API mirrors XAML but uses lambda syntax.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ buttonStyle }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Style}\OperatorTok{(}\NormalTok{x }\OperatorTok{=\textgreater{}}\NormalTok{ x}\OperatorTok{.}\FunctionTok{OfType}\OperatorTok{\textless{}}\NormalTok{Button}\OperatorTok{\textgreater{}().}\FunctionTok{Class}\OperatorTok{(}\StringTok{"primary"}\OperatorTok{))}
\OperatorTok{\{}
\NormalTok{    Setters }\OperatorTok{=}
    \OperatorTok{\{}
        \KeywordTok{new} \FunctionTok{Setter}\OperatorTok{(}\NormalTok{Button}\OperatorTok{.}\FunctionTok{BackgroundProperty}\OperatorTok{,}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{MediumPurple}\OperatorTok{),}
        \KeywordTok{new} \FunctionTok{Setter}\OperatorTok{(}\NormalTok{Button}\OperatorTok{.}\FunctionTok{ForegroundProperty}\OperatorTok{,}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{White}\OperatorTok{),}
        \KeywordTok{new} \FunctionTok{Setter}\OperatorTok{(}\NormalTok{Button}\OperatorTok{.}\FunctionTok{PaddingProperty}\OperatorTok{,} \KeywordTok{new} \FunctionTok{Thickness}\OperatorTok{(}\DecValTok{20}\OperatorTok{,} \DecValTok{10}\OperatorTok{))}
    \OperatorTok{\},}
\NormalTok{    Triggers }\OperatorTok{=}
    \OperatorTok{\{}
        \KeywordTok{new}\NormalTok{ Trigger}
        \OperatorTok{\{}
\NormalTok{            Property }\OperatorTok{=}\NormalTok{ Button}\OperatorTok{.}\FunctionTok{IsPointerOverProperty}\OperatorTok{,}
\NormalTok{            Value }\OperatorTok{=} \KeywordTok{true}\OperatorTok{,}
\NormalTok{            Setters }\OperatorTok{=} \OperatorTok{\{} \KeywordTok{new} \FunctionTok{Setter}\OperatorTok{(}\NormalTok{Button}\OperatorTok{.}\FunctionTok{BackgroundProperty}\OperatorTok{,}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{DarkMagenta}\OperatorTok{)} \OperatorTok{\}}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Add styles to \texttt{Application.Current.Styles} or to a specific
control's \texttt{Styles} collection. Remember to freeze brushes (call
\texttt{ToImmutable()} or use static brushes) when reusing them widely.

\subsubsection{Style includes and theme
variants}\label{style-includes-and-theme-variants}

You can still load existing \texttt{.axaml} resources via
\texttt{StyleInclude}, or create purely code-based ones:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ theme }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Styles}
\OperatorTok{\{}
    \KeywordTok{new} \FunctionTok{StyleInclude}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Uri}\OperatorTok{(}\StringTok{"avares://App/Styles"}\OperatorTok{))}
    \OperatorTok{\{}
\NormalTok{        Source }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Uri}\OperatorTok{(}\StringTok{"avares://App/Styles/Buttons.axaml"}\OperatorTok{)}
    \OperatorTok{\},}
\NormalTok{    buttonStyle}
\OperatorTok{\};}

\NormalTok{Application}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{!.}\FunctionTok{Styles}\OperatorTok{.}\FunctionTok{AddRange}\OperatorTok{(}\NormalTok{theme}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

In pure C\#, \texttt{Styles} is just a list. If you don't have
\texttt{AddRange}, iterate:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ style }\KeywordTok{in}\NormalTok{ theme}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    Application}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{!.}\FunctionTok{Styles}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{style}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Theme variants (\texttt{ThemeVariant}) can be set directly on styles:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{buttonStyle}\OperatorTok{.}\FunctionTok{Resources}\OperatorTok{[}\NormalTok{ThemeVariant}\OperatorTok{.}\FunctionTok{Light}\OperatorTok{]} \OperatorTok{=}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{Black}\OperatorTok{;}
\NormalTok{buttonStyle}\OperatorTok{.}\FunctionTok{Resources}\OperatorTok{[}\NormalTok{ThemeVariant}\OperatorTok{.}\FunctionTok{Dark}\OperatorTok{]} \OperatorTok{=}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{White}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{6. Code-first binding infrastructure
patterns}\label{code-first-binding-infrastructure-patterns}

\subsubsection{Binding factories per
view-model}\label{binding-factories-per-view-model}

Encapsulate binding creation in dedicated classes to avoid scattering
strings:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ DashboardBindings}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ Binding TotalSales }\OperatorTok{=\textgreater{}} \KeywordTok{new}\OperatorTok{(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{DashboardViewModel}\OperatorTok{.}\FunctionTok{TotalSales}\OperatorTok{))} \OperatorTok{\{}\NormalTok{ Mode }\OperatorTok{=}\NormalTok{ BindingMode}\OperatorTok{.}\FunctionTok{OneWay} \OperatorTok{\};}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ Binding RefreshCommand }\OperatorTok{=\textgreater{}} \KeywordTok{new}\OperatorTok{(}\FunctionTok{nameof}\OperatorTok{(}\NormalTok{DashboardViewModel}\OperatorTok{.}\FunctionTok{RefreshCommand}\OperatorTok{));}
\OperatorTok{\}}

\NormalTok{salesText}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{TextBlock}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,}\NormalTok{ DashboardBindings}\OperatorTok{.}\FunctionTok{TotalSales}\OperatorTok{);}
\NormalTok{refreshButton}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{Button}\OperatorTok{.}\FunctionTok{CommandProperty}\OperatorTok{,}\NormalTok{ DashboardBindings}\OperatorTok{.}\FunctionTok{RefreshCommand}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\subsubsection{Expression-based helpers}\label{expression-based-helpers}

Use expression trees to produce path strings while maintaining
compile-time checks:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ BindingFactory}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ Binding Create}\OperatorTok{\textless{}}\NormalTok{TViewModel}\OperatorTok{,}\NormalTok{ TValue}\OperatorTok{\textgreater{}(}\NormalTok{Expression}\OperatorTok{\textless{}}\NormalTok{Func}\OperatorTok{\textless{}}\NormalTok{TViewModel}\OperatorTok{,}\NormalTok{ TValue}\OperatorTok{\textgreater{}\textgreater{}}\NormalTok{ expression}\OperatorTok{,}
\NormalTok{        BindingMode mode }\OperatorTok{=}\NormalTok{ BindingMode}\OperatorTok{.}\FunctionTok{Default}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ path }\OperatorTok{=}\NormalTok{ ExpressionHelper}\OperatorTok{.}\FunctionTok{GetMemberPath}\OperatorTok{(}\NormalTok{expression}\OperatorTok{);} \CommentTok{// custom helper}
        \KeywordTok{return} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\NormalTok{path}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ Mode }\OperatorTok{=}\NormalTok{ mode }\OperatorTok{\};}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{ExpressionHelper} can walk the expression tree to build
\texttt{Customer.Addresses{[}0{]}.City} style paths, ensuring refactors
update bindings.

\subsubsection{Declarative resource
builders}\label{declarative-resource-builders}

Provide factories for resource dictionaries similar to style factories:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ ResourceFactory}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ ResourceDictionary }\FunctionTok{CreateColors}\OperatorTok{()} \OperatorTok{=\textgreater{}} \KeywordTok{new}\OperatorTok{()}
    \OperatorTok{\{}
        \OperatorTok{[}\NormalTok{ResourceKeys}\OperatorTok{.}\FunctionTok{AccentBrush}\OperatorTok{]} \OperatorTok{=} \KeywordTok{new} \FunctionTok{SolidColorBrush}\OperatorTok{(}\NormalTok{Color}\OperatorTok{.}\FunctionTok{Parse}\OperatorTok{(}\StringTok{"\#4F8EF7"}\OperatorTok{)),}
        \OperatorTok{[}\NormalTok{ResourceKeys}\OperatorTok{.}\FunctionTok{AccentForeground}\OperatorTok{]} \OperatorTok{=}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{White}
    \OperatorTok{\};}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Merge them in \texttt{App.Initialize()} or feature modules when needed.

\subsection{7. Practice lab}\label{practice-lab-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Binding library} -- Implement a helper class that exposes
  strongly-typed bindings for a view-model using expression trees.
  Replace string-based paths in an existing code-first view.
\item
  \textbf{Indexer dashboards} -- Build a dashboard card that binds to
  \texttt{Metrics{[}"TotalRevenue"{]}} from a dictionary-backed
  view-model. Raise change notifications on dictionary updates and
  verify the UI refreshes.
\item
  \textbf{Validation styling} -- Create a reusable style that applies an
  \texttt{:invalid} pseudo-class template to controls with validation
  errors. Trigger validation via a headless test.
\item
  \textbf{Resource fallback provider} -- Write an extension method that
  locates a resource by key and throws a descriptive exception if
  missing, including current logical tree path. Use it in a headless
  test to catch missing theme registrations.
\item
  \textbf{Theme toggler} -- Compose two \texttt{Styles} collections
  (light/dark) in code, swap them at runtime, and ensure all bindings to
  theme resources update automatically. Validate behaviour with a
  headless pixel test (Chapter 40).
\end{enumerate}

With bindings, resources, and styles expressed in code, your Avalonia
app gains powerful refactorability and testability. Embrace the fluent
APIs and helper patterns to keep code-first UI as expressive as any XAML
counterpart.

What's next - Next: \href{Chapter36.md}{Chapter36}

\newpage

\subsection{36. Templates, indexers, and dynamic component
factories}\label{templates-indexers-and-dynamic-component-factories}

Goal - Compose control, data, and tree templates in pure C\# using
Avalonia's functional template APIs. - Harness indexer-driven bindings
and template bindings to build dynamic, data-driven components. -
Construct factories and selectors that swap templates at runtime without
touching XAML.

Why this matters - Templates define how controls render. In code-first
projects you still need \texttt{FuncControlTemplate},
\texttt{FuncDataTemplate}, and selectors to mirror the flexibility of
XAML. - Indexer bindings and instanced bindings power advanced scenarios
such as virtualization, item reuse, and hierarchical data. - Dynamic
factories unlock plugin architectures, runtime theme changes, and
feature toggles---all while keeping strong typing and testability.

Prerequisites - Chapter 34 (layouts) to place templated content within
layouts. - Chapter 35 (bindings/resources) for binding syntax and helper
patterns. - Chapter 23 (custom controls) if you plan to author templated
controls that consume templates from code.

\subsection{\texorpdfstring{1. Control templates in code with
\texttt{FuncControlTemplate}}{1. Control templates in code with FuncControlTemplate}}\label{control-templates-in-code-with-funccontroltemplate}

\texttt{FuncControlTemplate\textless{}T\textgreater{}} (source:
\texttt{external/Avalonia/src/Avalonia.Controls/Templates/FuncControlTemplate.cs})
produces a \texttt{ControlTemplate} that builds visuals from code. It
takes a lambda that receives the templated parent and returns a
\texttt{Control}/\texttt{IControl} tree.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static}\NormalTok{ ControlTemplate }\FunctionTok{CreateCardTemplate}\OperatorTok{()}
\OperatorTok{\{}
    \KeywordTok{return} \KeywordTok{new}\NormalTok{ FuncControlTemplate}\OperatorTok{\textless{}}\NormalTok{ContentControl}\OperatorTok{\textgreater{}((}\NormalTok{parent}\OperatorTok{,}\NormalTok{ scope}\OperatorTok{)} \OperatorTok{=\textgreater{}}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ border }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Border}
        \OperatorTok{\{}
\NormalTok{            Background }\OperatorTok{=}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{White}\OperatorTok{,}
\NormalTok{            CornerRadius }\OperatorTok{=} \KeywordTok{new} \FunctionTok{CornerRadius}\OperatorTok{(}\DecValTok{12}\OperatorTok{),}
\NormalTok{            Padding }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Thickness}\OperatorTok{(}\DecValTok{16}\OperatorTok{),}
\NormalTok{            Child }\OperatorTok{=} \KeywordTok{new}\NormalTok{ ContentPresenter}
            \OperatorTok{\{}
\NormalTok{                Name }\OperatorTok{=} \StringTok{"PART\_ContentPresenter"}
            \OperatorTok{\}}
        \OperatorTok{\};}

\NormalTok{        scope}\OperatorTok{?.}\FunctionTok{RegisterNamed}\OperatorTok{(}\StringTok{"PART\_ContentPresenter"}\OperatorTok{,}\NormalTok{ border}\OperatorTok{.}\FunctionTok{Child}\OperatorTok{);}
        \KeywordTok{return}\NormalTok{ border}\OperatorTok{;}
    \OperatorTok{\});}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Attach the template to a control:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ card }\OperatorTok{=} \KeywordTok{new}\NormalTok{ ContentControl}
\OperatorTok{\{}
\NormalTok{    Template }\OperatorTok{=} \FunctionTok{CreateCardTemplate}\OperatorTok{(),}
\NormalTok{    Content }\OperatorTok{=} \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Text }\OperatorTok{=} \StringTok{"Dashboard"} \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Notes from the source implementation: - The second parameter
(\texttt{INameScope\ scope}) lets you register named parts exactly like
\texttt{\textless{}ControlTemplate\textgreater{}} does in XAML. Use it
to satisfy template part lookups in your control's code-behind. - The
lambda executes each time the control template is applied, so create new
control instances inside the lambda---avoid caching across calls.

\subsubsection{\texorpdfstring{Template bindings and
\texttt{TemplatedParent}}{Template bindings and TemplatedParent}}\label{template-bindings-and-templatedparent}

Use \texttt{TemplateBinding} helpers
(\texttt{TemplateBindingExtensions}) to bind template visual properties
to the templated control.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{return} \KeywordTok{new}\NormalTok{ Border}
\OperatorTok{\{}
\NormalTok{    Background }\OperatorTok{=}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{White}\OperatorTok{,}
    \OperatorTok{[!}\NormalTok{Border}\OperatorTok{.}\FunctionTok{BackgroundProperty}\OperatorTok{]} \OperatorTok{=}\NormalTok{ parent}\OperatorTok{.}\FunctionTok{GetTemplateBinding}\OperatorTok{(}\NormalTok{ContentControl}\OperatorTok{.}\FunctionTok{BackgroundProperty}\OperatorTok{),}
\NormalTok{    Child }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ContentPresenter}\OperatorTok{()}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

The \texttt{{[}!Property{]}} indexer syntax is shorthand for creating a
template binding (enabled by the \texttt{Avalonia.Markup.Declarative}
helpers). If you prefer explicit code, use
\texttt{TemplateBindingExtensions.Bind}:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ presenter }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ContentPresenter}\OperatorTok{();}
\NormalTok{presenter}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{ContentPresenter}\OperatorTok{.}\FunctionTok{ContentProperty}\OperatorTok{,}\NormalTok{ parent}\OperatorTok{.}\FunctionTok{GetTemplateBinding}\OperatorTok{(}\NormalTok{ContentControl}\OperatorTok{.}\FunctionTok{ContentProperty}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

\texttt{TemplateBindingExtensions.cs} shows this helper returns a
lightweight binding linked to the templated parent's property value.

\subsection{\texorpdfstring{2. Data templates with
\texttt{FuncDataTemplate}}{2. Data templates with FuncDataTemplate}}\label{data-templates-with-funcdatatemplate}

\texttt{FuncDataTemplate\textless{}T\textgreater{}} (source:
\texttt{FuncDataTemplate.cs}) creates visuals for data items. Often you
assign it to \texttt{ContentControl.ContentTemplate} or
\texttt{ItemsControl.ItemTemplate}.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ itemTemplate }\OperatorTok{=} \KeywordTok{new}\NormalTok{ FuncDataTemplate}\OperatorTok{\textless{}}\NormalTok{OrderItem}\OperatorTok{\textgreater{}((}\NormalTok{item}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}
    \KeywordTok{new}\NormalTok{ Border}
    \OperatorTok{\{}
\NormalTok{        Margin }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Thickness}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{12}\OperatorTok{),}
\NormalTok{        Child }\OperatorTok{=} \KeywordTok{new}\NormalTok{ StackPanel}
        \OperatorTok{\{}
\NormalTok{            Orientation }\OperatorTok{=}\NormalTok{ Orientation}\OperatorTok{.}\FunctionTok{Horizontal}\OperatorTok{,}
\NormalTok{            Spacing }\OperatorTok{=} \DecValTok{12}\OperatorTok{,}
\NormalTok{            Children }\OperatorTok{=}
            \OperatorTok{\{}
                \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Text }\OperatorTok{=}\NormalTok{ item}\OperatorTok{.}\FunctionTok{ProductName}\OperatorTok{,}\NormalTok{ FontWeight }\OperatorTok{=}\NormalTok{ FontWeight}\OperatorTok{.}\FunctionTok{SemiBold} \OperatorTok{\},}
                \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Text }\OperatorTok{=}\NormalTok{ item}\OperatorTok{.}\FunctionTok{Quantity}\OperatorTok{.}\FunctionTok{ToString}\OperatorTok{()} \OperatorTok{\}}
            \OperatorTok{\}}
        \OperatorTok{\}}
    \OperatorTok{\},}\NormalTok{ recycle}\OperatorTok{:} \KeywordTok{true}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Pass \texttt{recycle:\ true} to participate in virtualization (controls
are reused). Attach to an \texttt{ItemsControl}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{itemsControl}\OperatorTok{.}\FunctionTok{ItemTemplate} \OperatorTok{=}\NormalTok{ itemTemplate}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Binding inside data
templates}\label{binding-inside-data-templates}

Because the template receives the data item, you can access its
properties directly or create bindings relative to the template context.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ template }\OperatorTok{=} \KeywordTok{new}\NormalTok{ FuncDataTemplate}\OperatorTok{\textless{}}\NormalTok{Customer}\OperatorTok{\textgreater{}((}\NormalTok{item}\OperatorTok{,}\NormalTok{ scope}\OperatorTok{)} \OperatorTok{=\textgreater{}}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ balance }\OperatorTok{=} \KeywordTok{new} \FunctionTok{TextBlock}\OperatorTok{();}
\NormalTok{    balance}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{TextBlock}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\StringTok{"Balance"}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        StringFormat }\OperatorTok{=} \StringTok{"\{0:C\}"}
    \OperatorTok{\});}

    \KeywordTok{return} \KeywordTok{new}\NormalTok{ StackPanel}
    \OperatorTok{\{}
\NormalTok{        Children }\OperatorTok{=}
        \OperatorTok{\{}
            \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Text }\OperatorTok{=}\NormalTok{ item}\OperatorTok{.}\FunctionTok{Name} \OperatorTok{\},}
\NormalTok{            balance}
        \OperatorTok{\}}
    \OperatorTok{\};}
\OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

\texttt{FuncDataTemplate} sets the \texttt{DataContext} to the item
automatically, so bindings with explicit paths work without additional
setup.

\subsubsection{Template selectors}\label{template-selectors}

\texttt{FuncDataTemplate} supports predicates for conditional templates.
Use the overload that accepts a
\texttt{Func\textless{}object?,\ bool\textgreater{}} predicate.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ positiveTemplate }\OperatorTok{=} \KeywordTok{new}\NormalTok{ FuncDataTemplate}\OperatorTok{\textless{}}\NormalTok{Transaction}\OperatorTok{\textgreater{}((}\NormalTok{item}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}} \FunctionTok{CreateTransactionRow}\OperatorTok{(}\NormalTok{item}\OperatorTok{));}
\DataTypeTok{var}\NormalTok{ negativeTemplate }\OperatorTok{=} \KeywordTok{new}\NormalTok{ FuncDataTemplate}\OperatorTok{\textless{}}\NormalTok{Transaction}\OperatorTok{\textgreater{}((}\NormalTok{item}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}} \FunctionTok{CreateTransactionRow}\OperatorTok{(}\NormalTok{item}\OperatorTok{,}\NormalTok{ isDebit}\OperatorTok{:} \KeywordTok{true}\OperatorTok{));}

\DataTypeTok{var}\NormalTok{ selector }\OperatorTok{=} \KeywordTok{new}\NormalTok{ FuncDataTemplate}\OperatorTok{\textless{}}\NormalTok{Transaction}\OperatorTok{\textgreater{}((}\NormalTok{item}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}
    \OperatorTok{(}\NormalTok{item}\OperatorTok{.}\FunctionTok{Amount} \OperatorTok{\textgreater{}=} \DecValTok{0} \OperatorTok{?}\NormalTok{ positiveTemplate}\OperatorTok{.}\FunctionTok{Build}\OperatorTok{(}\NormalTok{item}\OperatorTok{)} \OperatorTok{:}\NormalTok{ negativeTemplate}\OperatorTok{.}\FunctionTok{Build}\OperatorTok{(}\NormalTok{item}\OperatorTok{))!,}
\NormalTok{    supportsRecycling}\OperatorTok{:} \KeywordTok{true}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

For more complex selection logic, implement \texttt{IDataTemplate}
manually or use \texttt{DataTemplateSelector} base classes from
community packages.

\subsection{\texorpdfstring{3. Hierarchical templates with
\texttt{FuncTreeDataTemplate}}{3. Hierarchical templates with FuncTreeDataTemplate}}\label{hierarchical-templates-with-functreedatatemplate}

\texttt{FuncTreeDataTemplate\textless{}T\textgreater{}} builds item
templates for hierarchical data such as tree views. It receives the item
and a recursion function.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ treeTemplate }\OperatorTok{=} \KeywordTok{new}\NormalTok{ FuncTreeDataTemplate}\OperatorTok{\textless{}}\NormalTok{DirectoryNode}\OperatorTok{\textgreater{}((}\NormalTok{item}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}
    \KeywordTok{new}\NormalTok{ StackPanel}
    \OperatorTok{\{}
\NormalTok{        Orientation }\OperatorTok{=}\NormalTok{ Orientation}\OperatorTok{.}\FunctionTok{Horizontal}\OperatorTok{,}
\NormalTok{        Children }\OperatorTok{=}
        \OperatorTok{\{}
            \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Text }\OperatorTok{=}\NormalTok{ item}\OperatorTok{.}\FunctionTok{Name} \OperatorTok{\}}
        \OperatorTok{\}}
    \OperatorTok{\},}
\NormalTok{    x }\OperatorTok{=\textgreater{}}\NormalTok{ x}\OperatorTok{.}\FunctionTok{Children}\OperatorTok{,}
    \KeywordTok{true}\OperatorTok{);}

\DataTypeTok{var}\NormalTok{ treeView }\OperatorTok{=} \KeywordTok{new}\NormalTok{ TreeView}
\OperatorTok{\{}
\NormalTok{    Items }\OperatorTok{=}\NormalTok{ fileSystem}\OperatorTok{.}\FunctionTok{RootNodes}\OperatorTok{,}
\NormalTok{    ItemTemplate }\OperatorTok{=}\NormalTok{ treeTemplate}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

The third argument is \texttt{supportsRecycling}. The second argument is
the accessor returning child items. This mirrors XAML's
\texttt{\textless{}TreeDataTemplate\ ItemsSource="\{Binding\ Children\}"\textgreater{}}.

\texttt{FuncTreeDataTemplate} internally wires \texttt{TreeDataTemplate}
with lambda-based factories, so you get the same virtualization
behaviour as XAML templates.

\subsection{4. Instanced bindings and indexer
tricks}\label{instanced-bindings-and-indexer-tricks}

\texttt{InstancedBinding} (source:
\texttt{external/Avalonia/src/Avalonia.Data/Core/InstancedBinding.cs})
lets you precompute a binding for a known source. It's powerful when a
template needs to bind to an item-specific property or when you assemble
UI from graphs.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ binding }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\StringTok{"Metrics[}\SpecialCharTok{\textbackslash{}"}\StringTok{Total}\SpecialCharTok{\textbackslash{}"}\StringTok{]"}\OperatorTok{)} \OperatorTok{\{}\NormalTok{ Mode }\OperatorTok{=}\NormalTok{ BindingMode}\OperatorTok{.}\FunctionTok{OneWay} \OperatorTok{\};}
\DataTypeTok{var}\NormalTok{ instanced }\OperatorTok{=}\NormalTok{ InstancedBinding}\OperatorTok{.}\FunctionTok{OneWay}\OperatorTok{(}\NormalTok{binding}\OperatorTok{,}\NormalTok{ metricsDictionary}\OperatorTok{);}

\DataTypeTok{var}\NormalTok{ text }\OperatorTok{=} \KeywordTok{new} \FunctionTok{TextBlock}\OperatorTok{();}
\NormalTok{text}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{text}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{,}\NormalTok{ instanced}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Because you supply the source (\texttt{metricsDictionary}), the binding
bypasses \texttt{DataContext}. This is useful in templates where you
juggle multiple sources (e.g., templated parent + external service).

\subsubsection{Binding to template parts via
indexers}\label{binding-to-template-parts-via-indexers}

Within templates you can reference named parts registered through
\texttt{scope.RegisterNamed}. After applying the template, resolve them
via \texttt{TemplateAppliedEventArgs}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnApplyTemplate}\OperatorTok{(}\NormalTok{TemplateAppliedEventArgs e}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnApplyTemplate}\OperatorTok{(}\NormalTok{e}\OperatorTok{);}
\NormalTok{    \_presenter }\OperatorTok{=}\NormalTok{ e}\OperatorTok{.}\FunctionTok{NameScope}\OperatorTok{.}\FunctionTok{Find}\OperatorTok{\textless{}}\NormalTok{ContentPresenter}\OperatorTok{\textgreater{}(}\StringTok{"PART\_ContentPresenter"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

From code-first templates, ensure the name scope registration occurs
inside the template lambda as shown earlier.

\subsection{5. Swapping templates at
runtime}\label{swapping-templates-at-runtime}

Because templates are just CLR objects, you can replace them dynamically
to support different visual representations.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \DataTypeTok{void} \FunctionTok{UseCompactTemplates}\OperatorTok{(}\NormalTok{Window window}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    window}\OperatorTok{.}\FunctionTok{Resources}\OperatorTok{[}\StringTok{"CardTemplate"}\OperatorTok{]} \OperatorTok{=}\NormalTok{ Templates}\OperatorTok{.}\FunctionTok{CompactCard}\OperatorTok{;}
\NormalTok{    window}\OperatorTok{.}\FunctionTok{Resources}\OperatorTok{[}\StringTok{"ListItemTemplate"}\OperatorTok{]} \OperatorTok{=}\NormalTok{ Templates}\OperatorTok{.}\FunctionTok{CompactListItem}\OperatorTok{;}

    \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ presenter }\KeywordTok{in}\NormalTok{ window}\OperatorTok{.}\FunctionTok{GetVisualDescendants}\OperatorTok{().}\FunctionTok{OfType}\OperatorTok{\textless{}}\NormalTok{ContentPresenter}\OperatorTok{\textgreater{}())}
    \OperatorTok{\{}
\NormalTok{        presenter}\OperatorTok{.}\FunctionTok{UpdateChild}\OperatorTok{();} \CommentTok{// apply new template}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{ContentPresenter.UpdateChild()} forces the presenter to
re-evaluate its template. \texttt{GetVisualDescendants} comes from
\texttt{VisualTreeExtensions}. Consider performance: only call on
affected presenters.

Use \texttt{IStyle} triggers or the view-model to change templates
automatically. Example using a binding:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{contentControl}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\NormalTok{ContentControl}\OperatorTok{.}\FunctionTok{ContentTemplateProperty}\OperatorTok{,} \KeywordTok{new} \FunctionTok{Binding}\OperatorTok{(}\StringTok{"SelectedTemplate"}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    Mode }\OperatorTok{=}\NormalTok{ BindingMode}\OperatorTok{.}\FunctionTok{OneWay}
\OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

The view-model exposes \texttt{IDataTemplate\ SelectedTemplate}, and
your code-first view updates this property to switch visuals.

\subsection{6. Component factories and
virtualization}\label{component-factories-and-virtualization}

\subsubsection{Control factories}\label{control-factories}

Wrap template logic in factories that accept data and return controls,
useful for plugin systems.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{interface}\NormalTok{ IWidgetFactory}
\OperatorTok{\{}
    \DataTypeTok{bool} \FunctionTok{CanHandle}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ widgetType}\OperatorTok{);}
\NormalTok{    Control }\FunctionTok{Create}\OperatorTok{(}\NormalTok{IWidgetContext context}\OperatorTok{);}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ ChartWidgetFactory }\OperatorTok{:}\NormalTok{ IWidgetFactory}
\OperatorTok{\{}
    \KeywordTok{public} \DataTypeTok{bool} \FunctionTok{CanHandle}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ widgetType}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ widgetType }\OperatorTok{==} \StringTok{"chart"}\OperatorTok{;}

    \KeywordTok{public}\NormalTok{ Control }\FunctionTok{Create}\OperatorTok{(}\NormalTok{IWidgetContext context}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{return} \KeywordTok{new}\NormalTok{ Border}
        \OperatorTok{\{}
\NormalTok{            Child }\OperatorTok{=} \KeywordTok{new}\NormalTok{ ChartControl }\OperatorTok{\{}\NormalTok{ DataContext }\OperatorTok{=}\NormalTok{ context}\OperatorTok{.}\FunctionTok{Data} \OperatorTok{\}}
        \OperatorTok{\};}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Register factories and pick one at runtime:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ widget }\OperatorTok{=}\NormalTok{ factories}\OperatorTok{.}\FunctionTok{First}\OperatorTok{(}\NormalTok{f }\OperatorTok{=\textgreater{}}\NormalTok{ f}\OperatorTok{.}\FunctionTok{CanHandle}\OperatorTok{(}\NormalTok{config}\OperatorTok{.}\FunctionTok{Type}\OperatorTok{)).}\FunctionTok{Create}\OperatorTok{(}\NormalTok{context}\OperatorTok{);}
\NormalTok{panel}\OperatorTok{.}\FunctionTok{Children}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{widget}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Factories can also emit data templates instead of controls. For
virtualization, return a \texttt{FuncDataTemplate} that participates in
recycling.

\subsubsection{Items panel factories}\label{items-panel-factories}

\texttt{ItemsControl} allows specifying the \texttt{ItemsPanel} with
\texttt{FuncTemplate\textless{}Panel?\textgreater{}}. Build them from
code to align virtualization mode with runtime options.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{itemsControl}\OperatorTok{.}\FunctionTok{ItemsPanel} \OperatorTok{=} \KeywordTok{new}\NormalTok{ FuncTemplate}\OperatorTok{\textless{}}\NormalTok{Panel}\OperatorTok{?\textgreater{}(()} \OperatorTok{=\textgreater{}}
    \KeywordTok{new}\NormalTok{ VirtualizingStackPanel}
    \OperatorTok{\{}
\NormalTok{        Orientation }\OperatorTok{=}\NormalTok{ Orientation}\OperatorTok{.}\FunctionTok{Vertical}\OperatorTok{,}
\NormalTok{        VirtualizationMode }\OperatorTok{=}\NormalTok{ ItemVirtualizationMode}\OperatorTok{.}\FunctionTok{Simple}
    \OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

\texttt{FuncTemplate\textless{}T\textgreater{}} lives in
\texttt{external/Avalonia/src/Avalonia.Controls/Templates/FuncTemplate.cs}
and returns a new panel per items presenter.

\subsubsection{\texorpdfstring{Recycling with
\texttt{RecyclingElementFactory}}{Recycling with RecyclingElementFactory}}\label{recycling-with-recyclingelementfactory}

Avalonia's element factories provide direct control over virtualization
(see \texttt{external/Avalonia/src/Avalonia.Controls/Generators/}). You
can use \texttt{RecyclingElementFactory} and supply templates via
\texttt{IDataTemplate} implementations defined in code.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ factory }\OperatorTok{=} \KeywordTok{new}\NormalTok{ RecyclingElementFactory}
\OperatorTok{\{}
\NormalTok{    RecycleKey }\OperatorTok{=} \StringTok{"Widget"}\OperatorTok{,}
\NormalTok{    Template }\OperatorTok{=} \KeywordTok{new}\NormalTok{ FuncDataTemplate}\OperatorTok{\textless{}}\NormalTok{IWidgetViewModel}\OperatorTok{\textgreater{}((}\NormalTok{item}\OperatorTok{,}\NormalTok{ \_}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ WidgetFactory}\OperatorTok{.}\FunctionTok{CreateControl}\OperatorTok{(}\NormalTok{item}\OperatorTok{))}
\OperatorTok{\};}

\DataTypeTok{var}\NormalTok{ items }\OperatorTok{=} \KeywordTok{new}\NormalTok{ ItemsRepeater }\OperatorTok{\{}\NormalTok{ ItemTemplate }\OperatorTok{=}\NormalTok{ factory }\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

\texttt{ItemsRepeater} (in \texttt{Avalonia.Controls}) mirrors WinUI's
control. Providing a factory integrates with virtualization surfaces
better than raw \texttt{ItemsControl} in performance-sensitive
scenarios.

\subsection{7. Testing templates and
factories}\label{testing-templates-and-factories}

\begin{itemize}
\tightlist
\item
  \textbf{Unit tests}: Use \texttt{FuncDataTemplate.Build(item)} to
  materialize the control tree in memory and assert shape/values.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\NormalTok{Fact}\OperatorTok{]}
\KeywordTok{public} \DataTypeTok{void} \FunctionTok{Order\_item\_template\_renders\_quantity}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ template }\OperatorTok{=}\NormalTok{ Templates}\OperatorTok{.}\FunctionTok{OrderItem}\OperatorTok{;}
    \DataTypeTok{var}\NormalTok{ control }\OperatorTok{=} \OperatorTok{(}\NormalTok{Control}\OperatorTok{)}\NormalTok{template}\OperatorTok{.}\FunctionTok{Build}\OperatorTok{(}\KeywordTok{new}\NormalTok{ OrderItem }\OperatorTok{\{}\NormalTok{ Quantity }\OperatorTok{=} \DecValTok{5} \OperatorTok{\},} \KeywordTok{null}\OperatorTok{)!;}

\NormalTok{    control}\OperatorTok{.}\FunctionTok{GetVisualDescendants}\OperatorTok{().}\FunctionTok{OfType}\OperatorTok{\textless{}}\NormalTok{TextBlock}\OperatorTok{\textgreater{}().}\FunctionTok{Should}\OperatorTok{().}\FunctionTok{Contain}\OperatorTok{(}\NormalTok{t }\OperatorTok{=\textgreater{}}\NormalTok{ t}\OperatorTok{.}\FunctionTok{Text} \OperatorTok{==} \StringTok{"5"}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{Headless rendering}: Combine with Chapter 40 to capture
  template output bitmaps.
\item
  \textbf{Name scope checks}: After applying control templates, call
  \texttt{TemplateAppliedEventArgs.NameScope.Find} in tests to guarantee
  required parts exist.
\end{itemize}

\subsection{8. Practice lab}\label{practice-lab-3}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Card control template} -- Build a \texttt{FuncControlTemplate}
  for a \texttt{CardControl} that registers named parts, uses template
  bindings for background/content, and applies to multiple instances
  with different content.
\item
  \textbf{Conditional data templates} -- Create templates for
  \texttt{IssueViewModel} that render differently based on
  \texttt{IsClosed}. Swap templates dynamically by changing a property
  on the view-model.
\item
  \textbf{Hierarchical explorer} -- Compose a \texttt{TreeView} for file
  system data using \texttt{FuncTreeDataTemplate}, including icons and
  lazy loading. Ensure child collections load on demand.
\item
  \textbf{Template factory registry} -- Implement a registry of
  \texttt{IDataTemplate} factories keyed by type names. Resolve
  templates at runtime and verify virtualization with an
  \texttt{ItemsRepeater} in a headless test.
\item
  \textbf{Template swap diagnostics} -- Write a helper that re-applies
  templates when theme changes occur, logging how many presenters were
  updated. Ensure the log stays small by limiting scope to affected
  regions.
\end{enumerate}

By mastering code-based templates, indexers, and factories, you gain
full control over Avalonia's presentation layer without depending on
XAML. Combine these techniques with the binding and layout patterns from
earlier chapters to build highly dynamic, testable UI modules in pure
C\#.

What's next - Next: \href{Chapter37.md}{Chapter37}

\newpage

\subsection{37. Reactive patterns, helpers, and tooling for code-first
teams}\label{reactive-patterns-helpers-and-tooling-for-code-first-teams}

Goal - Combine Avalonia's property system with reactive libraries
(ReactiveUI, DynamicData) entirely from C\#. - Build helper extensions
for behaviours, pseudo-classes, transitions, and animation triggers
without XAML. - Integrate diagnostics and hot-reload-style tooling that
keeps developer loops tight in code-first workflows.

Why this matters - Code-first projects often favour reactive patterns to
keep UI logic composable and testable. - Avalonia exposes rich helper
APIs (\texttt{Classes}, \texttt{PseudoClasses}, \texttt{Transitions},
\texttt{Interaction}) that work perfectly in C\# once you know where to
look. - Tooling such as DevTools, live reload, and logging remain
essential even without XAML; wiring them programmatically ensures parity
with markup-heavy projects.

Prerequisites - Chapter 33--36 for code-first startup, layouts,
bindings, and templates. - Chapter 29 (animations) and Chapter 24
(DevTools) for background on transitions and diagnostics. - Working
familiarity with ReactiveUI/DynamicData if you plan to reuse those
patterns.

\subsection{1. Reactive building blocks in
Avalonia}\label{reactive-building-blocks-in-avalonia}

Avalonia's property system already supports observables.
\texttt{AvaloniaObject} exposes \texttt{GetObservable} and
\texttt{GetPropertyChangedObservable} so you can build reactive
pipelines without XAML triggers.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ textBox }\OperatorTok{=} \KeywordTok{new} \FunctionTok{TextBox}\OperatorTok{();}
\NormalTok{textBox}\OperatorTok{.}\FunctionTok{GetObservable}\OperatorTok{(}\NormalTok{TextBox}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{Throttle}\OperatorTok{(}\NormalTok{TimeSpan}\OperatorTok{.}\FunctionTok{FromMilliseconds}\OperatorTok{(}\DecValTok{250}\OperatorTok{),}\NormalTok{ RxApp}\OperatorTok{.}\FunctionTok{MainThreadScheduler}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{DistinctUntilChanged}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{text }\OperatorTok{=\textgreater{}}\NormalTok{ \_search}\OperatorTok{.}\FunctionTok{Execute}\OperatorTok{(}\NormalTok{text}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Use \texttt{ObserveOn(RxApp.MainThreadScheduler)} to marshal onto the UI
thread when subscribing. For non-ReactiveUI projects, use
\texttt{DispatcherScheduler.Current} (from \texttt{Avalonia.Reactive})
or \texttt{Dispatcher.UIThread.InvokeAsync} inside the observer.

\subsubsection{Connecting to ReactiveUI
view-models}\label{connecting-to-reactiveui-view-models}

ReactiveUI view-models usually expose \texttt{ReactiveCommand} and
\texttt{ObservableAsPropertyHelper}. Bind them as usual, but you can
also subscribe directly:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ vm }\OperatorTok{=} \KeywordTok{new} \FunctionTok{DashboardViewModel}\OperatorTok{();}
\NormalTok{vm}\OperatorTok{.}\FunctionTok{WhenAnyValue}\OperatorTok{(}\NormalTok{x }\OperatorTok{=\textgreater{}}\NormalTok{ x}\OperatorTok{.}\FunctionTok{IsLoading}\OperatorTok{)}
  \OperatorTok{.}\FunctionTok{ObserveOn}\OperatorTok{(}\NormalTok{RxApp}\OperatorTok{.}\FunctionTok{MainThreadScheduler}\OperatorTok{)}
  \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{isLoading }\OperatorTok{=\textgreater{}}\NormalTok{ spinner}\OperatorTok{.}\FunctionTok{IsVisible} \OperatorTok{=}\NormalTok{ isLoading}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{WhenAnyValue} is extension from \texttt{ReactiveUI}. For
code-first views, you may bridge them via constructor injection,
ensuring the view wires observable pipelines in its constructor or
\texttt{OnAttachedToVisualTree} lifecycle methods.

\subsubsection{DynamicData for
collections}\label{dynamicdata-for-collections}

DynamicData shines when projecting observable collections into
UI-friendly lists.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ source }\OperatorTok{=} \KeywordTok{new}\NormalTok{ SourceList}\OperatorTok{\textless{}}\NormalTok{ItemViewModel}\OperatorTok{\textgreater{}();}
\DataTypeTok{var}\NormalTok{ bindingList }\OperatorTok{=}\NormalTok{ source}\OperatorTok{.}\FunctionTok{Connect}\OperatorTok{()}
    \OperatorTok{.}\FunctionTok{Filter}\OperatorTok{(}\NormalTok{item }\OperatorTok{=\textgreater{}}\NormalTok{ item}\OperatorTok{.}\FunctionTok{IsEnabled}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{Sort}\OperatorTok{(}\NormalTok{SortExpressionComparer}\OperatorTok{\textless{}}\NormalTok{ItemViewModel}\OperatorTok{\textgreater{}.}\FunctionTok{Descending}\OperatorTok{(}\NormalTok{x }\OperatorTok{=\textgreater{}}\NormalTok{ x}\OperatorTok{.}\FunctionTok{CreatedAt}\OperatorTok{))}
    \OperatorTok{.}\FunctionTok{ObserveOn}\OperatorTok{(}\NormalTok{RxApp}\OperatorTok{.}\FunctionTok{MainThreadScheduler}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{Bind}\OperatorTok{(}\KeywordTok{out} \DataTypeTok{var}\NormalTok{ items}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{();}

\NormalTok{listBox}\OperatorTok{.}\FunctionTok{Items} \OperatorTok{=}\NormalTok{ items}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Dispose the subscription when the control unloads to prevent leaks
(e.g., store \texttt{IDisposable} and dispose in
\texttt{DetachedFromVisualTree}).

\subsection{\texorpdfstring{2. Working with \texttt{Classes} and
\texttt{PseudoClasses}}{2. Working with Classes and PseudoClasses}}\label{working-with-classes-and-pseudoclasses}

\texttt{Classes} and \texttt{PseudoClasses} collections (defined in
\texttt{Avalonia.Styling}) let you toggle CSS-like states entirely from
C\#.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ panel }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Border}\OperatorTok{();}
\NormalTok{panel}\OperatorTok{.}\FunctionTok{Classes}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\StringTok{"card"}\OperatorTok{);} \CommentTok{// corresponds to :class selectors in styles}

\NormalTok{panel}\OperatorTok{.}\FunctionTok{PseudoClasses}\OperatorTok{.}\FunctionTok{Set}\OperatorTok{(}\StringTok{":active"}\OperatorTok{,} \KeywordTok{true}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Use helpers to line up state changes with view-model events:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vm}\OperatorTok{.}\FunctionTok{WhenAnyValue}\OperatorTok{(}\NormalTok{x }\OperatorTok{=\textgreater{}}\NormalTok{ x}\OperatorTok{.}\FunctionTok{IsSelected}\OperatorTok{)}
  \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{selected }\OperatorTok{=\textgreater{}}\NormalTok{ panel}\OperatorTok{.}\FunctionTok{Classes}\OperatorTok{.}\FunctionTok{Toggle}\OperatorTok{(}\StringTok{"selected"}\OperatorTok{,}\NormalTok{ selected}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

\texttt{Toggle} is an extension you can write:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ ClassExtensions}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static} \DataTypeTok{void} \FunctionTok{Toggle}\OperatorTok{(}\KeywordTok{this}\NormalTok{ Classes classes}\OperatorTok{,} \DataTypeTok{string}\NormalTok{ name}\OperatorTok{,} \DataTypeTok{bool}\NormalTok{ add}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{add}\OperatorTok{)}
\NormalTok{            classes}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{name}\OperatorTok{);}
        \KeywordTok{else}
\NormalTok{            classes}\OperatorTok{.}\FunctionTok{Remove}\OperatorTok{(}\NormalTok{name}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Behaviours from
\texttt{Avalonia.Interactivity}}{Behaviours from Avalonia.Interactivity}}\label{behaviours-from-avalonia.interactivity}

\texttt{Interaction} (in
\texttt{external/Avalonia/src/Avalonia.Interactivity/Interaction.cs})
provides behaviour collections similar to WPF. You can attach behaviours
programmatically via \texttt{Interaction.SetBehaviors}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Interaction}\OperatorTok{.}\FunctionTok{SetBehaviors}\OperatorTok{(}\NormalTok{listBox}\OperatorTok{,} \KeywordTok{new}\NormalTok{ BehaviorCollection}
\OperatorTok{\{}
    \KeywordTok{new} \FunctionTok{SelectOnPointerOverBehavior}\OperatorTok{()}
\OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

Behaviours are regular classes implementing \texttt{IBehavior}. Author
your own to encapsulate complex logic like drag-to-reorder.

\subsection{3. Transitions, animations, and reactive
triggers}\label{transitions-animations-and-reactive-triggers}

\texttt{Transitions} collection (from \texttt{Avalonia.Animation}) lives
on \texttt{Control}. Build transitions and hook them dynamically.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{panel}\OperatorTok{.}\FunctionTok{Transitions} \OperatorTok{=} \KeywordTok{new}\NormalTok{ Transitions}
\OperatorTok{\{}
    \KeywordTok{new}\NormalTok{ DoubleTransition}
    \OperatorTok{\{}
\NormalTok{        Property }\OperatorTok{=}\NormalTok{ Border}\OperatorTok{.}\FunctionTok{OpacityProperty}\OperatorTok{,}
\NormalTok{        Duration }\OperatorTok{=}\NormalTok{ TimeSpan}\OperatorTok{.}\FunctionTok{FromMilliseconds}\OperatorTok{(}\DecValTok{200}\OperatorTok{),}
\NormalTok{        Easing }\OperatorTok{=} \KeywordTok{new} \FunctionTok{CubicEaseOut}\OperatorTok{()}
    \OperatorTok{\}}
\OperatorTok{\};}
\end{Highlighting}
\end{Shaded}

Activate transitions via property setters:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vm}\OperatorTok{.}\FunctionTok{WhenAnyValue}\OperatorTok{(}\NormalTok{x }\OperatorTok{=\textgreater{}}\NormalTok{ x}\OperatorTok{.}\FunctionTok{ShowDetails}\OperatorTok{)}
  \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{show }\OperatorTok{=\textgreater{}}\NormalTok{ panel}\OperatorTok{.}\FunctionTok{Opacity} \OperatorTok{=}\NormalTok{ show }\OperatorTok{?} \DecValTok{1} \OperatorTok{:} \DecValTok{0}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

The change triggers the transition. Because transitions live on the
control, you can swap them per theme or feature by replacing the
\texttt{Transitions} collection at runtime.

\subsubsection{Animation helpers}\label{animation-helpers}

\texttt{Animatable.BeginAnimation} (from \texttt{AnimationExtensions})
lets you trigger storyboards without styles:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{panel}\OperatorTok{.}\FunctionTok{BeginAnimation}\OperatorTok{(}\NormalTok{Border}\OperatorTok{.}\FunctionTok{OpacityProperty}\OperatorTok{,} \KeywordTok{new}\NormalTok{ Animation}
\OperatorTok{\{}
\NormalTok{    Duration }\OperatorTok{=}\NormalTok{ TimeSpan}\OperatorTok{.}\FunctionTok{FromMilliseconds}\OperatorTok{(}\DecValTok{400}\OperatorTok{),}
\NormalTok{    Easing }\OperatorTok{=} \KeywordTok{new} \FunctionTok{SineEaseInOut}\OperatorTok{(),}
\NormalTok{    Children }\OperatorTok{=}
    \OperatorTok{\{}
        \KeywordTok{new}\NormalTok{ KeyFrames}
        \OperatorTok{\{}
            \KeywordTok{new}\NormalTok{ KeyFrame }\OperatorTok{\{}\NormalTok{ Cue }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Cue}\OperatorTok{(}\DecValTok{0}\NormalTok{d}\OperatorTok{),}\NormalTok{ Setters }\OperatorTok{=} \OperatorTok{\{} \KeywordTok{new} \FunctionTok{Setter}\OperatorTok{(}\NormalTok{Border}\OperatorTok{.}\FunctionTok{OpacityProperty}\OperatorTok{,} \DecValTok{0}\NormalTok{d}\OperatorTok{)} \OperatorTok{\}} \OperatorTok{\},}
            \KeywordTok{new}\NormalTok{ KeyFrame }\OperatorTok{\{}\NormalTok{ Cue }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Cue}\OperatorTok{(}\DecValTok{1}\NormalTok{d}\OperatorTok{),}\NormalTok{ Setters }\OperatorTok{=} \OperatorTok{\{} \KeywordTok{new} \FunctionTok{Setter}\OperatorTok{(}\NormalTok{Border}\OperatorTok{.}\FunctionTok{OpacityProperty}\OperatorTok{,} \DecValTok{1}\NormalTok{d}\OperatorTok{)} \OperatorTok{\}} \OperatorTok{\}}
        \OperatorTok{\}}
    \OperatorTok{\}}
\OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

Encapsulate animations into factory methods for reuse across views.

\subsection{4. Hot reload and state persistence
helpers}\label{hot-reload-and-state-persistence-helpers}

While Avalonia's XAML Previewer focuses on markup, code-first workflows
can approximate hot reload using: - \textbf{\texttt{DevTools}}:
\texttt{AttachDevTools()} on the main window or \texttt{AppBuilder} (see
\texttt{ApplicationLifetimes}). - \textbf{\texttt{Avalonia.ReactiveUI}
HotReload} packages or community tooling for reloading compiled
assemblies. - \textbf{State persistence}: store view-model state in
services to rehydrate UI after code changes.

Enable DevTools programmatically in debug builds:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \OperatorTok{(}\NormalTok{Debugger}\OperatorTok{.}\FunctionTok{IsAttached}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{this}\OperatorTok{.}\FunctionTok{AttachDevTools}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

For headless tests, log control trees after creation to confirm state
without UI.

\subsection{5. Diagnostics pipelines}\label{diagnostics-pipelines}

Integrate logging by observing key properties and commands.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ subscription }\OperatorTok{=}\NormalTok{ panel}\OperatorTok{.}\FunctionTok{GetPropertyChangedObservable}\OperatorTok{(}\NormalTok{Border}\OperatorTok{.}\FunctionTok{OpacityProperty}\OperatorTok{)}
    \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{args }\OperatorTok{=\textgreater{}}\NormalTok{ \_logger}\OperatorTok{.}\FunctionTok{Debug}\OperatorTok{(}\StringTok{"Opacity changed from \{Old\} to \{New\}"}\OperatorTok{,}\NormalTok{ args}\OperatorTok{.}\FunctionTok{OldValue}\OperatorTok{,}\NormalTok{ args}\OperatorTok{.}\FunctionTok{NewValue}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Tie into Avalonia's diagnostics overlays (Chapter 24) by enabling them
in code-first startup:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{if} \OperatorTok{(}\NormalTok{Debugger}\OperatorTok{.}\FunctionTok{IsAttached}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    RenderOptions}\OperatorTok{.}\FunctionTok{ProcessRenderOperations} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
\NormalTok{    RendererDiagnostics}\OperatorTok{.}\FunctionTok{DebugOverlays} \OperatorTok{=}\NormalTok{ RendererDebugOverlays}\OperatorTok{.}\FunctionTok{Fps} \OperatorTok{|}\NormalTok{ RendererDebugOverlays}\OperatorTok{.}\FunctionTok{Layout}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{6. Putting it together: Building reusable helper
libraries}\label{putting-it-together-building-reusable-helper-libraries}

Create a shared library of helpers tailored to your code-first patterns:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ ReactiveControlHelpers}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ IDisposable BindState}\OperatorTok{\textless{}}\NormalTok{TViewModel}\OperatorTok{\textgreater{}(}\KeywordTok{this}\NormalTok{ TViewModel vm}\OperatorTok{,}\NormalTok{ Control control}\OperatorTok{,}
\NormalTok{        Expression}\OperatorTok{\textless{}}\NormalTok{Func}\OperatorTok{\textless{}}\NormalTok{TViewModel}\OperatorTok{,} \DataTypeTok{bool}\OperatorTok{\textgreater{}\textgreater{}}\NormalTok{ property}\OperatorTok{,} \DataTypeTok{string}\NormalTok{ pseudoClass}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{return}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{WhenAnyValue}\OperatorTok{(}\NormalTok{property}\OperatorTok{)}
            \OperatorTok{.}\FunctionTok{ObserveOn}\OperatorTok{(}\NormalTok{RxApp}\OperatorTok{.}\FunctionTok{MainThreadScheduler}\OperatorTok{)}
            \OperatorTok{.}\FunctionTok{Subscribe}\OperatorTok{(}\NormalTok{value }\OperatorTok{=\textgreater{}}\NormalTok{ control}\OperatorTok{.}\FunctionTok{PseudoClasses}\OperatorTok{.}\FunctionTok{Set}\OperatorTok{(}\NormalTok{pseudoClass}\OperatorTok{,}\NormalTok{ value}\OperatorTok{));}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Use it in views:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\_disposables}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\NormalTok{vm}\OperatorTok{.}\FunctionTok{BindState}\OperatorTok{(}\KeywordTok{this}\OperatorTok{,}\NormalTok{ x }\OperatorTok{=\textgreater{}}\NormalTok{ x}\OperatorTok{.}\FunctionTok{IsActive}\OperatorTok{,} \StringTok{":active"}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

Maintain a \texttt{CompositeDisposable} on the view to dispose
subscriptions when the view unloads. Override
\texttt{OnAttachedToVisualTree}/\texttt{OnDetachedFromVisualTree} to
manage lifetime.

\subsection{7. Practice lab}\label{practice-lab-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Reactive state toggles} -- Implement a helper that watches
  \texttt{WhenAnyValue} on a view-model and toggles \texttt{Classes} on
  a panel. Verify with headless tests that pseudo-class changes
  propagate to styles.
\item
  \textbf{Transition kit} -- Build a factory returning
  \texttt{Transitions} configured per theme (e.g., fast vs.~slow). Swap
  collections at runtime and instrument the effect with property
  observers.
\item
  \textbf{Behavior registry} -- Create a behaviour that wires
  \texttt{PointerMoved} events into an observable stream. Use it to
  implement drag selection without code-behind duplication.
\item
  \textbf{Diagnostic dashboard} -- Add DevTools and renderer overlays
  programmatically. Expose a keyboard shortcut (ReactiveCommand) that
  toggles them during development.
\item
  \textbf{Hot reload simulation} -- Persist view-model state to a
  service, tear down the view, rebuild it from code, and reapply state
  to mimic live-edit workflows. Assert via unit test that state survives
  the rebuild.
\end{enumerate}

Reactive helper patterns ensure code-first Avalonia apps stay
expressive, maintainable, and observable. By leveraging observables,
behaviours, transitions, and tooling APIs directly from C\#, your team
keeps the productivity of markup-driven workflows while embracing the
flexibility of a single-language stack.

What's next - Next: \href{Chapter38.md}{Chapter38}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part VIII — Headless unit testing that gives confidence}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part VIII — Headless unit testing that gives confidence}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{38. Headless platform fundamentals and
lifetimes}\label{headless-platform-fundamentals-and-lifetimes}

Goal - Run Avalonia apps without a windowing system so tests, previews,
and automation can execute in CI. - Configure headless lifetimes,
services, and render loops to mimic production behaviour while remaining
deterministic. - Understand the knobs provided by
\texttt{Avalonia.Headless} so you can toggle Skia rendering, timers, and
focus/input handling on demand.

Why this matters - Headless execution unlocks fast feedback loops:
BDD/UI unit tests, snapshot rendering, and tooling all rely on it. - CI
agents rarely expose desktops or GPUs; the headless backend gives you a
predictable environment across Windows, macOS, and Linux. - Knowing the
lifetimes and options ensures app startup mirrors real
targets---preventing bugs that only appear when the full desktop
lifetime runs.

Prerequisites - Chapter 4 (startup and lifetimes) for the
\texttt{AppBuilder} pipeline. - Chapter 33 (code-first startup) for
wiring services/resources without XAML. - Chapter 21 (Headless and
testing overview) for the bigger picture of test tooling.

\subsection{1. Meet the headless
platform}\label{meet-the-headless-platform}

The headless backend lives in
\texttt{external/Avalonia/src/Headless/Avalonia.Headless}. You enable it
by calling \texttt{UseHeadless()} on \texttt{AppBuilder}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Headless}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Themes}\OperatorTok{.}\FunctionTok{Fluent}\OperatorTok{;}

\KeywordTok{public} \KeywordTok{static} \KeywordTok{class}\NormalTok{ Program}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{static}\NormalTok{ AppBuilder }\FunctionTok{BuildAvaloniaApp}\OperatorTok{(}\DataTypeTok{bool}\NormalTok{ enableSkia }\OperatorTok{=} \KeywordTok{false}\OperatorTok{)}
        \OperatorTok{=\textgreater{}}\NormalTok{ AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}()}
            \OperatorTok{.}\FunctionTok{UseHeadless}\OperatorTok{(}\KeywordTok{new}\NormalTok{ AvaloniaHeadlessPlatformOptions}
            \OperatorTok{\{}
\NormalTok{                UseHeadlessDrawing }\OperatorTok{=} \OperatorTok{!}\NormalTok{enableSkia}\OperatorTok{,}
\NormalTok{                UseSkia }\OperatorTok{=}\NormalTok{ enableSkia}\OperatorTok{,}
\NormalTok{                AllowEglInitialization }\OperatorTok{=} \KeywordTok{false}\OperatorTok{,}
\NormalTok{                PreferDispatcherScheduling }\OperatorTok{=} \KeywordTok{true}
            \OperatorTok{\})}
            \OperatorTok{.}\FunctionTok{LogToTrace}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Key extension: \texttt{AvaloniaHeadlessAppBuilderExtensions.UseHeadless}
registers platform services, render loop, and input plumbing. Options: -
\texttt{UseHeadlessDrawing}: if \texttt{true}, renders to an in-memory
framebuffer without Skia. - \texttt{UseSkia}: when \texttt{true}, create
a Skia GPU context (requires \texttt{UseHeadlessDrawing\ =\ false}). -
\texttt{AllowEglInitialization}: opt-in to EGL for hardware acceleration
when available. - \texttt{PreferDispatcherScheduling}: ensures timers
queue work via \texttt{Dispatcher} instead of busy loops.

Because \texttt{UseHeadless()} skips \texttt{UsePlatformDetect()}, call
it explicitly in tests. For hybrid apps, provide a
\texttt{BuildAvaloniaApp} overload that chooses headless vs.~desktop
based on environment.

\subsection{2. Lifetimes built for
tests}\label{lifetimes-built-for-tests}

Headless apps use \texttt{HeadlessLifetime} (see
\texttt{Avalonia.Headless/HeadlessLifetime.cs}). It mimics
\texttt{IClassicDesktopStyleApplicationLifetime} but never opens OS
windows.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ TestApp }\OperatorTok{:}\NormalTok{ Application}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{if} \OperatorTok{(}\NormalTok{ApplicationLifetime }\KeywordTok{is}\NormalTok{ HeadlessLifetime lifetime}\OperatorTok{)}
        \OperatorTok{\{}
\NormalTok{            lifetime}\OperatorTok{.}\FunctionTok{MainView} \OperatorTok{=} \KeywordTok{new}\NormalTok{ MainView }\OperatorTok{\{}\NormalTok{ DataContext }\OperatorTok{=} \KeywordTok{new} \FunctionTok{MainViewModel}\OperatorTok{()} \OperatorTok{\};}
        \OperatorTok{\}}

        \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{();}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{HeadlessLifetime} exposes: - \texttt{MainView}: root visual
displayed inside the headless window implementation. - \texttt{Start()},
\texttt{Stop()}: manual control for test harnesses. -
\texttt{Parameters}: mirrors command-line args.

You can also use \texttt{SingleViewLifetime}
(\texttt{Avalonia.Controls/ApplicationLifetimes/ISingleViewApplicationLifetime.cs})
for mobile-like scenarios. Headless tests frequently wire both so code
mirrors production flows.

\subsubsection{Switching lifetimes per
environment}\label{switching-lifetimes-per-environment}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ builder }\OperatorTok{=}\NormalTok{ Program}\OperatorTok{.}\FunctionTok{BuildAvaloniaApp}\OperatorTok{(}\NormalTok{enableSkia}\OperatorTok{:} \KeywordTok{true}\OperatorTok{);}

\KeywordTok{if} \OperatorTok{(}\NormalTok{RuntimeInformation}\OperatorTok{.}\FunctionTok{IsOSPlatform}\OperatorTok{(}\NormalTok{OSPlatform}\OperatorTok{.}\FunctionTok{Linux}\OperatorTok{)} \OperatorTok{\&\&}\NormalTok{ IsCiAgent}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    builder}\OperatorTok{.}\FunctionTok{SetupWithoutStarting}\OperatorTok{();}
    \KeywordTok{using} \DataTypeTok{var}\NormalTok{ lifetime }\OperatorTok{=} \KeywordTok{new} \FunctionTok{HeadlessLifetime}\OperatorTok{();}
\NormalTok{    builder}\OperatorTok{.}\FunctionTok{Instance}\OperatorTok{?.}\FunctionTok{ApplicationLifetime} \OperatorTok{=}\NormalTok{ lifetime}\OperatorTok{;}
\NormalTok{    lifetime}\OperatorTok{.}\FunctionTok{Start}\OperatorTok{();}
\OperatorTok{\}}
\KeywordTok{else}
\OperatorTok{\{}
\NormalTok{    builder}\OperatorTok{.}\FunctionTok{StartWithClassicDesktopLifetime}\OperatorTok{(}\NormalTok{args}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{SetupWithoutStarting()} (from \texttt{AppBuilderBase})
initializes the app without running the run loop, allowing you to plug
in custom lifetimes.

\subsection{3. Headless application sessions for test
frameworks}\label{headless-application-sessions-for-test-frameworks}

\texttt{HeadlessUnitTestSession} (source:
\texttt{Avalonia.Headless/HeadlessUnitTestSession.cs}) coordinates app
startup across tests so each fixture doesn't rebuild the runtime.

\subsubsection{NUnit integration}\label{nunit-integration}

\texttt{Avalonia.Headless.NUnit} ships attributes
(\texttt{{[}AvaloniaTest{]}}, \texttt{{[}AvaloniaTheory{]}}) that wrap
tests in a session. Example test fixture:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\FunctionTok{AvaloniaTest}\OperatorTok{(}\NormalTok{Application }\OperatorTok{=} \KeywordTok{typeof}\OperatorTok{(}\NormalTok{TestApp}\OperatorTok{))]}
\KeywordTok{public} \KeywordTok{class}\NormalTok{ CounterTests}
\OperatorTok{\{}
    \OperatorTok{[}\NormalTok{Test}\OperatorTok{]}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Clicking\_increment\_updates\_label}\OperatorTok{()}
    \OperatorTok{\{}
        \KeywordTok{using} \DataTypeTok{var}\NormalTok{ app }\OperatorTok{=}\NormalTok{ HeadlessUnitTestSession}\OperatorTok{.}\FunctionTok{Start}\OperatorTok{\textless{}}\NormalTok{App}\OperatorTok{\textgreater{}();}
        \DataTypeTok{var}\NormalTok{ window }\OperatorTok{=} \KeywordTok{new}\NormalTok{ MainWindow }\OperatorTok{\{}\NormalTok{ DataContext }\OperatorTok{=} \KeywordTok{new} \FunctionTok{MainViewModel}\OperatorTok{()} \OperatorTok{\};}
\NormalTok{        window}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{();}

\NormalTok{        window}\OperatorTok{.}\FunctionTok{FindControl}\OperatorTok{\textless{}}\NormalTok{Button}\OperatorTok{\textgreater{}(}\StringTok{"IncrementButton"}\OperatorTok{)!.}\FunctionTok{RaiseEvent}\OperatorTok{(}\KeywordTok{new} \FunctionTok{RoutedEventArgs}\OperatorTok{(}\NormalTok{Button}\OperatorTok{.}\FunctionTok{ClickEvent}\OperatorTok{));}

\NormalTok{        window}\OperatorTok{.}\FunctionTok{FindControl}\OperatorTok{\textless{}}\NormalTok{TextBlock}\OperatorTok{\textgreater{}(}\StringTok{"CounterLabel"}\OperatorTok{)!.}\FunctionTok{Text}\OperatorTok{.}\FunctionTok{Should}\OperatorTok{().}\FunctionTok{Be}\OperatorTok{(}\StringTok{"1"}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{HeadlessUnitTestSession.Start\textless{}TApp\textgreater{}()}
spins up the shared app and dispatcher. \texttt{FindControl} works
because the visual tree exists even though no OS window renders.

\subsubsection{xUnit integration}\label{xunit-integration}

\texttt{Avalonia.Headless.XUnit} provides \texttt{{[}AvaloniaFact{]}}
and \texttt{{[}AvaloniaTheory{]}} attributes. Decorate your test class
with \texttt{{[}CollectionDefinition{]}} to ensure single app instance
per collection when running in parallel.

\subsection{4. Dispatcher, render loops, and
timing}\label{dispatcher-render-loops-and-timing}

Headless rendering still uses Avalonia's dispatcher and render loop.
\texttt{HeadlessWindowImpl} (source:
\texttt{Avalonia.Headless/HeadlessWindowImpl.cs}) implements
\texttt{IWindowImpl} with an in-memory framebuffer. Understanding its
behaviour is crucial for deterministic tests.

\subsubsection{Forcing layout/render
ticks}\label{forcing-layoutrender-ticks}

Headless tests don't run an infinite loop unless you start it. Use
\texttt{AvaloniaHeadlessPlatform.ForceRenderTimerTick()} to advance
timers manually.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static} \DataTypeTok{void} \FunctionTok{RenderFrame}\OperatorTok{(}\NormalTok{TopLevel topLevel}\OperatorTok{)}
\OperatorTok{\{}
\NormalTok{    AvaloniaHeadlessPlatform}\OperatorTok{.}\FunctionTok{ForceRenderTimerTick}\OperatorTok{();}
\NormalTok{    topLevel}\OperatorTok{.}\FunctionTok{RunJobsOnMainThread}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{RunJobsOnMainThread()} is a helper extension defined in
\texttt{HeadlessWindowExtensions}. It drains pending dispatcher work and
ensures layout/render happens before assertions.

\subsubsection{Simulating async work}\label{simulating-async-work}

Combine \texttt{Dispatcher.UIThread.InvokeAsync} with
\texttt{ForceRenderTimerTick} to await UI updates:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{await Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{InvokeAsync}\OperatorTok{(()} \OperatorTok{=\textgreater{}}\NormalTok{ viewModel}\OperatorTok{.}\FunctionTok{LoadAsync}\OperatorTok{());}
\NormalTok{AvaloniaHeadlessPlatform}\OperatorTok{.}\FunctionTok{ForceRenderTimerTick}\OperatorTok{();}
\end{Highlighting}
\end{Shaded}

In tests, call \texttt{Dispatcher.UIThread.RunJobs()} to flush pending
tasks (extension in \texttt{Avalonia.Headless} as well).

\subsection{5. Input, focus, and window
services}\label{input-focus-and-window-services}

\texttt{HeadlessWindowImpl} implements \texttt{IHeadlessWindow},
exposing methods to simulate input:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ topLevel }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Window}\OperatorTok{();}
\DataTypeTok{var}\NormalTok{ headless }\OperatorTok{=} \OperatorTok{(}\NormalTok{IHeadlessWindow}\OperatorTok{)}\NormalTok{topLevel}\OperatorTok{.}\FunctionTok{PlatformImpl}\OperatorTok{!;}

\NormalTok{headless}\OperatorTok{.}\FunctionTok{MouseMove}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{50}\OperatorTok{,} \DecValTok{30}\OperatorTok{),}\NormalTok{ RawInputModifiers}\OperatorTok{.}\FunctionTok{None}\OperatorTok{);}
\NormalTok{headless}\OperatorTok{.}\FunctionTok{MouseDown}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{50}\OperatorTok{,} \DecValTok{30}\OperatorTok{),}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{,}\NormalTok{ RawInputModifiers}\OperatorTok{.}\FunctionTok{LeftMouseButton}\OperatorTok{);}
\NormalTok{headless}\OperatorTok{.}\FunctionTok{MouseUp}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{50}\OperatorTok{,} \DecValTok{30}\OperatorTok{),}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{,}\NormalTok{ RawInputModifiers}\OperatorTok{.}\FunctionTok{LeftMouseButton}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Use extension methods from \texttt{HeadlessWindowExtensions} (e.g.,
\texttt{Click(Point)}) to simplify. Focus management works: call
\texttt{topLevel.Focus()} or
\texttt{KeyboardDevice.Instance.SetFocusedElement}.

Services like storage providers or dialogs aren't available by default.
If your app depends on them, register test doubles in
\texttt{Application.RegisterServices()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{RegisterServices}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ services }\OperatorTok{=}\NormalTok{ AvaloniaLocator}\OperatorTok{.}\FunctionTok{CurrentMutable}\OperatorTok{;}
\NormalTok{    services}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{\textless{}}\NormalTok{IPlatformLifetimeEvents}\OperatorTok{\textgreater{}().}\FunctionTok{ToConstant}\OperatorTok{(}\KeywordTok{new} \FunctionTok{TestLifetimeEvents}\OperatorTok{());}
\NormalTok{    services}\OperatorTok{.}\FunctionTok{Bind}\OperatorTok{\textless{}}\NormalTok{IClipboard}\OperatorTok{\textgreater{}().}\FunctionTok{ToSingleton}\OperatorTok{\textless{}}\NormalTok{HeadlessClipboard}\OperatorTok{\textgreater{}();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{Avalonia.Headless} already provides \texttt{HeadlessClipboard},
\texttt{HeadlessCursorFactory}, and other minimal implementations;
inspect \texttt{Avalonia.Headless} folder for available services before
writing your own.

\subsection{6. Rendering options and Skia
integration}\label{rendering-options-and-skia-integration}

By default headless renders via CPU copy. To generate bitmaps (Chapter
40), enable Skia:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ builder }\OperatorTok{=}\NormalTok{ Program}\OperatorTok{.}\FunctionTok{BuildAvaloniaApp}\OperatorTok{(}\NormalTok{enableSkia}\OperatorTok{:} \KeywordTok{true}\OperatorTok{);}
\DataTypeTok{var}\NormalTok{ options }\OperatorTok{=}\NormalTok{ AvaloniaLocator}\OperatorTok{.}\FunctionTok{Current}\OperatorTok{.}\FunctionTok{GetService}\OperatorTok{\textless{}}\NormalTok{AvaloniaHeadlessPlatformOptions}\OperatorTok{\textgreater{}();}
\end{Highlighting}
\end{Shaded}

When \texttt{UseSkia} is true, the backend creates a Skia surface per
frame. Ensure the CI environment has the necessary native dependencies
(\texttt{libSkiaSharp}). If you stick with
\texttt{UseHeadlessDrawing\ =\ true}, \texttt{RenderTargetBitmap} still
works but without GPU acceleration.

\texttt{HeadlessWindowExtensions.CaptureRenderedFrame(topLevel)}
captures an \texttt{IBitmap} of the latest frame---use it for snapshot
tests.

\subsection{7. Troubleshooting common
issues}\label{troubleshooting-common-issues}

\begin{itemize}
\tightlist
\item
  \textbf{App not initialized}: Ensure
  \texttt{AppBuilder.Configure\textless{}App\textgreater{}()} runs
  before calling \texttt{HeadlessUnitTestSession.Start}. Missing static
  constructor often stems from trimming or linking; mark entry point
  classes with \texttt{{[}assembly:\ RequiresUnreferencedCode{]}} if
  needed.
\item
  \textbf{Dispatcher deadlocks}: Always schedule UI work via
  \texttt{Dispatcher.UIThread}. If a test blocks the UI thread, there's
  no OS event loop to bail you out.
\item
  \textbf{Missing services}: Headless backend only registers core
  services. Provide mocks for file dialogs, storage, or notifications.
\item
  \textbf{Time-dependent tests}: When using timers, call
  \texttt{ForceRenderTimerTick} repeatedly or provide deterministic
  scheduler wrappers.
\item
  \textbf{Memory leaks}: Dispose windows (\texttt{window.Close()}) and
  subscriptions (\texttt{CompositeDisposable}) after each
  test---headless sessions persist across multiple tests by default.
\end{itemize}

\subsection{8. Practice lab}\label{practice-lab-5}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Headless bootstrap} -- Build a reusable
  \texttt{HeadlessTestApplication} that mirrors your production
  \texttt{App} styles/resources. Verify service registration via unit
  tests that resolve dependencies from \texttt{AvaloniaLocator}.
\item
  \textbf{Lifetime switcher} -- Write a helper that starts your app with
  \texttt{HeadlessLifetime} when \texttt{DOTNET\_RUNNING\_IN\_CONTAINER}
  is set. Assert via tests that both classic desktop and headless
  lifetimes share the same \texttt{OnFrameworkInitializationCompleted}
  flow.
\item
  \textbf{Deterministic render loop} -- Create a headless fixture that
  mounts a view, updates the view-model, calls
  \texttt{ForceRenderTimerTick}, and asserts layout/visual changes with
  zero sleeps.
\item
  \textbf{Input harness} -- Implement extensions wrapping
  \texttt{IHeadlessWindow} for click, drag, and keyboard simulation. Use
  them to test complex interactions (drag-to-reorder list) without real
  input devices.
\item
  \textbf{Service fallback} -- Provide headless implementations for
  storage provider and clipboard, inject them in
  \texttt{RegisterServices}, and write tests asserting your UI handles
  success/failure cases.
\end{enumerate}

Mastering the headless platform ensures Avalonia apps stay testable,
portable, and CI-friendly. With lifetimes, options, and input surfaces
under your control, you can script rich UI scenarios without ever
opening an OS window.

What's next - Next: \href{Chapter39.md}{Chapter39}

\newpage

\subsection{39. Unit testing view-models and controls
headlessly}\label{unit-testing-view-models-and-controls-headlessly}

Goal - Exercise your UI and view-model logic inside real
\texttt{Dispatcher} loops without opening desktop windows. - Share
fixtures and app configuration across xUnit and NUnit by wiring
\texttt{AvaloniaHeadless} runners correctly. - Simulate input, state
changes, and async updates deterministically so assertions stay reliable
in CI.

Why this matters - Headless UI tests catch regressions that unit tests
miss while remaining fast enough for continuous builds. - Avalonia's
dispatcher and property system require a running application
instance---adapters handle that for you. - Framework-provided attributes
eliminate flaky cross-thread failures and keep tests close to production
startup paths.

Prerequisites - Chapter 4 for lifetime selection and \texttt{AppBuilder}
basics. - Chapter 21 for the bird's-eye view of headless testing
capabilities. - Chapter 38 for platform options, dispatcher control, and
input helpers.

\subsection{1. Pick the headless
harness}\label{pick-the-headless-harness}

Avalonia ships runner glue for xUnit and NUnit so your test bodies
always execute on the UI dispatcher.

\subsubsection{xUnit: opt into the Avalonia test
framework}\label{xunit-opt-into-the-avalonia-test-framework}

Add the assembly-level attribute once and then decorate tests with
\texttt{{[}AvaloniaFact{]}}/\texttt{{[}AvaloniaTheory{]}}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// AssemblyInfo.cs}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Headless}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Headless}\OperatorTok{.}\FunctionTok{XUnit}\OperatorTok{;}

\OperatorTok{[}\NormalTok{assembly}\OperatorTok{:} \FunctionTok{AvaloniaTestApplication}\OperatorTok{(}\KeywordTok{typeof}\OperatorTok{(}\NormalTok{TestApp}\OperatorTok{))]}
\OperatorTok{[}\NormalTok{assembly}\OperatorTok{:}\NormalTok{ AvaloniaTestFramework}\OperatorTok{]}
\end{Highlighting}
\end{Shaded}

\texttt{AvaloniaTestFramework} (see
\texttt{external/Avalonia/src/Headless/Avalonia.Headless.XUnit/AvaloniaTestFramework.cs})
installs a custom executor that spawns a
\texttt{HeadlessUnitTestSession} for the assembly. Each
\texttt{{[}AvaloniaFact{]}} routes through
\texttt{AvaloniaTestCaseRunner}, ensuring awaited continuations re-enter
the dispatcher thread.

\subsubsection{\texorpdfstring{NUnit: wrap commands via
\texttt{{[}AvaloniaTest{]}}}{NUnit: wrap commands via {[}AvaloniaTest{]}}}\label{nunit-wrap-commands-via-avaloniatest}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Headless}\OperatorTok{;}
\KeywordTok{using}\NormalTok{ Avalonia}\OperatorTok{.}\FunctionTok{Headless}\OperatorTok{.}\FunctionTok{NUnit}\OperatorTok{;}

\OperatorTok{[}\NormalTok{assembly}\OperatorTok{:} \FunctionTok{AvaloniaTestApplication}\OperatorTok{(}\KeywordTok{typeof}\OperatorTok{(}\NormalTok{TestApp}\OperatorTok{))]}

\KeywordTok{public} \KeywordTok{class}\NormalTok{ ButtonSpecs}
\OperatorTok{\{}
    \OperatorTok{[}\NormalTok{SetUp}\OperatorTok{]}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{OpenApp}\OperatorTok{()} \OperatorTok{=\textgreater{}}\NormalTok{ Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{VerifyAccess}\OperatorTok{();}

    \OperatorTok{[}\NormalTok{AvaloniaTest}\OperatorTok{,} \FunctionTok{Timeout}\OperatorTok{(}\DecValTok{10000}\OperatorTok{)]}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Click\_updates\_counter}\OperatorTok{()}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ window }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Window}\OperatorTok{();}
        \CommentTok{// ...}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{AvaloniaTestAttribute} swaps NUnit's command pipeline with
\texttt{AvaloniaTestMethodCommand}
(\texttt{external/Avalonia/src/Headless/Avalonia.Headless.NUnit/AvaloniaTestMethodCommand.cs}),
capturing \texttt{SetUp}/\texttt{TearDown} delegates and executing them
inside the shared dispatcher.

\subsection{2. Bootstrap the application under
test}\label{bootstrap-the-application-under-test}

The harness needs an entry point that mirrors production startup. Reuse
your \texttt{BuildAvaloniaApp} method or author a lightweight test
shell.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ TestApp }\OperatorTok{:}\NormalTok{ Application}
\OperatorTok{\{}
    \KeywordTok{public} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{()}
    \OperatorTok{\{}
\NormalTok{        Styles}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\KeywordTok{new} \FunctionTok{SimpleTheme}\OperatorTok{());}
        \KeywordTok{base}\OperatorTok{.}\FunctionTok{OnFrameworkInitializationCompleted}\OperatorTok{();}
    \OperatorTok{\}}

    \KeywordTok{public} \KeywordTok{static}\NormalTok{ AppBuilder }\FunctionTok{BuildAvaloniaApp}\OperatorTok{()} \OperatorTok{=\textgreater{}}
\NormalTok{        AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{TestApp}\OperatorTok{\textgreater{}()}
            \OperatorTok{.}\FunctionTok{UseSkia}\OperatorTok{()}
            \OperatorTok{.}\FunctionTok{UseHeadless}\OperatorTok{(}\KeywordTok{new}\NormalTok{ AvaloniaHeadlessPlatformOptions}
            \OperatorTok{\{}
\NormalTok{                UseHeadlessDrawing }\OperatorTok{=} \KeywordTok{false}\OperatorTok{,} \CommentTok{// enable Skia{-}backed surfaces for rendering checks}
\NormalTok{                PreferDispatcherScheduling }\OperatorTok{=} \KeywordTok{true}
            \OperatorTok{\});}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

This pattern matches Avalonia's own tests
(\texttt{external/Avalonia/tests/Avalonia.Headless.UnitTests/TestApplication.cs}).
When the runner detects \texttt{BuildAvaloniaApp}, it invokes it before
each dispatch, so your services, themes, and dependency injection mirror
the real app. If your production bootstrap already includes
\texttt{UseHeadless}, the harness respects it; otherwise
\texttt{HeadlessUnitTestSession.StartNew} injects defaults.

\subsection{3. Understand session lifetime and dispatcher
flow}\label{understand-session-lifetime-and-dispatcher-flow}

\texttt{HeadlessUnitTestSession}
(\texttt{external/Avalonia/src/Headless/Avalonia.Headless/HeadlessUnitTestSession.cs})
is the engine behind both harnesses. Highlights:

\begin{itemize}
\tightlist
\item
  \texttt{GetOrStartForAssembly} caches a session per test assembly,
  honoring \texttt{{[}AvaloniaTestApplication{]}}.
\item
  \texttt{Dispatch}/\texttt{Dispatch\textless{}TResult\textgreater{}}
  queue work onto the UI thread while keeping NUnit/xUnit's thread
  blocked until completion.
\item
  \texttt{EnsureApplication()} recreates the \texttt{AppBuilder} scope
  for every dispatched action, resetting \texttt{Dispatcher} state so
  tests remain isolated.
\end{itemize}

You can opt into manual session control when writing custom runners or
diagnostics:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using} \DataTypeTok{var}\NormalTok{ session }\OperatorTok{=}\NormalTok{ HeadlessUnitTestSession}\OperatorTok{.}\FunctionTok{StartNew}\OperatorTok{(}\KeywordTok{typeof}\OperatorTok{(}\NormalTok{TestApp}\OperatorTok{));}
\NormalTok{await session}\OperatorTok{.}\FunctionTok{Dispatch}\OperatorTok{(}\FunctionTok{async} \OperatorTok{()} \OperatorTok{=\textgreater{}}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ window }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Window}\OperatorTok{();}
\NormalTok{    window}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{();}
\NormalTok{    await Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{InvokeAsync}\OperatorTok{(()} \OperatorTok{=\textgreater{}}\NormalTok{ window}\OperatorTok{.}\FunctionTok{Close}\OperatorTok{());}
\OperatorTok{\},}\NormalTok{ CancellationToken}\OperatorTok{.}\FunctionTok{None}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Dispose the session at the end of a run to stop the dispatcher loop and
release the blocking queue.

\subsection{4. Mount controls and bind
view-models}\label{mount-controls-and-bind-view-models}

With the dispatcher in place, tests can instantiate real controls,
establish bindings, and observe Avalonia's property system.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ CounterTests}
\OperatorTok{\{}
    \OperatorTok{[}\NormalTok{AvaloniaFact}\OperatorTok{]}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Button\_click\_updates\_label}\OperatorTok{()}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ vm }\OperatorTok{=} \KeywordTok{new} \FunctionTok{CounterViewModel}\OperatorTok{();}
        \DataTypeTok{var}\NormalTok{ window }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Window}
        \OperatorTok{\{}
\NormalTok{            DataContext }\OperatorTok{=}\NormalTok{ vm}\OperatorTok{,}
\NormalTok{            Content }\OperatorTok{=} \KeywordTok{new}\NormalTok{ StackPanel}
            \OperatorTok{\{}
\NormalTok{                Children }\OperatorTok{=}
                \OperatorTok{\{}
                    \KeywordTok{new}\NormalTok{ Button }\OperatorTok{\{}\NormalTok{ Name }\OperatorTok{=} \StringTok{"IncrementButton"}\OperatorTok{,}\NormalTok{ Command }\OperatorTok{=}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{IncrementCommand} \OperatorTok{\},}
                    \KeywordTok{new}\NormalTok{ TextBlock }\OperatorTok{\{}\NormalTok{ Name }\OperatorTok{=} \StringTok{"CounterLabel"}\OperatorTok{,} \OperatorTok{[!}\NormalTok{TextBlock}\OperatorTok{.}\FunctionTok{TextProperty}\OperatorTok{]} \OperatorTok{=}\NormalTok{ vm}\OperatorTok{.}\FunctionTok{CounterBinding} \OperatorTok{\}}
                \OperatorTok{\}}
            \OperatorTok{\}}
        \OperatorTok{\};}

\NormalTok{        window}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{();}
\NormalTok{        window}\OperatorTok{.}\FunctionTok{MouseDown}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{20}\OperatorTok{,} \DecValTok{20}\OperatorTok{),}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}
\NormalTok{        window}\OperatorTok{.}\FunctionTok{MouseUp}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{20}\OperatorTok{,} \DecValTok{20}\OperatorTok{),}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}

\NormalTok{        window}\OperatorTok{.}\FunctionTok{FindControl}\OperatorTok{\textless{}}\NormalTok{TextBlock}\OperatorTok{\textgreater{}(}\StringTok{"CounterLabel"}\OperatorTok{)!.}\FunctionTok{Text}\OperatorTok{.}\FunctionTok{Should}\OperatorTok{().}\FunctionTok{Be}\OperatorTok{(}\StringTok{"1"}\OperatorTok{);}
\NormalTok{        window}\OperatorTok{.}\FunctionTok{Close}\OperatorTok{();}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The mouse helpers come from \texttt{HeadlessWindowExtensions}
(\texttt{external/Avalonia/src/Headless/Avalonia.Headless/HeadlessWindowExtensions.cs}).
They flush pending dispatcher work before delivering input, then run
jobs again afterward so bindings update before the assertion. Always
\texttt{Close()} windows when you finish to keep the session clean.

\subsection{5. Share fixtures with setup/teardown
hooks}\label{share-fixtures-with-setupteardown-hooks}

Both frameworks let you prepare windows or services per test while
staying on the UI thread.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ InputHarness}
\KeywordTok{\#if}\NormalTok{ XUNIT}
    \OperatorTok{:}\NormalTok{ IDisposable}
\KeywordTok{\#endif}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Window \_window}\OperatorTok{;}

\KeywordTok{\#if}\NormalTok{ NUNIT}
    \OperatorTok{[}\NormalTok{SetUp}\OperatorTok{]}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{SetUp}\OperatorTok{()}
\KeywordTok{\#elif}\NormalTok{ XUNIT}
    \KeywordTok{public} \FunctionTok{InputHarness}\OperatorTok{()}
\KeywordTok{\#endif}
    \OperatorTok{\{}
\NormalTok{        Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{VerifyAccess}\OperatorTok{();}
\NormalTok{        \_window }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Window }\OperatorTok{\{}\NormalTok{ Width }\OperatorTok{=} \DecValTok{100}\OperatorTok{,}\NormalTok{ Height }\OperatorTok{=} \DecValTok{100} \OperatorTok{\};}
    \OperatorTok{\}}

\KeywordTok{\#if}\NormalTok{ NUNIT}
    \OperatorTok{[}\NormalTok{AvaloniaTest}\OperatorTok{]}
\KeywordTok{\#elif}\NormalTok{ XUNIT}
    \OperatorTok{[}\NormalTok{AvaloniaFact}\OperatorTok{]}
\KeywordTok{\#endif}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Drag\_updates\_position}\OperatorTok{()}
    \OperatorTok{\{}
\NormalTok{        \_window}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{();}
\NormalTok{        \_window}\OperatorTok{.}\FunctionTok{MouseDown}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{10}\OperatorTok{),}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}
\NormalTok{        \_window}\OperatorTok{.}\FunctionTok{MouseMove}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{60}\OperatorTok{,} \DecValTok{40}\OperatorTok{));}
\NormalTok{        \_window}\OperatorTok{.}\FunctionTok{MouseUp}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{60}\OperatorTok{,} \DecValTok{40}\OperatorTok{),}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}
\NormalTok{        \_window}\OperatorTok{.}\FunctionTok{Position}\OperatorTok{.}\FunctionTok{Should}\OperatorTok{().}\FunctionTok{Be}\OperatorTok{(}\KeywordTok{new} \FunctionTok{PixelPoint}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{));} \CommentTok{// headless doesn’t move windows automatically}
    \OperatorTok{\}}

\KeywordTok{\#if}\NormalTok{ NUNIT}
    \OperatorTok{[}\NormalTok{TearDown}\OperatorTok{]}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{TearDown}\OperatorTok{()}
\KeywordTok{\#elif}\NormalTok{ XUNIT}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Dispose}\OperatorTok{()}
\KeywordTok{\#endif}
    \OperatorTok{\{}
\NormalTok{        Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{VerifyAccess}\OperatorTok{();}
\NormalTok{        \_window}\OperatorTok{.}\FunctionTok{Close}\OperatorTok{();}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The sample mirrors Avalonia's own \texttt{InputTests}
(\texttt{external/Avalonia/tests/Avalonia.Headless.UnitTests/InputTests.cs}).
Use preprocessor guards if you cross-compile the same tests between
xUnit and NUnit packages.

\subsection{6. Keep async work
deterministic}\label{keep-async-work-deterministic}

Headless tests still depend on Avalonia's dispatcher and timers. Prefer
structured helpers over \texttt{Task.Delay}.

\begin{itemize}
\tightlist
\item
  \texttt{Dispatcher.UIThread.RunJobs()} drains queued operations
  immediately.
\item
  \texttt{AvaloniaHeadlessPlatform.ForceRenderTimerTick()} advances
  layout and render timers---pair it with \texttt{RunJobs()} when you
  expect visuals to update.
\item
  \texttt{DispatcherTimer.RunOnce} works inside tests; the runner
  ensures the callback fires on the same thread, as shown in
  \texttt{ThreadingTests}
  (\texttt{external/Avalonia/tests/Avalonia.Headless.UnitTests/ThreadingTests.cs}).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\NormalTok{AvaloniaFact}\OperatorTok{]}
\KeywordTok{public}\NormalTok{ async Task }\FunctionTok{Loader\_raises\_progress}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ progress }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
    \DataTypeTok{var}\NormalTok{ loader }\OperatorTok{=} \KeywordTok{new} \FunctionTok{AsyncLoader}\OperatorTok{();}

\NormalTok{    await Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{InvokeAsync}\OperatorTok{(()} \OperatorTok{=\textgreater{}}\NormalTok{ loader}\OperatorTok{.}\FunctionTok{Start}\OperatorTok{());}

    \KeywordTok{while} \OperatorTok{(}\NormalTok{progress }\OperatorTok{\textless{}} \DecValTok{100}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        AvaloniaHeadlessPlatform}\OperatorTok{.}\FunctionTok{ForceRenderTimerTick}\OperatorTok{();}
\NormalTok{        Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{RunJobs}\OperatorTok{();}
\NormalTok{        progress }\OperatorTok{=}\NormalTok{ loader}\OperatorTok{.}\FunctionTok{Progress}\OperatorTok{;}
    \OperatorTok{\}}

\NormalTok{    progress}\OperatorTok{.}\FunctionTok{Should}\OperatorTok{().}\FunctionTok{Be}\OperatorTok{(}\DecValTok{100}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

If your view-model uses \texttt{DispatcherTimer}, expose a hook that
ticks manually so tests avoid clock-based flakiness.

\subsection{7. Theories, collections, and
parallelism}\label{theories-collections-and-parallelism}

\texttt{{[}AvaloniaTheory{]}} supports data-driven tests while staying
on the dispatcher. For xUnit, decorate a collection definition to run
related fixtures sequentially:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\NormalTok{AvaloniaCollection}\OperatorTok{]} \CommentTok{// custom marker}
\KeywordTok{public} \KeywordTok{class}\NormalTok{ DialogTests}
\OperatorTok{\{}
    \OperatorTok{[}\NormalTok{AvaloniaTheory}\OperatorTok{]}
    \OperatorTok{[}\FunctionTok{InlineData}\OperatorTok{(}\KeywordTok{false}\OperatorTok{)]}
    \OperatorTok{[}\FunctionTok{InlineData}\OperatorTok{(}\KeywordTok{true}\OperatorTok{)]}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Dialog\_lifecycle}\OperatorTok{(}\DataTypeTok{bool}\NormalTok{ useAsync}\OperatorTok{)}
    \OperatorTok{\{}
        \CommentTok{// ...}
    \OperatorTok{\}}
\OperatorTok{\}}

\OperatorTok{[}\FunctionTok{CollectionDefinition}\OperatorTok{(}\StringTok{"AvaloniaCollection"}\OperatorTok{,}\NormalTok{ DisableParallelization }\OperatorTok{=} \KeywordTok{true}\OperatorTok{)]}
\KeywordTok{public} \KeywordTok{class}\NormalTok{ AvaloniaCollection }\OperatorTok{:}\NormalTok{ ICollectionFixture}\OperatorTok{\textless{}}\NormalTok{HeadlessFixture}\OperatorTok{\textgreater{}} \OperatorTok{\{} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The custom fixture can preload services or share the \texttt{MainView}.
NUnit users can rely on \texttt{{[}Apartment(ApartmentState.STA){]}}
plus \texttt{{[}AvaloniaTest{]}} when mixing with other UI frameworks,
but remember Avalonia already enforces a single dispatcher thread.

\subsection{8. Troubleshooting failures}\label{troubleshooting-failures}

\begin{itemize}
\tightlist
\item
  \textbf{Test never finishes} -- ensure you awaited async work through
  \texttt{Dispatcher.UIThread} or
  \texttt{HeadlessUnitTestSession.Dispatch}. Background tasks without
  dispatcher access will hang because the harness blocks the originating
  test thread.
\item
  \textbf{Missing services} -- register substitutes in
  \texttt{Application.RegisterServices()} before calling base
  initialization. Clipboard, dialogs, or storage require
  headless-friendly implementations (see Chapter 38).
\item
  \textbf{State bleed between tests} -- close all \texttt{TopLevel}s,
  dispose \texttt{CompositeDisposable}s, and avoid static view-model
  singletons. Each dispatched action gets a fresh \texttt{Application}
  scope, but stray static caches persist.
\item
  \textbf{Random \texttt{InvalidOperationException:\ VerifyAccess}} -- a
  test ran code on a thread pool thread. Wrap the block in
  \texttt{Dispatcher.UIThread.InvokeAsync} or use
  \texttt{await\ session.Dispatch(...)} in custom helpers.
\item
  \textbf{Parallel collection deadlocks} -- turn off test parallelism
  when fixtures share windows. xUnit:
  \texttt{{[}assembly:\ CollectionBehavior(DisableTestParallelization\ =\ true){]}};
  NUnit: \texttt{-\/-workers=1} or \texttt{{[}NonParallelizable{]}} per
  fixture.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-6}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Session helper} -- Write a reusable
  \texttt{HeadlessTestSessionFixture} exposing
  \texttt{Dispatch(Func\textless{}Task\textgreater{})} so plain unit
  tests can invoke dispatcher-bound code without attributes.
\item
  \textbf{View-model assertions} -- Mount a form with compiled bindings,
  trigger \texttt{BindingOperations} updates, and assert validation
  errors surface via \texttt{DataValidationErrors.GetErrors}.
\item
  \textbf{Keyboard automation} -- Use
  \texttt{HeadlessWindowExtensions.KeyPressQwerty} to simulate typing
  into a \texttt{TextBox}, verify selection state, then assert command
  execution when pressing Enter.
\item
  \textbf{Timer-driven UI} -- Create a progress dialog using
  \texttt{DispatcherTimer}. In tests, tick the timer manually and assert
  the dialog closes itself at 100\% without sleeping.
\item
  \textbf{Theory matrix} -- Build a \texttt{{[}AvaloniaTheory{]}} test
  that runs the same control suite using Classic Desktop vs.~Single View
  lifetimes by swapping \texttt{HeadlessLifetime.MainView}. Confirm both
  paths render identical text through \texttt{GetLastRenderedFrame()}.
\end{enumerate}

What's next - Next: \href{Chapter40.md}{Chapter40}

\newpage

\subsection{40. Rendering verification and pixel
assertions}\label{rendering-verification-and-pixel-assertions}

Goal - Capture deterministic frames from controls and windows so UI
regressions show up as image diffs. - Re-render visuals off-screen with
\texttt{RenderTargetBitmap} for pipeline-level validation without a
running window. - Build comparison utilities that tolerate minor noise
while still failing on real regressions.

Why this matters - Visual bugs rarely surface through property
assertions alone; pixel diffs make style and layout drift obvious. - CI
agents run headless---leveraging Avalonia's off-screen renderers keeps
comparison workflows portable. - Consistent capture pipelines simplify
storing baselines, reviewing diffs, and onboarding QA to UI automation.

Prerequisites - Chapter 21 for the overview of headless testing options.
- Chapter 38 for dispatcher control and headless render ticks. - Chapter
39 for running xUnit/NUnit fixtures on the Avalonia dispatcher.

\subsection{1. Capture frames from headless top
levels}\label{capture-frames-from-headless-top-levels}

\texttt{HeadlessWindowExtensions.CaptureRenderedFrame}
(\texttt{external/Avalonia/src/Headless/Avalonia.Headless/HeadlessWindowExtensions.cs:20})
flushes the dispatcher, ticks the headless timer, and returns a
\texttt{WriteableBitmap} of the latest frame. The helper delegates to
\texttt{GetLastRenderedFrame}, which requires Skia-backed
rendering---set \texttt{UseHeadlessDrawing\ =\ false} and
\texttt{UseSkia\ =\ true} in your test app:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static}\NormalTok{ AppBuilder }\FunctionTok{BuildAvaloniaApp}\OperatorTok{()} \OperatorTok{=\textgreater{}}
\NormalTok{    AppBuilder}\OperatorTok{.}\FunctionTok{Configure}\OperatorTok{\textless{}}\NormalTok{TestApp}\OperatorTok{\textgreater{}()}
        \OperatorTok{.}\FunctionTok{UseHeadless}\OperatorTok{(}\KeywordTok{new}\NormalTok{ AvaloniaHeadlessPlatformOptions}
        \OperatorTok{\{}
\NormalTok{            UseHeadlessDrawing }\OperatorTok{=} \KeywordTok{false}\OperatorTok{,}
\NormalTok{            UseSkia }\OperatorTok{=} \KeywordTok{true}\OperatorTok{,}
\NormalTok{            PreferDispatcherScheduling }\OperatorTok{=} \KeywordTok{true}
        \OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

Once configured, capture snapshots straight from a headless window:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ window }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Window}
\OperatorTok{\{}
\NormalTok{    Content }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ControlCatalogPage}\OperatorTok{(),}
\NormalTok{    SizeToContent }\OperatorTok{=}\NormalTok{ SizeToContent}\OperatorTok{.}\FunctionTok{WidthAndHeight}
\OperatorTok{\};}

\NormalTok{window}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{();}
\DataTypeTok{var}\NormalTok{ frame }\OperatorTok{=}\NormalTok{ window}\OperatorTok{.}\FunctionTok{CaptureRenderedFrame}\OperatorTok{();}
\NormalTok{Assert}\OperatorTok{.}\FunctionTok{NotNull}\OperatorTok{(}\NormalTok{frame}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Avalonia's own regression tests follow this pattern
(\texttt{external/Avalonia/tests/Avalonia.Headless.UnitTests/RenderingTests.cs:18}).
Use \texttt{CaptureRenderedFrame} when you want the helper to tick
timers for you; call \texttt{GetLastRenderedFrame} if you have already
driven the dispatcher manually.

\subsection{\texorpdfstring{2. Render visuals off-screen with
\texttt{RenderTargetBitmap}}{2. Render visuals off-screen with RenderTargetBitmap}}\label{render-visuals-off-screen-with-rendertargetbitmap}

To avoid constructing full windows, target the visual tree directly.
\texttt{RenderTargetBitmap} uses \texttt{ImmediateRenderer.Render} under
the hood
(\texttt{external/Avalonia/src/Avalonia.Base/Media/Imaging/RenderTargetBitmap.cs:33}).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ root }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Border}
\OperatorTok{\{}
\NormalTok{    Width }\OperatorTok{=} \DecValTok{200}\OperatorTok{,}
\NormalTok{    Height }\OperatorTok{=} \DecValTok{120}\OperatorTok{,}
\NormalTok{    Background }\OperatorTok{=}\NormalTok{ Brushes}\OperatorTok{.}\FunctionTok{CornflowerBlue}\OperatorTok{,}
\NormalTok{    Child }\OperatorTok{=} \KeywordTok{new}\NormalTok{ TextBlock}
    \OperatorTok{\{}
\NormalTok{        Text }\OperatorTok{=} \StringTok{"Hello Avalonia"}\OperatorTok{,}
\NormalTok{        FontSize }\OperatorTok{=} \DecValTok{24}\OperatorTok{,}
\NormalTok{        HorizontalAlignment }\OperatorTok{=}\NormalTok{ HorizontalAlignment}\OperatorTok{.}\FunctionTok{Center}\OperatorTok{,}
\NormalTok{        VerticalAlignment }\OperatorTok{=}\NormalTok{ VerticalAlignment}\OperatorTok{.}\FunctionTok{Center}
    \OperatorTok{\}}
\OperatorTok{\};}

\NormalTok{await Dispatcher}\OperatorTok{.}\FunctionTok{UIThread}\OperatorTok{.}\FunctionTok{InvokeAsync}\OperatorTok{(()} \OperatorTok{=\textgreater{}}\NormalTok{ root}\OperatorTok{.}\FunctionTok{Measure}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Size}\OperatorTok{(}\DataTypeTok{double}\OperatorTok{.}\FunctionTok{PositiveInfinity}\OperatorTok{,} \DataTypeTok{double}\OperatorTok{.}\FunctionTok{PositiveInfinity}\OperatorTok{)));}
\NormalTok{root}\OperatorTok{.}\FunctionTok{Arrange}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Rect}\OperatorTok{(}\NormalTok{root}\OperatorTok{.}\FunctionTok{DesiredSize}\OperatorTok{));}

\KeywordTok{using} \DataTypeTok{var}\NormalTok{ rtb }\OperatorTok{=} \KeywordTok{new} \FunctionTok{RenderTargetBitmap}\OperatorTok{(}\KeywordTok{new} \FunctionTok{PixelSize}\OperatorTok{(}\DecValTok{200}\OperatorTok{,} \DecValTok{120}\OperatorTok{));}
\NormalTok{rtb}\OperatorTok{.}\FunctionTok{Render}\OperatorTok{(}\NormalTok{root}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

The bitmap implements \texttt{IBitmap}, so you can save it, compare
pixels, or embed it in diagnostics emails. For complex compositions,
grab a \texttt{DrawingContext} from
\texttt{RenderTargetBitmap.CreateDrawingContext} to draw primitive
overlays before comparison.

\subsection{3. Compare pixels with configurable
tolerances}\label{compare-pixels-with-configurable-tolerances}

Whether you use \texttt{CaptureRenderedFrame} or
\texttt{RenderTargetBitmap}, lock the frame buffer to access raw bytes.
\texttt{WriteableBitmap.Lock()} exposes an \texttt{ILockedFramebuffer}
with stride, format, and a pointer into the pixel buffer
(\texttt{external/Avalonia/src/Avalonia.Base/Media/Imaging/WriteableBitmap.cs:59}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static}\NormalTok{ PixelDiffResult }\FunctionTok{CompareBitmaps}\OperatorTok{(}\NormalTok{IBitmap expected}\OperatorTok{,}\NormalTok{ IBitmap actual}\OperatorTok{,} \DataTypeTok{byte}\NormalTok{ tolerance }\OperatorTok{=} \DecValTok{2}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{using} \DataTypeTok{var}\NormalTok{ left }\OperatorTok{=}\NormalTok{ expected}\OperatorTok{.}\FunctionTok{Lock}\OperatorTok{();}
    \KeywordTok{using} \DataTypeTok{var}\NormalTok{ right }\OperatorTok{=}\NormalTok{ actual}\OperatorTok{.}\FunctionTok{Lock}\OperatorTok{();}

    \KeywordTok{if} \OperatorTok{(}\NormalTok{left}\OperatorTok{.}\FunctionTok{Size} \OperatorTok{!=}\NormalTok{ right}\OperatorTok{.}\FunctionTok{Size}\OperatorTok{)}
        \KeywordTok{return}\NormalTok{ PixelDiffResult}\OperatorTok{.}\FunctionTok{SizeMismatch}\OperatorTok{(}\NormalTok{left}\OperatorTok{.}\FunctionTok{Size}\OperatorTok{,}\NormalTok{ right}\OperatorTok{.}\FunctionTok{Size}\OperatorTok{);}

    \DataTypeTok{var}\NormalTok{ failures }\OperatorTok{=} \KeywordTok{new}\NormalTok{ List}\OperatorTok{\textless{}}\NormalTok{PixelDiff}\OperatorTok{\textgreater{}();}

    \KeywordTok{unsafe}
    \OperatorTok{\{}
        \KeywordTok{for} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ y }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ y }\OperatorTok{\textless{}}\NormalTok{ left}\OperatorTok{.}\FunctionTok{Size}\OperatorTok{.}\FunctionTok{Height}\OperatorTok{;}\NormalTok{ y}\OperatorTok{++)}
        \OperatorTok{\{}
            \DataTypeTok{var}\NormalTok{ pLeft }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{byte}\OperatorTok{*)}\NormalTok{left}\OperatorTok{.}\FunctionTok{Address} \OperatorTok{+}\NormalTok{ y }\OperatorTok{*}\NormalTok{ left}\OperatorTok{.}\FunctionTok{RowBytes}\OperatorTok{;}
            \DataTypeTok{var}\NormalTok{ pRight }\OperatorTok{=} \OperatorTok{(}\DataTypeTok{byte}\OperatorTok{*)}\NormalTok{right}\OperatorTok{.}\FunctionTok{Address} \OperatorTok{+}\NormalTok{ y }\OperatorTok{*}\NormalTok{ right}\OperatorTok{.}\FunctionTok{RowBytes}\OperatorTok{;}

            \KeywordTok{for} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ x }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ x }\OperatorTok{\textless{}}\NormalTok{ left}\OperatorTok{.}\FunctionTok{Size}\OperatorTok{.}\FunctionTok{Width}\OperatorTok{;}\NormalTok{ x}\OperatorTok{++)}
            \OperatorTok{\{}
                \DataTypeTok{var}\NormalTok{ idx }\OperatorTok{=}\NormalTok{ x }\OperatorTok{*} \DecValTok{4}\OperatorTok{;} \CommentTok{// BGRA}
                \DataTypeTok{var}\NormalTok{ delta }\OperatorTok{=}\NormalTok{ Math}\OperatorTok{.}\FunctionTok{Max}\OperatorTok{(}
\NormalTok{                    Math}\OperatorTok{.}\FunctionTok{Abs}\OperatorTok{(}\NormalTok{pLeft}\OperatorTok{[}\NormalTok{idx}\OperatorTok{]} \OperatorTok{{-}}\NormalTok{ pRight}\OperatorTok{[}\NormalTok{idx}\OperatorTok{]),}
\NormalTok{                    Math}\OperatorTok{.}\FunctionTok{Max}\OperatorTok{(}\NormalTok{Math}\OperatorTok{.}\FunctionTok{Abs}\OperatorTok{(}\NormalTok{pLeft}\OperatorTok{[}\NormalTok{idx }\OperatorTok{+} \DecValTok{1}\OperatorTok{]} \OperatorTok{{-}}\NormalTok{ pRight}\OperatorTok{[}\NormalTok{idx }\OperatorTok{+} \DecValTok{1}\OperatorTok{]),}
\NormalTok{                             Math}\OperatorTok{.}\FunctionTok{Abs}\OperatorTok{(}\NormalTok{pLeft}\OperatorTok{[}\NormalTok{idx }\OperatorTok{+} \DecValTok{2}\OperatorTok{]} \OperatorTok{{-}}\NormalTok{ pRight}\OperatorTok{[}\NormalTok{idx }\OperatorTok{+} \DecValTok{2}\OperatorTok{])));}

                \KeywordTok{if} \OperatorTok{(}\NormalTok{delta }\OperatorTok{\textgreater{}}\NormalTok{ tolerance}\OperatorTok{)}
\NormalTok{                    failures}\OperatorTok{.}\FunctionTok{Add}\OperatorTok{(}\KeywordTok{new} \FunctionTok{PixelDiff}\OperatorTok{(}\NormalTok{x}\OperatorTok{,}\NormalTok{ y}\OperatorTok{,}\NormalTok{ delta}\OperatorTok{));}
            \OperatorTok{\}}
        \OperatorTok{\}}
    \OperatorTok{\}}

    \KeywordTok{return}\NormalTok{ PixelDiffResult}\OperatorTok{.}\FunctionTok{FromList}\OperatorTok{(}\NormalTok{failures}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Tune the tolerance to absorb small antialiasing differences. Consider
summing absolute channel differences or using the Delta-E metric when
gradients highlight sub-pixel drift.

\subsubsection{Produce diagnostic
overlays}\label{produce-diagnostic-overlays}

When differences occur, create an error bitmap that highlights only
changed pixels:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static}\NormalTok{ WriteableBitmap }\FunctionTok{CreateDiffMask}\OperatorTok{(}\NormalTok{IBitmap baseline}\OperatorTok{,}\NormalTok{ PixelDiffResult result}\OperatorTok{)}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ size }\OperatorTok{=}\NormalTok{ baseline}\OperatorTok{.}\FunctionTok{PixelSize}\OperatorTok{;}
    \DataTypeTok{var}\NormalTok{ diff }\OperatorTok{=} \KeywordTok{new} \FunctionTok{WriteableBitmap}\OperatorTok{(}\NormalTok{size}\OperatorTok{,}\NormalTok{ baseline}\OperatorTok{.}\FunctionTok{Dpi}\OperatorTok{);} \CommentTok{// default BGRA32}

    \KeywordTok{using} \DataTypeTok{var}\NormalTok{ target }\OperatorTok{=}\NormalTok{ diff}\OperatorTok{.}\FunctionTok{Lock}\OperatorTok{();}
    \DataTypeTok{var}\NormalTok{ buffer }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Span}\OperatorTok{\textless{}}\DataTypeTok{byte}\OperatorTok{\textgreater{}((}\DataTypeTok{void}\OperatorTok{*)}\NormalTok{target}\OperatorTok{.}\FunctionTok{Address}\OperatorTok{,}\NormalTok{ target}\OperatorTok{.}\FunctionTok{RowBytes} \OperatorTok{*}\NormalTok{ size}\OperatorTok{.}\FunctionTok{Height}\OperatorTok{);}
\NormalTok{    buffer}\OperatorTok{.}\FunctionTok{Clear}\OperatorTok{();}

    \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ pixel }\KeywordTok{in}\NormalTok{ result}\OperatorTok{.}\FunctionTok{Failures}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ idx }\OperatorTok{=}\NormalTok{ pixel}\OperatorTok{.}\FunctionTok{Y} \OperatorTok{*}\NormalTok{ target}\OperatorTok{.}\FunctionTok{RowBytes} \OperatorTok{+}\NormalTok{ pixel}\OperatorTok{.}\FunctionTok{X} \OperatorTok{*} \DecValTok{4}\OperatorTok{;}
\NormalTok{        buffer}\OperatorTok{[}\NormalTok{idx }\OperatorTok{+} \DecValTok{0}\OperatorTok{]} \OperatorTok{=} \DecValTok{0}\OperatorTok{;}          \CommentTok{// B}
\NormalTok{        buffer}\OperatorTok{[}\NormalTok{idx }\OperatorTok{+} \DecValTok{1}\OperatorTok{]} \OperatorTok{=} \DecValTok{0}\OperatorTok{;}          \CommentTok{// G}
\NormalTok{        buffer}\OperatorTok{[}\NormalTok{idx }\OperatorTok{+} \DecValTok{2}\OperatorTok{]} \OperatorTok{=} \DecValTok{255}\OperatorTok{;}        \CommentTok{// R highlights}
\NormalTok{        buffer}\OperatorTok{[}\NormalTok{idx }\OperatorTok{+} \DecValTok{3}\OperatorTok{]} \OperatorTok{=} \DecValTok{255}\OperatorTok{;}        \CommentTok{// A}
    \OperatorTok{\}}

    \KeywordTok{return}\NormalTok{ diff}\OperatorTok{;}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Attach the original frame, baseline, and diff mask to CI artifacts so
reviewers can inspect regressions quickly.

\subsection{4. Manage baselines and golden
images}\label{manage-baselines-and-golden-images}

Golden images can live alongside tests as embedded resources. Load them
via \texttt{WriteableBitmap.Decode} and normalize configuration before
comparison:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{await }\KeywordTok{using} \DataTypeTok{var}\NormalTok{ stream }\OperatorTok{=}\NormalTok{ manifestAssembly}\OperatorTok{.}\FunctionTok{GetManifestResourceStream}\OperatorTok{(}\StringTok{"Tests.Baselines.Dialog.png"}\OperatorTok{);}
\DataTypeTok{var}\NormalTok{ baseline }\OperatorTok{=}\NormalTok{ WriteableBitmap}\OperatorTok{.}\FunctionTok{Decode}\OperatorTok{(}\NormalTok{stream}\OperatorTok{!);}
\end{Highlighting}
\end{Shaded}

When baselines must be refreshed, capture a new frame and save it to
disk using \texttt{frame.Save(fileStream)}. Normalize DPI and render
scaling so new baselines remain cross-platform:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ normalized }\OperatorTok{=} \KeywordTok{new} \FunctionTok{RenderTargetBitmap}\OperatorTok{(}\KeywordTok{new} \FunctionTok{PixelSize}\OperatorTok{(}\DecValTok{800}\OperatorTok{,} \DecValTok{600}\OperatorTok{),} \KeywordTok{new} \FunctionTok{Vector}\OperatorTok{(}\DecValTok{96}\OperatorTok{,} \DecValTok{96}\OperatorTok{));}
\NormalTok{normalized}\OperatorTok{.}\FunctionTok{Render}\OperatorTok{(}\NormalTok{window}\OperatorTok{);}
\NormalTok{await }\KeywordTok{using} \DataTypeTok{var}\NormalTok{ file }\OperatorTok{=}\NormalTok{ File}\OperatorTok{.}\FunctionTok{Create}\OperatorTok{(}\StringTok{"Baselines/Dialog.png"}\OperatorTok{);}
\NormalTok{normalized}\OperatorTok{.}\FunctionTok{Save}\OperatorTok{(}\NormalTok{file}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

\texttt{RenderTargetBitmapImpl} uses Skia surfaces
(\texttt{external/Avalonia/src/Skia/Avalonia.Skia/RenderTargetBitmapImpl.cs:8}),
so CI agents must have the Skia native bundle available. If you target
platforms without GPU support, stick to headless captures with
\texttt{UseHeadlessDrawing\ =\ true} and fall back to
\texttt{WriteableBitmap} comparisons.

\subsection{5. Handle DPI, alpha, and layout
variability}\label{handle-dpi-alpha-and-layout-variability}

Visual tests are sensitive to device-independent rounding. Lock down
inputs:

\begin{itemize}
\tightlist
\item
  Set explicit window sizes and call
  \texttt{SizeToContent\ =\ WidthAndHeight} to avoid layout
  fluctuations.
\item
  Fix \texttt{RenderScaling} by pinning \texttt{UseHeadlessDrawing} and
  Skia DPI to 96.
\item
  Strip alpha when comparing controls that rely on transparency to avoid
  background differences. Copy pixels into a new bitmap with an opaque
  fill before diffing.
\end{itemize}

For dynamic content (animations, timers), tick the dispatcher
deterministically: call
\texttt{AvaloniaHeadlessPlatform.ForceRenderTimerTick()} between each
capture, and pause transitions via \texttt{IClock} injection so frames
stay stable.

Leverage composition snapshots when you need sub-tree captures:
\texttt{Compositor.CreateCompositionVisualSnapshot} returns a
GPU-rendered image of any \texttt{Visual}
(\texttt{external/Avalonia/tests/Avalonia.Headless.UnitTests/RenderingTests.cs:118}).
Convert the snapshot to \texttt{WriteableBitmap} for comparisons if you
want to isolate specific effects layers.

\subsection{6. Troubleshooting}\label{troubleshooting-4}

\begin{itemize}
\tightlist
\item
  \textbf{\texttt{GetLastRenderedFrame} throws} -- ensure Skia is
  active; the helper checks for \texttt{HeadlessPlatformRenderInterface}
  and fails when only headless drawing is enabled.
\item
  \textbf{Alpha mismatches} -- multiply against a known background
  before diffing. Render your control inside a \texttt{Border} with a
  solid color or premultiply the buffer before comparison.
\item
  \textbf{Different stride values} -- always use
  \texttt{ILockedFramebuffer.RowBytes} instead of assuming width × 4
  bytes.
\item
  \textbf{Platform font differences} -- embed test fonts or ship them
  with the test harness so text metrics remain identical across agents.
\item
  \textbf{Large golden files} -- compress PNGs with \texttt{optipng} or
  generate vector baselines by storing the render input (XAML/data)
  alongside the image for easier review.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-7}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Snapshot harness} -- Build a
  \texttt{PixelAssert.Capture(window)} helper that returns baseline,
  actual, and diff images, then integrates them with your test
  framework's logging.
\item
  \textbf{Tolerance sweeper} -- Write a diagnostic that runs the same
  render with multiple tolerances, reporting how many pixels fail each
  threshold to help pick a sensible default.
\item
  \textbf{Golden management} -- Implement a CLI command that regenerates
  baselines from the latest controls, writes them to disk, and updates a
  manifest listing checksum + control name.
\item
  \textbf{Alpha neutralization} -- Add a utility that composites
  captured frames over a configurable background color before
  comparison, and verify it fixes regressions caused by transparent
  overlays.
\item
  \textbf{Snapshot localization} -- Capture the same view under
  different resource cultures and ensure your comparison harness accepts
  localized text while still flagging layout drift.
\end{enumerate}

What's next - Next: \href{Chapter41.md}{Chapter41}

\newpage

\subsection{41. Simulating input and automation in headless
runs}\label{simulating-input-and-automation-in-headless-runs}

Goal - Drive Avalonia UI interactions programmatically inside headless
tests, mirroring real user gestures. - Coordinate keyboard, pointer, and
text input events through \texttt{HeadlessWindowExtensions} so focus and
routing behave exactly as on desktop. - Assert downstream automation
effects---commands, behaviors, drag/drop---without launching OS-level
windows.

Why this matters - Interactive flows (menus, drag handles, keyboard
shortcuts) break easily if you only test bindings or view-models;
simulated input keeps coverage honest. - CI agents lack real hardware.
The headless platform proxies devices so you can rehearse full user
journeys deterministically. - Automation/UIP frameworks often rely on
routed events and focus transitions; reproducing them in tests prevents
last-minute surprises.

Prerequisites - Chapter 38 for headless dispatcher control and platform
options. - Chapter 39 for integrating Avalonia's headless test
attributes in xUnit or NUnit. - Chapter 40 if you plan to pair input
simulation with pixel verification.

\subsection{1. Meet the headless input
surface}\label{meet-the-headless-input-surface}

Every headless \texttt{TopLevel} implements \texttt{IHeadlessWindow}
(\texttt{external/Avalonia/src/Headless/Avalonia.Headless/IHeadlessWindow.cs:7}),
exposing methods for keyboard, pointer, wheel, and drag/drop events.
\texttt{HeadlessWindowExtensions}
(\texttt{external/Avalonia/src/Headless/Avalonia.Headless/HeadlessWindowExtensions.cs:20})
wraps those APIs, handling dispatcher ticks before and after each
gesture so routed events fire on time.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ window }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Window }\OperatorTok{\{}\NormalTok{ Content }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Button }\OperatorTok{\{}\NormalTok{ Content }\OperatorTok{=} \StringTok{"Click me"} \OperatorTok{\}} \OperatorTok{\};}
\NormalTok{window}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{();}

\NormalTok{window}\OperatorTok{.}\FunctionTok{MouseMove}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{20}\OperatorTok{,} \DecValTok{20}\OperatorTok{));}
\NormalTok{window}\OperatorTok{.}\FunctionTok{MouseDown}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{20}\OperatorTok{,} \DecValTok{20}\OperatorTok{),}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}
\NormalTok{window}\OperatorTok{.}\FunctionTok{MouseUp}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{20}\OperatorTok{,} \DecValTok{20}\OperatorTok{),}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Under the hood the extension flushes outstanding work
(\texttt{Dispatcher.UIThread.RunJobs()}), triggers the render timer
(\texttt{AvaloniaHeadlessPlatform.ForceRenderTimerTick()}), invokes the
requested gesture on the \texttt{IHeadlessWindow}, and drains the
dispatcher again. This ensures property changes, focus updates, and
automation events complete before your assertions run.

\subsection{2. Keyboard and text input}\label{keyboard-and-text-input}

\texttt{HeadlessWindowExtensions} provides multiple helpers for
synthesizing key strokes:

\begin{itemize}
\tightlist
\item
  \texttt{KeyPress}/\texttt{KeyRelease} accept logical \texttt{Key}
  values plus \texttt{RawInputModifiers}.
\item
  \texttt{KeyPressQwerty}/\texttt{KeyReleaseQwerty} map physical scan
  codes to logical keys using a QWERTY layout.
\item
  \texttt{KeyTextInput} sends text composition events directly to
  controls that listen for \texttt{TextInput}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ textBox }\OperatorTok{=} \KeywordTok{new}\NormalTok{ TextBox }\OperatorTok{\{}\NormalTok{ AcceptsReturn }\OperatorTok{=} \KeywordTok{true} \OperatorTok{\};}
\DataTypeTok{var}\NormalTok{ window }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Window }\OperatorTok{\{}\NormalTok{ Content }\OperatorTok{=}\NormalTok{ textBox }\OperatorTok{\};}
\NormalTok{window}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{();}
\NormalTok{textBox}\OperatorTok{.}\FunctionTok{Focus}\OperatorTok{();}

\NormalTok{window}\OperatorTok{.}\FunctionTok{KeyPressQwerty}\OperatorTok{(}\NormalTok{PhysicalKey}\OperatorTok{.}\FunctionTok{KeyH}\OperatorTok{,}\NormalTok{ RawInputModifiers}\OperatorTok{.}\FunctionTok{Shift}\OperatorTok{);}
\NormalTok{window}\OperatorTok{.}\FunctionTok{KeyPressQwerty}\OperatorTok{(}\NormalTok{PhysicalKey}\OperatorTok{.}\FunctionTok{KeyI}\OperatorTok{,}\NormalTok{ RawInputModifiers}\OperatorTok{.}\FunctionTok{None}\OperatorTok{);}
\NormalTok{window}\OperatorTok{.}\FunctionTok{KeyReleaseQwerty}\OperatorTok{(}\NormalTok{PhysicalKey}\OperatorTok{.}\FunctionTok{Enter}\OperatorTok{,}\NormalTok{ RawInputModifiers}\OperatorTok{.}\FunctionTok{None}\OperatorTok{);}
\NormalTok{window}\OperatorTok{.}\FunctionTok{KeyTextInput}\OperatorTok{(}\StringTok{"!"}\OperatorTok{);}

\NormalTok{textBox}\OperatorTok{.}\FunctionTok{Text}\OperatorTok{.}\FunctionTok{Should}\OperatorTok{().}\FunctionTok{Be}\OperatorTok{(}\StringTok{"Hi!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Avalonia routes the events through \texttt{KeyboardDevice} so controls
experience the same bubbling/tunneling as in production. Remember to set
focus explicitly (\texttt{textBox.Focus()} or
\texttt{KeyboardDevice.Instance.SetFocusedElement}) before
typing---headless windows do not auto-focus when shown.

\subsection{3. Pointer gestures and
drag/drop}\label{pointer-gestures-and-dragdrop}

Mouse helpers cover move, button transitions, wheel scrolling, and
drag/drop scenarios. The headless platform maintains a single virtual
pointer (\texttt{HeadlessWindowImpl} uses \texttt{PointerDevice}, see
\texttt{external/Avalonia/src/Headless/Avalonia.Headless/HeadlessWindowImpl.cs:34}).

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ listBox }\OperatorTok{=} \KeywordTok{new}\NormalTok{ ListBox}
\OperatorTok{\{}
\NormalTok{    ItemsSource }\OperatorTok{=} \KeywordTok{new}\OperatorTok{[]} \OperatorTok{\{} \StringTok{"Alpha"}\OperatorTok{,} \StringTok{"Beta"}\OperatorTok{,} \StringTok{"Gamma"} \OperatorTok{\}}
\OperatorTok{\};}
\DataTypeTok{var}\NormalTok{ window }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Window }\OperatorTok{\{}\NormalTok{ Content }\OperatorTok{=}\NormalTok{ listBox }\OperatorTok{\};}
\NormalTok{window}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{();}

\CommentTok{// Click first item}
\NormalTok{window}\OperatorTok{.}\FunctionTok{MouseMove}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{));}
\NormalTok{window}\OperatorTok{.}\FunctionTok{MouseDown}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{),}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}
\NormalTok{window}\OperatorTok{.}\FunctionTok{MouseUp}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{),}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}
\NormalTok{listBox}\OperatorTok{.}\FunctionTok{SelectedIndex}\OperatorTok{.}\FunctionTok{Should}\OperatorTok{().}\FunctionTok{Be}\OperatorTok{(}\DecValTok{0}\OperatorTok{);}

\CommentTok{// Scroll down}
\NormalTok{window}\OperatorTok{.}\FunctionTok{MouseWheel}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{),} \KeywordTok{new} \FunctionTok{Vector}\OperatorTok{(}\DecValTok{0}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{120}\OperatorTok{));}
\end{Highlighting}
\end{Shaded}

For drag/drop, build a \texttt{DataObject} and send a sequence of drag
events:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ data }\OperatorTok{=} \KeywordTok{new} \FunctionTok{DataObject}\OperatorTok{();}
\NormalTok{data}\OperatorTok{.}\FunctionTok{Set}\OperatorTok{(}\NormalTok{DataFormats}\OperatorTok{.}\FunctionTok{Text}\OperatorTok{,} \StringTok{"payload"}\OperatorTok{);}
\NormalTok{window}\OperatorTok{.}\FunctionTok{DragDrop}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{20}\OperatorTok{),}\NormalTok{ RawDragEventType}\OperatorTok{.}\FunctionTok{DragEnter}\OperatorTok{,}\NormalTok{ data}\OperatorTok{,}\NormalTok{ DragDropEffects}\OperatorTok{.}\FunctionTok{Copy}\OperatorTok{);}
\NormalTok{window}\OperatorTok{.}\FunctionTok{DragDrop}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{80}\OperatorTok{,} \DecValTok{40}\OperatorTok{),}\NormalTok{ RawDragEventType}\OperatorTok{.}\FunctionTok{DragOver}\OperatorTok{,}\NormalTok{ data}\OperatorTok{,}\NormalTok{ DragDropEffects}\OperatorTok{.}\FunctionTok{Copy}\OperatorTok{);}
\NormalTok{window}\OperatorTok{.}\FunctionTok{DragDrop}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{80}\OperatorTok{,} \DecValTok{40}\OperatorTok{),}\NormalTok{ RawDragEventType}\OperatorTok{.}\FunctionTok{Drop}\OperatorTok{,}\NormalTok{ data}\OperatorTok{,}\NormalTok{ DragDropEffects}\OperatorTok{.}\FunctionTok{Copy}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Your controls will receive \texttt{DragEventArgs}, invoke drop handlers,
and update view-models just as they would with real user input.

\subsection{4. Focus, capture, and multi-step
workflows}\label{focus-capture-and-multi-step-workflows}

Headless tests still rely on Avalonia's focus and capture services:

\begin{itemize}
\tightlist
\item
  Call \texttt{control.Focus()} or
  \texttt{FocusManager.Instance.Focus(control)} before keyboard entry.
\item
  Pointer capture happens automatically when a control handles
  \texttt{PointerPressed} and calls \texttt{e.Pointer.Capture(control)}.
  To assert capture, inspect \texttt{Pointer.Captured} inside your test
  after dispatching input.
\item
  Release capture manually with \texttt{pointer.Capture(null)} when
  simulating complex gestures to avoid stale state.
\end{itemize}

Example: testing a custom drag handle that requires capture and modifier
keys.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\NormalTok{AvaloniaFact}\OperatorTok{]}
\KeywordTok{public} \DataTypeTok{void} \FunctionTok{DragHandle\_updates\_offset}\OperatorTok{()}
\OperatorTok{\{}
    \DataTypeTok{var}\NormalTok{ handle }\OperatorTok{=} \KeywordTok{new} \FunctionTok{DragHandleControl}\OperatorTok{();}
    \DataTypeTok{var}\NormalTok{ window }\OperatorTok{=} \KeywordTok{new}\NormalTok{ Window }\OperatorTok{\{}\NormalTok{ Content }\OperatorTok{=}\NormalTok{ handle }\OperatorTok{\};}
\NormalTok{    window}\OperatorTok{.}\FunctionTok{Show}\OperatorTok{();}

\NormalTok{    window}\OperatorTok{.}\FunctionTok{MouseMove}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{5}\OperatorTok{,} \DecValTok{5}\OperatorTok{));}
\NormalTok{    window}\OperatorTok{.}\FunctionTok{MouseDown}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{5}\OperatorTok{,} \DecValTok{5}\OperatorTok{),}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{,}\NormalTok{ RawInputModifiers}\OperatorTok{.}\FunctionTok{LeftMouseButton}\OperatorTok{);}
\NormalTok{    handle}\OperatorTok{.}\FunctionTok{PointerIsCaptured}\OperatorTok{.}\FunctionTok{Should}\OperatorTok{().}\FunctionTok{BeTrue}\OperatorTok{();}

\NormalTok{    window}\OperatorTok{.}\FunctionTok{MouseMove}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{45}\OperatorTok{,} \DecValTok{5}\OperatorTok{),}\NormalTok{ RawInputModifiers}\OperatorTok{.}\FunctionTok{LeftMouseButton} \OperatorTok{|}\NormalTok{ RawInputModifiers}\OperatorTok{.}\FunctionTok{Shift}\OperatorTok{);}
\NormalTok{    window}\OperatorTok{.}\FunctionTok{MouseUp}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\DecValTok{45}\OperatorTok{,} \DecValTok{5}\OperatorTok{),}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}

\NormalTok{    handle}\OperatorTok{.}\FunctionTok{Offset}\OperatorTok{.}\FunctionTok{Should}\OperatorTok{().}\FunctionTok{BeGreaterThan}\OperatorTok{(}\DecValTok{0}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Because \texttt{HeadlessWindowExtensions} executes all gestures on the
UI thread, your control can update dependency properties, trigger
animations, and publish events synchronously within the test.

\subsection{5. Compose higher-level automation
helpers}\label{compose-higher-level-automation-helpers}

Most suites wrap common interaction patterns in reusable functions to
keep tests declarative:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ HeadlessUser}
\OperatorTok{\{}
    \KeywordTok{private} \KeywordTok{readonly}\NormalTok{ Window \_window}\OperatorTok{;}
    \KeywordTok{public} \FunctionTok{HeadlessUser}\OperatorTok{(}\NormalTok{Window window}\OperatorTok{)} \OperatorTok{=\textgreater{}}\NormalTok{ \_window }\OperatorTok{=}\NormalTok{ window}\OperatorTok{;}

    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Click}\OperatorTok{(}\NormalTok{Control control}\OperatorTok{)}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ point }\OperatorTok{=}\NormalTok{ control}\OperatorTok{.}\FunctionTok{TranslatePoint}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Point}\OperatorTok{(}\NormalTok{control}\OperatorTok{.}\FunctionTok{Bounds}\OperatorTok{.}\FunctionTok{Width} \OperatorTok{/} \DecValTok{2}\OperatorTok{,}\NormalTok{ control}\OperatorTok{.}\FunctionTok{Bounds}\OperatorTok{.}\FunctionTok{Height} \OperatorTok{/} \DecValTok{2}\OperatorTok{),}\NormalTok{ \_window}\OperatorTok{)} \OperatorTok{??} \KeywordTok{default}\OperatorTok{;}
\NormalTok{        \_window}\OperatorTok{.}\FunctionTok{MouseMove}\OperatorTok{(}\NormalTok{point}\OperatorTok{);}
\NormalTok{        \_window}\OperatorTok{.}\FunctionTok{MouseDown}\OperatorTok{(}\NormalTok{point}\OperatorTok{,}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}
\NormalTok{        \_window}\OperatorTok{.}\FunctionTok{MouseUp}\OperatorTok{(}\NormalTok{point}\OperatorTok{,}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{);}
    \OperatorTok{\}}

    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Type}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ text}\OperatorTok{)}
    \OperatorTok{\{}
        \KeywordTok{foreach} \OperatorTok{(}\DataTypeTok{var}\NormalTok{ ch }\KeywordTok{in}\NormalTok{ text}\OperatorTok{)}
\NormalTok{            \_window}\OperatorTok{.}\FunctionTok{KeyTextInput}\OperatorTok{(}\NormalTok{ch}\OperatorTok{.}\FunctionTok{ToString}\OperatorTok{());}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Pair these helpers with assertions against \texttt{AutomationProperties}
to verify accessibility metadata as you drive the UI. Tests in
\texttt{external/Avalonia/tests/Avalonia.Headless.UnitTests/InputTests.cs:29}
demonstrate structuring fixtures that open a window in
\texttt{{[}SetUp{]}}/constructor, execute gestures, and dispose
deterministically.

\subsection{6. Raw input modifiers and multiple
devices}\label{raw-input-modifiers-and-multiple-devices}

\texttt{RawInputModifiers} combines buttons, keyboard modifiers, and
touch states into a single bit field. Use it to emulate complex
shortcuts:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{window}\OperatorTok{.}\FunctionTok{MouseDown}\OperatorTok{(}\NormalTok{point}\OperatorTok{,}\NormalTok{ MouseButton}\OperatorTok{.}\FunctionTok{Left}\OperatorTok{,}\NormalTok{ RawInputModifiers}\OperatorTok{.}\FunctionTok{LeftMouseButton} \OperatorTok{|}\NormalTok{ RawInputModifiers}\OperatorTok{.}\FunctionTok{Control}\OperatorTok{);}
\NormalTok{window}\OperatorTok{.}\FunctionTok{KeyPress}\OperatorTok{(}\NormalTok{Key}\OperatorTok{.}\FunctionTok{S}\OperatorTok{,}\NormalTok{ RawInputModifiers}\OperatorTok{.}\FunctionTok{Control}\OperatorTok{,}\NormalTok{ PhysicalKey}\OperatorTok{.}\FunctionTok{KeyS}\OperatorTok{,} \StringTok{"s"}\OperatorTok{);}
\end{Highlighting}
\end{Shaded}

Headless currently exposes a single mouse pointer and keyboard. To
simulate multi-pointer scenarios (e.g., pinch gestures), create custom
\texttt{RawPointerEventArgs} and push them through
\texttt{InputManager.Instance.ProcessInput}. That advanced path uses
\texttt{IInputRoot.Input} (hook available via
\texttt{HeadlessWindowImpl.Input}), giving you full control when default
helpers are insufficient.

\subsection{7. Troubleshooting}\label{troubleshooting-5}

\begin{itemize}
\tightlist
\item
  \textbf{No events firing} -- confirm you called \texttt{window.Show()}
  and that the target control is in the visual tree. Without showing,
  the platform impl doesn't attach an \texttt{InputRoot}.
\item
  \textbf{Focus lost between gestures} -- check whether your control
  closes popups or dialogs. Re-focus before continuing or assert against
  \texttt{FocusManager.Instance.Current}.
\item
  \textbf{Pointer coordinates off} -- convert control-relative
  coordinates to window coordinates (\texttt{TranslatePoint}) and
  double-check logical vs.~visual point units (headless always uses
  logical units, scaling = 1 unless you override).
\item
  \textbf{Keyboard text missing} -- some controls ignore
  \texttt{KeyTextInput} without focus or when \texttt{AcceptsReturn} is
  false. Set the right properties or use \texttt{TextInputOptions} when
  testing IME handling
  (\texttt{external/Avalonia/src/Avalonia.Base/Input/TextInput/TextInputOptions.cs}).
\item
  \textbf{Drag/drop crashes} -- make sure Skia is enabled for
  capture-heavy tests and that you dispose \texttt{DataObject} content
  streams after the drop completes.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-8}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{User DSL} -- Build a \texttt{HeadlessUser} helper that
  supports click, double-click, context menu, typing, and modifier-aware
  shortcuts. Use it to script multi-page navigation flows.
\item
  \textbf{Pointer capture assertions} -- Write a test that verifies a
  custom canvas captures the pointer during drawing and releases it when
  \texttt{PointerReleased} fires, asserting against
  \texttt{Pointer.Captured}.
\item
  \textbf{Keyboard navigation} -- Simulate
  \texttt{Tab}/\texttt{Shift+Tab} sequences across a dialog and assert
  \texttt{FocusManager.Instance.Current} to ensure accessibility order
  is correct.
\item
  \textbf{Drag/drop harness} -- Create reusable helpers for
  \texttt{DragEnter}/\texttt{DragOver}/\texttt{Drop} with specific
  \texttt{IDataObject} payloads. Verify your view-model receives the
  right data and that effects (\texttt{DragDropEffects}) match
  expectations.
\item
  \textbf{IME/text services} -- Toggle \texttt{TextInputOptions} on a
  \texttt{TextBox}, send mixed \texttt{KeyPress} and
  \texttt{KeyTextInput} events, and confirm composition events surface
  in your view-model for languages requiring IME support.
\end{enumerate}

What's next - Next: \href{Chapter42.md}{Chapter42}

\newpage

\subsection{42. CI pipelines, diagnostics, and
troubleshooting}\label{ci-pipelines-diagnostics-and-troubleshooting}

Goal - Run Avalonia headless and automation suites reliably in CI across
Windows, macOS, and Linux agents. - Capture logs, screenshots, and
diagnostics artifacts so UI regressions are easy to triage. - Detect
hangs or ordering issues proactively and keep runs deterministic even
under heavy concurrency.

Why this matters - UI regressions usually surface first in
automation---if the pipeline flakes, the team stops trusting the signal.
- Headless tests rely on the dispatcher and render loop; CI environments
with limited GPUs or desktops need deliberate setup. - Rich artifacts
(logs, videos, dumps) turn red builds into actionable bug reports
instead of mystery failures.

Prerequisites - Chapter 38 for configuring \texttt{UseHeadless} and
driving the dispatcher. - Chapter 39 for integrating the headless test
session into xUnit or NUnit. - Chapter 41 for scripting complex input
sequences that your pipeline will exercise.

\subsection{1. Pick a CI host and bootstrap
prerequisites}\label{pick-a-ci-host-and-bootstrap-prerequisites}

Avalonia's own integration pipeline (see
\texttt{external/Avalonia/azure-pipelines-integrationtests.yml:1})
demonstrates the moving parts for Appium + headless test runs:

\begin{itemize}
\tightlist
\item
  Install the correct .NET runtimes/SDKs via \texttt{UseDotNet@2}.
\item
  Prepare platform dependencies (e.g., select Xcode, kill stray
  \texttt{node} processes, start Appium on macOS; start WinAppDriver on
  Windows).
\item
  Build the test app and run \texttt{dotnet\ test} against
  \texttt{Avalonia.IntegrationTests.Appium.csproj}.
\item
  Publish artifacts---\texttt{appium.out} on failure and TRX results on
  all outcomes.
\end{itemize}

For GitHub Actions, mirror that setup with runner-specific steps:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{jobs}\KeywordTok{:}
\AttributeTok{  }\FunctionTok{ui{-}tests}\KeywordTok{:}
\AttributeTok{    }\FunctionTok{strategy}\KeywordTok{:}
\AttributeTok{      }\FunctionTok{matrix}\KeywordTok{:}
\AttributeTok{        }\FunctionTok{os}\KeywordTok{:}\AttributeTok{ }\KeywordTok{[}\AttributeTok{windows{-}latest}\KeywordTok{,}\AttributeTok{ macos}\DecValTok{{-}13}\KeywordTok{]}
\AttributeTok{    }\FunctionTok{runs{-}on}\KeywordTok{:}\AttributeTok{ $\{\{ matrix.os \}\}}
\AttributeTok{    }\FunctionTok{steps}\KeywordTok{:}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{uses}\KeywordTok{:}\AttributeTok{ actions/checkout@v4}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{uses}\KeywordTok{:}\AttributeTok{ actions/setup{-}dotnet@v3}
\AttributeTok{        }\FunctionTok{with}\KeywordTok{:}
\AttributeTok{          }\FunctionTok{global{-}json{-}file}\KeywordTok{:}\AttributeTok{ global.json}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ Start WinAppDriver}
\AttributeTok{        }\FunctionTok{if}\KeywordTok{:}\AttributeTok{ runner.os == \textquotesingle{}Windows\textquotesingle{}}
\AttributeTok{        }\FunctionTok{run}\KeywordTok{:}\AttributeTok{ Start{-}Process {-}FilePath \textquotesingle{}C:\textbackslash{}\textbackslash{}Program Files (x86)\textbackslash{}\textbackslash{}Windows Application Driver\textbackslash{}\textbackslash{}WinAppDriver.exe\textquotesingle{}}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ Restore}
\AttributeTok{        }\FunctionTok{run}\KeywordTok{:}\AttributeTok{ dotnet restore tests/Avalonia.Headless.UnitTests}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ Test headless suite}
\AttributeTok{        }\FunctionTok{run}\KeywordTok{:}\AttributeTok{ dotnet test tests/Avalonia.Headless.UnitTests {-}{-}logger "trx;LogFileName=headless.trx" {-}{-}blame{-}hang{-}timeout 5m}
\AttributeTok{      }\KeywordTok{{-}}\AttributeTok{ }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ Publish results}
\AttributeTok{        }\FunctionTok{if}\KeywordTok{:}\AttributeTok{ always()}
\AttributeTok{        }\FunctionTok{uses}\KeywordTok{:}\AttributeTok{ actions/upload{-}artifact@v4}
\AttributeTok{        }\FunctionTok{with}\KeywordTok{:}
\AttributeTok{          }\FunctionTok{name}\KeywordTok{:}\AttributeTok{ headless{-}results}
\AttributeTok{          }\FunctionTok{path}\KeywordTok{:}\AttributeTok{ }\StringTok{\textquotesingle{}**/*.trx\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Adjust the matrix for Linux when you only need headless tests (no
Appium). Use the same \texttt{dotnet\ test} command locally to validate
pipeline scripts.

\subsection{2. Configure deterministic test
execution}\label{configure-deterministic-test-execution}

Headless suites should run with parallelism disabled unless every
fixture is isolation-safe. xUnit supports assembly-level configuration:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// AssemblyInfo.cs}
\OperatorTok{[}\NormalTok{assembly}\OperatorTok{:} \FunctionTok{CollectionBehavior}\OperatorTok{(}\NormalTok{DisableTestParallelization }\OperatorTok{=} \KeywordTok{true}\OperatorTok{)]}
\OperatorTok{[}\NormalTok{assembly}\OperatorTok{:}\NormalTok{ AvaloniaTestFramework}\OperatorTok{]}
\end{Highlighting}
\end{Shaded}

Pair the attribute with \texttt{AvaloniaTestApplication} so a single
\texttt{HeadlessUnitTestSession} drives the whole assembly. For NUnit,
launch the test runner with \texttt{-\/-workers=1} or mark fixtures
\texttt{{[}NonParallelizable{]}}. This avoids fighting over the
singleton dispatcher and ensures actions happen in the same order on
developer machines and CI bots.

Within tests, drain work deterministically.
\texttt{HeadlessWindowExtensions} already wraps each gesture with
\texttt{Dispatcher.UIThread.RunJobs()} and
\texttt{AvaloniaHeadlessPlatform.ForceRenderTimerTick()}; call those
directly from helpers when you schedule background tasks outside the
provided wrappers.

\subsection{3. Capture logs, screenshots, and
videos}\label{capture-logs-screenshots-and-videos}

Collect evidence automatically so failing builds are actionable:

\begin{itemize}
\tightlist
\item
  Turn on Avalonia's trace logging by chaining \texttt{.LogToTrace()} in
  your \texttt{AppBuilder}. Redirect stderr to a file in CI
  (\texttt{dotnet\ test\ …\ 2\textgreater{}\ headless.log}) and upload
  it as an artifact.
\item
  Use \texttt{CaptureRenderedFrame} (Chapter 40) to grab before/after
  bitmaps on failure. Save them with a timestamp inside
  \texttt{TestContext.CurrentContext.WorkDirectory} (NUnit) or
  \texttt{ITestOutputHelper} attachments (xUnit).
\item
  On Windows, record screen captures with MSTest data collectors.
  Avalonia ships \texttt{record-video.runsettings}
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/record-video.runsettings:1})
  to capture Appium sessions; reuse it by passing
  \texttt{/Settings:record-video.runsettings} to VSTest or
  \texttt{-\/-settings} to \texttt{dotnet\ test}.
\item
  For Appium runs, write driver logs to disk. The macOS pipeline
  publishes \texttt{appium.out} when a job fails
  (\texttt{external/Avalonia/azure-pipelines-integrationtests.yml:27}).
\end{itemize}

\subsection{4. Diagnose hangs and
deadlocks}\label{diagnose-hangs-and-deadlocks}

UI tests occasionally hang because outstanding work blocks the
dispatcher. Harden your pipeline with diagnosis options:

\begin{itemize}
\tightlist
\item
  Use
  \texttt{dotnet\ test\ -\/-blame-hang-timeout\ 5m\ -\/-blame-hang-dump-type\ full}
  to trigger crash dumps when a test exceeds the timeout.
\item
  Wrap long-running awaits inside
  \texttt{HeadlessUnitTestSession.Dispatch} so the framework can pump
  the dispatcher
  (\texttt{external/Avalonia/src/Headless/Avalonia.Headless/HeadlessUnitTestSession.cs:54}).
\item
  Expose a helper that runs \texttt{Dispatcher.UIThread.RunJobs()} and
  \texttt{AvaloniaHeadlessPlatform.ForceRenderTimerTick()} in a loop
  until a condition is met. Fail the test if the condition never becomes
  true to avoid infinite waits.
\item
  When debugging locally, attach a logger to \texttt{DispatcherTimer}
  callbacks or set \texttt{DispatcherTimer.Tag} to identify timers
  causing hangs; the headless render timer is labeled
  \texttt{HeadlessRenderTimer}
  (\texttt{external/Avalonia/src/Headless/Avalonia.Headless/AvaloniaHeadlessPlatform.cs:21}).
\end{itemize}

Analyze captured dumps with \texttt{dotnet-dump\ analyze} to inspect
managed thread stacks and spot blocked tasks.

\subsection{5. Environment hygiene on shared
agents}\label{environment-hygiene-on-shared-agents}

CI agents often reuse workspaces. Add cleanup steps before running UI
automation:

\begin{itemize}
\tightlist
\item
  Kill straggling processes (\texttt{pkill\ IntegrationTestApp},
  \texttt{pkill\ node}) as the macOS pipeline does
  (\texttt{external/Avalonia/azure-pipelines-integrationtests.yml:21}).
\item
  Remove stale app bundles or temporary data to guarantee a clean run.
\item
  Reset environment variables that influence Avalonia behavior (e.g.,
  \texttt{AVALONIA\_RENDERER} overrides). Keep your scripts explicit to
  avoid surprises when infra engineers tweak images.
\end{itemize}

For cross-platform Appium tests, encapsulate capability setup in
fixtures. \texttt{DefaultAppFixture}
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/DefaultAppFixture.cs:9})
configures Windows and macOS sessions differently while exposing a
consistent driver to tests.

\subsection{6. Build health dashboards and
alerts}\label{build-health-dashboards-and-alerts}

Publish TRX or NUnit XML outputs to your CI system so failures appear in
dashboards. Azure Pipelines uses \texttt{PublishTestResults@2} to ingest
xUnit results even when the job succeeds with warnings
(\texttt{external/Avalonia/azure-pipelines-integrationtests.yml:67}).
GitHub Actions can read TRX via \texttt{dorny/test-reporter} or similar
actions.

Send critical logs to observability tools if your team maintains
telemetry infrastructure. A simple approach is to push structured log
lines to stdout in JSON---CI services preserve the console by default.

\subsection{7. Troubleshooting
checklist}\label{troubleshooting-checklist-1}

\begin{itemize}
\tightlist
\item
  \textbf{Tests fail only on CI} -- compare fonts, localization, and
  DPI. Ensure custom fonts are deployed with the test app and
  \texttt{CultureInfo.DefaultThreadCurrentUICulture} is set for
  deterministic layouts.
\item
  \textbf{Intermittent hangs} -- add \texttt{-\/-blame} dumps, then
  review stuck threads. Often a test awaited \texttt{Task.Delay} without
  advancing the render timer; replace with deterministic loops.
\item
  \textbf{Missing screenshots} -- confirm Skia is enabled
  (\texttt{UseHeadlessDrawing\ =\ false}) so
  \texttt{CaptureRenderedFrame} works in pipelines.
\item
  \textbf{Appium session errors} -- verify the automation server is
  running (WinAppDriver/Appium) before tests start, and stop it in a
  final step to avoid port conflicts next run.
\item
  \textbf{Resource leaks across tests} -- always close windows
  (\texttt{window.Close()}), dispose \texttt{CompositeDisposable}, and
  tear down Appium sessions in \texttt{Dispose}. Lingering windows keep
  the dispatcher alive and can cause later tests to inherit state.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-9}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Pipeline parity} -- Create a local script that mirrors your CI
  job (\texttt{dotnet\ restore}, \texttt{dotnet\ test}, artifact copy).
  Run it before pushing so pipeline failures never surprise you.
\item
  \textbf{Hang detector} -- Wire \texttt{dotnet\ test\ -\/-blame} into
  your CI job and practice analyzing the generated dumps for a
  deliberately hung test.
\item
  \textbf{Artifact triage} -- Extend your test harness to save headless
  screenshots and logs into an output directory, then configure your
  pipeline to upload them on failure.
\item
  \textbf{Parallelism audit} -- Temporarily enable test parallelization
  to identify fixtures that rely on global state. Fix the offenders or
  permanently disable parallel runs via assembly attributes.
\item
  \textbf{Cross-platform dry run} -- Use a GitHub Actions matrix or
  Azure multi-job pipeline to run headless tests on Windows and Linux
  simultaneously, comparing logs for environment-specific quirks.
\end{enumerate}

What's next - Next: \href{Chapter43.md}{Chapter43}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part IX — Appium automation done right}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part IX — Appium automation done right}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{43. Appium fundamentals for Avalonia
apps}\label{appium-fundamentals-for-avalonia-apps}

Goal - Stand up Appium-based UI tests that drive Avalonia desktop apps
on Windows and macOS. - Reuse the built-in integration harness
(\texttt{Avalonia.IntegrationTests.Appium}) to spin sessions, navigate
the sample app, and locate controls reliably. - Understand the
accessibility surface Avalonia exposes so selectors stay stable across
platforms and Appium versions.

Why this matters - End-to-end coverage validates window chrome, dialogs,
and platform behaviors that headless tests can't touch. - Appium works
with the same accessibility tree users rely on---tests that pass here
give confidence in automation readiness. - A disciplined harness keeps
session setup, synchronization, and cleanup consistent across operating
systems.

Prerequisites - Chapter 12 for windowing concepts referenced by Appium
tests. - Chapter 13 for menus/dialogs---the automation harness exercises
them heavily. - Chapter 42 for CI orchestration once your Appium suite
is green locally.

\subsection{1. Anatomy of the Avalonia Appium
harness}\label{anatomy-of-the-avalonia-appium-harness}

Avalonia ships an Appium test suite in
\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium}. Key
parts:

\begin{itemize}
\tightlist
\item
  \texttt{DefaultAppFixture} builds and launches the sample
  \texttt{IntegrationTestApp}, creating an \texttt{AppiumDriver} for
  Windows or macOS sessions
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/DefaultAppFixture.cs:9}).
\item
  \texttt{TestBase} accepts the fixture and navigates the
  ControlCatalog-style pager. It retries the navigation click to absorb
  macOS animations
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TestBase.cs:6}).
\item
  \texttt{CollectionDefinitions} wires fixtures into xUnit collections
  so sessions are shared per test class
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/CollectionDefinitions.cs:4}).
\end{itemize}

Reuse this structure in your own project: create a fixture that launches
your app (packaged exe/bundle), expose the \texttt{AppiumDriver}, and
derive page-specific test classes from a \texttt{TestBase} that performs
navigation.

\subsection{2. Configure sessions per
platform}\label{configure-sessions-per-platform}

\texttt{DefaultAppFixture} populates capability sets tailored to each
OS:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{var}\NormalTok{ options }\OperatorTok{=} \KeywordTok{new} \FunctionTok{AppiumOptions}\OperatorTok{();}
\KeywordTok{if} \OperatorTok{(}\NormalTok{OperatingSystem}\OperatorTok{.}\FunctionTok{IsWindows}\OperatorTok{())}
\OperatorTok{\{}
\NormalTok{    options}\OperatorTok{.}\FunctionTok{AddAdditionalCapability}\OperatorTok{(}\NormalTok{MobileCapabilityType}\OperatorTok{.}\FunctionTok{App}\OperatorTok{,}\NormalTok{ TestAppPath}\OperatorTok{);}
\NormalTok{    options}\OperatorTok{.}\FunctionTok{AddAdditionalCapability}\OperatorTok{(}\NormalTok{MobileCapabilityType}\OperatorTok{.}\FunctionTok{PlatformName}\OperatorTok{,}\NormalTok{ MobilePlatform}\OperatorTok{.}\FunctionTok{Windows}\OperatorTok{);}
\NormalTok{    options}\OperatorTok{.}\FunctionTok{AddAdditionalCapability}\OperatorTok{(}\NormalTok{MobileCapabilityType}\OperatorTok{.}\FunctionTok{DeviceName}\OperatorTok{,} \StringTok{"WindowsPC"}\OperatorTok{);}
\NormalTok{    Session }\OperatorTok{=} \KeywordTok{new} \FunctionTok{WindowsDriver}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Uri}\OperatorTok{(}\StringTok{"http://127.0.0.1:4723"}\OperatorTok{),}\NormalTok{ options}\OperatorTok{);}
\OperatorTok{\}}
\KeywordTok{else} \KeywordTok{if} \OperatorTok{(}\NormalTok{OperatingSystem}\OperatorTok{.}\FunctionTok{IsMacOS}\OperatorTok{())}
\OperatorTok{\{}
\NormalTok{    options}\OperatorTok{.}\FunctionTok{AddAdditionalCapability}\OperatorTok{(}\StringTok{"appium:bundleId"}\OperatorTok{,} \StringTok{"net.avaloniaui.avalonia.integrationtestapp"}\OperatorTok{);}
\NormalTok{    options}\OperatorTok{.}\FunctionTok{AddAdditionalCapability}\OperatorTok{(}\NormalTok{MobileCapabilityType}\OperatorTok{.}\FunctionTok{PlatformName}\OperatorTok{,}\NormalTok{ MobilePlatform}\OperatorTok{.}\FunctionTok{MacOS}\OperatorTok{);}
\NormalTok{    options}\OperatorTok{.}\FunctionTok{AddAdditionalCapability}\OperatorTok{(}\NormalTok{MobileCapabilityType}\OperatorTok{.}\FunctionTok{AutomationName}\OperatorTok{,} \StringTok{"mac2"}\OperatorTok{);}
\NormalTok{    Session }\OperatorTok{=} \KeywordTok{new} \FunctionTok{MacDriver}\OperatorTok{(}\KeywordTok{new} \FunctionTok{Uri}\OperatorTok{(}\StringTok{"http://127.0.0.1:4723/wd/hub"}\OperatorTok{),}\NormalTok{ options}\OperatorTok{);}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The fixture also foregrounds the window on Windows via
\texttt{SetForegroundWindow} to avoid focus issues. Always close the
session in \texttt{Dispose} even if Appium errors---macOS' \texttt{mac2}
driver may throw on shutdown, so wrap in try/catch like the sample.

TIP: keep Appium/WAD endpoints configurable via environment variables so
your CI scripts can point to remote device clouds.

\subsection{3. Navigating the sample
app}\label{navigating-the-sample-app}

\texttt{TestBase} selects a page by finding the pager control and
clicking the relevant button. The same pattern applies to your app:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{class}\NormalTok{ WindowTests }\OperatorTok{:}\NormalTok{ TestBase}
\OperatorTok{\{}
    \KeywordTok{public} \FunctionTok{WindowTests}\OperatorTok{(}\NormalTok{DefaultAppFixture fixture}\OperatorTok{)} \OperatorTok{:} \KeywordTok{base}\OperatorTok{(}\NormalTok{fixture}\OperatorTok{,} \StringTok{"Window"}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{\}}

    \OperatorTok{[}\NormalTok{Fact}\OperatorTok{]}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{Can\_toggle\_window\_state}\OperatorTok{()}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ windowStateCombo }\OperatorTok{=}\NormalTok{ Session}\OperatorTok{.}\FunctionTok{FindElementByAccessibilityId}\OperatorTok{(}\StringTok{"CurrentWindowState"}\OperatorTok{);}
\NormalTok{        windowStateCombo}\OperatorTok{.}\FunctionTok{Click}\OperatorTok{();}
\NormalTok{        Session}\OperatorTok{.}\FunctionTok{FindElementByAccessibilityId}\OperatorTok{(}\StringTok{"WindowStateMaximized"}\OperatorTok{).}\FunctionTok{SendClick}\OperatorTok{();}
\NormalTok{        Assert}\OperatorTok{.}\FunctionTok{Equal}\OperatorTok{(}\StringTok{"Maximized"}\OperatorTok{,}\NormalTok{ windowStateCombo}\OperatorTok{.}\FunctionTok{GetComboBoxValue}\OperatorTok{());}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{pageName} passed to \texttt{TestBase} must match the
accessible name exposed by the pager button. Avalonia's sample
ControlCatalog sets these via \texttt{AutomationProperties.Name}, so
always annotate navigation controls in your app for consistent
selectors.

\subsection{4. Element discovery and helper
APIs}\label{element-discovery-and-helper-apis}

Selectors vary subtly across platforms. Avalonia's helpers hide those
differences:

\begin{itemize}
\tightlist
\item
  \texttt{AppiumDriverEx} defines \texttt{FindElementByAccessibilityId},
  \texttt{FindElementByName}, and other convenience methods to work with
  both Appium 1 and 2
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/AppiumDriverEx.cs:1}).
\item
  \texttt{ElementExtensions} centralizes common queries such as chrome
  buttons and combo box value extraction. For example,
  \texttt{GetComboBoxValue} uses \texttt{Text} on Windows and
  \texttt{value} attributes elsewhere
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:34}).
\item
  \texttt{GetCurrentSingleWindow} hides the extra wrapper window present
  in macOS accessibility trees
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:60}).
\end{itemize}

When building your suite, add similar extension methods instead of
hard-coding XPath per test. Keep selectors rooted in
\texttt{AutomationId} or names you control via
\texttt{AutomationProperties.AutomationId} and \texttt{Name} to minimize
brittleness.

\subsection{5. Synchronization and
retries}\label{synchronization-and-retries}

Appium commands are asynchronous relative to the app. Avalonia tests mix
explicit waits, retries, and timeouts:

\begin{itemize}
\tightlist
\item
  \texttt{TestBase} retries page navigation three times with a 1s delay
  to survive macOS transitions.
\item
  \texttt{ElementExtensions.OpenWindowWithClick} polls for either a new
  window handle or child window to appear, retrying up to ten times
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:86}).
\item
  For transitions with animations (e.g., exiting full screen), tests
  call \texttt{Thread.Sleep} after sending commands---note the cleanup
  block in \texttt{WindowTests} that waits 1 second on macOS before
  asserting
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/WindowTests.cs:53}).
\end{itemize}

Wrap these patterns in helper methods so timing tweaks stay centralized.
For more resilient waits, use Appium's \texttt{WebDriverWait} with
conditions such as \texttt{driver.FindElementByAccessibilityId(...)} or
\texttt{element.Displayed}.

\subsection{6. Cross-platform control with attributes and
collections}\label{cross-platform-control-with-attributes-and-collections}

Automation suites often need OS-specific assertions. Avalonia uses:

\begin{itemize}
\tightlist
\item
  \texttt{{[}PlatformFact{]}}/\texttt{{[}PlatformTheory{]}} to skip
  tests on unsupported OSes
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PlatformFactAttribute.cs:7}).
\item
  Collection definitions to isolate fixtures for specialized apps (e.g.,
  overlay popups vs.~default ControlCatalog)
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/CollectionDefinitions.cs:10}).
\end{itemize}

Follow suit by tagging tests with custom attributes that read
environment variables or capability flags. This keeps your suite from
failing on agents lacking certain features (e.g., Win32-only APIs).

\subsection{7. Exposing automation IDs in
Avalonia}\label{exposing-automation-ids-in-avalonia}

Appium relies on the accessibility tree. Avalonia maps these properties
as follows:

\begin{itemize}
\tightlist
\item
  \texttt{AutomationProperties.AutomationId} and control \texttt{Name}
  become accessibility IDs (\texttt{AutomationTests.AutomationId},
  \texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/AutomationTests.cs:12}).
\item
  \texttt{AutomationProperties.Name} populates the element name in both
  Windows UIA and macOS accessibility APIs.
\item
  \texttt{AutomationProperties.LabeledBy} and other metadata surface via
  Appium attributes so you can assert associations
  (\texttt{AutomationTests.LabeledBy}).
\end{itemize}

Ensure the controls you interact with set both \texttt{AutomationId} and
\texttt{Name}; for templated controls expose IDs through \texttt{x:Name}
or \texttt{Automation.Id}. Without these properties, selectors fall back
to fragile XPath queries.

\subsection{8. Running the suite}\label{running-the-suite}

\subsubsection{Windows}\label{windows-3}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Install WinAppDriver (ships with Visual Studio workloads) and start it
  on port 4723.
\item
  Build your Avalonia app for \texttt{net8.0-windows} with
  \texttt{UseWindowsForms} disabled (the sample uses
  \texttt{IntegrationTestApp}).
\item
  Launch Appium tests:
  \texttt{dotnet\ test\ tests/Avalonia.IntegrationTests.Appium\ -\/-logger\ "trx;LogFileName=appium.trx"}.
\end{enumerate}

\subsubsection{macOS}\label{macos-3}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Install Appium 2 with the \texttt{mac2} driver and run
  \texttt{appium\ -\/-base-path\ /wd/hub}.
\item
  Ensure the test runner has accessibility permissions; the pipeline
  script resets them via \texttt{pkill} and \texttt{osascript}
  (\texttt{external/Avalonia/azure-pipelines-integrationtests.yml:17}).
\item
  Bundle the app (\texttt{samples/IntegrationTestApp/bundle.sh}) so
  Appium can reference it by bundle ID.
\end{enumerate}

Use the provided \texttt{macos-clean-build-test.sh} as a reference for
orchestrating builds locally or in CI.

\subsection{9. Troubleshooting}\label{troubleshooting-6}

\begin{itemize}
\tightlist
\item
  \textbf{Session fails to start} -- Verify the Appium server is running
  and that the path/bundle ID is correct. On Windows, ensure the test
  app exists relative to the test project
  (\texttt{DefaultAppFixture.TestAppPath}).
\item
  \textbf{Elements not found} -- Inspect the accessibility tree with
  tools such as Windows Inspect or macOS Accessibility Inspector. Add
  missing \texttt{AutomationId} values to the Avalonia XAML.
\item
  \textbf{Focus issues after fullscreen} -- Mirror Avalonia's retry
  \texttt{Thread.Sleep} or use explicit waits; macOS may animate
  transitions for up to a second.
\item
  \textbf{Multiple windows} -- Use \texttt{OpenWindowWithClick} helper
  to track handles. Remember to dispose the returned
  \texttt{IDisposable} so the new window closes after the test.
\item
  \textbf{Driver shutdown crashes} -- Wrap \texttt{Session.Close()} in
  try/catch like \texttt{DefaultAppFixture.Dispose} to shield flaky
  platform drivers.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-10}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Custom fixture} -- Implement a fixture that launches your app
  under test, parameterized by environment variables for executable path
  and Appium endpoint.
\item
  \textbf{Navigation helper} -- Create a \texttt{TestBase} that
  navigates your shell's menu/pager via automation IDs, then write a
  smoke test asserting window title, version label, or status bar text.
\item
  \textbf{Selector audit} -- Add \texttt{AutomationId} attributes to
  controls in a sample page, write tests that locate them by
  accessibility ID, and verify they remain stable after theme changes.
\item
  \textbf{Cross-platform skip logic} -- Introduce
  \texttt{{[}PlatformFact{]}}-style attributes that read from
  \texttt{RuntimeInformation} and feature flags (e.g., skip tray icon
  tests on macOS), then apply them to OS-specific suites.
\item
  \textbf{Wait strategy} -- Replace any \texttt{Thread.Sleep} in your
  tests with a reusable wait helper that polls for element state using
  Appium's \texttt{WebDriverWait}, ensuring the helper raises
  descriptive timeout errors.
\end{enumerate}

What's next - Next: \href{Chapter44.md}{Chapter44}

\newpage

\subsection{44. Environment setup, drivers, and device
clouds}\label{environment-setup-drivers-and-device-clouds}

Goal - Stand up reliable Appium infrastructure for Avalonia desktop
automation on Windows and macOS. - Package and register test apps so
automation servers can launch them locally or on remote device clouds. -
Script build/start/stop flows that keep CI agents clean while preserving
diagnostics.

Why this matters - Incorrect driver versions or unregistered bundles are
the top causes of flaky Appium runs. - Avalonia apps often ship custom
arguments (overlay popups, experimental features); tests need a
repeatable way to pass them to the harness. - Device-cloud execution
magnifies small misconfigurations---locking your setup locally prevents
expensive remote reruns.

Prerequisites - Chapter 43 for the fundamentals of Avalonia's Appium
test harness. - Chapter 42 for CI orchestration patterns and artifact
capture. - Base familiarity with platform build tooling (PowerShell,
bash, Xcode command-line tools).

\subsection{1. Install automation servers and
drivers}\label{install-automation-servers-and-drivers}

\subsubsection{Windows}\label{windows-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Install \textbf{WinAppDriver}
  (https://github.com/microsoft/WinAppDriver). It registers itself in
  the Start menu and listens on \texttt{http://127.0.0.1:4723}.
\item
  Ensure the machine is running in \textbf{desktop interactive}
  mode---WinAppDriver cannot interact with headless Windows Server
  sessions.
\item
  Optional: pin the service to auto-start via \texttt{schtasks} or a
  Windows Service wrapper so CI agents bring it up automatically.
\end{enumerate}

\subsubsection{macOS}\label{macos-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Install \textbf{Appium} (\texttt{npm\ install\ -g\ appium}). For
  Appium 1, the built-in mac driver is sufficient; for Appium 2 install
  the \texttt{mac2} driver (\texttt{appium\ driver\ install\ mac2}).
\item
  Grant Xcode helper the accessibility permissions required to drive UI
  (see harness readme at
  \texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/readme.md}).
\item
  Register your Avalonia app bundle so Appium can launch it by bundle
  ID. Avalonia's script \texttt{samples/IntegrationTestApp/bundle.sh}
  builds and publishes the bundle.
\item
  Start Appium. For Appium 2 use a base path to maintain compatibility
  with existing clients: \texttt{appium\ -\/-base-path=/wd/hub}.
\end{enumerate}

The harness toggles between Appium 1 and 2 using the
\texttt{IsRunningAppium2} property
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/Avalonia.IntegrationTests.Appium.csproj:5}).
Set the property to \texttt{true} in \texttt{Directory.Build.props} or
via \texttt{dotnet\ test\ -p:IsRunningAppium2=true} when running against
Appium 2.

\subsection{2. Package and register the test
app}\label{package-and-register-the-test-app}

Appium launches desktop apps by path (Windows) or bundle identifier
(macOS). The Avalonia sample uses \texttt{IntegrationTestApp} and
rebuilds it before each run:

\begin{itemize}
\tightlist
\item
  macOS pipeline script
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/macos-clean-build-test.sh:1})
  cleans the repo, compiles native dependencies, bundles the app, and
  opens it once to register Launch Services.
\item
  Windows pipeline
  (\texttt{external/Avalonia/azure-pipelines-integrationtests.yml:42})
  builds \texttt{IntegrationTestApp} and the test project before running
  \texttt{dotnet\ test}.
\end{itemize}

When testing your own app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Provide a CLI or script (PowerShell/bbash) that packs the app and
  exposes the absolute path or bundle ID through environment variables
  (\texttt{TEST\_APP\_PATH}, \texttt{TEST\_APP\_BUNDLE}).
\item
  Inherit from \texttt{DefaultAppFixture} and override
  \texttt{ConfigureWin32Options} / \texttt{ConfigureMacOptions} to use
  those values. Example:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{ConfigureWin32Options}\OperatorTok{(}\NormalTok{AppiumOptions options}\OperatorTok{,} \DataTypeTok{string}\OperatorTok{?}\NormalTok{ app }\OperatorTok{=} \KeywordTok{null}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{base}\OperatorTok{.}\FunctionTok{ConfigureWin32Options}\OperatorTok{(}\NormalTok{options}\OperatorTok{,}\NormalTok{ Environment}\OperatorTok{.}\FunctionTok{GetEnvironmentVariable}\OperatorTok{(}\StringTok{"TEST\_APP\_PATH"}\OperatorTok{));}
\OperatorTok{\}}

\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{ConfigureMacOptions}\OperatorTok{(}\NormalTok{AppiumOptions options}\OperatorTok{,} \DataTypeTok{string}\OperatorTok{?}\NormalTok{ app }\OperatorTok{=} \KeywordTok{null}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{base}\OperatorTok{.}\FunctionTok{ConfigureMacOptions}\OperatorTok{(}\NormalTok{options}\OperatorTok{,}\NormalTok{ Environment}\OperatorTok{.}\FunctionTok{GetEnvironmentVariable}\OperatorTok{(}\StringTok{"TEST\_APP\_BUNDLE"}\OperatorTok{));}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  For variants (e.g., overlay popups), add command-line arguments via
  capabilities. \texttt{OverlayPopupsAppFixture} adds
  \texttt{-\/-overlayPopups} on both platforms
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/OverlayPopupsAppFixture.cs:4}).
\end{enumerate}

\subsection{3. Start/stop lifecycle
scripts}\label{startstop-lifecycle-scripts}

Automation servers must be running when tests start and shut down
afterward. Avalonia's pipelines demonstrate the sequence:

\begin{itemize}
\tightlist
\item
  \textbf{macOS job} kills stray processes (\texttt{pkill\ node},
  \texttt{pkill\ IntegrationTestApp}), starts Appium in the background,
  bundles the app, launches it, runs \texttt{dotnet\ test}, then
  terminates Appium and the app again
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/macos-clean-build-test.sh:6}).
\item
  \textbf{Windows job} uses Azure DevOps tasks to start/stop
  WinAppDriver
  (\texttt{external/Avalonia/azure-pipelines-integrationtests.yml:32}).
  When scripting locally, run \texttt{Start-Process\ "WinAppDriver.exe"}
  before tests and \texttt{Stop-Process\ -Name\ WinAppDriver} afterward.
\end{itemize}

General guidelines:

\begin{itemize}
\tightlist
\item
  Always clean up (\texttt{pkill}, \texttt{Stop-Process}) on both
  success and failure to keep subsequent runs deterministic.
\item
  Redirect server logs to files
  (\texttt{appium\ \textgreater{}\ appium.out\ \&}). Publish them when
  the job fails for easier triage (see pipeline's
  \texttt{publish\ appium.out} step).
\end{itemize}

\subsection{4. Device cloud
configuration}\label{device-cloud-configuration}

Device clouds (BrowserStack App Automate, Sauce Labs, Azure-hosted
desktops) require the same capabilities plus authentication tokens:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{options}\OperatorTok{.}\FunctionTok{AddAdditionalCapability}\OperatorTok{(}\StringTok{"browserstack.user"}\OperatorTok{,}\NormalTok{ Environment}\OperatorTok{.}\FunctionTok{GetEnvironmentVariable}\OperatorTok{(}\StringTok{"BS\_USER"}\OperatorTok{));}
\NormalTok{options}\OperatorTok{.}\FunctionTok{AddAdditionalCapability}\OperatorTok{(}\StringTok{"browserstack.key"}\OperatorTok{,}\NormalTok{ Environment}\OperatorTok{.}\FunctionTok{GetEnvironmentVariable}\OperatorTok{(}\StringTok{"BS\_KEY"}\OperatorTok{));}
\NormalTok{options}\OperatorTok{.}\FunctionTok{AddAdditionalCapability}\OperatorTok{(}\StringTok{"appium:options"}\OperatorTok{,} \KeywordTok{new}\NormalTok{ Dictionary}\OperatorTok{\textless{}}\DataTypeTok{string}\OperatorTok{,} \DataTypeTok{object}\OperatorTok{\textgreater{}}
\OperatorTok{\{}
    \OperatorTok{[}\StringTok{"osVersion"}\OperatorTok{]} \OperatorTok{=} \StringTok{"11"}\OperatorTok{,}
    \OperatorTok{[}\StringTok{"deviceName"}\OperatorTok{]} \OperatorTok{=} \StringTok{"Windows 11"}\OperatorTok{,}
    \OperatorTok{[}\StringTok{"appium:app"}\OperatorTok{]} \OperatorTok{=} \StringTok{"bs://\textless{}uploaded{-}app{-}id\textgreater{}"}
\OperatorTok{\});}
\end{Highlighting}
\end{Shaded}

Upload your Avalonia app (packaged exe zipped, or macOS \texttt{.app}
bundle) via the vendor's CLI before tests run. On hosted Windows
machines, ensure the automation provider exposes UI Automation
trees---some locked-down images disable it.

When targeting clouds, keep these adjustments in fixtures:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{protected} \KeywordTok{override} \DataTypeTok{void} \FunctionTok{ConfigureWin32Options}\OperatorTok{(}\NormalTok{AppiumOptions options}\OperatorTok{,} \DataTypeTok{string}\OperatorTok{?}\NormalTok{ app }\OperatorTok{=} \KeywordTok{null}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{if} \OperatorTok{(}\NormalTok{UseCloud}\OperatorTok{)}
    \OperatorTok{\{}
\NormalTok{        options}\OperatorTok{.}\FunctionTok{AddAdditionalCapability}\OperatorTok{(}\StringTok{"app"}\OperatorTok{,}\NormalTok{ CloudAppId}\OperatorTok{);}
\NormalTok{        options}\OperatorTok{.}\FunctionTok{AddAdditionalCapability}\OperatorTok{(}\StringTok{"bstack:options"}\OperatorTok{,} \KeywordTok{new} \OperatorTok{\{}\NormalTok{ osVersion }\OperatorTok{=} \StringTok{"11"}\OperatorTok{,}\NormalTok{ sessionName }\OperatorTok{=}\NormalTok{ TestContext}\OperatorTok{.}\FunctionTok{CurrentContext}\OperatorTok{.}\FunctionTok{Test}\OperatorTok{.}\FunctionTok{Name} \OperatorTok{\});}
    \OperatorTok{\}}
    \KeywordTok{else}
    \OperatorTok{\{}
        \KeywordTok{base}\OperatorTok{.}\FunctionTok{ConfigureWin32Options}\OperatorTok{(}\NormalTok{options}\OperatorTok{,}\NormalTok{ app}\OperatorTok{);}
    \OperatorTok{\}}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Guard cloud-specific behavior using environment variables so local runs
stay unchanged.

\subsection{5. Managing driver
compatibility}\label{managing-driver-compatibility}

The harness conditionally compiles for Appium 1 vs.~2 via
\texttt{APPIUM1}/\texttt{APPIUM2} constants
(\texttt{AppiumDriverEx.cs}). Checklist:

\begin{itemize}
\tightlist
\item
  Run \texttt{dotnet\ test\ -p:IsRunningAppium2=true} when hitting
  Appium 2 endpoints. This updates \texttt{DefineConstants} and switches
  to the newer \texttt{Appium.WebDriver\ 5.x} client.
\item
  Ensure the Appium server version matches the driver: Appium 2 + mac2
  driver expect W3C protocol only.
\item
  WinAppDriver currently supports only Appium 1, so keep a separate
  pipeline lane for Windows if you standardize on Appium 2 for macOS.
\end{itemize}

If you see protocol errors, print the server log (\texttt{appium.out})
and compare capability names. Appium 2 requires \texttt{appium:}
prefixes for vendor-specific entries (already shown in
\texttt{DefaultAppFixture.ConfigureMacOptions}).

\subsection{6. Permissions and security
prompts}\label{permissions-and-security-prompts}

Desktop automation breaks when the app lacks accessibility permissions:

\begin{itemize}
\tightlist
\item
  macOS: add the Appium binary, the terminal/agent, and Xcode helper to
  \texttt{System\ Settings\ →\ Privacy\ \&\ Security\ →\ Accessibility}.
  The readme covers the exact steps.
\item
  Windows: disable UAC prompts or run the agent as administrator. If UAC
  prompts appear, automation cannot interact with the foreground until
  dismissed.
\item
  Device clouds: follow provider docs to grant persistent accessibility
  or run under pre-approved automation accounts.
\end{itemize}

Automate these steps where possible---on macOS you can pre-provision a
profile or run a script to enable permissions via \texttt{tccutil}. For
Windows, prefer an image with WinAppDriver pre-installed.

\subsection{7. Logging and diagnostics}\label{logging-and-diagnostics}

Augment your harness to collect evidence:

\begin{itemize}
\tightlist
\item
  Use \texttt{appium\ -\/-log-level\ info\ -\/-log\ appium.log} to write
  structured JSON logs.
\item
  Forward driver logs to test output:
  \texttt{Session.Manage().Logs.GetLog("driver");} after a failure.
\item
  For WinAppDriver, enable verbose logs via registry
  (\texttt{HKEY\_LOCAL\_MACHINE\textbackslash{}SOFTWARE\textbackslash{}Microsoft\textbackslash{}WinAppDriver\textbackslash{}ConsoleLogging\ =\ 1}).
\item
  Record video on Windows using the supplied
  \texttt{record-video.runsettings} file when executing through VSTest
  (Chapter 42).
\end{itemize}

\subsection{8. Troubleshooting}\label{troubleshooting-7}

\begin{itemize}
\tightlist
\item
  \textbf{\texttt{SessionNotCreatedException}} -- Check that the app
  path/bundle exists and the process isn't already running. On macOS,
  run \texttt{osascript} cleanup like the sample script to delete stale
  bundles.
\item
  \textbf{\texttt{Could\ not\ find\ app}} -- Re-run your packaging
  script; the bundle path changes when switching architectures
  (\texttt{osx-arm64} vs.~\texttt{osx-x64}).
\item
  \textbf{Authentication failures on clouds} -- Ensure credentials are
  injected securely via pipeline secrets; log obfuscated values for
  debugging but never commit them to source.
\item
  \textbf{Driver mismatch} -- Align \texttt{IsRunningAppium2} with the
  server version. Appium 2 rejects legacy capability names like
  \texttt{bundleId} without the \texttt{appium:} prefix.
\item
  \textbf{Resource leaks} -- Always dispose fixtures, even in skipped
  tests. Wrap \texttt{Session} accesses in \texttt{try/finally} or use
  \texttt{IAsyncLifetime} to guarantee cleanup after each class.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-11}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Bootstrap script} -- Create cross-platform scripts
  (\texttt{scripts/run-appium-tests.ps1} and \texttt{.sh}) that build
  your app, start/stop automation servers, and invoke
  \texttt{dotnet\ test}. Validate they leave no background processes.
\item
  \textbf{Configurable fixture} -- Extend \texttt{DefaultAppFixture} to
  read capabilities from JSON (local vs.~cloud). Add tests that assert
  the chosen configuration by inspecting \texttt{Session.Capabilities}.
\item
  \textbf{Permission audit} -- Write a checklist or automated probe that
  verifies accessibility permissions before starting tests (e.g.,
  attempt to focus a dummy window and fail fast with instructions).
\item
  \textbf{Driver matrix} -- Run the same smoke suite against Appium 1
  (WinAppDriver) and Appium 2 (mac2) by toggling
  \texttt{IsRunningAppium2}. Capture and compare server logs to
  understand protocol differences.
\item
  \textbf{CI integration} -- Add jobs to your pipeline that call your
  bootstrap script on Windows and macOS runners. Upload Appium logs and
  test TRX files as artifacts, confirming cleanup occurs even when tests
  fail.
\end{enumerate}

What's next - Next: \href{Chapter45.md}{Chapter45}

\newpage

\subsection{45. Element discovery, selectors, and
PageObjects}\label{element-discovery-selectors-and-pageobjects}

Goal - Locate Avalonia controls reliably through Appium's accessibility
surface, even when templates or virtualization hide elements. -
Encapsulate selectors and interactions in reusable PageObjects so suites
stay maintainable as the UI grows. - Combine waits, retries, and
platform-aware helpers to avoid brittle tests across Windows, macOS, and
remote hosts.

Why this matters - Avalonia templates can reshape automation trees;
hard-coded XPath falls apart when themes change. - Virtualized lists
only materialize visible items---selectors must cope with dynamic
children. - Cross-platform automation surfaces expose different
attributes; centralizing logic keeps suites portable.

Prerequisites - Chapter 43 for harness fundamentals. - Chapter 44 for
environment setup and driver configuration. - Familiarity with Avalonia
accessibility APIs (\texttt{AutomationProperties}).

\subsection{1. Build selectors on accessibility IDs
first}\label{build-selectors-on-accessibility-ids-first}

Avalonia maps \texttt{AutomationProperties.AutomationId} and control
\texttt{Name} directly into Appium selectors. Tests such as
\texttt{AutomationTests.AutomationId} rely on
\texttt{FindElementByAccessibilityId}
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/AutomationTests.cs:12}).
Adopt this priority order:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{FindElementByAccessibilityId} for IDs you own.
\item
  \texttt{FindElementByName} for localized labels
  (\texttt{ElementExtensions.GetName}) or menu items.
\item
  \texttt{FindElementByXPath} as a last resort for structure-dependent
  lookups (e.g., tray icons on Windows).
\end{enumerate}

Annotate controls in XAML with both \texttt{x:Name} and
\texttt{AutomationProperties.AutomationId} to keep selectors stable. For
templated controls, expose IDs through template parts so they enter the
automation tree.

\subsection{2. Reuse PageObject-style
wrappers}\label{reuse-pageobject-style-wrappers}

Avalonia's Appium harness centralizes navigation in \texttt{TestBase}.
Each test class inherits and passes the page name, letting
\texttt{TestBase} click through the pager with retries
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TestBase.cs:6}).
Mirror this structure:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{abstract} \KeywordTok{class}\NormalTok{ CatalogPage }\OperatorTok{:}\NormalTok{ TestBase}
\OperatorTok{\{}
    \KeywordTok{protected} \FunctionTok{CatalogPage}\OperatorTok{(}\NormalTok{DefaultAppFixture fixture}\OperatorTok{,} \DataTypeTok{string}\NormalTok{ pageName}\OperatorTok{)}
        \OperatorTok{:} \KeywordTok{base}\OperatorTok{(}\NormalTok{fixture}\OperatorTok{,}\NormalTok{ pageName}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{\}}

    \KeywordTok{protected}\NormalTok{ AppiumWebElement }\FunctionTok{Control}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ automationId}\OperatorTok{)}
        \OperatorTok{=\textgreater{}}\NormalTok{ Session}\OperatorTok{.}\FunctionTok{FindElementByAccessibilityId}\OperatorTok{(}\NormalTok{automationId}\OperatorTok{);}
\OperatorTok{\}}

\KeywordTok{public} \KeywordTok{sealed} \KeywordTok{class}\NormalTok{ WindowPage }\OperatorTok{:}\NormalTok{ CatalogPage}
\OperatorTok{\{}
    \KeywordTok{public} \FunctionTok{WindowPage}\OperatorTok{(}\NormalTok{DefaultAppFixture fixture}\OperatorTok{)} \OperatorTok{:} \KeywordTok{base}\OperatorTok{(}\NormalTok{fixture}\OperatorTok{,} \StringTok{"Window"}\OperatorTok{)} \OperatorTok{\{} \OperatorTok{\}}

    \KeywordTok{public}\NormalTok{ AppiumWebElement WindowState }\OperatorTok{=\textgreater{}} \FunctionTok{Control}\OperatorTok{(}\StringTok{"CurrentWindowState"}\OperatorTok{);}
    \KeywordTok{public} \DataTypeTok{void} \FunctionTok{SelectState}\OperatorTok{(}\DataTypeTok{string}\NormalTok{ id}\OperatorTok{)} \OperatorTok{=\textgreater{}} \FunctionTok{Control}\OperatorTok{(}\NormalTok{id}\OperatorTok{).}\FunctionTok{SendClick}\OperatorTok{();}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Wrap gestures (click, double-click, modifier shortcuts) in extension
methods rather than duplicating \texttt{Actions} blocks. Avalonia's
\texttt{ElementExtensions.SendClick} simulates physical clicks to
accommodate controls that resist \texttt{element.Click()}
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:235}).

\subsection{3. Handle virtualization and dynamic
children}\label{handle-virtualization-and-dynamic-children}

Virtualized lists only generate visible items.
\texttt{ListBoxTests.Is\_Virtualized} counts visual children returned by
\texttt{GetChildren} to prove virtualization is active
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ListBoxTests.cs:52}).

Techniques: - Scroll or page through lists via keyboard
(\texttt{Keys.PageDown}) or pointer wheel to materialize items lazily. -
Query container children each time rather than caching stale
\texttt{AppiumWebElement} references. - Use sentinel elements (e.g.,
``Loading\ldots'' items) to detect asynchronous population and wait
before asserting.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public}\NormalTok{ IReadOnlyList}\OperatorTok{\textless{}}\NormalTok{AppiumWebElement}\OperatorTok{\textgreater{}} \FunctionTok{VisibleRows}\OperatorTok{()}
    \OperatorTok{=\textgreater{}}\NormalTok{ Session}\OperatorTok{.}\FunctionTok{FindElementByAccessibilityId}\OperatorTok{(}\StringTok{"BasicListBox"}\OperatorTok{).}\FunctionTok{GetChildren}\OperatorTok{();}
\end{Highlighting}
\end{Shaded}

Combine with helper waits to poll until a desired item appears instead
of assuming immediate materialization.

\subsection{4. Account for platform differences in
selectors}\label{account-for-platform-differences-in-selectors}

Avalonia ships cross-platform helpers that encapsulate OS-specific
attribute quirks:

\begin{itemize}
\tightlist
\item
  \texttt{ElementExtensions.GetComboBoxValue} chooses \texttt{Text} on
  Windows and \texttt{value} on macOS
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:34}).
\item
  \texttt{GetCurrentSingleWindow} navigates macOS's duplicated window
  hierarchy by using a parent XPath
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:60}).
\item
  \texttt{TrayIconTests} opens nested sessions to access Windows taskbar
  automation IDs, while macOS uses generic status item XPath
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TrayIconTests.cs:13}).
\end{itemize}

Keep such logic in dedicated helpers; PageObjects should consume a
single API regardless of platform. Provide capabilities (e.g.,
\texttt{UseOverlayPopups}) through fixtures so tests stay declarative
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/OverlayPopupsAppFixture.cs:4}).

\subsection{5. Synchronize with the UI
deliberately}\label{synchronize-with-the-ui-deliberately}

Animations and popups require waits. The harness uses:

\begin{itemize}
\tightlist
\item
  Retries in \texttt{TestBase} navigation with
  \texttt{Thread.Sleep(1000)} between attempts to allow fullscreen
  transitions
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TestBase.cs:12}).
\item
  Looped polling in \texttt{ElementExtensions.OpenWindowWithClick} to
  detect new window handles or child windows, retrying up to ten times
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:86}).
\item
  Explicit sleeps after context menu or tray interactions when platform
  APIs lag
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TrayIconTests.cs:33}).
\end{itemize}

Upgrade these patterns using \texttt{WebDriverWait} to poll until
predicates succeed:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{public} \KeywordTok{static}\NormalTok{ AppiumWebElement }\FunctionTok{WaitForElement}\OperatorTok{(}\NormalTok{AppiumDriver session}\OperatorTok{,}\NormalTok{ By by}\OperatorTok{,}\NormalTok{ TimeSpan timeout}\OperatorTok{)}
\OperatorTok{\{}
    \KeywordTok{return} \KeywordTok{new} \FunctionTok{WebDriverWait}\OperatorTok{(}\NormalTok{session}\OperatorTok{,}\NormalTok{ timeout}\OperatorTok{).}\FunctionTok{Until}\OperatorTok{(}\NormalTok{driver }\OperatorTok{=\textgreater{}}
    \OperatorTok{\{}
        \DataTypeTok{var}\NormalTok{ element }\OperatorTok{=}\NormalTok{ driver}\OperatorTok{.}\FunctionTok{FindElement}\OperatorTok{(}\NormalTok{by}\OperatorTok{);}
        \KeywordTok{return}\NormalTok{ element}\OperatorTok{.}\FunctionTok{Displayed} \OperatorTok{?}\NormalTok{ element }\OperatorTok{:} \KeywordTok{null}\OperatorTok{;}
    \OperatorTok{\});}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Centralize waits so adjustments (timeouts, polling intervals) propagate
across the suite.

\subsection{6. Model complex selectors as
queries}\label{model-complex-selectors-as-queries}

Large UIs often require multi-step discovery:

\begin{itemize}
\tightlist
\item
  Menus: \texttt{MenuTests} clicks through root, child, and grandchild
  items using accessibility IDs and names
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/MenuTests.cs:25}).
  Wrap this into helper methods like
  \texttt{OpenMenu("Root",\ "Child",\ "Grandchild")}.
\item
  Tray icons: \texttt{GetTrayIconButton} first attempts to find the
  icon, then expands the overflow flyout if absent, handling whitespace
  quirks in names
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TrayIconTests.cs:62}).
\item
  Windows: \texttt{OpenWindowWithClick} tracks new handles or titles,
  accommodating macOS fullscreen behavior by ignoring untitled
  intermediate nodes
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:200}).
\end{itemize}

Treat these as queries, not static selectors. Accept parameters (icon
name, menu path) and apply consistent error messaging when assertions
fail.

\subsection{7. Use test attributes to scope
runs}\label{use-test-attributes-to-scope-runs}

Selectors often depend on platform capabilities. Decorate tests with
\texttt{{[}PlatformFact{]}} / \texttt{{[}PlatformTheory{]}} to skip
unsupported scenarios
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PlatformFactAttribute.cs:7}).
This prevents PageObjects from needing conditionals inside every method
and ensures pipelines stay green when features diverge.

Group tests requiring special fixtures (e.g., overlay popups) via xUnit
collections
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/CollectionDefinitions.cs:4}).
PageObjects then request the appropriate fixture type through
constructor injection.

\subsection{8. Troubleshooting
selectors}\label{troubleshooting-selectors}

\begin{itemize}
\tightlist
\item
  \textbf{Elements disappear mid-test} -- virtualization recycled them;
  retrieve fresh references after scrolling.
\item
  \textbf{Click no-ops} -- switch to \texttt{SendClick} actions; some
  controls ignore \texttt{element.Click()} on macOS.
\item
  \textbf{Wrong element chosen} -- qualify by automation ID before
  falling back to names. Names may change with localization.
\item
  \textbf{Popups not found} -- ensure you expanded parent menus or
  overflow trays first. Add logging describing the hierarchy you
  traversed for easier debugging.
\item
  \textbf{Timeouts} -- adopt structured waits instead of arbitrary
  sleeps; log the search strategy (selector type, fallback attempts) on
  failure.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-12}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{PageObject refactor} -- Extract a PageObject for a complex
  page (e.g., ComboBox) that exposes strongly-typed actions and returns
  typed results (\texttt{GetSelectedValue}). Replace direct selector
  usage in tests.
\item
  \textbf{Selector fallback} -- Implement a helper that tries
  \texttt{AutomationId}, then \texttt{Name}, then a custom XPath,
  logging each attempt. Use it to locate menu items with localized
  labels.
\item
  \textbf{Virtualized scrolling} -- Write a test that scrolls through a
  long \texttt{ListBox}, verifying virtualization by checking
  \texttt{GetChildren().Count} stays below a threshold while confirming
  a distant item becomes Selected.
\item
  \textbf{Wait utility} -- Replace \texttt{Thread.Sleep} in one test
  with a reusable \texttt{WaitFor} method leveraging
  \texttt{WebDriverWait}. Confirm the test still passes under slower
  animations by injecting artificial delays.
\item
  \textbf{Cross-platform assertions} -- Add assertions that rely on
  windows or tray icons, guarding them with \texttt{{[}PlatformFact{]}}.
  Implement helper methods that throw informative exceptions when run on
  unsupported platforms.
\end{enumerate}

What's next - Next: \href{Chapter46.md}{Chapter46}

\newpage

\subsection{46. Cross-platform scenarios and advanced
gestures}\label{cross-platform-scenarios-and-advanced-gestures}

Goal - Exercise Avalonia apps under platform-specific shells---window
chrome, tray icons, menus---without duplicating logic per OS. - Drive
complex pointer and keyboard gestures (drag, multi-click, context tap)
using Appium actions that map correctly on Windows and macOS. - Validate
multi-monitor layouts, fullscreen transitions, and system integrations
while keeping selectors and waits resilient.

Why this matters - Desktop affordances behave differently across Win32
and macOS accessibility stacks; tests must adapt or risk false
negatives. - Advanced gestures rely on low-level pointer semantics that
Appium exposes inconsistently across drivers. - Cross-platform
consistency is a core Avalonia selling point---automated verification
keeps regressions from sneaking in.

Prerequisites - Chapter 43 for the foundational Appium harness. -
Chapter 45 for selector patterns and PageObject design. - Familiarity
with Avalonia windowing APIs (Chapters 12 and 18).

\subsection{1. Split platform-specific coverage with fixtures and
attributes}\label{split-platform-specific-coverage-with-fixtures-and-attributes}

\texttt{PlatformFactAttribute} and \texttt{PlatformTheoryAttribute} skip
tests on unsupported OSes
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PlatformFactAttribute.cs:7}).
Use them to branch behavior cleanly:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{[}\FunctionTok{PlatformFact}\OperatorTok{(}\NormalTok{TestPlatforms}\OperatorTok{.}\FunctionTok{MacOS}\OperatorTok{)]}
\KeywordTok{public} \DataTypeTok{void} \FunctionTok{ThickTitleBar\_Drag\_Reports\_Moves}\OperatorTok{()} \OperatorTok{\{} \OperatorTok{...} \OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

Group tests into collections bound to fixtures that configure
capabilities. For example, \texttt{DefaultAppFixture} launches the stock
ControlCatalog, while \texttt{OverlayPopupsAppFixture} adds
\texttt{-\/-overlayPopups} arguments to highlight overlay behavior
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/OverlayPopupsAppFixture.cs:4}).

\subsection{2. Window management across
platforms}\label{window-management-across-platforms}

\subsubsection{Windows}\label{windows-5}

\texttt{WindowTests} (see
\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/WindowTests.cs})
verifies state transitions (Normal, Maximized, FullScreen), docked
windows, and mode toggles. It uses \texttt{SendClick} on combo entries
because native \texttt{Click()} is unreliable on certain automation
peers (\texttt{ElementExtensions.SendClick},
\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:235}).

\subsubsection{macOS}\label{macos-5}

\texttt{WindowTests\_MacOS} covers thick title bars, system chrome
toggles, and fullscreen animations
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/WindowTests\_MacOS.cs:19}).
Tests depend on applying window decoration parameters via checkboxes
exposed in the demo app.

\textbf{Tips} - Normalize state by calling the same helper at test end;
\texttt{PointerTests\_MacOS.Dispose} resets window parameters before
exiting
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PointerTests\_MacOS.cs:119}).
- When switching states that trigger animations, add intentional waits
or \texttt{WebDriverWait} polling before grabbing the next snapshot.

\subsection{3. Multi-window flows and
dialogs}\label{multi-window-flows-and-dialogs}

Use \texttt{ElementExtensions.OpenWindowWithClick} to encapsulate the
logic of detecting new windows. It differentiates between top-level
handles (Windows) and child windows (macOS) and returns an
\texttt{IDisposable} that closes the window on teardown
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:86}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{using} \OperatorTok{(}\FunctionTok{Control}\OperatorTok{(}\StringTok{"OpenModal"}\OperatorTok{).}\FunctionTok{OpenWindowWithClick}\OperatorTok{())}
\OperatorTok{\{}
    \CommentTok{// Assert modal state}
\OperatorTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{PointerTests.Pointer\_Capture\_Is\_Released\_When\_Showing\_Dialog}
relies on this helper to ensure capture is cleared when a dialog opens
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PointerTests.cs:13}).

\subsection{4. Tray icons and system
menus}\label{tray-icons-and-system-menus}

System integration differs dramatically:

\begin{itemize}
\tightlist
\item
  \textbf{Windows}: \texttt{TrayIconTests} locates the shell tray
  window, handles overflow flyouts, and accounts for whitespace-prefixed
  icon names
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TrayIconTests.cs:62}).
  It also opens a secondary ``Root'' session that targets the desktop to
  access the taskbar.
\item
  \textbf{macOS}: tray icons appear as
  \texttt{XCUIElementTypeStatusItem} elements and menus are retrieved
  via \texttt{//XCUIElementTypeStatusItem/XCUIElementTypeMenu}.
\end{itemize}

Wrap this logic in helper methods and hide it behind PageObjects so
tests merely call \texttt{TrayIcon().ShowMenu()} and assert resulting
automation flags.

\subsection{5. Advanced pointer
gestures}\label{advanced-pointer-gestures}

\subsubsection{Gesture taxonomy}\label{gesture-taxonomy}

\texttt{GestureTests} demonstrates how to script taps, double-taps,
drags, and right-clicks using Actions API
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/GestureTests.cs:16}).
Examples:

\begin{itemize}
\tightlist
\item
  \texttt{new\ Actions(Session).DoubleClick(element).Perform();}
\item
  Multi-step pointer sequences using \texttt{PointerInputDevice} for
  macOS-specific right-tap semantics
  (\texttt{GestureTests.RightTapped\_Is\_Raised\_2}, line 139).
\end{itemize}

\subsubsection{Title bar drags on macOS}\label{title-bar-drags-on-macos}

\texttt{PointerTests\_MacOS.OSXThickTitleBar\_Pointer\_Events\_Continue\_Outside\_Window\_During\_Drag}
verifies pointer capture beyond window bounds while dragging the title
bar
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PointerTests\_MacOS.cs:17}).
It uses \texttt{DragAndDropToOffset} and reads automation counters from
the secondary window.

\textbf{Practice} - Always move the pointer onto the target before
pressing:
\texttt{new\ Actions(Session).MoveToElement(titleAreaControl).Perform();}
- After custom pointer sequences, release buttons even when assertions
fail to leave the driver in a consistent state
(\texttt{GestureTests.DoubleTapped\_Is\_Raised\_2}, line 70).

\subsection{6. Keyboard modifiers and selection
semantics}\label{keyboard-modifiers-and-selection-semantics}

\texttt{ListBoxTests} executes Shift-range selection and marks
Ctrl-click tests as skipped due to driver limitations
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ListBoxTests.cs:36}).
Document such constraints in your suite and apply
\texttt{{[}Fact(Skip=...){]}} with explanations for future debugging.

\texttt{ComboBoxTests} rely on keyboard shortcuts
(\texttt{Keys.LeftAlt\ +\ Keys.ArrowDown}) and ensure wrapping behavior
toggles via checkboxes before assertion
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ComboBoxTests.cs:41}).
Keep these interactions in PageObjects so tests remain expressive
(\texttt{ComboBoxPage.OpenDropdown()} vs.~inline key sequences).

\subsection{7. Multi-monitor and screen
awareness}\label{multi-monitor-and-screen-awareness}

\texttt{ScreenTests} pulls current monitor data and asserts invariants
around bounds, work area, and scaling
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ScreenTests.cs:12}).
Use similar verifications when you need to assert window placement on
multi-monitor setups.

For drag-to-monitor flows, record starting and ending positions via text
fields surfaced in the app, then compare after applying pointer moves.
Ensure tests reset state (move window back) when done to avoid cascading
failures.

\subsection{8. Troubleshooting cross-platform
gestures}\label{troubleshooting-cross-platform-gestures}

\begin{itemize}
\tightlist
\item
  \textbf{Stuck pointer buttons} -- Ensure \texttt{PointerInputDevice}
  sequences end with \texttt{PointerUp}. If a test fails mid-action, add
  \texttt{try/finally} to release buttons.
\item
  \textbf{Unexpected double-taps} -- As shown in
  \texttt{PointerTests\_MacOS.OSXThickTitleBar\_Single\_Click\_Does\_Not\_Generate\_DoubleTapped\_Event},
  add counters to your app to observe actual events and assert on them
  instead of stateful UI side effects.
\item
  \textbf{Tray icon discovery failures} -- Expand overflow menus
  explicitly on Windows; on macOS, allow for menu creation delays by
  polling after clicking the status item.
\item
  \textbf{Localization differences} -- Names of system menu items vary;
  rely on automation IDs when possible or provide fallback selectors.
\item
  \textbf{Driver limitations} -- Document known issues (e.g.,
  WinAppDriver ctrl-click) with skip reasons so team members know why
  coverage is missing.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-13}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Window choreography} -- Script a test that opens a secondary
  window, drags it to a new position, toggles fullscreen, and returns to
  normal. Assert pointer capture counts using automation counters
  exposed in the sample.
\item
  \textbf{Tray icon helper} -- Build a PageObject with
  \texttt{ShowMenu()} and \texttt{ClickMenuItem(string\ text)} methods
  that handle Windows overflow and macOS status items automatically. Use
  it to verify a menu command toggles a checkbox in the main window.
\item
  \textbf{Gesture pipeline} -- Implement a helper that performs a
  parameterized pointer gesture (\texttt{PointerSequence} builder). Use
  it to test tap, double-tap, drag, and right-tap on the same control,
  asserting the logged gesture text each time.
\item
  \textbf{Multi-monitor regression} -- Extend the sample app to surface
  target screen IDs. Write a test that moves a window across monitors
  and verifies the reported screen changes, resetting to the primary
  display afterward.
\item
  \textbf{Platform matrix} -- Create a theory that runs the same smoke
  scenario across Windows/Mac fixtures using
  \texttt{{[}PlatformTheory{]}}. Capture driver logs on failure and
  assert the test records which platform executed for easier triage.
\end{enumerate}

What's next - Next: \href{Chapter47.md}{Chapter47}

\newpage

\subsection{47. Stabilizing suites, reporting, and best
practices}\label{stabilizing-suites-reporting-and-best-practices}

Goal - Keep Appium-based Avalonia suites reliable on developer machines
and CI by isolating flakiness causes. - Capture meaningful diagnostics
(logs, videos, artifacts) that accelerate investigation when tests fail.
- Scale coverage with retry, quarantine, and reporting strategies that
protect signal quality.

Why this matters - Cross-platform automation is sensitive to timing,
focus, and OS updates---without discipline the suite becomes noisy. -
Fast feedback requires structured artifacts; otherwise failures devolve
into manual repro marathons. - Stakeholders need trend visibility: which
areas flake, which platforms lag, and where to invest engineering
effort.

Prerequisites - Chapter 43--46 for harness setup, selectors, and
advanced scenarios. - Chapter 42 for CI pipeline integration basics.

\subsection{1. Triage flakiness with
classification}\label{triage-flakiness-with-classification}

Begin every investigation by tagging failures: - \textbf{Timing}
(animations, virtualization) -- resolved with better waits
(\texttt{WebDriverWait}, dispatcher polling). - \textbf{Environment}
(permissions, display scaling) -- addressed by setup scripts or platform
skips. - \textbf{Driver quirks} (WinAppDriver Ctrl-click) -- documented
with \texttt{{[}Fact(Skip="..."){]}} like
\texttt{ListBoxTests.Can\_Select\_Items\_By\_Ctrl\_Clicking}
(\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ListBoxTests.cs:36}).
- \textbf{App bugs} -- file issues with automation evidence attached.

Maintain a living flake log referencing test name, platform, root cause,
and remediation. Automate updates by pushing annotations into test
reporters (Azure Pipelines, GitHub Actions).

\subsection{2. Quarantine and retries without hiding real
bugs}\label{quarantine-and-retries-without-hiding-real-bugs}

Retries buy time but can mask regressions. Strategies:

\begin{itemize}
\tightlist
\item
  Implement targeted retries via xUnit ordering or
  \texttt{{[}RetryFact{]}} equivalents. Avalonia currently handles
  retries manually by skipping unstable tests with reason strings (e.g.,
  \texttt{TrayIconTests.Should\_Handle\_Left\_Click} is marked
  \texttt{{[}PlatformFact(...,\ Skip\ =\ "Flaky\ test"){]}},
  \texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TrayIconTests.cs:29}).
\item
  Prefer \textbf{automatic quarantine}: tag flaky tests and run them in
  a separate lane, keeping main suites failure-free. Example: use xUnit
  traits or custom attributes to filter
  (\texttt{dotnet\ test\ -\/-filter\ "TestCategory!=Quarantine"}).
\item
  Combine retries with diagnostics: on the last retry failure, dump
  Appium logs and take screenshots before failing.
\end{itemize}

\subsection{3. Capture rich diagnostics}\label{capture-rich-diagnostics}

For every critical failure, collect:

\begin{itemize}
\tightlist
\item
  \textbf{Appium server logs} (\texttt{appium.out} in the macOS script)
  and publish them via CI artifacts
  (\texttt{external/Avalonia/azure-pipelines-integrationtests.yml:27}).
\item
  \textbf{Driver logs}: \texttt{Session.Manage().Logs.GetLog("driver")}
  after catch blocks to capture protocol exchanges.
\item
  \textbf{Screenshots}: call
  \texttt{Session.GetScreenshot().SaveAsFile(...)} on failure; stash
  path in test output.
\item
  \textbf{Videos}: on Windows, VSTest runsettings
  \texttt{record-video.runsettings} records screen output
  (\texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/record-video.runsettings}).
\item
  \textbf{Headless imagery}: pair Appium runs with headless captures
  (Chapter 40) to highlight visual state at failure.
\end{itemize}

Build helper methods so tests simply call
\texttt{ArtifactCollector.Capture(context);}. Ensure cleanup occurs even
when assertions throw (use \texttt{try/finally}).

\subsection{4. Standardize waiting and polling
policies}\label{standardize-waiting-and-polling-policies}

Enforce consistent defaults:

\begin{itemize}
\tightlist
\item
  Set a global implicit wait (short, e.g., 1s) and rely on explicit
  waits for complex states. Too-long implicit waits slow down failure
  discovery.
\item
  Provide \texttt{WaitForElement} and \texttt{WaitForCondition} helpers
  with logging. Use them instead of ad-hoc \texttt{Thread.Sleep}.
\item
  For dispatcher-driven state, expose instrumentation in the app (text
  fields reporting counters like \texttt{GetMoveCount} in
  \texttt{PointerTests\_MacOS},
  \texttt{external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PointerTests\_MacOS.cs:86}).
  Poll those values to assert behavior deterministically.
\end{itemize}

Document wait policies in CONTRIBUTING guidelines to onboard new
contributors.

\subsection{5. Structure reports for quick
scanning}\label{structure-reports-for-quick-scanning}

\subsubsection{Azure Pipelines / GitHub
Actions}\label{azure-pipelines-github-actions}

\begin{itemize}
\tightlist
\item
  Publish TRX results with names that encode platform, driver, and suite
  (e.g., \texttt{Appium-macOS-Appium2.trx}).
\item
  Upload log bundles (\texttt{logs/appium.log},
  \texttt{screenshots/*.png}). Provide clickable links in summary
  markdown.
\item
  Add summary steps that print failing test names grouped by category
  (flaky, new regression, quarantined).
\end{itemize}

\subsubsection{Local development}\label{local-development}

\begin{itemize}
\tightlist
\item
  Provide a script (Chapter 44) that mirrors CI output directories so
  developers can inspect logs locally.
\item
  Encourage use of
  \texttt{dotnet\ test\ -\/-logger\ "trx;LogFileName=local.trx"} +
  \texttt{reportgenerator} for HTML summaries.
\end{itemize}

\subsection{6. Enforce coding standards in
tests}\label{enforce-coding-standards-in-tests}

\begin{itemize}
\tightlist
\item
  \textbf{Selectors}: centralize in PageObjects. No raw XPath in tests.
\item
  \textbf{Waits}: ban \texttt{Thread.Sleep} in code review; insist on
  helper usage.
\item
  \textbf{Cleanup}: always dispose windows/sessions (\texttt{using}
  pattern with \texttt{OpenWindowWithClick}). Review tests that skip
  cleanup (they often cause downstream failures).
\item
  \textbf{Platform gating}: pair every platform-specific assertion with
  \texttt{{[}PlatformFact{]}}/\texttt{{[}PlatformTheory{]}} to avoid
  accidental runs on unsupported OSes.
\end{itemize}

Add lint tooling (Roslyn analyzers or custom scripts) to scan for banned
patterns (e.g., \texttt{Thread.Sleep(}) in test projects.

\subsection{7. Monitor and alert on
trends}\label{monitor-and-alert-on-trends}

\begin{itemize}
\tightlist
\item
  Track success rate per platform, per suite. Configure dashboards
  (Azure Analytics, GitHub Insights) to display pass percentages over
  time.
\item
  Emit custom metrics (e.g., number of retries) to a time-series store.
  If retries spike, alert engineers before builds start failing.
\item
  Rotate flake triage duty; publish weekly summaries identifying top
  offenders and assigned owners.
\end{itemize}

\subsection{8. Troubleshooting
checklist}\label{troubleshooting-checklist-2}

\begin{itemize}
\tightlist
\item
  \textbf{Frequent timeouts} -- confirm Appium server stability, check
  CPU usage on agents, review wait durations.
\item
  \textbf{Intermittent focus issues} -- ensure tests foreground windows
  (\texttt{SetForegroundWindow} on Windows) or click background-free
  zones before interacting.
\item
  \textbf{Driver crashes} -- update Appium/WinAppDriver, capture crash
  dumps, and reference known issues (e.g., mac2 driver close-session
  crash handled in \texttt{DefaultAppFixture.Dispose}).
\item
  \textbf{Artifacts missing} -- verify CI scripts always run artifact
  upload steps with \texttt{condition:\ always()}.
\item
  \textbf{Quarantine drift} -- periodic reviews to reinstate fixed
  tests; failing to do so erodes coverage.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-14}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Artifact collector} -- Implement a helper that captures Appium
  logs, driver logs, screenshots, and optional videos when a test fails.
  Wire it into an xUnit \texttt{IAsyncLifetime} fixture so it runs
  automatically.
\item
  \textbf{Wait audit} -- Write an analyzer or script that flags
  \texttt{Thread.Sleep} usages in the Appium test project. Replace them
  with explicit waits and document the change.
\item
  \textbf{Quarantine lane} -- Configure your CI pipeline with two jobs:
  stable and quarantine
  (\texttt{dotnet\ test\ -\/-filter\ "Category!=Quarantine"}
  vs.~\texttt{Category=Quarantine}). Move a flaky test into the
  quarantine lane and verify reporting highlights it separately.
\item
  \textbf{Trend dashboard} -- Export TRX results for the past week and
  build a simple dashboard (Power BI, Grafana) showing pass/fail counts
  per platform. Identify top flaky tests.
\item
  \textbf{Regression template} -- Create an issue template that captures
  test name, platform, driver version, app commit, and links to
  artifacts. Use it when logging Appium regressions to standardize
  triage information.
\end{enumerate}

What's next - Return to \href{../Index.md}{Index} for appendices,
publishing checklists, or future updates.
