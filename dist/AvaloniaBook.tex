\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Avalonia Book}
\end{center}
\vspace*{\fill}
\clearpage

\setcounter{tocdepth}{3}
\tableofcontents
\clearpage

\phantomsection
\addcontentsline{toc}{section}{Part I — Foundations you can’t skip}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part I — Foundations you can’t skip}
\end{center}
\vspace*{\fill}
\clearpage

\subsection{1. Welcome to Avalonia and
MVVM}\label{welcome-to-avalonia-and-mvvm}

Goal - Understand what Avalonia is today, how it has grown, and where it
is heading. - Learn the roles of C\#, XAML, and MVVM (with their core
building blocks) inside an Avalonia app. - Map Avalonia's layered
architecture so you can navigate the source confidently. - Compare
Avalonia with WPF, WinUI, .NET MAUI, and Uno to make an informed
platform choice. - Follow the journey from
\passthrough{\lstinline!AppBuilder.Configure!} to the first window, and
know how to inspect it in the samples.

Why this matters - Picking a UI framework is a strategic decision.
Knowing Avalonia's history, roadmap, and governance helps you judge its
momentum. - Understanding the framework layers and MVVM primitives
prevents ``magic'' and makes documentation, samples, and source code
less intimidating. - Being able to contrast Avalonia with sibling
frameworks keeps expectations realistic and helps you explain the choice
to teammates.

Avalonia in simple words - Avalonia is an open-source, cross-platform UI
framework. One code base targets Windows, macOS, Linux, Android, iOS,
and the browser (WebAssembly). - It brings a modern Fluent-inspired
theme, a deep control set, rich data binding, and tooling such as
DevTools and the XAML Previewer. - If you have WPF experience, Avalonia
feels familiar; if you are new, you get gradual guidance with MVVM,
XAML, and C\#.

A short history, governance, and roadmap - Origins (2013-2018): The
project began as a community effort to bring a modern, cross-platform
take on the WPF programming model. - Maturing releases (0.9-0.10):
Stabilised control set, styling, and platform backends while adding
mobile and browser support. - Avalonia 11 (2023): The 11.x line
introduced the Fluent 2 theme refresh, compiled bindings, a new
rendering backend, and long-term support. New minor updates land roughly
every 2-3 months with patch releases in between. - Governance:
AvaloniaUI is stewarded by a core team at Avalonia Solutions Ltd.~with
an active GitHub community. Development is fully open with public issue
tracking and roadmap discussions. - Roadmap themes: continuing Fluent
updates, performance and tooling investments, deeper designer
integration, and steady platform parity across desktop, mobile, and web.

How Avalonia is layered - \textbf{Avalonia.Base}: foundational
services--dependency properties
(\passthrough{\lstinline!AvaloniaProperty!}), threading, layout
primitives, and rendering contracts. Source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base}{src/Avalonia.Base}.
- \textbf{Avalonia.Controls}: the control set, templated controls,
panels, windowing, and lifetimes. Source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls}{src/Avalonia.Controls}
with the \passthrough{\lstinline!Application!} class in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Application.cs}{Application.cs}.
- \textbf{Styling and themes}: styles, selectors, control themes, and
Fluent resources. Source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Styling}{src/Avalonia.Base/Styling}
and
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent}{src/Avalonia.Themes.Fluent}.
- \textbf{Markup}: XAML parsing, compiled XAML, and the runtime loader
used at startup. Source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Markup.Xaml}{src/Avalonia.Markup.Xaml}
with
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}{AvaloniaXamlLoader.cs}.
- \textbf{Platform backends}: per-OS integrations--for example
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Windows/Avalonia.Win32}{src/Windows/Avalonia.Win32},
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Native}{src/Avalonia.Native},
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Android/Avalonia.Android}{src/Android/Avalonia.Android},
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/iOS/Avalonia.iOS}{src/iOS/Avalonia.iOS},
and
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Browser/Avalonia.Browser}{src/Browser/Avalonia.Browser}.

Create your own architecture sketch showing
\passthrough{\lstinline!Avalonia.Base!} at the foundation,
\passthrough{\lstinline!Avalonia.Controls!} and
\passthrough{\lstinline!Avalonia.Markup.Xaml!} layered above it, theme
assemblies such as \passthrough{\lstinline!Avalonia.Themes.Fluent!}, and
platform backends surrounding the stack. Keep the diagram handy as you
read later chapters.

C\#, XAML, and MVVM--who does what - \textbf{C\#}: application startup
(\passthrough{\lstinline!AppBuilder!}), services, models, and view
models. Logic lives in strongly typed classes. - \textbf{XAML}:
declarative UI markup--controls, layout, styles, resources, and data
templates. - \textbf{MVVM}: separates responsibilities. The View (XAML)
binds to a ViewModel (C\#) which exposes Models and services. Tests
target ViewModels and models directly.

MVVM building blocks you should recognise early -
\passthrough{\lstinline!INotifyPropertyChanged!}: standard .NET
interface. When a ViewModel property raises
\passthrough{\lstinline!PropertyChanged!}, bound controls refresh. -
\passthrough{\lstinline!AvaloniaProperty!}: Avalonia's dependency
property system (see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/AvaloniaProperty.cs}{AvaloniaProperty.cs})
powers styling, animation, and templated control state. - Binding
expressions: XAML bindings are parsed and applied via the XAML loader.
The runtime loader lives in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}{AvaloniaXamlLoader.cs}.
- Commands: typically \passthrough{\lstinline!ICommand!} implementations
on the ViewModel (plain or via libraries such as CommunityToolkit.Mvvm
or ReactiveUI) so buttons and menu items can invoke logic. - Data
templates: define how ViewModels render in lists and navigation. We will
use them extensively starting in Chapter 3.

The MVVM contract inside Avalonia -
\passthrough{\lstinline!AvaloniaObject!} and
\passthrough{\lstinline!StyledElement!}: every control derives from
\passthrough{\lstinline!AvaloniaObject!}, gaining access to the
dependency property system. \passthrough{\lstinline!StyledElement!} adds
styling, resources, and the logical tree. These classes live in
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base}{\passthrough{\lstinline!Avalonia.Base!}}.
- \passthrough{\lstinline!AvaloniaLocator!}: a lightweight service
locator
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/AvaloniaLocator.cs}{\passthrough{\lstinline!AvaloniaLocator.cs!}})
used by the framework to resolve services (logging, platform
implementations). You can register your own singletons during startup
when integrating DI containers. - Logical vs visual tree: controls
participate in a logical tree (resources, data context inheritance) and
a visual tree (rendered elements). Explore helpers such as
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/LogicalTree/LogicalTreeExtensions.cs}{\passthrough{\lstinline!LogicalTreeExtensions!}}
and the DevTools tree viewers to see both perspectives. -
\passthrough{\lstinline!ViewLocator!}: MVVM projects often map view
models to views dynamically. Avalonia ships a default
\passthrough{\lstinline!ViewLocator!} in
\passthrough{\lstinline!Avalonia.ReactiveUI!}, and you can create your
own service that resolves XAML types by naming convention. - Service
registration: register singleton services with
\passthrough{\lstinline!AvaloniaLocator.CurrentMutable.Bind<TService>().ToConstant(instance)!}
during \passthrough{\lstinline!AppBuilder!} configuration so both
code-behind and markup extensions can retrieve them.

Data context flow across trees - Data contexts inherit through the
logical tree (e.g., \passthrough{\lstinline!Window!} →
\passthrough{\lstinline!Grid!} → \passthrough{\lstinline!TextBlock!}).
Controls outside that tree, such as popups, will not inherit
automatically; explicitly assign contexts when necessary. - The visual
tree may contain additional elements introduced by control templates.
Bindings resolve by name through the logical tree first, then resource
lookups, so understanding both structures keeps bindings predictable. -
Use DevTools' Logical/Visual tabs to inspect the tree at runtime and
trace resource lookups or data-context changes.

From \passthrough{\lstinline!AppBuilder.Configure!} to the first window
(annotated flow) 1. \textbf{Program entry point} creates a builder:
\passthrough{\lstinline!BuildAvaloniaApp()!} returns
\passthrough{\lstinline!AppBuilder.Configure<App>()!}. 2.
\textbf{Platform detection}
(\passthrough{\lstinline!UsePlatformDetect!}) selects the right backend
(Win32, macOS, X11, Android, iOS, Browser). 3. \textbf{Rendering setup}
(\passthrough{\lstinline!UseSkia!}) chooses the rendering pipeline--Skia
by default. 4. \textbf{Logging and services}
(\passthrough{\lstinline!LogToTrace!}, custom DI) configure diagnostics.
5. \textbf{Start a lifetime}:
\passthrough{\lstinline!StartWithClassicDesktopLifetime(args)!}
(desktop) or \passthrough{\lstinline!StartWithSingleViewLifetime!}
(mobile/browser). Lifetimes live under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/ApplicationLifetimes}{ApplicationLifetimes}.
6. \textbf{\passthrough{\lstinline!Application!} initialises}:
\passthrough{\lstinline!App.OnFrameworkInitializationCompleted!} is
called; this is where you typically create and show the first
\passthrough{\lstinline!Window!} or set
\passthrough{\lstinline!MainView!}. 7. \textbf{XAML loads}:
\passthrough{\lstinline!AvaloniaXamlLoader!} reads
\passthrough{\lstinline!App.axaml!} and your window/user control XAML.
8. \textbf{Bindings connect}: when the window's data context is set to a
ViewModel, bindings listen for \passthrough{\lstinline!PropertyChanged!}
events and keep UI and data in sync.

Tour the ControlCatalog (your guided sample) - Clone the repo (or open
the
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples/ControlCatalog}{ControlCatalog
sample}). - \passthrough{\lstinline!ControlCatalog.Desktop!}
demonstrates desktop controls, theming, and navigation. Inspect
\passthrough{\lstinline!App.axaml!},
\passthrough{\lstinline!MainWindow.axaml!}, and their code-behind to see
how \passthrough{\lstinline!AppBuilder!} and MVVM connect. - Use
DevTools (press \passthrough{\lstinline!F12!} when running the sample)
to inspect bindings, the visual tree, and live styles. - Explore the
repository mapping: the \passthrough{\lstinline!Button!} page in the
catalog points to code under
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Button.cs}{src/Avalonia.Controls/Button.cs};
style resources originate from Fluent theme XAML under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent/Controls}{src/Avalonia.Themes.Fluent/Controls}.

Why Avalonia instead of\ldots{} - \textbf{WPF} (Windows only): mature
desktop tooling and huge ecosystem, but no cross-platform story.
Avalonia keeps the mental model while expanding to macOS, Linux, mobile,
and web. - \textbf{WinUI 3} (Windows 10/11): modern Windows UI with
native Win32 packaging. Great for Windows-only solutions; Avalonia wins
when you must ship beyond Windows. - \textbf{.NET MAUI}: Microsoft's
cross-platform evolution of Xamarin.Forms focused on mobile-first UI.
Avalonia emphasises desktop parity, theming flexibility, and XAML
consistency across platforms. - \textbf{Uno Platform}: reuses WinUI XAML
across platforms via WebAssembly and native controls. Avalonia offers a
single rendering pipeline (Skia) for consistent visuals when you prefer
pixel-perfect fidelity over native look-and-feel.

Repository landmarks (bookmark these) - Framework source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src}{src} -
Samples:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples}{samples}
- Docs:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/docs}{docs} -
ControlCatalog entry point:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/samples/ControlCatalog/ControlCatalog.csproj}{ControlCatalog.csproj}

Check yourself - Can you describe how Avalonia evolved to its current
release cadence and governance model? - Can you name the key Avalonia
layers (Base, Controls, Markup, Themes, Platforms) and what each
provides? - Can you explain the MVVM building blocks
(\passthrough{\lstinline!INotifyPropertyChanged!},
\passthrough{\lstinline!AvaloniaProperty!}, bindings, commands) in your
own words? - Can you sketch the \passthrough{\lstinline!AppBuilder!}
startup steps that end with a \passthrough{\lstinline!Window!} or
\passthrough{\lstinline!MainView!} being shown? - Can you list one
reason you might choose Avalonia over WPF, WinUI, .NET MAUI, or Uno?

Practice and validation - Clone the Avalonia repository, build, and run
the desktop ControlCatalog. Set a breakpoint in
\passthrough{\lstinline!Application.OnFrameworkInitializationCompleted!}
inside \passthrough{\lstinline!App.axaml.cs!} to watch the lifetime
hand-off. - While ControlCatalog runs, open DevTools (F12) and track a
ViewModel property change (for example, toggle a CheckBox) in the
binding diagnostics panel to see
\passthrough{\lstinline!PropertyChanged!} events flowing. - Inspect the
source jump-offs for \passthrough{\lstinline!Application!}
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Application.cs}{Application.cs}),
\passthrough{\lstinline!AvaloniaProperty!}
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/AvaloniaProperty.cs}{AvaloniaProperty.cs}),
and the XAML loader
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}{AvaloniaXamlLoader.cs}).
Note how the pieces you just read about appear in real code. - Pick
three controls from ControlCatalog (e.g., Button, SplitView,
ColorPicker) and map each to the assembly and namespace hosting its
implementation. Sketch the relationships in the architecture diagram you
created earlier so you can orient yourself quickly when diving into
source.

What's next - Next: \href{Chapter02.md}{Chapter 2}

\newpage

\subsection{2. Set up tools and build your first
project}\label{set-up-tools-and-build-your-first-project}

Goal - Install the .NET SDK, Avalonia templates, and an IDE on your
operating system of choice. - Configure optional workloads (Android,
iOS, WebAssembly) so you are ready for multi-target development. -
Create, build, and run a new Avalonia project from the command line and
from your IDE. - Understand the generated project structure and where
startup, resources, and build targets live. - Build the Avalonia
framework from source when you need nightly features or to debug the
platform.

Why this matters - A confident setup avoids painful environment issues
later when you add mobile or browser targets. - Knowing where the
generated files live prepares you for upcoming chapters on layout,
lifetimes, and MVVM. - Building the framework from source lets you test
bug fixes, follow development, and debug into the toolkit.

\subsection{Prerequisites by operating
system}\label{prerequisites-by-operating-system}

\subsubsection{SDK matrix at a glance}\label{sdk-matrix-at-a-glance}

Avalonia 11 targets .NET 8.0. The official repository pins versions in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/global.json}{\passthrough{\lstinline!global.json!}}:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Scenario
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
SDK / Tooling
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Notes
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Desktop (Windows/macOS/Linux) & .NET SDK \passthrough{\lstinline!8.0.x!}
& Use latest LTS; \passthrough{\lstinline!global.json!} ensures
consistent builds across machines. \\
Android & .NET SDK \passthrough{\lstinline!8.0.x!} +
\passthrough{\lstinline!android!} workload & Requires Android Studio or
Visual Studio mobile workloads. \\
iOS/macOS Catalyst & .NET SDK \passthrough{\lstinline!8.0.x!} +
\passthrough{\lstinline!ios!} workload & Requires Xcode CLI tools and
Apple certificates for device deployment. \\
Browser (WebAssembly) & .NET SDK \passthrough{\lstinline!8.0.x!} +
\passthrough{\lstinline!wasm-tools!} workload & Installs Emscripten
toolchain for WASM builds. \\
\end{longtable}

Run \passthrough{\lstinline!dotnet --list-sdks!} to confirm the expected
SDK version is installed. When multiple SDKs coexist, keep a repo-level
\passthrough{\lstinline!global.json!} to pin builds to the
Avalonia-supported version.

\subsubsection{Windows}\label{windows}

\begin{itemize}
\tightlist
\item
  Install the latest \textbf{.NET SDK} (x64) from
  \url{https://dotnet.microsoft.com/download}.
\item
  Install \textbf{Visual Studio 2022} with the ``.NET desktop
  development'' workload; add ``.NET Multi-platform App UI development''
  for mobile tooling.
\item
  Optional:
  \passthrough{\lstinline!winget install --id Microsoft.DotNet.SDK.8!}
  (replace with the current LTS) and install the \textbf{Windows
  Subsystem for Linux} if you plan to test Linux packages.
\item
  Native dependencies: Avalonia bundles Skia; keep GPU drivers updated.
  When shipping self-contained builds, include ANGLE libraries
  (\passthrough{\lstinline!libEGL!},
  \passthrough{\lstinline!libGLESv2!},
  \passthrough{\lstinline!d3dcompiler\_47!}) for broader GPU
  compatibility (see Chapter 26).
\end{itemize}

\subsubsection{macOS}\label{macos}

\begin{itemize}
\tightlist
\item
  Install the latest \textbf{.NET SDK (Arm64 or x64)} from Microsoft.
\item
  Install \textbf{Xcode} (App Store) to satisfy iOS build prerequisites.
\item
  Recommended IDEs: \textbf{JetBrains Rider}, \textbf{Visual Studio 2022
  for Mac} (if installed), or \textbf{Visual Studio Code} with the C\#
  Dev Kit.
\item
  Optional: install \textbf{Homebrew} and use it for
  \passthrough{\lstinline!brew install dotnet-sdk!} to keep versions
  updated.
\item
  Native dependencies: Avalonia uses Skia via Metal/OpenGL; ensure
  Command Line Tools are installed
  (\passthrough{\lstinline!xcode-select --install!}).
\end{itemize}

\subsubsection{Linux (Ubuntu/Debian
example)}\label{linux-ubuntudebian-example}

\begin{itemize}
\tightlist
\item
  Add the Microsoft package feed and install the latest \textbf{.NET
  SDK} (\passthrough{\lstinline!sudo apt install dotnet-sdk-8.0!}).
\item
  Install an IDE: \textbf{Rider} or \textbf{Visual Studio Code} with the
  C\# extension (OmniSharp or C\# Dev Kit).
\item
  Ensure GTK dependencies are present
  (\passthrough{\lstinline!sudo apt install libgtk-3-0 libwebkit2gtk-4.1-0!})
  because the ControlCatalog sample relies on them.
\item
  Native dependencies: install Mesa/OpenGL drivers
  (\passthrough{\lstinline!sudo apt install mesa-utils!}) and ICU
  libraries for globalization support.
\end{itemize}

\begin{quote}
Verify your SDK installation:

\begin{lstlisting}[language=bash]
dotnet --version
dotnet --list-sdks
\end{lstlisting}

Make sure the Avalonia-supported SDK (currently .NET 8.x for Avalonia
11) appears in the list before moving on.
\end{quote}

\subsection{Optional workloads for advanced
targets}\label{optional-workloads-for-advanced-targets}

Run these commands only if you plan to target additional platforms soon
(you can add them later):

\begin{lstlisting}[language=bash]
dotnet workload install wasm-tools      # Browser (WebAssembly)
dotnet workload install android         # Android toolchain
dotnet workload install ios             # iOS/macOS Catalyst toolchain
dotnet workload install maui           # Optional: Windows tooling support

## Restore workloads declared in a solution (after cloning a repo)
dotnet workload restore
\end{lstlisting}

If a workload fails, run
\passthrough{\lstinline!dotnet workload repair!} and confirm your IDE
also installed the Android/iOS dependencies (Android SDK Managers, Xcode
command-line tools).

\subsection{Recommended IDE setup}\label{recommended-ide-setup}

\subsubsection{Visual Studio 2022
(Windows)}\label{visual-studio-2022-windows}

\begin{itemize}
\tightlist
\item
  Ensure the \textbf{Avalonia for Visual Studio} extension is installed
  (Marketplace) for XAML IntelliSense and the previewer.
\item
  Enable \textbf{XAML Hot Reload} under Tools -\textgreater{} Options
  -\textgreater{} Debugging -\textgreater{} General.
\item
  For Android/iOS, open Visual Studio Installer and add the
  corresponding mobile workloads.
\end{itemize}

\subsubsection{JetBrains Rider}\label{jetbrains-rider}

\begin{itemize}
\tightlist
\item
  Install the \textbf{Avalonia plugin} (File -\textgreater{} Settings
  -\textgreater{} Plugins -\textgreater{} Marketplace -\textgreater{}
  search ``Avalonia'').
\item
  Enable the built-in XAML previewer via
  \passthrough{\lstinline!View -> Tool Windows -> Avalonia Previewer!}.
\item
  Configure Android SDKs under Preferences -\textgreater{} Build Tools
  if you plan to run Android projects.
\end{itemize}

\subsubsection{Visual Studio Code}\label{visual-studio-code}

\begin{itemize}
\tightlist
\item
  Install the \textbf{C\# Dev Kit} or \textbf{C\# (OmniSharp)} extension
  for IntelliSense and debugging.
\item
  Add the \textbf{Avalonia for VS Code} extension for XAML tooling and
  preview.
\item
  Configure \passthrough{\lstinline!dotnet watch!} tasks or use the
  Avalonia preview extension's Live Preview panel.
\item
  Add tasks in \passthrough{\lstinline!.vscode/tasks.json!} for
  \passthrough{\lstinline!dotnet run!} /
  \passthrough{\lstinline!dotnet watch!} to trigger builds with
  \textbf{Ctrl+Shift+B}.
\item
  Set \passthrough{\lstinline!"avalonia.preview.host"!} to
  \passthrough{\lstinline!dotnet!} in
  \passthrough{\lstinline!.vscode/settings.json!} so the previewer
  launches automatically when you open XAML files.
\end{itemize}

\subsection{Install Avalonia project
templates}\label{install-avalonia-project-templates}

\begin{lstlisting}[language=bash]
dotnet new install Avalonia.Templates
\end{lstlisting}

This adds templates such as \passthrough{\lstinline!avalonia.app!},
\passthrough{\lstinline!avalonia.mvvm!},
\passthrough{\lstinline!avalonia.reactiveui!}, and
\passthrough{\lstinline!avalonia.xplat!}.

Verify installation:

\begin{lstlisting}[language=bash]
dotnet new list avalonia
\end{lstlisting}

You should see a table of available Avalonia templates.

\subsubsection{Template quick-reference}\label{template-quick-reference}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Template
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Command
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
When to use
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Desktop (code-behind) &
\passthrough{\lstinline!dotnet new avalonia.app -n MyApp!} & Small
prototypes with code-behind patterns. \\
MVVM starter &
\passthrough{\lstinline!dotnet new avalonia.mvvm -n MyApp.Mvvm!} &
Includes a ViewModel base class and sample bindings. \\
ReactiveUI &
\passthrough{\lstinline!dotnet new avalonia.reactiveui -n MyApp.ReactiveUI!}
& If you standardise on ReactiveUI for MVVM. \\
Cross-platform heads &
\passthrough{\lstinline!dotnet new avalonia.app --multiplatform -n MyApp.Multi!}
& Generates desktop, mobile, and browser heads in one project. \\
Split head projects &
\passthrough{\lstinline!dotnet new avalonia.xplat -n MyApp.Xplat!} &
Separate desktop/mobile projects (Visual Studio friendly). \\
Control library &
\passthrough{\lstinline!dotnet new avalonia.library -n MyApp.Controls!}
& Create reusable UI/control libraries. \\
\end{longtable}

Pair this with \passthrough{\lstinline!dotnet workload list!} to confirm
matching workloads are installed for the heads you create.

\subsection{Create and run your first project (CLI-first
flow)}\label{create-and-run-your-first-project-cli-first-flow}

\begin{lstlisting}[language=bash]
## Create a new solution folder
mkdir HelloAvalonia && cd HelloAvalonia

## Scaffold a desktop app template (code-behind pattern)
dotnet new avalonia.app -o HelloAvalonia.Desktop

cd HelloAvalonia.Desktop

## Restore packages and build
dotnet build

## Run the app
dotnet run
\end{lstlisting}

A starter window appears. Close it when done.

\subsubsection{Alternative templates}\label{alternative-templates}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!dotnet new avalonia.mvvm -o HelloAvalonia.Mvvm!}
  -\textgreater{} includes a ViewModel base class and data-binding
  sample.
\item
  \passthrough{\lstinline!dotnet new avalonia.reactiveui -o HelloAvalonia.ReactiveUI!}
  -\textgreater{} adds ReactiveUI integration out of the box.
\item
  \passthrough{\lstinline!dotnet new avalonia.app --multiplatform -o HelloAvalonia.Multi!}
  -\textgreater{} single-project layout with mobile/browser heads.
\item
  \passthrough{\lstinline!dotnet new avalonia.xplat -o HelloAvalonia.Xplat!}
  -\textgreater{} generates separate head projects (desktop/mobile)
  suited to Visual Studio.
\item
  \passthrough{\lstinline!dotnet new avalonia.library -o HelloAvalonia.Controls!}
  -\textgreater{} starts a reusable control/library project.
\end{itemize}

\subsection{Open the project in your
IDE}\label{open-the-project-in-your-ide}

\subsubsection{Visual Studio}\label{visual-studio}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  File -\textgreater{} Open -\textgreater{} Project/Solution
  -\textgreater{} select
  \passthrough{\lstinline!HelloAvalonia.Desktop.csproj!}.
\item
  Press \textbf{F5} (or the green Run arrow) to launch with the
  debugger.
\item
  Verify XAML Hot Reload by editing
  \passthrough{\lstinline!MainWindow.axaml!} while the app runs.
\end{enumerate}

\subsubsection{Rider}\label{rider}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  File -\textgreater{} Open -\textgreater{} choose the solution folder.
\item
  Use the top-right run configuration to run/debug.
\item
  Open the Avalonia Previewer tool window to see live XAML updates.
\end{enumerate}

\subsubsection{VS Code}\label{vs-code}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \passthrough{\lstinline!code .!} inside the project directory.
\item
  Accept the prompt to add build/debug assets; VS Code generates
  \passthrough{\lstinline!launch.json!} and
  \passthrough{\lstinline!.vscode/tasks.json!}.
\item
  Use the Run and Debug panel (F5) and the Avalonia preview extension
  for live previews.
\end{enumerate}

\subsection{Generated project tour (why each file
matters)}\label{generated-project-tour-why-each-file-matters}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!HelloAvalonia.Desktop.csproj!}: project
  metadata--target frameworks, NuGet packages, Avalonia build tasks
  (\passthrough{\lstinline!Avalonia.Build.Tasks!} compiles XAML to
  BAML-like assets; see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Build.Tasks/CompileAvaloniaXamlTask.cs}{CompileAvaloniaXamlTask.cs}).
\item
  \passthrough{\lstinline!Program.cs!}: entry point returning
  \passthrough{\lstinline!BuildAvaloniaApp()!}. Calls
  \passthrough{\lstinline!UsePlatformDetect!},
  \passthrough{\lstinline!UseSkia!},
  \passthrough{\lstinline!LogToTrace!}, and starts the classic desktop
  lifetime (definition in
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs}{AppBuilderDesktopExtensions.cs}).
\item
  \passthrough{\lstinline!App.axaml!} /
  \passthrough{\lstinline!App.axaml.cs!}: global resources and startup
  logic.
  \passthrough{\lstinline!App.OnFrameworkInitializationCompleted!}
  creates and shows \passthrough{\lstinline!MainWindow!} (implementation
  defined in
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Application.cs}{Application.cs}).
\item
  \passthrough{\lstinline!MainWindow.axaml!} /
  \passthrough{\lstinline!.axaml.cs!}: your initial view. XAML is loaded
  by
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}{AvaloniaXamlLoader}.
\item
  \passthrough{\lstinline!Assets/!} and
  \passthrough{\lstinline!Styles/!}: sample resource dictionaries you
  can expand later.
\end{itemize}

\subsection{Make a visible change and
rerun}\label{make-a-visible-change-and-rerun}

\begin{lstlisting}[language=XML]

<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="HelloAvalonia.MainWindow"
        Width="400" Height="260"
        Title="Hello Avalonia!">
  <StackPanel Margin="16" Spacing="12">
    <TextBlock Text="It works!" FontSize="24"/>
    <Button Content="Click me" HorizontalAlignment="Left"/>
  </StackPanel>
</Window>
\end{lstlisting}

Rebuild and run (\passthrough{\lstinline!dotnet run!} or IDE Run) to
confirm the change.

\subsection{Troubleshooting checklist}\label{troubleshooting-checklist}

\begin{itemize}
\tightlist
\item
  \textbf{\passthrough{\lstinline!dotnet!} command missing}: reinstall
  the .NET SDK and restart the terminal/IDE. Confirm environment
  variables (\passthrough{\lstinline!PATH!}) include the dotnet
  installation path.
\item
  \textbf{Template not found}: rerun
  \passthrough{\lstinline!dotnet new install Avalonia.Templates!} or
  remove outdated versions with
  \passthrough{\lstinline!dotnet new uninstall Avalonia.Templates!}.
\item
  \textbf{NuGet restore issues}: clear caches
  (\passthrough{\lstinline!dotnet nuget locals all --clear!}), ensure
  internet access or configure an offline mirror, then rerun
  \passthrough{\lstinline!dotnet restore!}.
\item
  \textbf{Workload errors}: run
  \passthrough{\lstinline!dotnet workload repair!}. Ensure Visual Studio
  or Xcode installed the matching tooling.
\item
  \textbf{IDE previewer fails}: confirm the Avalonia extension/plugin is
  installed, build the project once, and check the Output window for
  loader errors.
\item
  \textbf{Runtime missing native dependencies} (Linux): install GTK,
  Skia, and OpenGL packages (\passthrough{\lstinline!libmesa!},
  \passthrough{\lstinline!libx11-dev!}).
\item
  \textbf{GPU anomalies}: temporarily disable GPU
  (\passthrough{\lstinline!SKIA\_SHARP\_GPU=0!}) to isolate driver
  issues, then update GPU drivers or include ANGLE fallbacks.
\item
  \textbf{Nightly packages}: add
  \passthrough{\lstinline!https://www.myget.org/F/avalonia-nightly/api/v3/index.json!}
  to NuGet sources to test nightly builds; pin a stable package before
  release.
\end{itemize}

\subsection{Build Avalonia from source (optional but recommended
once)}\label{build-avalonia-from-source-optional-but-recommended-once}

\begin{itemize}
\tightlist
\item
  Clone the framework:
  \passthrough{\lstinline!git clone https://github.com/AvaloniaUI/Avalonia.git!}.
\item
  Initialise submodules if prompted:
  \passthrough{\lstinline!git submodule update --init --recursive!}.
\item
  On Windows: run \passthrough{\lstinline!.\\build.ps1 -Target Build!}.
\item
  On macOS/Linux: run
  \passthrough{\lstinline!./build.sh --target=Build!}.
\item
  Docs reference:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/docs/build.md}{docs/build.md}.
\item
  Launch the ControlCatalog from source:
  \passthrough{\lstinline!dotnet run --project samples/ControlCatalog.Desktop/ControlCatalog.Desktop.csproj!}.
\end{itemize}

Building from source gives you binaries with the latest commits, useful
for testing fixes or contributing.

\subsection{Practice and validation}\label{practice-and-validation}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Confirm your environment with
  \passthrough{\lstinline!dotnet --list-sdks!} and
  \passthrough{\lstinline!dotnet workload list!}. If workloads are
  missing, run \passthrough{\lstinline!dotnet workload restore!}.
\item
  Install the Avalonia templates and scaffold each template from the
  quick-reference table. Capture which commands require additional
  workloads.
\item
  Run one generated app from the CLI and another from your IDE,
  verifying hot reload or the previewer works in both flows.
\item
  Clone the Avalonia repo, build it
  (\passthrough{\lstinline!./build.sh --target=Build!} or
  \passthrough{\lstinline!.\\build.ps1 -Target Build!}), and run the
  ControlCatalog sample.
\item
  Inspect
  \passthrough{\lstinline!samples/ControlCatalog/ControlCatalog.csproj!}
  and map referenced Avalonia packages to their source folders. Update
  your architecture sketch with these relationships.
\item
  Set a breakpoint in \passthrough{\lstinline!App.axaml.cs!}
  (\passthrough{\lstinline!OnFrameworkInitializationCompleted!}) and
  step through startup to watch the lifetime initialise.
\item
  Document SDK versions, workloads, and template output in a team README
  so new developers can reproduce your setup.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks}

\begin{itemize}
\tightlist
\item
  Build pipeline tasks:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Build.Tasks}{src/Avalonia.Build.Tasks}.
\item
  Desktop lifetime helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs}{src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs}.
\item
  ControlCatalog project:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/samples/ControlCatalog/ControlCatalog.csproj}{samples/ControlCatalog/ControlCatalog.csproj}.
\item
  Framework application startup:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Application.cs}{src/Avalonia.Controls/Application.cs}.
\end{itemize}

\subsection{Check yourself}\label{check-yourself}

\begin{itemize}
\tightlist
\item
  Which command installs Avalonia templates and how do you verify the
  install?
\item
  How do you list installed .NET SDKs and workloads?
\item
  Where does
  \passthrough{\lstinline!App.OnFrameworkInitializationCompleted!} live
  and what does it do?
\item
  Which files control project startup, resources, and views in a new
  template?
\item
  What steps are required to build Avalonia from source on your OS?
\end{itemize}

What's next - Next: \href{Chapter03.md}{Chapter 3}

\newpage

\subsection{3. Your first UI: layouts, controls, and XAML
basics}\label{your-first-ui-layouts-controls-and-xaml-basics}

Goal - Build your first meaningful window with StackPanel, Grid, and
reusable user controls. - Learn how
\passthrough{\lstinline!ContentControl!},
\passthrough{\lstinline!UserControl!}, and
\passthrough{\lstinline!NameScope!} help you compose UIs cleanly. - See
how logical and visual trees differ so you can find controls and debug
bindings. - Use \passthrough{\lstinline!ItemsControl!} with
\passthrough{\lstinline!DataTemplate!} and a simple value converter to
repeat UI for collections. - Understand XAML namespaces
(\passthrough{\lstinline!xmlns:!}) and how to reference custom classes
or Avalonia namespaces.

Why this matters - Real apps are more than a single window--you compose
views, reuse user controls, and bind lists of data. - Understanding the
logical tree versus the visual tree makes tooling (DevTools,
FindControl, bindings) predictable. - Data templates and converters are
the backbone of MVVM-friendly UIs; learning them early prevents hacks
later.

Prerequisites - Chapter 2 completed. You can run
\passthrough{\lstinline!dotnet new!},
\passthrough{\lstinline!dotnet build!}, and
\passthrough{\lstinline!dotnet run!} on your machine.

\subsection{1. Scaffold the sample
project}\label{scaffold-the-sample-project}

\begin{lstlisting}[language=bash]
## Create a new sample app for this chapter
dotnet new avalonia.mvvm -o SampleUiBasics
cd SampleUiBasics

## Restore packages and run once to ensure the template works
dotnet run
\end{lstlisting}

Open the project in your IDE before continuing.

\subsection{2. Quick primer on XAML
namespaces}\label{quick-primer-on-xaml-namespaces}

The root \passthrough{\lstinline!<Window>!} tag declares namespaces so
XAML can resolve types:

\begin{lstlisting}[language=XML]
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:ui="clr-namespace:SampleUiBasics.Views"
        x:Class="SampleUiBasics.Views.MainWindow">
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  The default namespace maps to common Avalonia controls (Button, Grid,
  StackPanel).
\item
  \passthrough{\lstinline!xmlns:x!} exposes XAML keywords like
  \passthrough{\lstinline!x:Name!}, \passthrough{\lstinline!x:Key!}, and
  \passthrough{\lstinline!x:DataType!}.
\item
  Custom prefixes (e.g., \passthrough{\lstinline!xmlns:ui!}) point to
  CLR namespaces in your project or other assemblies so you can
  reference your own classes or controls
  (\passthrough{\lstinline!ui:OrderRow!}).
\item
  To import controls from other assemblies, add the prefix defined by
  their \passthrough{\lstinline![XmlnsDefinition]!} attribute (for
  example,
  \passthrough{\lstinline!xmlns:fluent="avares://Avalonia.Themes.Fluent"!}).
\end{itemize}

\subsection{3. How Avalonia loads this
XAML}\label{how-avalonia-loads-this-xaml}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!InitializeComponent()!} in
  \passthrough{\lstinline!MainWindow.axaml.cs!} invokes
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}{\passthrough{\lstinline!AvaloniaXamlLoader.Load!}},
  wiring the compiled XAML into the partial class defined by
  \passthrough{\lstinline!x:Class!}.
\item
  During build, Avalonia's MSBuild tasks generate code that registers
  resources, name scopes, and compiled bindings for the loader (see
  Chapter 30 for the full pipeline).
\item
  In design-time or hot reload scenarios, the same loader can parse XAML
  streams when no compiled version exists, so runtime errors usually
  originate from this method.
\item
  Keep \passthrough{\lstinline!x:Class!} values in sync with your
  namespace; mismatches result in
  \passthrough{\lstinline!XamlLoadException!} messages complaining about
  missing compiled XAML.
\end{itemize}

\subsection{4. Build the main layout (StackPanel +
Grid)}\label{build-the-main-layout-stackpanel-grid}

Open \passthrough{\lstinline!Views/MainWindow.axaml!} and replace the
\passthrough{\lstinline!<Window.Content>!} with:

\begin{lstlisting}[language=XML]
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:ui="clr-namespace:SampleUiBasics.Views"
        x:Class="SampleUiBasics.Views.MainWindow"
        Width="540" Height="420"
        Title="Customer overview">
  <DockPanel LastChildFill="True" Margin="16">
    <TextBlock DockPanel.Dock="Top"
               Classes="h1"
               Text="Customer overview"
               Margin="0,0,0,16"/>

    <Grid ColumnDefinitions="2*,3*"
          RowDefinitions="Auto,*"
          ColumnSpacing="16"
          RowSpacing="16">

      <StackPanel Grid.Column="0" Spacing="8">
        <TextBlock Classes="h2" Text="Details"/>

        <Grid ColumnDefinitions="Auto,*" RowDefinitions="Auto,Auto,Auto" RowSpacing="8" ColumnSpacing="12">
          <TextBlock Text="Name:"/>
          <TextBox Grid.Column="1" Width="200" Text="{Binding Customer.Name}"/>

          <TextBlock Grid.Row="1" Text="Email:"/>
          <TextBox Grid.Row="1" Grid.Column="1" Text="{Binding Customer.Email}"/>

          <TextBlock Grid.Row="2" Text="Status:"/>
          <ComboBox Grid.Row="2" Grid.Column="1" SelectedIndex="0">
            <ComboBoxItem>Prospect</ComboBoxItem>
            <ComboBoxItem>Active</ComboBoxItem>
            <ComboBoxItem>Dormant</ComboBoxItem>
          </ComboBox>
        </Grid>
      </StackPanel>


      <StackPanel Grid.Column="1" Spacing="8">
        <TextBlock Classes="h2" Text="Recent orders"/>
        <ItemsControl Items="{Binding RecentOrders}">
          <ItemsControl.ItemTemplate>
            <DataTemplate>
              <ui:OrderRow />
            </DataTemplate>
          </ItemsControl.ItemTemplate>
        </ItemsControl>
      </StackPanel>
    </Grid>
  </DockPanel>
</Window>
\end{lstlisting}

What you just used: - \passthrough{\lstinline!DockPanel!} places a title
bar on top and fills the rest. - \passthrough{\lstinline!Grid!} split
into two columns for the form (left) and list (right). -
\passthrough{\lstinline!ItemsControl!} repeats a data template for each
item in \passthrough{\lstinline!RecentOrders!}.

\subsection{\texorpdfstring{5. Create a reusable user control
(\texttt{OrderRow})}{5. Create a reusable user control (OrderRow)}}\label{create-a-reusable-user-control-orderrow}

Add a new file \passthrough{\lstinline!Views/OrderRow.axaml!}:

\begin{lstlisting}[language=XML]
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="SampleUiBasics.Views.OrderRow"
             Padding="8"
             Classes="card">
  <Border Background="{DynamicResource ThemeBackgroundBrush}"
          CornerRadius="6"
          Padding="12">
    <Grid ColumnDefinitions="*,Auto" RowDefinitions="Auto,Auto" ColumnSpacing="12">
      <TextBlock Classes="h3" Text="{Binding Title}"/>
      <TextBlock Grid.Column="1"
                 Foreground="{DynamicResource ThemeAccentBrush}"
                 Text="{Binding Total, Converter={StaticResource CurrencyConverter}}"/>

      <TextBlock Grid.Row="1" Grid.ColumnSpan="2" Text="{Binding PlacedOn, StringFormat='Ordered on {0:d}'}"/>
    </Grid>
  </Border>
</UserControl>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!UserControl!} encapsulates UI so you can reuse
  it via \passthrough{\lstinline!<ui:OrderRow />!}.
\item
  It relies on bindings (\passthrough{\lstinline!Title!},
  \passthrough{\lstinline!Total!}, \passthrough{\lstinline!PlacedOn!})
  which come from the current item in the data template.
\item
  Using a user control keeps the item template readable and testable.
\end{itemize}

\subsection{6. Add a value converter}\label{add-a-value-converter}

Converters adapt data for display. Create
\passthrough{\lstinline!Converters/CurrencyConverter.cs!}:

\begin{lstlisting}
using System;
using System.Globalization;
using Avalonia.Data.Converters;

namespace SampleUiBasics.Converters;

public sealed class CurrencyConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
    {
        if (value is decimal amount)
            return string.Format(culture, "{0:C}", amount);

        return value;
    }

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture) => value;
}
\end{lstlisting}

Register the converter in \passthrough{\lstinline!App.axaml!} so XAML
can reference it:

\begin{lstlisting}[language=XML]
<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:converters="clr-namespace:SampleUiBasics.Converters"
             x:Class="SampleUiBasics.App">
  <Application.Resources>
    <converters:CurrencyConverter x:Key="CurrencyConverter"/>
  </Application.Resources>

  <Application.Styles>
    <FluentTheme />
  </Application.Styles>
</Application>
\end{lstlisting}

\subsection{7. Populate the ViewModel with nested
data}\label{populate-the-viewmodel-with-nested-data}

Open \passthrough{\lstinline!ViewModels/MainWindowViewModel.cs!} and
replace its contents with:

\begin{lstlisting}
using System;
using System.Collections.ObjectModel;

namespace SampleUiBasics.ViewModels;

public sealed class MainWindowViewModel
{
    public CustomerViewModel Customer { get; } = new("Avery Diaz", "avery@example.com");

    public ObservableCollection<OrderViewModel> RecentOrders { get; } = new()
    {
        new OrderViewModel("Starter subscription", 49.00m, DateTime.Today.AddDays(-2)),
        new OrderViewModel("Design add-on", 129.00m, DateTime.Today.AddDays(-12)),
        new OrderViewModel("Consulting", 900.00m, DateTime.Today.AddDays(-20))
    };
}

public sealed record CustomerViewModel(string Name, string Email);

public sealed record OrderViewModel(string Title, decimal Total, DateTime PlacedOn);
\end{lstlisting}

Now bindings like \passthrough{\lstinline!\{Binding Customer.Name\}!}
and \passthrough{\lstinline!\{Binding RecentOrders\}!} have backing
data.

\subsection{\texorpdfstring{8. Understand \texttt{ContentControl},
\texttt{UserControl}, and
\texttt{NameScope}}{8. Understand ContentControl, UserControl, and NameScope}}\label{understand-contentcontrol-usercontrol-and-namescope}

\begin{itemize}
\tightlist
\item
  \textbf{\passthrough{\lstinline!ContentControl!}} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ContentControl.cs}{ContentControl.cs})
  holds a single content object. Windows, Buttons, and many controls
  inherit from it. Setting \passthrough{\lstinline!Content!} or placing
  child XAML elements populates that content.
\item
  \textbf{\passthrough{\lstinline!UserControl!}} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/UserControl.cs}{UserControl.cs})
  packages a reusable view with its own XAML and code-behind. Each
  \passthrough{\lstinline!UserControl!} creates its own
  \passthrough{\lstinline!NameScope!} so
  \passthrough{\lstinline!x:Name!} values remain local.
\item
  \textbf{\passthrough{\lstinline!NameScope!}} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/NameScope.cs}{NameScope.cs})
  governs how \passthrough{\lstinline!x:Name!} lookups work. Use
  \passthrough{\lstinline!this.FindControl<T>("OrdersList")!} or
  \passthrough{\lstinline!NameScope.GetNameScope(this)!} to resolve
  names inside the nearest scope.
\end{itemize}

Example: add \passthrough{\lstinline!x:Name="OrdersList"!} to the
\passthrough{\lstinline!ItemsControl!} in
\passthrough{\lstinline!MainWindow.axaml!} and access it from
code-behind:

\begin{lstlisting}
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();

        var ordersList = this.FindControl<ItemsControl>("OrdersList");
        // Inspect or manipulate generated visuals here if needed.
    }
}
\end{lstlisting}

When you nest user controls, remember: a name defined in
\passthrough{\lstinline!OrderRow!} is not visible in
\passthrough{\lstinline!MainWindow!} because each
\passthrough{\lstinline!UserControl!} has its own scope. This avoids
name collisions in templated scenarios.

\subsection{9. Logical tree vs visual tree (why it
matters)}\label{logical-tree-vs-visual-tree-why-it-matters}

\begin{itemize}
\tightlist
\item
  The \textbf{logical tree} tracks content relationships: windows
  -\textgreater{} user controls -\textgreater{} ItemsControl items.
  Bindings and resource lookups walk the logical tree. Inspect with
  \passthrough{\lstinline!this.GetLogicalChildren()!} or DevTools
  -\textgreater{} Logical tree.
\item
  The \textbf{visual tree} includes the actual visuals created by
  templates (Borders, TextBlocks, Panels). DevTools -\textgreater{}
  Visual tree shows the rendered hierarchy.
\item
  Some controls (e.g., \passthrough{\lstinline!ContentPresenter!}) exist
  in the visual tree but not in the logical tree. When
  \passthrough{\lstinline!FindControl!} fails, confirm whether the
  element is in the logical tree.
\item
  Reference implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/LogicalTree/LogicalTreeExtensions.cs}{LogicalTreeExtensions.cs}
  and
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Visual.cs}{Visual.cs}.
\end{itemize}

\subsection{10. Data templates
explained}\label{data-templates-explained}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!ItemsControl.ItemTemplate!} applies a
  \passthrough{\lstinline!DataTemplate!} for each item. Inside a data
  template, the \passthrough{\lstinline!DataContext!} is the individual
  item (an \passthrough{\lstinline!OrderViewModel!}).
\item
  You can inline XAML or reference a key:
  \passthrough{\lstinline!<DataTemplate x:Key="OrderTemplate"> ...!} and
  then
  \passthrough{\lstinline!ItemTemplate="\{StaticResource OrderTemplate\}"!}.
\item
  Data templates can contain user controls, panels, or inline elements.
  They are the foundation for list virtualization later.
\item
  Template source:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/Templates/DataTemplate.cs}{DataTemplate.cs}.
\end{itemize}

\subsection{\texorpdfstring{11. Work with resources
(\texttt{FindResource})}{11. Work with resources (FindResource)}}\label{work-with-resources-findresource}

\begin{itemize}
\tightlist
\item
  Declare brushes, converters, or styles in
  \passthrough{\lstinline!Window.Resources!} or
  \passthrough{\lstinline!Application.Resources!}.
\item
  Retrieve them at runtime with \passthrough{\lstinline!FindResource!}
  or \passthrough{\lstinline!TryFindResource!}:
\end{itemize}

\begin{lstlisting}[language=XML]
<Window.Resources>
  <SolidColorBrush x:Key="HighlightBrush" Color="#FFE57F"/>
</Window.Resources>
\end{lstlisting}

\begin{lstlisting}
private void OnHighlight(object? sender, RoutedEventArgs e)
{
    if (FindResource("HighlightBrush") is IBrush brush)
    {
        Background = brush;
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!FindResource!} walks the logical tree first,
  then escalates to application resources, mirroring how the XAML parser
  resolves \passthrough{\lstinline!StaticResource!}.
\item
  Resources defined inside a \passthrough{\lstinline!UserControl!} or
  \passthrough{\lstinline!DataTemplate!} are scoped; use
  \passthrough{\lstinline!this.Resources!} to override per-view
  resources without affecting the rest of the app.
\end{itemize}

\subsection{12. Run, inspect, and
iterate}\label{run-inspect-and-iterate}

\begin{lstlisting}[language=bash]
dotnet run
\end{lstlisting}

While the app runs: - Press \textbf{F12} (DevTools). Explore both
logical and visual trees for \passthrough{\lstinline!OrderRow!} entries.
- Select an \passthrough{\lstinline!OrderRow!} TextBlock and confirm the
binding path (\passthrough{\lstinline!Total!}) resolves to the right
data. - Try editing \passthrough{\lstinline!OrderViewModel!} values in
code and rerun to see updates.

\subsection{Troubleshooting}\label{troubleshooting}

\begin{itemize}
\tightlist
\item
  \textbf{Binding path errors}: DevTools -\textgreater{} Diagnostics
  -\textgreater{} Binding Errors shows typos. Ensure properties exist or
  set \passthrough{\lstinline!x:DataType="vm:OrderViewModel"!} in
  templates for compile-time checks (once you add namespaces for view
  models).
\item
  \textbf{Converter not found}: ensure the namespace prefix in
  \passthrough{\lstinline!App.axaml!} matches the converter's CLR
  namespace and the key matches
  \passthrough{\lstinline!StaticResource CurrencyConverter!}.
\item
  \textbf{User control not rendering}: confirm the namespace prefix
  \passthrough{\lstinline!xmlns:ui!} matches the CLR namespace of
  \passthrough{\lstinline!OrderRow!} and that the class is
  \passthrough{\lstinline!partial!} with matching
  \passthrough{\lstinline!x:Class!}.
\item
  \textbf{FindControl returns null}: check
  \passthrough{\lstinline!NameScope!}. If the element is inside a data
  template, use \passthrough{\lstinline!e.Source!} from events or bind
  through the ViewModel instead of searching.
\end{itemize}

\subsection{Practice and validation}\label{practice-and-validation-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a \passthrough{\lstinline!ui:AddressCard!} user control showing
  billing address details. Bind it to \passthrough{\lstinline!Customer!}
  using
  \passthrough{\lstinline!ContentControl.Content="\{Binding Customer\}"!}
  and define a data template for
  \passthrough{\lstinline!CustomerViewModel!}.
\item
  Add a \passthrough{\lstinline!ValueConverter!} that highlights orders
  above \$500 by returning a different brush; apply it to the Border
  background via
  \passthrough{\lstinline!\{Binding Total, Converter=...\}!}.
\item
  Name the \passthrough{\lstinline!ItemsControl!}
  (\passthrough{\lstinline!x:Name="OrdersList"!}) and call
  \passthrough{\lstinline!this.FindControl<ItemsControl>("OrdersList")!}
  in code-behind to verify name scoping.
\item
  Override \passthrough{\lstinline!HighlightBrush!} in
  \passthrough{\lstinline!MainWindow.Resources!} and use
  \passthrough{\lstinline!FindResource!} to swap the window background
  at runtime (e.g., from a button click).
\item
  Add a \passthrough{\lstinline!ListBox!} instead of
  \passthrough{\lstinline!ItemsControl!} and observe how selection adds
  visual states in the visual tree.
\item
  Use DevTools to inspect both logical and visual trees for
  \passthrough{\lstinline!OrderRow!}. Toggle the Namescope overlay to
  see how scopes nest.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-1}

\begin{itemize}
\tightlist
\item
  XAML loader:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}{src/Markup/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs}
\item
  Content control composition:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ContentControl.cs}{src/Avalonia.Controls/ContentControl.cs}
\item
  User controls and name scopes:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/UserControl.cs}{src/Avalonia.Controls/UserControl.cs}
\item
  \passthrough{\lstinline!NameScope!} implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/NameScope.cs}{src/Avalonia.Base/Styling/NameScope.cs}
\item
  Logical tree helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/LogicalTree/LogicalTreeExtensions.cs}{src/Avalonia.Base/LogicalTree/LogicalTreeExtensions.cs}
\item
  Data template implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/Templates/DataTemplate.cs}{src/Markup/Avalonia.Markup.Xaml/Templates/DataTemplate.cs}
\item
  Value converters:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Data/Converters}{src/Avalonia.Base/Data/Converters}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-1}

\begin{itemize}
\tightlist
\item
  How do XAML namespaces (\passthrough{\lstinline!xmlns!}) relate to CLR
  namespaces and assemblies?
\item
  What is the difference between the logical and visual tree, and why
  does it matter for bindings?
\item
  How do \passthrough{\lstinline!ContentControl!} and
  \passthrough{\lstinline!UserControl!} differ and when would you choose
  each?
\item
  Where do you register value converters so they can be referenced in
  XAML?
\item
  Inside a \passthrough{\lstinline!DataTemplate!}, what object provides
  the \passthrough{\lstinline!DataContext!}?
\end{itemize}

What's next - Next: \href{Chapter04.md}{Chapter 4}

\newpage

\subsection{4. Application startup: AppBuilder and
lifetimes}\label{application-startup-appbuilder-and-lifetimes}

Goal - Trace the full AppBuilder pipeline from
\passthrough{\lstinline!Program.Main!} to the first window or view. -
Understand how each lifetime
(\passthrough{\lstinline!ClassicDesktopStyleApplicationLifetime!},
\passthrough{\lstinline!SingleViewApplicationLifetime!},
\passthrough{\lstinline!BrowserSingleViewLifetime!},
\passthrough{\lstinline!HeadlessApplicationLifetime!}) boots and shuts
down your app. - Learn where to register services, logging, and global
configuration before the UI appears. - Handle startup exceptions
gracefully and log early so failures are diagnosable. - Prepare a
project that can swap between desktop, mobile/browser, and headless test
lifetimes.

Why this matters - The startup path decides which platforms you can
target and where dependency injection, logging, and configuration
happen. - Knowing the lifetime contracts keeps your code organised when
you add secondary windows, mobile navigation, or browser shells later. -
Understanding the AppBuilder steps helps you debug platform issues
(e.g., missing native dependencies or misconfigured rendering).

Prerequisites - You have completed Chapter 2 and can build/run a
template project. - You are comfortable editing
\passthrough{\lstinline!Program.cs!},
\passthrough{\lstinline!App.axaml!}, and
\passthrough{\lstinline!App.axaml.cs!}.

\subsection{1. Follow the AppBuilder pipeline step by
step}\label{follow-the-appbuilder-pipeline-step-by-step}

\passthrough{\lstinline!Program.cs!} (or
\passthrough{\lstinline!Program.fs!} in F\#) is the entry point. A
typical template looks like this:

\begin{lstlisting}
using Avalonia;
using Avalonia.ReactiveUI; // optional in ReactiveUI template

internal static class Program
{
    [STAThread]
    public static void Main(string[] args) => BuildAvaloniaApp()
        .StartWithClassicDesktopLifetime(args);

    public static AppBuilder BuildAvaloniaApp()
        => AppBuilder.Configure<App>()       // 1. Choose your Application subclass
            .UsePlatformDetect()             // 2. Detect the right native backend (Win32, macOS, X11, Android, iOS, Browser)
            .UseSkia()                      // 3. Configure the rendering pipeline (Skia GPU/CPU renderer)
            .With(new SkiaOptions {         // 4. (Optional) tweak renderer settings
                MaxGpuResourceSizeBytes = 96 * 1024 * 1024
            })
            .LogToTrace()                   // 5. Hook logging before startup completes
            .UseReactiveUI();               // 6. (Optional) enable ReactiveUI integration
}
\end{lstlisting}

Each call returns the builder so you can chain configuration. Relevant
source: - \passthrough{\lstinline!AppBuilder!} implementation:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/AppBuilder.cs}{\passthrough{\lstinline!src/Avalonia.Controls/AppBuilder.cs!}}
- Skia configuration:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Skia/Avalonia.Skia/SkiaOptions.cs}{\passthrough{\lstinline!src/Skia/Avalonia.Skia/SkiaOptions.cs!}}
- Desktop helpers
(\passthrough{\lstinline!StartWithClassicDesktopLifetime!}):
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs}{\passthrough{\lstinline!src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs!}}

\subsubsection{Builder pipeline diagram (mental
map)}\label{builder-pipeline-diagram-mental-map}

\begin{lstlisting}
Program.Main
  `--- BuildAvaloniaApp()
        |-- Configure<App>()        (create Application instance)
        |-- UsePlatformDetect()     (choose backend)
        |-- UseSkia()/UseReactiveUI (features)
        |-- LogToTrace()/With(...)  (diagnostics/options)
        `-- StartWith...Lifetime()  (select lifetime and enter main loop)
\end{lstlisting}

If anything in the pipeline throws, the process exits before UI renders.
Log early to catch those cases.

\subsection{2. Lifetimes in detail}\label{lifetimes-in-detail}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Lifetime type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Typical targets
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Key members
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!ClassicDesktopStyleApplicationLifetime!} &
Windowed desktop apps with startup/shutdown events and main window &
Windows, macOS, Linux & \passthrough{\lstinline!MainWindow!},
\passthrough{\lstinline!ShutdownMode!}, \passthrough{\lstinline!Exit!},
\passthrough{\lstinline!ShutdownRequested!},
\passthrough{\lstinline!OnExit!} \\
\passthrough{\lstinline!SingleViewApplicationLifetime!} & Hosts a single
root control (\passthrough{\lstinline!MainView!}) & Android, iOS,
Embedded & \passthrough{\lstinline!MainView!},
\passthrough{\lstinline!MainViewClosing!},
\passthrough{\lstinline!OnMainViewClosed!} \\
\passthrough{\lstinline!BrowserSingleViewLifetime!} (implements
\passthrough{\lstinline!ISingleViewApplicationLifetime!}) & Same
contract as single view, tuned for WebAssembly & Browser (WASM) &
\passthrough{\lstinline!MainView!}, async app init \\
\passthrough{\lstinline!HeadlessApplicationLifetime!} & No visible UI;
runs for tests or background services & Unit/UI tests &
\passthrough{\lstinline!TryGetTopLevel()!}, manual pumping \\
\end{longtable}

Key interfaces and classes to read: - Desktop lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs}{\passthrough{\lstinline!ClassicDesktopStyleApplicationLifetime.cs!}}
- Single view lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/SingleViewApplicationLifetime.cs}{\passthrough{\lstinline!SingleViewApplicationLifetime.cs!}}
- Browser lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserSingleViewLifetime.cs}{\passthrough{\lstinline!BrowserSingleViewLifetime.cs!}}
- Headless lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Headless/Avalonia.Headless/AvaloniaHeadlessApplicationLifetime.cs}{\passthrough{\lstinline!AvaloniaHeadlessApplicationLifetime.cs!}}

\subsubsection{Desktop lifetime flow}\label{desktop-lifetime-flow}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!MainWindow!} must be assigned before
  \passthrough{\lstinline!base.OnFrameworkInitializationCompleted()!} or
  no window will appear.
\item
  \passthrough{\lstinline!ShutdownMode!} controls when the app exits
  (\passthrough{\lstinline!OnLastWindowClose!},
  \passthrough{\lstinline!OnMainWindowClose!}, or
  \passthrough{\lstinline!OnExplicitShutdown!}).
\item
  Subscribe to \passthrough{\lstinline!ShutdownRequested!} to cancel
  shutdown (e.g., unsaved document prompt). Call
  \passthrough{\lstinline!e.Cancel = true!} to keep the app running.
\item
  Additional windows can be opened by tracking them in a collection and
  calling \passthrough{\lstinline!Show()!} /
  \passthrough{\lstinline!Close()!}.
\end{itemize}

\subsubsection{Single view and browser
lifetimes}\label{single-view-and-browser-lifetimes}

\begin{itemize}
\tightlist
\item
  Provide a root \passthrough{\lstinline!Control!} via
  \passthrough{\lstinline!MainView!}. Navigation stacks switch the child
  content instead of opening new windows.
\item
  For Android/iOS, the host platform handles navigation/back events;
  forward them to view models via commands.
\item
  Browser lifetime initialises asynchronously---await long-running
  startup logic before assigning \passthrough{\lstinline!MainView!}.
\end{itemize}

\subsubsection{Headless lifetime notes}\label{headless-lifetime-notes}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!StartWithHeadless!} disables rendering but
  still runs the dispatcher. Use it for integration tests.
\item
  Combine with \passthrough{\lstinline!Avalonia.Headless.XUnit!} or
  \passthrough{\lstinline!Avalonia.Headless.NUnit!} to drive UI
  interactions programmatically.
\end{itemize}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Typical targets
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Key members
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!ClassicDesktopStyleApplicationLifetime!} &
Windowed desktop apps with startup/shutdown events and main window &
Windows, macOS, Linux & \passthrough{\lstinline!MainWindow!},
\passthrough{\lstinline!ShutdownMode!}, \passthrough{\lstinline!Exit!},
\passthrough{\lstinline!OnExit!} \\
\passthrough{\lstinline!SingleViewApplicationLifetime!} & Hosts a single
root control (\passthrough{\lstinline!MainView!}) & Android, iOS,
Embedded & \passthrough{\lstinline!MainView!},
\passthrough{\lstinline!MainViewClosing!},
\passthrough{\lstinline!OnMainViewClosed!} \\
\passthrough{\lstinline!BrowserSingleViewLifetime!} (implements
\passthrough{\lstinline!ISingleViewApplicationLifetime!}) & Same
contract as single view, tuned for WebAssembly & Browser (WASM) &
\passthrough{\lstinline!MainView!}, async app init \\
\passthrough{\lstinline!HeadlessApplicationLifetime!} & No visible UI;
runs for tests or background services & Unit/UI tests &
\passthrough{\lstinline!TryGetTopLevel()!}, manual pumping \\
\end{longtable}

Key interfaces and classes to read: - Desktop lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs}{\passthrough{\lstinline!ClassicDesktopStyleApplicationLifetime.cs!}}
- Single view lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/SingleViewApplicationLifetime.cs}{\passthrough{\lstinline!SingleViewApplicationLifetime.cs!}}
- Browser lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserSingleViewLifetime.cs}{\passthrough{\lstinline!BrowserSingleViewLifetime.cs!}}
- Headless lifetime:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Headless/Avalonia.Headless/AvaloniaHeadlessApplicationLifetime.cs}{\passthrough{\lstinline!src/Headless/Avalonia.Headless/AvaloniaHeadlessApplicationLifetime.cs!}}

\subsection{\texorpdfstring{3. Wiring lifetimes in
\texttt{App.OnFrameworkInitializationCompleted}}{3. Wiring lifetimes in App.OnFrameworkInitializationCompleted}}\label{wiring-lifetimes-in-app.onframeworkinitializationcompleted}

\passthrough{\lstinline!App.axaml.cs!} is the right place to react once
the framework is ready:

\begin{lstlisting}
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Microsoft.Extensions.DependencyInjection; // if using DI

namespace MultiLifetimeSample;

public partial class App : Application
{
    private IServiceProvider? _services;

    public override void Initialize()
        => AvaloniaXamlLoader.Load(this);

    public override void OnFrameworkInitializationCompleted()
    {
        // Create/register services only once
        _services ??= ConfigureServices();

        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            var shell = _services.GetRequiredService<MainWindow>();
            desktop.MainWindow = shell;
            desktop.Exit += (_, _) => _services.Dispose();
        }
        else if (ApplicationLifetime is ISingleViewApplicationLifetime singleView)
        {
            singleView.MainView = _services.GetRequiredService<MainView>();
        }
        else if (ApplicationLifetime is IControlledApplicationLifetime controlled)
        {
            controlled.Exit += (_, _) => Console.WriteLine("Application exited");
        }

        base.OnFrameworkInitializationCompleted();
    }

    private IServiceProvider ConfigureServices()
    {
        var services = new ServiceCollection();
        services.AddSingleton<MainWindow>();
        services.AddSingleton<MainView>();
        services.AddSingleton<DashboardViewModel>();
        services.AddLogging(builder => builder.AddDebug());
        return services.BuildServiceProvider();
    }
}
\end{lstlisting}

Notes: - \passthrough{\lstinline!ApplicationLifetime!} always implements
\passthrough{\lstinline!IControlledApplicationLifetime!}, so you can
subscribe to \passthrough{\lstinline!Exit!} for cleanup even if you do
not know the exact subtype. - Use dependency injection (any container)
to share views/view models. Avalonia does not ship a DI container, so
you control the lifetime. - For headless tests, your
\passthrough{\lstinline!App!} still runs but you typically return
\passthrough{\lstinline!SingleView!} or host view models manually.

\subsection{4. Handling exceptions and
logging}\label{handling-exceptions-and-logging}

Important logging points: -
\passthrough{\lstinline!AppBuilder.LogToTrace()!} uses Avalonia's
logging infrastructure (see
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Logging}{\passthrough{\lstinline!src/Avalonia.Base/Logging!}}).
For production apps, plug in \passthrough{\lstinline!Serilog!},
\passthrough{\lstinline!Microsoft.Extensions.Logging!}, or your
preferred provider. - Subscribe to
\passthrough{\lstinline!AppDomain.CurrentDomain.UnhandledException!},
\passthrough{\lstinline!TaskScheduler.UnobservedTaskException!}, and
\passthrough{\lstinline!Dispatcher.UIThread.UnhandledException!} to
capture failures before they tear down the dispatcher. -
\passthrough{\lstinline!IControlledApplicationLifetime!}
(\passthrough{\lstinline!ApplicationLifetime!}) exposes
\passthrough{\lstinline!Exit!} and \passthrough{\lstinline!Shutdown()!}
so you can close gracefully after logging or prompting the user.

Example:

\begin{lstlisting}
[STAThread]
public static void Main(string[] args)
{
    AppDomain.CurrentDomain.UnhandledException += (_, e) => LogFatal(e.ExceptionObject);
    TaskScheduler.UnobservedTaskException += (_, e) => LogFatal(e.Exception);

    Dispatcher.UIThread.UnhandledException += (_, e) =>
    {
        LogFatal(e.Exception);
        e.Handled = true; // optionally keep the app alive after logging
    };

    try
    {
        BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);
    }
    catch (Exception ex)
    {
        LogFatal(ex);
        throw;
    }
}
\end{lstlisting}

\passthrough{\lstinline!ClassicDesktopStyleApplicationLifetime!} exposes
\passthrough{\lstinline!ShutdownMode!},
\passthrough{\lstinline!ShutdownRequested!}, and
\passthrough{\lstinline!Shutdown()!} so you can decide whether to exit
on last window close, on main window close, or only when you call
\passthrough{\lstinline!Shutdown()!} explicitly.

\subsection{5. Switching lifetimes inside one
project}\label{switching-lifetimes-inside-one-project}

You can provide different entry points or compile-time switches:

\begin{lstlisting}
public static void Main(string[] args)
{
#if HEADLESS
    BuildAvaloniaApp().Start(AppMain);
#elif BROWSER
    BuildAvaloniaApp().SetupBrowserApp("app");
#else
    BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);
#endif
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!SetupBrowserApp!} is defined in
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserAppBuilder.cs}{\passthrough{\lstinline!BrowserAppBuilder.cs!}}
  and attaches the app to a DOM element.
\item
  \passthrough{\lstinline!Start!} (with
  \passthrough{\lstinline!AppMain!}) lets you provide your own lifetime,
  often used in headless/integration tests.
\end{itemize}

\subsection{6. Headless/testing
scenarios}\label{headlesstesting-scenarios}

Avalonia's headless assemblies let you boot an app without rendering:

\begin{lstlisting}
using Avalonia;
using Avalonia.Headless;

public static class Program
{
    public static void Main(string[] args)
        => BuildAvaloniaApp().StartWithHeadless(new HeadlessApplicationOptions
        {
            RenderingMode = HeadlessRenderingMode.None,
            UseHeadlessDrawingContext = true
        });
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!Avalonia.Headless!} lives under
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Headless}{\passthrough{\lstinline!src/Headless!}}
  and powers automated UI tests
  (\passthrough{\lstinline!Avalonia.Headless.XUnit!},
  \passthrough{\lstinline!Avalonia.Headless.NUnit!}).
\item
  You can pump the dispatcher manually to run asynchronous UI logic in
  tests (\passthrough{\lstinline!HeadlessUnitTestSession.Run!} displays
  an example).
\end{itemize}

\subsection{7. Putting it together: desktop + single-view
sample}\label{putting-it-together-desktop-single-view-sample}

\passthrough{\lstinline!Program.cs!}:

\begin{lstlisting}
public static AppBuilder BuildAvaloniaApp() => AppBuilder.Configure<App>()
    .UsePlatformDetect()
    .UseSkia()
    .LogToTrace();

[STAThread]
public static void Main(string[] args)
{
    if (args.Contains("--single-view"))
    {
        BuildAvaloniaApp().StartWithSingleViewLifetime(new MainView());
    }
    else
    {
        BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);
    }
}
\end{lstlisting}

\passthrough{\lstinline!App.axaml.cs!} sets up both
\passthrough{\lstinline!MainWindow!} and
\passthrough{\lstinline!MainView!} (as shown earlier). At runtime, you
can switch lifetimes via command-line or compile condition.

\subsection{Troubleshooting}\label{troubleshooting-1}

\begin{itemize}
\tightlist
\item
  \textbf{Black screen on startup}: check
  \passthrough{\lstinline!UsePlatformDetect()!}; on Linux you might need
  extra packages (mesa, libwebkit) or use
  \passthrough{\lstinline!UseSkia!} explicitly.
\item
  \textbf{No window appearing}: ensure
  \passthrough{\lstinline!desktop.MainWindow!} is assigned before
  calling
  \passthrough{\lstinline!base.OnFrameworkInitializationCompleted()!}.
\item
  \textbf{Single view renders but inputs fail}: confirm you used the
  right lifetime (\passthrough{\lstinline!StartWithSingleViewLifetime!})
  and that your root view is a \passthrough{\lstinline!Control!} with
  focusable children.
\item
  \textbf{DI container disposed too early}: if you
  \passthrough{\lstinline!using!} the provider, keep it alive for the
  app lifetime and dispose in \passthrough{\lstinline!Exit!}.
\item
  \textbf{Unhandled exception after closing last window}: check
  \passthrough{\lstinline!ShutdownMode!}. Default is
  \passthrough{\lstinline!OnLastWindowClose!}; switch to
  \passthrough{\lstinline!OnMainWindowClose!} or call
  \passthrough{\lstinline!Shutdown()!} to exit on demand.
\end{itemize}

\subsection{Practice and validation}\label{practice-and-validation-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Modify your project so the same \passthrough{\lstinline!App!} supports
  both desktop and single-view lifetimes. Use a command-line switch
  (\passthrough{\lstinline!--mobile!}) to select
  \passthrough{\lstinline!StartWithSingleViewLifetime!} and verify your
  \passthrough{\lstinline!MainView!} renders inside a mobile head
  (Android emulator or \passthrough{\lstinline!dotnet run -- --mobile!}
  + \passthrough{\lstinline!SingleView!} desktop simulation).
\item
  Register a logging provider using
  \passthrough{\lstinline!Microsoft.Extensions.Logging!}. Log the
  current lifetime type inside
  \passthrough{\lstinline!OnFrameworkInitializationCompleted!},
  subscribe to \passthrough{\lstinline!ShutdownRequested!}, and record
  when the app exits.
\item
  Add a simple DI container (as shown) and resolve
  \passthrough{\lstinline!MainWindow!}/\passthrough{\lstinline!MainView!}
  through it. Confirm disposal happens when the app exits.
\item
  Create a headless console entry point
  (\passthrough{\lstinline!BuildAvaloniaApp().Start(AppMain)!}) and run
  a unit test that constructs a view, invokes bindings, and pumps the
  dispatcher.
\item
  Wire \passthrough{\lstinline!Dispatcher.UIThread.UnhandledException!}
  and verify that handled exceptions keep the app alive while unhandled
  ones terminate.
\item
  Intentionally throw inside
  \passthrough{\lstinline!OnFrameworkInitializationCompleted!} and
  observe how logging captures the stack. Then add a
  \passthrough{\lstinline!try/catch!} to show a fallback dialog or log
  and exit gracefully.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-2}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!AppBuilder!} internals:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/AppBuilder.cs}{\passthrough{\lstinline!src/Avalonia.Controls/AppBuilder.cs!}}
\item
  Desktop startup helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs}{\passthrough{\lstinline!src/Avalonia.Desktop/AppBuilderDesktopExtensions.cs!}}
\item
  Desktop lifetime implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs}{\passthrough{\lstinline!src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs!}}
\item
  Single-view lifetime:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/SingleViewApplicationLifetime.cs}{\passthrough{\lstinline!src/Avalonia.Controls/ApplicationLifetimes/SingleViewApplicationLifetime.cs!}}
\item
  Browser lifetime:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserSingleViewLifetime.cs}{\passthrough{\lstinline!src/Browser/Avalonia.Browser/BrowserSingleViewLifetime.cs!}}
\item
  Headless lifetime and tests:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Headless}{\passthrough{\lstinline!src/Headless!}}
\item
  Controlled lifetime interface
  (\passthrough{\lstinline!IControlledApplicationLifetime!}):
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/IControlledApplicationLifetime.cs}{\passthrough{\lstinline!src/Avalonia.Controls/ApplicationLifetimes/IControlledApplicationLifetime.cs!}}
\item
  Dispatcher unhandled exception hook:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Threading/Dispatcher.cs}{\passthrough{\lstinline!src/Avalonia.Base/Threading/Dispatcher.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-2}

\begin{itemize}
\tightlist
\item
  What steps does \passthrough{\lstinline!BuildAvaloniaApp()!} perform
  before choosing a lifetime?
\item
  Which lifetime would you use for Windows/macOS, Android/iOS, browser,
  and automated tests?
\item
  Where should you place dependency injection setup and where should you
  dispose the container?
\item
  How can you capture and log unhandled exceptions thrown during
  startup?
\item
  How would you attach the app to a DOM element in a WebAssembly host?
\end{itemize}

What's next - Next: \href{Chapter05.md}{Chapter 5}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part II — Building beautiful and useful UIs}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part II — Building beautiful and useful UIs}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{5. Layout system without
mystery}\label{layout-system-without-mystery}

Goal - Understand Avalonia's layout pass
(\passthrough{\lstinline!Measure!} then
\passthrough{\lstinline!Arrange!}) and how
\passthrough{\lstinline!Layoutable!} and
\passthrough{\lstinline!LayoutManager!} orchestrate it. - Master the
core panels (StackPanel, Grid, DockPanel, WrapPanel) plus advanced tools
(\passthrough{\lstinline!GridSplitter!},
\passthrough{\lstinline!Viewbox!},
\passthrough{\lstinline!LayoutTransformControl!},
\passthrough{\lstinline!SharedSizeGroup!}). - Learn when to create
custom panels by overriding
\passthrough{\lstinline!MeasureOverride!}/\passthrough{\lstinline!ArrangeOverride!}.
- Know how scrolling, virtualization, and
\passthrough{\lstinline!Panel.ZIndex!} interact with layout. - Practice
diagnosing layout issues with DevTools overlays and logging.

Why this matters - Layout defines the user experience: predictable
resizing, adaptive forms, responsive dashboards. - Panels are reusable
building blocks. Understanding the underlying contract helps you read
control templates and write your own. - Troubleshooting layout without a
plan wastes time; with DevTools and knowledge of the pass order, you
debug confidently.

Prerequisites - You can run a basic Avalonia app and edit XAML (Chapters
2-4). - You have DevTools (F12) available to inspect layout rectangles.

\subsection{1. Mental model: measure and
arrange}\label{mental-model-measure-and-arrange}

Every control inherits from \passthrough{\lstinline!Layoutable!}
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/Layoutable.cs}{Layoutable.cs}).
The layout pass runs in two stages:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Measure}: Parent asks each child ``How big would you like to
  be?'' providing an available size. The child can respond with any size
  up to that constraint. Override
  \passthrough{\lstinline!MeasureOverride!} in panels to lay out
  children.
\item
  \textbf{Arrange}: Parent decides where to place each child within its
  final bounds. Override \passthrough{\lstinline!ArrangeOverride!} to
  position children based on the measured sizes.
\end{enumerate}

The \passthrough{\lstinline!LayoutManager!}
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/LayoutManager.cs}{LayoutManager.cs})
schedules layout passes when controls invalidate measure or arrange
(\passthrough{\lstinline!InvalidateMeasure!},
\passthrough{\lstinline!InvalidateArrange!}).

\subsection{2. Layout invalidation and
diagnostics}\label{layout-invalidation-and-diagnostics}

\begin{itemize}
\tightlist
\item
  Call \passthrough{\lstinline!InvalidateMeasure()!} when a control's
  desired size changes (for example, text content updates).
\item
  Call \passthrough{\lstinline!InvalidateArrange()!} when position
  changes but desired size remains the same. Panels do this when
  children move without resizing.
\item
  \passthrough{\lstinline!LayoutManager!} batches these requests;
  inspect timings via
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/LayoutPassTiming.cs}{\passthrough{\lstinline!LayoutPassTiming!}}
  or DevTools -\textgreater{} Layout tab.
\item
  Enable DevTools layout overlays (F12 -\textgreater{} Layout) to
  visualise measure/arrange bounds. Combine with
  \passthrough{\lstinline!RendererDebugOverlays.LayoutTimeGraph!} to
  profile layout costs.
\item
  For custom panels, avoid calling
  \passthrough{\lstinline!InvalidateMeasure!} from inside
  \passthrough{\lstinline!MeasureOverride!}; schedule work via
  \passthrough{\lstinline!Dispatcher!} if you must recalc
  asynchronously.
\end{itemize}

\subsection{3. Start a layout playground
project}\label{start-a-layout-playground-project}

\begin{lstlisting}[language=bash]
dotnet new avalonia.app -o LayoutPlayground
cd LayoutPlayground
\end{lstlisting}

Replace \passthrough{\lstinline!MainWindow.axaml!} with an experiment
playground that demonstrates the core panels and alignment tools:

\begin{lstlisting}[language=XML]
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="LayoutPlayground.MainWindow"
        Width="880" Height="560"
        Title="Layout Playground">
  <Grid ColumnDefinitions="*,*" RowDefinitions="Auto,*" Padding="16" RowSpacing="16" ColumnSpacing="16">
    <TextBlock Grid.ColumnSpan="2" Classes="h1" Text="Layout system without mystery"/>

    <StackPanel Grid.Row="1" Spacing="12">
      <TextBlock Classes="h2" Text="StackPanel"/>
      <Border BorderBrush="#CCC" BorderThickness="1" Padding="8">
        <StackPanel Spacing="6">
          <Button Content="Top"/>
          <Button Content="Middle"/>
          <Button Content="Bottom"/>
          <Button Content="Stretch me" HorizontalAlignment="Stretch"/>
        </StackPanel>
      </Border>

      <TextBlock Classes="h2" Text="DockPanel"/>
      <Border BorderBrush="#CCC" BorderThickness="1" Padding="8">
        <DockPanel LastChildFill="True">
          <TextBlock DockPanel.Dock="Top" Text="Top bar"/>
          <TextBlock DockPanel.Dock="Left" Text="Left" Margin="0,4,8,0"/>
          <Border Background="#F0F6FF" CornerRadius="4" Padding="8">
            <TextBlock Text="Last child fills remaining space"/>
          </Border>
        </DockPanel>
      </Border>
    </StackPanel>

    <StackPanel Grid.Column="1" Grid.Row="1" Spacing="12">
      <TextBlock Classes="h2" Text="Grid + WrapPanel"/>
      <Border BorderBrush="#CCC" BorderThickness="1" Padding="8">
        <Grid ColumnDefinitions="Auto,*" RowDefinitions="Auto,Auto,Auto" ColumnSpacing="8" RowSpacing="8">
          <TextBlock Text="Name:"/>
          <TextBox Grid.Column="1" MinWidth="200"/>

          <TextBlock Grid.Row="1" Text="Email:"/>
          <TextBox Grid.Row="1" Grid.Column="1"/>

          <TextBlock Grid.Row="2" Text="Notes:" VerticalAlignment="Top"/>
          <TextBox Grid.Row="2" Grid.Column="1" Height="80" AcceptsReturn="True" TextWrapping="Wrap"/>
        </Grid>
      </Border>

      <Border BorderBrush="#CCC" BorderThickness="1" Padding="8">
        <WrapPanel ItemHeight="32" MinWidth="200" ItemWidth="100" HorizontalAlignment="Left">
          <Button Content="One"/>
          <Button Content="Two"/>
          <Button Content="Three"/>
          <Button Content="Four"/>
          <Button Content="Five"/>
          <Button Content="Six"/>
        </WrapPanel>
      </Border>
    </StackPanel>
  </Grid>
</Window>
\end{lstlisting}

Run the app and resize the window. Observe how StackPanel, DockPanel,
Grid, and WrapPanel distribute space.

\subsection{4. Alignment and sizing toolkit
recap}\label{alignment-and-sizing-toolkit-recap}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!Margin!} vs \passthrough{\lstinline!Padding!}:
  Margin adds space around a control; Padding adds space inside a
  container.
\item
  \passthrough{\lstinline!HorizontalAlignment!}/\passthrough{\lstinline!VerticalAlignment!}:
  \passthrough{\lstinline!Stretch!} makes controls fill available space;
  \passthrough{\lstinline!Center!}, \passthrough{\lstinline!Start!},
  \passthrough{\lstinline!End!} align within the assigned slot.
\item
  \passthrough{\lstinline!Width!}/\passthrough{\lstinline!Height!}:
  fixed sizes; use sparingly. Prefer \passthrough{\lstinline!MinWidth!},
  \passthrough{\lstinline!MaxWidth!},
  \passthrough{\lstinline!MinHeight!},
  \passthrough{\lstinline!MaxHeight!} for adaptive layouts.
\item
  Grid sizing: \passthrough{\lstinline!Auto!} (size to content),
  \passthrough{\lstinline!*!} (take remaining space),
  \passthrough{\lstinline!2*!} (take twice the share). Column/row
  definitions can mix Auto, star, and pixel values.
\end{itemize}

\subsection{5. Advanced layout tools}\label{advanced-layout-tools}

\subsubsection{\texorpdfstring{Grid with
\texttt{SharedSizeGroup}}{Grid with SharedSizeGroup}}\label{grid-with-sharedsizegroup}

\passthrough{\lstinline!SharedSizeGroup!} lets multiple grids share
sizes within a scope. Mark the parent with
\passthrough{\lstinline!Grid.IsSharedSizeScope="True"!}:

\begin{lstlisting}[language=XML]
<Grid ColumnDefinitions="Auto,*" RowDefinitions="Auto,Auto" Grid.IsSharedSizeScope="True">
  <Grid.ColumnDefinitions>
    <ColumnDefinition SharedSizeGroup="Label"/>
    <ColumnDefinition Width="*"/>
  </Grid.ColumnDefinitions>
  <Grid RowDefinitions="Auto,Auto" ColumnDefinitions="Auto,*">
    <TextBlock Text="First" Grid.Column="0"/>
    <TextBox Grid.Column="1" MinWidth="200"/>
  </Grid>
  <Grid Grid.Row="1" ColumnDefinitions="Auto,*">
    <TextBlock Text="Second" Grid.Column="0"/>
    <TextBox Grid.Column="1" MinWidth="200"/>
  </Grid>
</Grid>
\end{lstlisting}

All label columns share the same width. Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Grid.cs}{\passthrough{\lstinline!Grid.cs!}}
and
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/DefinitionBase.cs}{\passthrough{\lstinline!DefinitionBase.cs!}}.

\subsubsection{\texorpdfstring{\texttt{GridSplitter}}{GridSplitter}}\label{gridsplitter}

\begin{lstlisting}[language=XML]
<Grid ColumnDefinitions="3*,Auto,2*">
  <StackPanel Grid.Column="0">...</StackPanel>
  <GridSplitter Grid.Column="1" Width="6" ShowsPreview="True" Background="#DDD"/>
  <StackPanel Grid.Column="2">...</StackPanel>
</Grid>
\end{lstlisting}

\passthrough{\lstinline!GridSplitter!} lets users resize star-sized
columns/rows. Implementation:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/GridSplitter.cs}{\passthrough{\lstinline!GridSplitter.cs!}}.

\subsubsection{\texorpdfstring{\texttt{Viewbox} and
\texttt{LayoutTransformControl}}{Viewbox and LayoutTransformControl}}\label{viewbox-and-layouttransformcontrol}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!Viewbox!} scales its child proportionally to
  fit the available space.
\item
  \passthrough{\lstinline!LayoutTransformControl!} applies transforms
  (rotate, scale, skew) while preserving layout.
\end{itemize}

\begin{lstlisting}[language=XML]
<Viewbox Stretch="Uniform" Width="200" Height="200">
  <TextBlock Text="Scaled" FontSize="24"/>
</Viewbox>

<LayoutTransformControl>
  <LayoutTransformControl.LayoutTransform>
    <RotateTransform Angle="-10"/>
  </LayoutTransformControl.LayoutTransform>
  <Border Padding="12" Background="#E7F1FF">
    <TextBlock Text="Rotated layout"/>
  </Border>
</LayoutTransformControl>
\end{lstlisting}

Sources:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Viewbox.cs}{\passthrough{\lstinline!Viewbox.cs!}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/LayoutTransformControl.cs}{\passthrough{\lstinline!LayoutTransformControl.cs!}}.

\subsubsection{\texorpdfstring{\texttt{Panel.ZIndex}}{Panel.ZIndex}}\label{panel.zindex}

Controls inside the same panel respect
\passthrough{\lstinline!Panel.ZIndex!} for stacking order. Higher ZIndex
renders above lower values.

\begin{lstlisting}[language=XML]
<Canvas>
  <Rectangle Width="100" Height="80" Fill="#60FF0000" Panel.ZIndex="1"/>
  <Rectangle Width="120" Height="60" Fill="#6000FF00" Panel.ZIndex="2" Margin="20,10,0,0"/>
</Canvas>
\end{lstlisting}

\subsection{6. Scrolling and
LogicalScroll}\label{scrolling-and-logicalscroll}

\passthrough{\lstinline!ScrollViewer!} wraps content to provide
scrolling. When the child implements
\passthrough{\lstinline!ILogicalScrollable!} (e.g.,
\passthrough{\lstinline!ItemsPresenter!} with virtualization), the
scrolling is smoother and can skip measurement of offscreen content.

\begin{lstlisting}[language=XML]
<ScrollViewer HorizontalScrollBarVisibility="Auto" VerticalScrollBarVisibility="Auto">
  <StackPanel>

  </StackPanel>
</ScrollViewer>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  For virtualization, panels may implement
  \passthrough{\lstinline!ILogicalScrollable!} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/LogicalScroll.cs}{\passthrough{\lstinline!LogicalScroll.cs!}}).
\item
  \passthrough{\lstinline!ScrollViewer!} triggers layout when viewports
  change.
\end{itemize}

\subsection{7. Custom panels (when the built-ins aren't
enough)}\label{custom-panels-when-the-built-ins-arent-enough}

Derive from \passthrough{\lstinline!Panel!} and override
\passthrough{\lstinline!MeasureOverride!}/\passthrough{\lstinline!ArrangeOverride!}
to create custom layout logic. Example: a simplified
\passthrough{\lstinline!UniformGrid!}:

\begin{lstlisting}
using Avalonia;
using Avalonia.Controls;
using Avalonia.Layout;

namespace LayoutPlayground.Controls;

public class UniformGridPanel : Panel
{
    public static readonly StyledProperty<int> ColumnsProperty =
        AvaloniaProperty.Register<UniformGridPanel, int>(nameof(Columns), 2);

    public int Columns
    {
        get => GetValue(ColumnsProperty);
        set => SetValue(ColumnsProperty, value);
    }

    protected override Size MeasureOverride(Size availableSize)
    {
        foreach (var child in Children)
        {
            child.Measure(Size.Infinity);
        }

        var rows = (int)Math.Ceiling(Children.Count / (double)Columns);
        var cellWidth = availableSize.Width / Columns;
        var cellHeight = availableSize.Height / rows;

        return new Size(cellWidth * Columns, cellHeight * rows);
    }

    protected override Size ArrangeOverride(Size finalSize)
    {
        var rows = (int)Math.Ceiling(Children.Count / (double)Columns);
        var cellWidth = finalSize.Width / Columns;
        var cellHeight = finalSize.Height / rows;

        for (var index = 0; index < Children.Count; index++)
        {
            var child = Children[index];
            var row = index / Columns;
            var column = index % Columns;
            var rect = new Rect(column * cellWidth, row * cellHeight, cellWidth, cellHeight);
            child.Arrange(rect);
        }

        return finalSize;
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  This panel ignores child desired sizes for simplicity; real panels
  usually respect \passthrough{\lstinline!child.DesiredSize!} from
  \passthrough{\lstinline!Measure!}.
\item
  Read \passthrough{\lstinline!Layoutable!} and
  \passthrough{\lstinline!Panel!} sources to understand helper methods
  like \passthrough{\lstinline!ArrangeRect!}.
\end{itemize}

\subsection{8. Layout diagnostics with
DevTools}\label{layout-diagnostics-with-devtools}

While running the app press \textbf{F12} -\textgreater{} Layout tab: -
Inspect the measurement and arrange rectangles for each control. -
Toggle the Layout Bounds overlay to visualise margins and paddings. -
Use the Render Options overlay to show dirty rectangles (requires
enabling \passthrough{\lstinline!RendererDebugOverlays!} in code: see
\passthrough{\lstinline!RendererDebugOverlays.cs!}).

You can also enable layout logging:

\begin{lstlisting}
AppBuilder.Configure<App>()
    .UsePlatformDetect()
    .LogToTrace(LogEventLevel.Debug, new[] { LogArea.Layout })
    .StartWithClassicDesktopLifetime(args);
\end{lstlisting}

\passthrough{\lstinline!LogArea.Layout!} logs measure/arrange operations
to the console.

\subsection{9. Practice scenarios}\label{practice-scenarios}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Shared field labels}: Use
  \passthrough{\lstinline!Grid.IsSharedSizeScope!} and
  \passthrough{\lstinline!SharedSizeGroup!} across multiple form
  sections so labels align perfectly, even when collapsed sections are
  toggled.
\item
  \textbf{Resizable master-detail}: Combine
  \passthrough{\lstinline!GridSplitter!} with a two-column layout;
  ensure minimum sizes keep content readable.
\item
  \textbf{Rotated card}: Wrap a Border in
  \passthrough{\lstinline!LayoutTransformControl!} to rotate it;
  evaluate how alignment behaves inside the transform.
\item
  \textbf{Custom panel}: Replace a WrapPanel with your
  \passthrough{\lstinline!UniformGridPanel!} and compare measurement
  behaviour in DevTools.
\item
  \textbf{Scroll diagnostics}: Place a long list inside
  \passthrough{\lstinline!ScrollViewer!}, enable DevTools Layout
  overlay, and observe how viewport size changes the arrange rectangles.
\item
  \textbf{Layout logging}: Enable
  \passthrough{\lstinline!LogArea.Layout!} and capture a trace of
  \passthrough{\lstinline!Measure!}/\passthrough{\lstinline!Arrange!}
  calls when resizing. Inspect
  \passthrough{\lstinline!LayoutManager.Instance.LayoutPassTiming.LastLayoutTime!}
  to correlate with DevTools overlays.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-3}

\begin{itemize}
\tightlist
\item
  Base layout contract:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/Layoutable.cs}{\passthrough{\lstinline!Layoutable.cs!}}
\item
  Layout manager:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/LayoutManager.cs}{\passthrough{\lstinline!LayoutManager.cs!}}
\item
  Layout pass timing \& diagnostics:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/LayoutPassTiming.cs}{\passthrough{\lstinline!LayoutPassTiming.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDebugOverlays.cs}{\passthrough{\lstinline!RendererDebugOverlays.cs!}}
\item
  Grid + shared size:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Grid.cs}{\passthrough{\lstinline!Grid.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/DefinitionBase.cs}{\passthrough{\lstinline!DefinitionBase.cs!}}
\item
  Layout transforms:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/LayoutTransformControl.cs}{\passthrough{\lstinline!LayoutTransformControl.cs!}}
\item
  Scroll infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ScrollViewer.cs}{\passthrough{\lstinline!ScrollViewer.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/LogicalScroll.cs}{\passthrough{\lstinline!LogicalScroll.cs!}}
\item
  Custom panels inspiration:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/VirtualizingStackPanel.cs}{\passthrough{\lstinline!VirtualizingStackPanel.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-3}

\begin{itemize}
\tightlist
\item
  What two steps does the layout system run for every control, and which
  classes coordinate them?
\item
  How does \passthrough{\lstinline!SharedSizeGroup!} influence multiple
  grids? What property enables shared sizing?
\item
  When would you use \passthrough{\lstinline!LayoutTransformControl!}
  instead of a render transform?
\item
  What happens if you change \passthrough{\lstinline!Panel.ZIndex!} for
  children inside the same panel?
\item
  How can DevTools and logging help you diagnose a control that does not
  appear where expected?
\end{itemize}

What's next - Next: \href{Chapter06.md}{Chapter 6}

\newpage

\subsection{6. Controls tour you'll actually
use}\label{controls-tour-youll-actually-use}

Goal - Build confidence with Avalonia's everyday controls grouped by
scenario: text input, selection, navigation, editing, and feedback. -
Learn how to bind controls to view models, template items, and customise
interaction states. - Discover specialised controls such as
\passthrough{\lstinline!NumericUpDown!},
\passthrough{\lstinline!MaskedTextBox!},
\passthrough{\lstinline!AutoCompleteBox!},
\passthrough{\lstinline!ColorPicker!},
\passthrough{\lstinline!TreeView!},
\passthrough{\lstinline!TabControl!}, and
\passthrough{\lstinline!SplitView!}. - Understand selection models,
virtualization, and templating so large lists stay responsive. - Know
where to find styles, templates, and extension points in the source
code.

Why this matters - Real apps mix many controls on the same screen.
Understanding their behaviour and key properties saves time. -
Avalonia's control set is broad; learning the structure of templates and
selection models prepares you for customisation later.

Prerequisites - You have built layouts (Chapter 5) and can bind data
(Chapter 3's data templates). Chapter 8 will deepen bindings further.

\subsection{1. Set up a sample project}\label{set-up-a-sample-project}

\begin{lstlisting}[language=bash]
dotnet new avalonia.mvvm -o ControlsShowcase
cd ControlsShowcase
\end{lstlisting}

We will extend \passthrough{\lstinline!Views/MainWindow.axaml!} with
multiple sections backed by
\passthrough{\lstinline!MainWindowViewModel!}.

\subsection{2. Control overview matrix}\label{control-overview-matrix}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Scenario
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Key controls
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Highlights
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Source snapshot
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Text \& numeric input & \passthrough{\lstinline!TextBox!},
\passthrough{\lstinline!MaskedTextBox!},
\passthrough{\lstinline!NumericUpDown!},
\passthrough{\lstinline!DatePicker!} & Validation-friendly inputs with
watermarks, masks, spinner buttons, culture-aware dates &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TextBox.cs}{\passthrough{\lstinline!TextBox.cs!}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/MaskedTextBox/MaskedTextBox.cs}{\passthrough{\lstinline!MaskedTextBox!}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/NumericUpDown/NumericUpDown.cs}{\passthrough{\lstinline!NumericUpDown!}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/DateTimePickers/DatePicker.cs}{\passthrough{\lstinline!DatePicker!}} \\
Toggles \& commands & \passthrough{\lstinline!ToggleSwitch!},
\passthrough{\lstinline!CheckBox!},
\passthrough{\lstinline!RadioButton!}, \passthrough{\lstinline!Button!}
& MVVM-friendly toggles and grouped options with automation peers &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ToggleSwitch.cs}{\passthrough{\lstinline!ToggleSwitch.cs!}} \\
Lists \& selection & \passthrough{\lstinline!ListBox!},
\passthrough{\lstinline!TreeView!},
\passthrough{\lstinline!SelectionModel!},
\passthrough{\lstinline!ItemsRepeater!} & Single/multi-select,
hierarchical data, virtualization &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Selection/SelectionModel.cs}{\passthrough{\lstinline!SelectionModel!}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TreeView.cs}{\passthrough{\lstinline!TreeView!}} \\
Navigation surfaces & \passthrough{\lstinline!TabControl!},
\passthrough{\lstinline!SplitView!}, \passthrough{\lstinline!Expander!},
\passthrough{\lstinline!TransitioningContentControl!} & Tabbed pages,
collapsible panes, animated transitions &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SplitView/SplitView.cs}{\passthrough{\lstinline!SplitView!}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TransitioningContentControl.cs}{\passthrough{\lstinline!TransitioningContentControl!}} \\
Search \& pickers & \passthrough{\lstinline!AutoCompleteBox!},
\passthrough{\lstinline!ComboBox!},
\passthrough{\lstinline!ColorPicker!},
\passthrough{\lstinline!FilePicker!} dialogs & Suggest-as-you-type,
palette pickers, storage providers &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/AutoCompleteBox/AutoCompleteBox.cs}{\passthrough{\lstinline!AutoCompleteBox!}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls.ColorPicker/ColorPicker/ColorPicker.cs}{\passthrough{\lstinline!ColorPicker!}} \\
Command surfaces & \passthrough{\lstinline!SplitButton!},
\passthrough{\lstinline!Menu!}, \passthrough{\lstinline!ContextMenu!},
\passthrough{\lstinline!Toolbar!} & Primary/secondary actions, keyboard
shortcuts, flyouts &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SplitButton/SplitButton.cs}{\passthrough{\lstinline!SplitButton!}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Menu.cs}{\passthrough{\lstinline!Menu!}} \\
Refresh \& feedback & \passthrough{\lstinline!RefreshContainer!},
\passthrough{\lstinline!RefreshVisualizer!},
\passthrough{\lstinline!WindowNotificationManager!},
\passthrough{\lstinline!StatusBar!},
\passthrough{\lstinline!NotificationCard!} & Pull-to-refresh gestures,
toast notifications, status indicators &
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/PullToRefresh/RefreshContainer.cs}{\passthrough{\lstinline!RefreshContainer!}},
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Notifications/WindowNotificationManager.cs}{\passthrough{\lstinline!WindowNotificationManager!}} \\
\end{longtable}

Use this table as a map while exploring ControlCatalog; each section
below dives into exemplars from these categories.

\subsection{3. Form inputs and validation
basics}\label{form-inputs-and-validation-basics}

\begin{lstlisting}[language=XML]
<StackPanel Spacing="16">
  <TextBlock Classes="h1" Text="Customer profile"/>

  <Grid ColumnDefinitions="Auto,*" RowDefinitions="Auto,Auto,Auto" RowSpacing="8" ColumnSpacing="12">
    <TextBlock Text="Name:"/>
    <TextBox Grid.Column="1" Text="{Binding Customer.Name}" Watermark="Full name"/>

    <TextBlock Grid.Row="1" Text="Email:"/>
    <TextBox Grid.Row="1" Grid.Column="1" Text="{Binding Customer.Email}"/>

    <TextBlock Grid.Row="2" Text="Phone:"/>
    <MaskedTextBox Grid.Row="2" Grid.Column="1" Mask="(000) 000-0000" Value="{Binding Customer.Phone}"/>
  </Grid>

  <StackPanel Orientation="Horizontal" Spacing="12">
    <NumericUpDown Width="120" Minimum="0" Maximum="20" Value="{Binding Customer.Seats}" Header="Seats"/>
    <DatePicker SelectedDate="{Binding Customer.RenewalDate}" Header="Renewal"/>
  </StackPanel>
</StackPanel>
\end{lstlisting}

Notes: - \passthrough{\lstinline!MaskedTextBox!} lives in
\passthrough{\lstinline!Avalonia.Controls!} (see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/MaskedTextBox/MaskedTextBox.cs}{\passthrough{\lstinline!MaskedTextBox.cs!}})
and enforces input patterns. - \passthrough{\lstinline!NumericUpDown!}
(from
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/NumericUpDown/NumericUpDown.cs}{\passthrough{\lstinline!NumericUpDown.cs!}})
provides spinner buttons and numeric formatting. - Accessibility:
provide spoken labels via
\passthrough{\lstinline!AutomationProperties.Name!} or
\passthrough{\lstinline!HelpText!} on inputs so screen readers identify
the fields correctly.

\subsection{4. Toggles, options, and
commands}\label{toggles-options-and-commands}

\begin{lstlisting}[language=XML]
<GroupBox Header="Plan options" Padding="12">
  <StackPanel Spacing="8">
    <ToggleSwitch Header="Enable auto-renew" IsChecked="{Binding Customer.AutoRenew}"/>

    <StackPanel Orientation="Horizontal" Spacing="12">
      <CheckBox Content="Include analytics" IsChecked="{Binding Customer.IncludeAnalytics}"/>
      <CheckBox Content="Priority support" IsChecked="{Binding Customer.IncludeSupport}"/>
    </StackPanel>

    <StackPanel Orientation="Horizontal" Spacing="12">
      <RadioButton GroupName="Plan" Content="Starter" IsChecked="{Binding Customer.IsStarter}"/>
      <RadioButton GroupName="Plan" Content="Growth" IsChecked="{Binding Customer.IsGrowth}"/>
      <RadioButton GroupName="Plan" Content="Enterprise" IsChecked="{Binding Customer.IsEnterprise}"/>
    </StackPanel>

    <Button Content="Save" HorizontalAlignment="Left" Command="{Binding SaveCommand}"/>
  </StackPanel>
</GroupBox>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!ToggleSwitch!} gives a Fluent-styled toggle.
  Implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ToggleSwitch.cs}{\passthrough{\lstinline!ToggleSwitch.cs!}}.
\item
  RadioButtons share state via \passthrough{\lstinline!GroupName!} or
  \passthrough{\lstinline!IsChecked!} bindings.
\end{itemize}

\subsection{5. Selection lists with
templating}\label{selection-lists-with-templating}

\begin{lstlisting}[language=XML]
<GroupBox Header="Teams" Padding="12">
  <ListBox Items="{Binding Teams}" SelectedItem="{Binding SelectedTeam}" Height="160">
    <ListBox.ItemTemplate>
      <DataTemplate>
        <StackPanel Orientation="Horizontal" Spacing="12">
          <Ellipse Width="24" Height="24" Fill="{Binding Color}"/>
          <TextBlock Text="{Binding Name}" FontWeight="SemiBold"/>
        </StackPanel>
      </DataTemplate>
    </ListBox.ItemTemplate>
  </ListBox>
</GroupBox>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!ListBox!} supports selection out of the box.
  For custom selection logic, use
  \passthrough{\lstinline!SelectionModel!} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Selection/SelectionModel.cs}{\passthrough{\lstinline!SelectionModel.cs!}}).
\item
  Consider \passthrough{\lstinline!ListBox.SelectionMode="Multiple"!}
  for multi-select.
\end{itemize}

\subsubsection{Virtualization tip}\label{virtualization-tip}

Large lists should virtualize. Use \passthrough{\lstinline!ListBox!}
with the default \passthrough{\lstinline!VirtualizingStackPanel!} or
switch panels:

\begin{lstlisting}[language=XML]
<ListBox Items="{Binding ManyItems}" VirtualizingPanel.IsVirtualizing="True" VirtualizingPanel.CacheLength="2"/>
\end{lstlisting}

Controls for virtualization:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/VirtualizingStackPanel.cs}{\passthrough{\lstinline!VirtualizingStackPanel.cs!}}.

\subsection{\texorpdfstring{6. Hierarchical data with
\texttt{TreeView}}{6. Hierarchical data with TreeView}}\label{hierarchical-data-with-treeview}

\begin{lstlisting}[language=XML]
<TreeView Items="{Binding Departments}" SelectedItems="{Binding SelectedDepartments}">
  <TreeView.ItemTemplate>
    <TreeDataTemplate ItemsSource="{Binding Teams}">
      <TextBlock Text="{Binding Name}" FontWeight="SemiBold"/>
      <TreeDataTemplate.ItemTemplate>
        <DataTemplate>
          <TextBlock Text="{Binding Name}" Margin="24,0,0,0"/>
        </DataTemplate>
      </TreeDataTemplate.ItemTemplate>
    </TreeDataTemplate>
  </TreeView.ItemTemplate>
</TreeView>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!TreeView!} uses
  \passthrough{\lstinline!TreeDataTemplate!} to describe hierarchical
  data. Each template can reference a property
  (\passthrough{\lstinline!Teams!}) for child items.
\item
  Source implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TreeView.cs}{\passthrough{\lstinline!TreeView.cs!}}.
\end{itemize}

\subsection{\texorpdfstring{7. Navigation controls (\texttt{TabControl},
\texttt{SplitView},
\texttt{Expander})}{7. Navigation controls (TabControl, SplitView, Expander)}}\label{navigation-controls-tabcontrol-splitview-expander}

\begin{lstlisting}[language=XML]
<TabControl SelectedIndex="{Binding SelectedTab}">
  <TabItem Header="Overview">
    <TextBlock Text="Overview content" Margin="12"/>
  </TabItem>
  <TabItem Header="Reports">
    <TextBlock Text="Reports content" Margin="12"/>
  </TabItem>
  <TabItem Header="Settings">
    <TextBlock Text="Settings content" Margin="12"/>
  </TabItem>
</TabControl>

<SplitView DisplayMode="CompactInline"
          IsPaneOpen="{Binding IsPaneOpen}"
          OpenPaneLength="240" CompactPaneLength="56">
  <SplitView.Pane>
    <NavigationViewContent/>
  </SplitView.Pane>
  <SplitView.Content>
    <Frame Content="{Binding ActivePage}"/>
  </SplitView.Content>
</SplitView>

<Expander Header="Advanced filters" IsExpanded="False">
  <StackPanel Margin="12" Spacing="8">
    <ComboBox Items="{Binding FilterSets}" SelectedItem="{Binding SelectedFilter}"/>
    <CheckBox Content="Include archived" IsChecked="{Binding IncludeArchived}"/>
  </StackPanel>
</Expander>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!TabControl!} enables tabbed navigation. Tab
  headers are content--you can template them via
  \passthrough{\lstinline!TabControl.ItemTemplate!}.
\item
  \passthrough{\lstinline!SplitView!} (from
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SplitView/SplitView.cs}{\passthrough{\lstinline!SplitView.cs!}})
  provides collapsible navigation, useful for sidebars.
\item
  \passthrough{\lstinline!Expander!} collapses/expands content.
  Implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Expander.cs}{\passthrough{\lstinline!Expander.cs!}}.
\end{itemize}

\subsection{8. Auto-complete, pickers, and
dialogs}\label{auto-complete-pickers-and-dialogs}

\subsection{9. Command surfaces and
flyouts}\label{command-surfaces-and-flyouts}

\begin{lstlisting}[language=XML]
<StackPanel Spacing="12">
  <SplitButton Content="Export" Command="{Binding ExportAllCommand}">
    <SplitButton.Flyout>
      <MenuFlyout>
        <MenuItem Header="Export CSV" Command="{Binding ExportCsvCommand}"/>
        <MenuItem Header="Export JSON" Command="{Binding ExportJsonCommand}"/>
        <MenuItem Header="Export PDF" Command="{Binding ExportPdfCommand}"/>
      </MenuFlyout>
    </SplitButton.Flyout>
  </SplitButton>

  <Menu>
    <MenuItem Header="File">
      <MenuItem Header="New" Command="{Binding NewCommand}"/>
      <MenuItem Header="Open..." Command="{Binding OpenCommand}"/>
      <Separator/>
      <MenuItem Header="Exit" Command="{Binding ExitCommand}"/>
    </MenuItem>
    <MenuItem Header="Help" Command="{Binding ShowHelpCommand}"/>
  </Menu>

  <StackPanel Orientation="Horizontal" Spacing="8">
    <Button Content="Copy" Command="{Binding CopyCommand}" HotKey="Ctrl+C"/>
    <Button Content="Paste" Command="{Binding PasteCommand}" HotKey="Ctrl+V"/>
  </StackPanel>
</StackPanel>
\end{lstlisting}

Notes: - \passthrough{\lstinline!SplitButton!} exposes a primary command
and a flyout for secondary options. Automation peers surface both the
button and flyout; see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SplitButton/SplitButton.cs}{\passthrough{\lstinline!SplitButton.cs!}}.
- \passthrough{\lstinline!Menu!}/\passthrough{\lstinline!ContextMenu!}
support keyboard navigation and
\passthrough{\lstinline!AutomationProperties.AcceleratorKey!} so
shortcuts are announced to assistive tech. Implementation:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Menu.cs}{\passthrough{\lstinline!Menu.cs!}}.
- Flyouts can host any control (\passthrough{\lstinline!MenuFlyout!},
\passthrough{\lstinline!Popup!}, \passthrough{\lstinline!FlyoutBase!}).
Use \passthrough{\lstinline!FlyoutBase.ShowAttachedFlyout!} to open
context actions from command handlers.

\begin{lstlisting}[language=XML]
<StackPanel Spacing="12">
  <AutoCompleteBox Width="240"
                   Items="{Binding Suggestions}"
                   Text="{Binding Query, Mode=TwoWay}">
    <AutoCompleteBox.ItemTemplate>
      <DataTemplate>
        <StackPanel Orientation="Horizontal" Spacing="8">
          <TextBlock Text="{Binding Icon}"/>
          <TextBlock Text="{Binding Title}"/>
        </StackPanel>
      </DataTemplate>
    </AutoCompleteBox.ItemTemplate>
  </AutoCompleteBox>

  <ColorPicker SelectedColor="{Binding ThemeColor}"/>

  <Button Content="Choose files" Command="{Binding OpenFilesCommand}"/>
</StackPanel>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!AutoCompleteBox!} helps with large suggestion
  lists. Source:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/AutoCompleteBox/AutoCompleteBox.cs}{\passthrough{\lstinline!AutoCompleteBox.cs!}}.
\item
  \passthrough{\lstinline!ColorPicker!} shows palettes, sliders, and
  input fields (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls.ColorPicker/ColorPicker.cs}{\passthrough{\lstinline!ColorPicker.cs!}}).
\item
  File pickers will use \passthrough{\lstinline!IStorageProvider!}
  (Chapter 16).
\end{itemize}

\subsection{10. Refresh gestures and
feedback}\label{refresh-gestures-and-feedback}

\begin{lstlisting}[language=XML]
<Window xmlns:ptr="clr-namespace:Avalonia.Controls;assembly=Avalonia.Controls"
        xmlns:notifications="clr-namespace:Avalonia.Controls.Notifications;assembly=Avalonia.Controls"
        ...>
  <Grid>
    <ptr:RefreshContainer RefreshRequested="OnRefreshRequested">
      <ptr:RefreshContainer.Visualizer>
        <ptr:RefreshVisualizer Orientation="TopToBottom"
                                Content="Pull to refresh"/>
      </ptr:RefreshContainer.Visualizer>
      <ScrollViewer>
        <ItemsControl Items="{Binding Orders}"/>
      </ScrollViewer>
    </ptr:RefreshContainer>
  </Grid>
</Window>
\end{lstlisting}

\begin{lstlisting}
private async void OnRefreshRequested(object? sender, RefreshRequestedEventArgs e)
{
    using var deferral = e.GetDeferral();
    await ViewModel.ReloadAsync();
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!RefreshContainer!} +
  \passthrough{\lstinline!RefreshVisualizer!} implement pull-to-refresh
  on any scrollable surface. Source:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/PullToRefresh/RefreshContainer.cs}{\passthrough{\lstinline!RefreshContainer!}}.
\item
  Always provide an alternate refresh action (button, keyboard) for
  desktop scenarios.
\end{itemize}

\begin{lstlisting}
var notifications = new WindowNotificationManager(this)
{
    Position = NotificationPosition.TopRight,
    MaxItems = 3
};
notifications.Show(new Notification("Update available", "Restart to apply updates.", NotificationType.Success));
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!WindowNotificationManager!} displays toast
  notifications layered over the current window; combine with inline
  \passthrough{\lstinline!NotificationCard!} or
  \passthrough{\lstinline!InfoBar!} for longer-lived messages. Sources:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Notifications/WindowNotificationManager.cs}{\passthrough{\lstinline!WindowNotificationManager!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Notifications/NotificationCard.cs}{\passthrough{\lstinline!NotificationCard!}}.
\item
  Mark status changes with
  \passthrough{\lstinline!AutomationProperties.LiveSetting="Polite"!} so
  assistive technologies announce them.
\end{itemize}

\begin{lstlisting}[language=XML]
<StatusBar>
  <StatusBarItem>
    <StackPanel Orientation="Horizontal" Spacing="8">
      <TextBlock Text="Ready"/>
      <ProgressBar Width="120" IsIndeterminate="{Binding IsBusy}"/>
    </StackPanel>
  </StatusBarItem>
  <StatusBarItem HorizontalAlignment="Right">
    <TextBlock Text="v1.2.0"/>
  </StatusBarItem>
</StatusBar>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!StatusBar!} hosts persistent indicators
  (connection status, progress). Implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/StatusBar/StatusBar.cs}{\passthrough{\lstinline!StatusBar!}}.
\end{itemize}

\subsection{11. Styling, classes, and visual
states}\label{styling-classes-and-visual-states}

Use classes (\passthrough{\lstinline!Classes="primary"!}) or
pseudo-classes (\passthrough{\lstinline!:pointerover!},
\passthrough{\lstinline!:pressed!}, \passthrough{\lstinline!:checked!})
to style stateful controls:

\begin{lstlisting}[language=XML]
<Button Content="Primary" Classes="primary"/>
\end{lstlisting}

\begin{lstlisting}[language=XML]
<Style Selector="Button.primary">
  <Setter Property="Background" Value="{DynamicResource AccentBrush}"/>
  <Setter Property="Foreground" Value="White"/>
</Style>

<Style Selector="Button.primary:pointerover">
  <Setter Property="Background" Value="{DynamicResource AccentBrush2}"/>
</Style>
\end{lstlisting}

Styles live in \passthrough{\lstinline!App.axaml!} or separate resource
dictionaries. Control templates are defined under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent/Controls}{\passthrough{\lstinline!src/Avalonia.Themes.Fluent!}}.
Inspect \passthrough{\lstinline!Button.xaml!},
\passthrough{\lstinline!ListBox.xaml!}, etc., to understand structure
and visual states.

\subsection{12. ControlCatalog treasure
hunt}\label{controlcatalog-treasure-hunt}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Clone the Avalonia repository and run the ControlCatalog (Desktop)
  sample:
  \passthrough{\lstinline!dotnet run --project samples/ControlCatalog.Desktop/ControlCatalog.Desktop.csproj!}.
\item
  Use the built-in search to find controls. Explore the
  \passthrough{\lstinline!Source!} tab to jump to relevant XAML or C\#
  files.
\item
  Compare ControlCatalog pages with the source directory structure:

  \begin{itemize}
  \tightlist
  \item
    Text input demos map to
    \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TextBox.cs}{\passthrough{\lstinline!src/Avalonia.Controls/TextBox.cs!}}.
  \item
    Collections and virtualization demos map to
    \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/VirtualizingStackPanel.cs}{\passthrough{\lstinline!VirtualizingStackPanel.cs!}}.
  \item
    Navigation samples map to
    \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SplitView/SplitView.cs}{\passthrough{\lstinline!SplitView.cs!}}
    and \passthrough{\lstinline!TabControl!} templates.
  \end{itemize}
\end{enumerate}

\subsection{13. Practice exercises}\label{practice-exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a ``dashboard'' page mixing text input, selection lists, tabs,
  a \passthrough{\lstinline!SplitButton!}, and a collapsible filter
  panel. Bind every control to a view model.
\item
  Add an \passthrough{\lstinline!AutoCompleteBox!} that filters as you
  type. Use DevTools to inspect the generated
  \passthrough{\lstinline!ListBox!} inside the control and verify
  automation names.
\item
  Replace the \passthrough{\lstinline!ListBox!} with a
  \passthrough{\lstinline!TreeView!} for hierarchical data; add an
  \passthrough{\lstinline!Expander!} per root item.
\item
  Wire up a \passthrough{\lstinline!RefreshContainer!} around a
  scrollable list and implement the
  \passthrough{\lstinline!RefreshRequested!} deferal pattern. Provide a
  fallback refresh button for keyboard users.
\item
  Register a singleton
  \passthrough{\lstinline!WindowNotificationManager!}, show a toast when
  the refresh completes, and style inline
  \passthrough{\lstinline!NotificationCard!} messages for success and
  error states.
\item
  Customise button states by adding pseudo-class styles and confirm they
  match the ControlCatalog defaults.
\item
  Swap the \passthrough{\lstinline!WrapPanel!} for an
  \passthrough{\lstinline!ItemsRepeater!} (Chapter 14) to prepare for
  virtualization scenarios.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-4}

\begin{itemize}
\tightlist
\item
  Core controls:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls}{\passthrough{\lstinline!src/Avalonia.Controls!}}
\item
  Specialized controls:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls.ColorPicker}{\passthrough{\lstinline!src/Avalonia.Controls.ColorPicker!}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/NumericUpDown}{\passthrough{\lstinline!src/Avalonia.Controls.NumericUpDown!}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/AutoCompleteBox}{\passthrough{\lstinline!src/Avalonia.Controls.AutoCompleteBox!}}
\item
  Command \& navigation surfaces:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/SplitButton}{\passthrough{\lstinline!src/Avalonia.Controls/SplitButton!}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/SplitView}{\passthrough{\lstinline!src/Avalonia.Controls/SplitView!}}
\item
  Refresh \& notifications:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/PullToRefresh}{\passthrough{\lstinline!src/Avalonia.Controls/PullToRefresh!}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/Notifications}{\passthrough{\lstinline!src/Avalonia.Controls/Notifications!}}
\item
  Selection framework:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/Selection}{\passthrough{\lstinline!src/Avalonia.Controls/Selection!}}
\item
  Styles and templates:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent/Controls}{\passthrough{\lstinline!src/Avalonia.Themes.Fluent/Controls!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-4}

\begin{itemize}
\tightlist
\item
  Which controls would you choose for numeric input, masked input, and
  auto-completion?
\item
  How do you template \passthrough{\lstinline!ListBox!} items and enable
  virtualization for large datasets?
\item
  Where do you look to customise the appearance of a
  \passthrough{\lstinline!ToggleSwitch!}?
\item
  What role does \passthrough{\lstinline!SelectionModel!} play for
  advanced selection scenarios?
\item
  How can ControlCatalog help you explore a control's API and default
  styles?
\end{itemize}

What's next - Next: \href{Chapter07.md}{Chapter 7}

\newpage

\subsection{7. Fluent theming and styles made
simple}\label{fluent-theming-and-styles-made-simple}

Goal - Understand Avalonia's Fluent theme architecture, theme variants,
and how theme resources flow through your app. - Organise resources and
styles with \passthrough{\lstinline!ResourceInclude!},
\passthrough{\lstinline!StyleInclude!},
\passthrough{\lstinline!ThemeVariantScope!}, and
\passthrough{\lstinline!ControlTheme!} for clean reuse. - Override
control templates, use pseudo-classes, and scope theme changes to
specific regions. - Support runtime theme switching (light/dark/high
contrast) and accessibility requirements. - Map the styles you edit to
the Fluent source files so you can explore defaults and extend them
safely.

Why this matters - Styling controls consistently is the difference
between a polished UI and visual chaos. - Avalonia's Fluent theme ships
with rich resources; knowing how to extend them keeps your design system
maintainable. - Accessibility requirements (contrast, theming per
surface) are easier when you understand theme scoping and dynamic
resources.

Prerequisites - Comfort editing \passthrough{\lstinline!App.axaml!},
windows, and user controls (Chapters 3-6). - Basic understanding of data
binding and commands (Chapters 3, 6).

\subsection{1. Fluent theme in a
nutshell}\label{fluent-theme-in-a-nutshell}

Avalonia ships with Fluent 2 based resources and templates. The theme
lives under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent}{\passthrough{\lstinline!src/Avalonia.Themes.Fluent!}}.
Templates reference resource keys (brushes, thicknesses, typography)
that resolve per theme variant.

\passthrough{\lstinline!App.axaml!} typically looks like this:

\begin{lstlisting}[language=XML]
<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="ThemePlayground.App"
             RequestedThemeVariant="Light">
  <Application.Styles>
    <FluentTheme Mode="Light"/>
  </Application.Styles>
</Application>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!RequestedThemeVariant!} controls the global
  variant (\passthrough{\lstinline!ThemeVariant.Light!},
  \passthrough{\lstinline!ThemeVariant.Dark!},
  \passthrough{\lstinline!ThemeVariant.HighContrast!}).
\item
  \passthrough{\lstinline!FluentTheme!} can be configured with
  \passthrough{\lstinline!Mode="Light"!},
  \passthrough{\lstinline!Mode="Dark"!}, or
  \passthrough{\lstinline!Mode="Default"!} (auto based on OS hints).
  Source:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Themes.Fluent/FluentTheme.cs}{\passthrough{\lstinline!FluentTheme.cs!}}.
\end{itemize}

\subsection{2. Structure resources into
dictionaries}\label{structure-resources-into-dictionaries}

Split large resource sets into dedicated files. Create
\passthrough{\lstinline!Styles/Colors.axaml!}:

\begin{lstlisting}[language=XML]
<ResourceDictionary xmlns="https://github.com/avaloniaui">
  <Color x:Key="BrandPrimaryColor">#2563EB</Color>
  <Color x:Key="BrandPrimaryHover">#1D4ED8</Color>

  <SolidColorBrush x:Key="BrandPrimaryBrush"
                   Color="{DynamicResource BrandPrimaryColor}"/>
  <SolidColorBrush x:Key="BrandPrimaryHoverBrush"
                   Color="{DynamicResource BrandPrimaryHover}"/>
</ResourceDictionary>
\end{lstlisting}

Then create \passthrough{\lstinline!Styles/Controls.axaml!}:

\begin{lstlisting}[language=XML]
<Styles xmlns="https://github.com/avaloniaui">
  <Style Selector="Button.primary">
    <Setter Property="Background" Value="{DynamicResource BrandPrimaryBrush}"/>
    <Setter Property="Foreground" Value="White"/>
    <Setter Property="Padding" Value="14,10"/>
    <Setter Property="CornerRadius" Value="6"/>
  </Style>

  <Style Selector="Button.primary:pointerover">
    <Setter Property="Background" Value="{DynamicResource BrandPrimaryHoverBrush}"/>
  </Style>
</Styles>
\end{lstlisting}

Include them in \passthrough{\lstinline!App.axaml!}:

\begin{lstlisting}[language=XML]
<Application ...>
  <Application.Resources>
    <ResourceInclude Source="avares://ThemePlayground/Styles/Colors.axaml"/>
  </Application.Resources>
  <Application.Styles>
    <FluentTheme Mode="Default"/>
    <StyleInclude Source="avares://ThemePlayground/Styles/Controls.axaml"/>
  </Application.Styles>
</Application>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!ResourceInclude!} expects a
  \passthrough{\lstinline!ResourceDictionary!} root and merges it into
  the resource lookup chain. Use it for brushes, colors, converters, and
  typography resources.
\item
  \passthrough{\lstinline!StyleInclude!} expects
  \passthrough{\lstinline!Styles!} (or a single
  \passthrough{\lstinline!Style!}) and registers selectors. Use
  \passthrough{\lstinline!avares://Assembly/Path.axaml!} URIs to include
  styles from other assemblies (for example,
  \passthrough{\lstinline!avares://Avalonia.Themes.Fluent/Controls/Button.xaml!}).
\item
  When you rename assemblies or move resource files, update the
  \passthrough{\lstinline!Source!} URI; missing includes surface as
  \passthrough{\lstinline!XamlLoadException!} during startup.
\end{itemize}

\subsection{3. Static vs dynamic
resources}\label{static-vs-dynamic-resources}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!StaticResource!} resolves once during load.
  Use it for values that never change (fonts, corner radius constants).
\item
  \passthrough{\lstinline!DynamicResource!} re-evaluates when the
  resource is replaced at runtime--essential for theme switching.
\end{itemize}

\begin{lstlisting}[language=XML]
<Border CornerRadius="{StaticResource CornerRadiusMedium}"
        Background="{DynamicResource BrandPrimaryBrush}"/>
\end{lstlisting}

Resource lookup order: 1. Control-local resources
(\passthrough{\lstinline!this.Resources!}). 2. Logical tree parents
(user controls, windows). 3.
\passthrough{\lstinline!Application.Resources!}. 4. Theme dictionaries
merged by \passthrough{\lstinline!FluentTheme!} (light/dark/high
contrast). 5. System theme fallbacks.

The implementation lives in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Resources/ResourceDictionary.cs}{\passthrough{\lstinline!ResourceDictionary.cs!}}.
DevTools -\textgreater{} Resources panel shows the chain and which
dictionary satisfied a lookup.

\subsection{4. Theme variant scope (local
theming)}\label{theme-variant-scope-local-theming}

\subsection{5. Migrating and overriding Fluent
resources}\label{migrating-and-overriding-fluent-resources}

When you need to change Fluent defaults globally (for example, switch
accent colors or typography), supply variant-specific dictionaries.
Place these under \passthrough{\lstinline!Application.Resources!} with a
\passthrough{\lstinline!ThemeVariant!} attribute so they override the
theme-provided value only for matching variants.

\begin{lstlisting}[language=XML]
<Application.Resources>
  <ResourceInclude Source="avares://ThemePlayground/Styles/Colors.axaml"/>
  <ResourceDictionary ThemeVariant="Light">
    <SolidColorBrush x:Key="SystemAccentColor" Color="#2563EB"/>
  </ResourceDictionary>
  <ResourceDictionary ThemeVariant="Dark">
    <SolidColorBrush x:Key="SystemAccentColor" Color="#60A5FA"/>
  </ResourceDictionary>
</Application.Resources>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  Keys that match Fluent resources
  (\passthrough{\lstinline!SystemAccentColor!},
  \passthrough{\lstinline!SystemControlBackgroundBaseLowBrush!}, etc.)
  override the defaults only for the specified variant.
\item
  Keep overrides minimal: inspect the Fluent source to copy exact keys.
  Replace \passthrough{\lstinline!FluentTheme!} with
  \passthrough{\lstinline!SimpleTheme!} if you want the simple default
  look.
\item
  To migrate an existing design system, split colors/typography into
  \passthrough{\lstinline!ResourceDictionary!} files and create
  \passthrough{\lstinline!ControlTheme!} overrides for specific controls
  rather than editing Fluent templates in place.
\end{itemize}

\passthrough{\lstinline!ThemeVariantScope!} lets you apply a specific
theme to part of the UI. Implementation:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ThemeVariantScope.cs}{\passthrough{\lstinline!ThemeVariantScope.cs!}}.

\begin{lstlisting}[language=XML]
<ThemeVariantScope RequestedThemeVariant="Dark">
  <Border Padding="16">
    <StackPanel>
      <TextBlock Classes="h2" Text="Dark section"/>
      <Button Content="Dark themed button" Classes="primary"/>
    </StackPanel>
  </Border>
</ThemeVariantScope>
\end{lstlisting}

Everything inside the scope resolves resources as if the app were using
\passthrough{\lstinline!ThemeVariant.Dark!}. Useful for popovers or
modal sheets.

\subsection{6. Runtime theme switching}\label{runtime-theme-switching}

Add a toggle to your main view:

\begin{lstlisting}[language=XML]
<ToggleSwitch Content="Dark mode" IsChecked="{Binding IsDark}"/>
\end{lstlisting}

In the view model:

\begin{lstlisting}
using Avalonia;
using Avalonia.Styling;

public sealed class ShellViewModel : ObservableObject
{
    private bool _isDark;
    public bool IsDark
    {
        get => _isDark;
        set
        {
            if (SetProperty(ref _isDark, value))
            {
                Application.Current!.RequestedThemeVariant = value ? ThemeVariant.Dark : ThemeVariant.Light;
            }
        }
    }
}
\end{lstlisting}

Because button styles use \passthrough{\lstinline!DynamicResource!},
they respond immediately. For per-window overrides set
\passthrough{\lstinline!RequestedThemeVariant!} on the window itself or
wrap content in \passthrough{\lstinline!ThemeVariantScope!}.

\subsection{\texorpdfstring{7. Customizing control templates with
\texttt{ControlTheme}}{7. Customizing control templates with ControlTheme}}\label{customizing-control-templates-with-controltheme}

\passthrough{\lstinline!ControlTheme!} lets you replace a control's
default template and resources without subclassing. Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/ControlTheme.cs}{\passthrough{\lstinline!ControlTheme.cs!}}.

Example: create a pill-shaped toggle button theme in
\passthrough{\lstinline!Styles/ToggleButton.axaml!}:

\begin{lstlisting}[language=XML]
<ResourceDictionary xmlns="https://github.com/avaloniaui"
                    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
                    xmlns:themes="clr-namespace:Avalonia.Themes.Fluent;assembly=Avalonia.Themes.Fluent">
  <ControlTheme x:Key="PillToggleTheme" TargetType="ToggleButton">
    <Setter Property="Template">
      <ControlTemplate>
        <Border x:Name="PART_Root"
                Background="{TemplateBinding Background}"
                CornerRadius="20"
                Padding="{TemplateBinding Padding}">
          <ContentPresenter HorizontalAlignment="Center"
                            VerticalAlignment="Center"
                            Content="{TemplateBinding Content}"/>
        </Border>
      </ControlTemplate>
    </Setter>
  </ControlTheme>
</ResourceDictionary>
\end{lstlisting}

Apply it:

\begin{lstlisting}[language=XML]
<ToggleButton Content="Pill" Theme="{StaticResource PillToggleTheme}" padding="12,6"/>
\end{lstlisting}

To inherit Fluent visual states, you can base your theme on existing
resources by referencing
\passthrough{\lstinline!themes:ToggleButtonTheme!}. Inspect templates in
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent/Controls}{\passthrough{\lstinline!src/Avalonia.Themes.Fluent/Controls!}}
for structure and named parts.

\subsection{8. Working with pseudo-classes and
classes}\label{working-with-pseudo-classes-and-classes}

Use pseudo-classes to target interaction states. Example for
\passthrough{\lstinline!ToggleSwitch!}:

\begin{lstlisting}[language=XML]
<Style Selector="ToggleSwitch:checked">
  <Setter Property="ThumbBrush" Value="{DynamicResource BrandPrimaryBrush}"/>
</Style>

<Style Selector="ToggleSwitch:checked:focus">
  <Setter Property="BorderBrush" Value="{DynamicResource BrandPrimaryHoverBrush}"/>
</Style>
\end{lstlisting}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Pseudo-class
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Applies when
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!:pointerover!} & Pointer hovers over the
control \\
\passthrough{\lstinline!:pressed!} & Pointer is pressed / command
triggered \\
\passthrough{\lstinline!:checked!} & Toggleable control is on
(\passthrough{\lstinline!CheckBox!},
\passthrough{\lstinline!ToggleSwitch!},
\passthrough{\lstinline!RadioButton!}) \\
\passthrough{\lstinline!:focus!} /
\passthrough{\lstinline!:focus-within!} & Control (or a descendant) has
keyboard focus \\
\passthrough{\lstinline!:disabled!} &
\passthrough{\lstinline!IsEnabled = false!} \\
\passthrough{\lstinline!:invalid!} & A binding reports validation
errors \\
\end{longtable}

Pseudo-class documentation lives in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/docs/styles/selectors.md}{\passthrough{\lstinline!Selectors.md!}}
and runtime code under
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Styling/Selector.cs}{\passthrough{\lstinline!Selector.cs!}}.
Combine pseudo-classes with style classes (e.g.,
\passthrough{\lstinline!Button.primary:pointerover!}) to keep
state-specific visuals consistent and accessible.

\subsection{9. Accessibility and high contrast
themes}\label{accessibility-and-high-contrast-themes}

Fluent ships high contrast resources. Switch by setting
\passthrough{\lstinline!RequestedThemeVariant="HighContrast"!}.

\begin{itemize}
\tightlist
\item
  Provide alternative color dictionaries with increased contrast ratios.
\item
  Use \passthrough{\lstinline!DynamicResource!} for all brushes so high
  contrast palettes propagate automatically.
\item
  Test with screen readers and OS high contrast modes; ensure custom
  colors respect \passthrough{\lstinline!ThemeVariant.HighContrast!}.
\end{itemize}

Example dictionary addition:

\begin{lstlisting}[language=XML]
<ResourceDictionary ThemeVariant="HighContrast"
                    xmlns="https://github.com/avaloniaui">
  <SolidColorBrush x:Key="BrandPrimaryBrush" Color="#00AACC"/>
  <SolidColorBrush x:Key="BrandPrimaryHoverBrush" Color="#007C99"/>
</ResourceDictionary>
\end{lstlisting}

\passthrough{\lstinline!ThemeVariant!}-specific dictionaries override
defaults when the variant matches.

\subsection{10. Debugging styles with
DevTools}\label{debugging-styles-with-devtools}

Press \textbf{F12} to open DevTools -\textgreater{} Styles panel: -
Inspect applied styles, pseudo-classes, and resources. - Use the palette
to modify brushes live and copy the generated XAML. - Toggle the
\passthrough{\lstinline!ThemeVariant!} dropdown in DevTools (bottom) to
preview Light/Dark/HighContrast variants.

Enable style diagnostics via logging:

\begin{lstlisting}
AppBuilder.Configure<App>()
    .UsePlatformDetect()
    .LogToTrace(LogEventLevel.Debug, new[] { LogArea.Binding, LogArea.Styling })
    .StartWithClassicDesktopLifetime(args);
\end{lstlisting}

\subsection{11. Practice exercises}\label{practice-exercises-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Create a brand palette}: define primary and secondary brushes
  with theme-specific overrides (light/dark/high contrast) and apply
  them to buttons and toggles.
\item
  \textbf{Scope a sub-view}: wrap a settings pane in
  \passthrough{\lstinline!ThemeVariantScope RequestedThemeVariant="Dark"!}
  to preview dual-theme experiences.
\item
  \textbf{Control template override}: create a
  \passthrough{\lstinline!ControlTheme!} for
  \passthrough{\lstinline!Button!} that changes the visual tree (e.g.,
  adds an icon placeholder) and apply it selectively.
\item
  \textbf{Runtime theme switching}: wire a
  \passthrough{\lstinline!ToggleSwitch!} or menu command to flip between
  Light/Dark; ensure all custom brushes use
  \passthrough{\lstinline!DynamicResource!}.
\item
  \textbf{DevTools audit}: use DevTools to inspect pseudo-classes on a
  \passthrough{\lstinline!ToggleSwitch!} and verify your custom styles
  apply in \passthrough{\lstinline!:checked!} and
  \passthrough{\lstinline!:focus!} states.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-5}

\begin{itemize}
\tightlist
\item
  Theme variant scoping:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ThemeVariantScope.cs}{\passthrough{\lstinline!ThemeVariantScope.cs!}}
\item
  Control themes and styles:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/ControlTheme.cs}{\passthrough{\lstinline!ControlTheme.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/Style.cs}{\passthrough{\lstinline!Style.cs!}}
\item
  Selector engine \& pseudo-classes:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Styling/Selector.cs}{\passthrough{\lstinline!Selector.cs!}}
\item
  Fluent resources and templates:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Themes.Fluent/Controls}{\passthrough{\lstinline!src/Avalonia.Themes.Fluent/Controls!}}
\item
  Theme variant definitions:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Styling/ThemeVariant.cs}{\passthrough{\lstinline!ThemeVariant.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-5}

\begin{itemize}
\tightlist
\item
  How do \passthrough{\lstinline!ResourceInclude!} and
  \passthrough{\lstinline!StyleInclude!} differ, and what root elements
  do they expect?
\item
  When should you use \passthrough{\lstinline!ThemeVariantScope!} versus
  changing \passthrough{\lstinline!RequestedThemeVariant!} on the
  application?
\item
  What advantages does \passthrough{\lstinline!ControlTheme!} give over
  subclassing a control?
\item
  Why do you prefer \passthrough{\lstinline!DynamicResource!} for
  brushes that change with theme switches?
\item
  Where would you inspect the default template for
  \passthrough{\lstinline!ToggleSwitch!} or
  \passthrough{\lstinline!ComboBox!}?
\end{itemize}

What's next - Next: \href{Chapter08.md}{Chapter 8}

\newpage

\subsection{8. Data binding basics you'll use every
day}\label{data-binding-basics-youll-use-every-day}

Goal - Understand the binding engine (DataContext, binding paths,
inheritance) and when to use different binding modes. - Work with
binding variations (\passthrough{\lstinline!Binding!},
\passthrough{\lstinline!CompiledBinding!},
\passthrough{\lstinline!MultiBinding!},
\passthrough{\lstinline!PriorityBinding!},
\passthrough{\lstinline!ElementName!},
\passthrough{\lstinline!RelativeSource!}) and imperative helpers via
\passthrough{\lstinline!BindingOperations!}. - Connect collections to
\passthrough{\lstinline!ItemsControl!}/\passthrough{\lstinline!ListBox!}
with data templates, \passthrough{\lstinline!SelectionModel!}, and
compiled binding expressions. - Use converters, validation
(\passthrough{\lstinline!INotifyDataErrorInfo!}), asynchronous bindings,
and reactive bridges
(\passthrough{\lstinline!AvaloniaPropertyObservable!}). - Bind to
attached properties, tune performance with compiled bindings, and
diagnose issues using DevTools and
\passthrough{\lstinline!BindingDiagnostics!} logging.

Why this matters - Bindings keep UI and data in sync, reducing
boilerplate and keeping views declarative. - Picking the right binding
technique (compiled, multi-value, priority) improves performance and
readability. - Diagnostics help track down ``binding isn't working''
issues quickly.

Prerequisites - You can create a project and run it (Chapters 2-7). -
You've seen basic controls and templates (Chapters 3 \& 6).

\subsection{1. The binding engine at a
glance}\label{the-binding-engine-at-a-glance}

Avalonia's binding engine lives under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Data}{\passthrough{\lstinline!src/Avalonia.Base/Data!}}.
Key pieces: - \passthrough{\lstinline!DataContext!}: inherited down the
logical tree. Most bindings resolve relative to the current element's
DataContext. - \passthrough{\lstinline!Binding!}: describes a path,
mode, converter, fallback, etc. - \passthrough{\lstinline!BindingBase!}:
base for compiled bindings, multi bindings, priority bindings. -
\passthrough{\lstinline!BindingExpression!}: runtime evaluation created
for each binding target. - \passthrough{\lstinline!BindingOperations!}:
static helpers to install, remove, or inspect bindings imperatively. -
\passthrough{\lstinline!ExpressionObserver!}: low-level observable
pipeline underpinning async, compiled, and reactive bindings.

Bindings resolve in this order: 1. Find the source (DataContext, element
name, relative source, etc.). 2. Evaluate the path (e.g.,
\passthrough{\lstinline!Customer.Name!}). 3. Apply converters or string
formatting. 4. Update the target property according to the binding mode.

\passthrough{\lstinline!BindingOperations.SetBinding!} mirrors WPF/WinUI
and is useful when you need to create bindings from code (for dynamic
property names or custom controls).
\passthrough{\lstinline!BindingOperations.ClearBinding!} removes them
safely, keeping reference tracking intact.

\subsection{2. Binding scopes and source
selection}\label{binding-scopes-and-source-selection}

Binding sources are resolved differently depending on the binding type:

\begin{itemize}
\tightlist
\item
  \textbf{\passthrough{\lstinline!DataContext!} inheritance} --
  \passthrough{\lstinline!StyledElement.DataContext!} flows through the
  logical tree. Setting \passthrough{\lstinline!DataContext!} on a
  container automatically scopes child bindings.
\item
  \textbf{Element name} --
  \passthrough{\lstinline!\{Binding ElementName=Root, Path=Value\}!}
  uses \passthrough{\lstinline!NameScope!} lookup to find another
  control.
\item
  \textbf{Relative source} --
  \passthrough{\lstinline!\{Binding RelativeSource=\{RelativeSource AncestorType=ListBox\}\}!}
  walks the logical tree to find an ancestor of the specified type.
\item
  \textbf{Self bindings} --
  \passthrough{\lstinline!\{Binding Path=Bounds, RelativeSource=\{RelativeSource Self\}\}!}
  is handy when exposing properties of the control itself.
\item
  \textbf{Static/CLR properties} --
  \passthrough{\lstinline!\{Binding Path=(local:ThemeOptions.AccentBrush)\}!}
  reads attached or static properties registered as Avalonia properties.
\end{itemize}

Avalonia also supports multi-level ancestor search and templated parent
references:

\begin{lstlisting}[language=XML]
<TextBlock Text="{Binding DataContext.Title, RelativeSource={RelativeSource AncestorType=Window}}"/>

<ContentControl ContentTemplate="{StaticResource CardTemplate}" />

<DataTemplate x:Key="CardTemplate" x:DataType="vm:Card">
  <Border Background="{Binding Source={RelativeSource TemplatedParent}, Path=Background}"/>
</DataTemplate>
\end{lstlisting}

When creating controls dynamically, use
\passthrough{\lstinline!BindingOperations.SetBinding!} so the engine
tracks lifetimes and updates \passthrough{\lstinline!DataContext!}
inheritance correctly:

\begin{lstlisting}
var binding = new Binding
{
    Path = "Person.FullName",
    Mode = BindingMode.OneWay
};

BindingOperations.SetBinding(nameTextBlock, TextBlock.TextProperty, binding);
\end{lstlisting}

\passthrough{\lstinline!BindingOperations.ClearBinding(nameTextBlock, TextBlock.TextProperty)!}
detaches it. To observe \passthrough{\lstinline!AvaloniaProperty!}
values reactively, wrap them with
\passthrough{\lstinline!AvaloniaPropertyObservable.Observe!}:

\begin{lstlisting}
using System;
using System.Reactive.Linq;
using Avalonia.Reactive;

var textStream = AvaloniaPropertyObservable.Observe(this, TextBox.TextProperty)
    .Select(value => value as string ?? string.Empty);

var subscription = textStream.Subscribe(text => ViewModel.TextLength = text.Length);
\end{lstlisting}

\passthrough{\lstinline!AvaloniaPropertyObservable!} lives in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Reactive/AvaloniaPropertyObservable.cs}{\passthrough{\lstinline!AvaloniaPropertyObservable.cs!}}
and bridges the binding system with
\passthrough{\lstinline!IObservable<T>!} pipelines. Dispose the
subscription in \passthrough{\lstinline!OnDetachedFromVisualTree!} (or
your view's \passthrough{\lstinline!Dispose!} pattern) to avoid leaks.

\subsection{3. Set up the sample
project}\label{set-up-the-sample-project}

\begin{lstlisting}[language=bash]
dotnet new avalonia.mvvm -o BindingPlayground
cd BindingPlayground
\end{lstlisting}

We'll expand \passthrough{\lstinline!MainWindow.axaml!} and
\passthrough{\lstinline!MainWindowViewModel.cs!}.

\subsection{4. Core bindings (OneWay, TwoWay,
OneTime)}\label{core-bindings-oneway-twoway-onetime}

View model implementing
\passthrough{\lstinline!INotifyPropertyChanged!}:

\begin{lstlisting}
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace BindingPlayground.ViewModels;

public class PersonViewModel : INotifyPropertyChanged
{
    private string _firstName = "Ada";
    private string _lastName = "Lovelace";
    private int _age = 36;

    public string FirstName
    {
        get => _firstName;
        set { if (_firstName != value) { _firstName = value; OnPropertyChanged(); OnPropertyChanged(nameof(FullName)); } }
    }

    public string LastName
    {
        get => _lastName;
        set { if (_lastName != value) { _lastName = value; OnPropertyChanged(); OnPropertyChanged(nameof(FullName)); } }
    }

    public int Age
    {
        get => _age;
        set { if (_age != value) { _age = value; OnPropertyChanged(); } }
    }

    public string FullName => ($"{FirstName} {LastName}").Trim();

    public event PropertyChangedEventHandler? PropertyChanged;
    protected void OnPropertyChanged([CallerMemberName] string? name = null)
        => PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
}
\end{lstlisting}

In \passthrough{\lstinline!MainWindow.axaml!} set the DataContext:

\begin{lstlisting}[language=XML]
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:vm="clr-namespace:BindingPlayground.ViewModels"
        x:Class="BindingPlayground.Views.MainWindow">
  <Window.DataContext>
    <vm:MainWindowViewModel />
  </Window.DataContext>

  <Design.DataContext>
    <vm:MainWindowViewModel />
  </Design.DataContext>


</Window>
\end{lstlisting}

\passthrough{\lstinline!Design.DataContext!} provides design-time data
in the previewer.

\subsection{5. Binding modes in action}\label{binding-modes-in-action}

\begin{lstlisting}[language=XML]
<Grid ColumnDefinitions="*,*" RowDefinitions="Auto,*" Padding="16" RowSpacing="16" ColumnSpacing="24">
  <TextBlock Grid.ColumnSpan="2" Classes="h1" Text="Binding basics"/>

  <StackPanel Grid.Row="1" Spacing="8">
    <TextBox Watermark="First name" Text="{Binding Person.FirstName, Mode=TwoWay}"/>
    <TextBox Watermark="Last name"  Text="{Binding Person.LastName, Mode=TwoWay}"/>
    <NumericUpDown Minimum="0" Maximum="120" Value="{Binding Person.Age, Mode=TwoWay}"/>
  </StackPanel>

  <StackPanel Grid.Column="1" Grid.Row="1" Spacing="8">
    <TextBlock Text="Live view" FontWeight="SemiBold"/>
    <TextBlock Text="{Binding Person.FullName, Mode=OneWay}" FontSize="20"/>
    <TextBlock Text="{Binding Person.Age, Mode=OneWay}"/>
    <TextBlock Text="{Binding CreatedAt, Mode=OneTime, StringFormat='Created on {0:d}'}"/>
  </StackPanel>
</Grid>
\end{lstlisting}

\passthrough{\lstinline!MainWindowViewModel!} holds
\passthrough{\lstinline!Person!} and other state:

\begin{lstlisting}
using System;
using System.Collections.ObjectModel;

namespace BindingPlayground.ViewModels;

public class MainWindowViewModel : INotifyPropertyChanged
{
    public PersonViewModel Person { get; } = new();
    public DateTime CreatedAt { get; } = DateTime.Now;

    // Additional samples below
}
\end{lstlisting}

\subsection{6. ElementName and
RelativeSource}\label{elementname-and-relativesource}

\subsubsection{ElementName binding}\label{elementname-binding}

\begin{lstlisting}[language=XML]
<StackPanel Margin="0,24,0,0" Spacing="6">
  <Slider x:Name="VolumeSlider" Minimum="0" Maximum="100" Value="50"/>
  <ProgressBar Minimum="0" Maximum="100" Value="{Binding #VolumeSlider.Value}"/>
</StackPanel>
\end{lstlisting}

\passthrough{\lstinline!\#VolumeSlider!} targets the element with
\passthrough{\lstinline!x:Name="VolumeSlider"!}.

\subsubsection{RelativeSource binding}\label{relativesource-binding}

Use \passthrough{\lstinline!RelativeSource!} to bind to ancestors:

\begin{lstlisting}[language=XML]
<TextBlock Text="{Binding DataContext.Person.FullName, RelativeSource={RelativeSource AncestorType=Window}}"/>
\end{lstlisting}

This binds to the window's DataContext even if the local control has its
own DataContext.

Relative source syntax also supports \passthrough{\lstinline!Self!}
(\passthrough{\lstinline!RelativeSource=\{RelativeSource Self\}!}) and
\passthrough{\lstinline!TemplatedParent!} for control templates.

\subsubsection{Binding to attached
properties}\label{binding-to-attached-properties}

Avalonia registers attached properties (e.g.,
\passthrough{\lstinline!ScrollViewer.HorizontalScrollBarVisibilityProperty!})
as \passthrough{\lstinline!AvaloniaProperty!}. Bind to them by wrapping
the property name in parentheses:

\begin{lstlisting}[language=XML]
<ListBox ItemsSource="{Binding Items}">
  <ListBox.Styles>
    <Style Selector="ListBox">
      <Setter Property="(ScrollViewer.HorizontalScrollBarVisibility)" Value="Disabled"/>
      <Setter Property="(ScrollViewer.VerticalScrollBarVisibility)" Value="Auto"/>
    </Style>
  </ListBox.Styles>
</ListBox>

<Border Background="{Binding (local:ThemeOptions.AccentBrush)}"/>
\end{lstlisting}

Attached property syntax also works inside
\passthrough{\lstinline!Binding!} or
\passthrough{\lstinline!MultiBinding!}. When setting them from code, use
the generated static accessor (e.g.,
\passthrough{\lstinline!ScrollViewer.SetHorizontalScrollBarVisibility(listBox, ScrollBarVisibility.Disabled);!}).

\subsection{7. Compiled bindings}\label{compiled-bindings}

Compiled bindings (\passthrough{\lstinline!CompiledBinding!}) produce
strongly-typed accessors with better performance. Require
\passthrough{\lstinline!x:DataType!} or
\passthrough{\lstinline!CompiledBindings!} namespace:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add namespace to the root element:
\end{enumerate}

\begin{lstlisting}[language=XML]
xmlns:vm="clr-namespace:BindingPlayground.ViewModels"
\end{lstlisting}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Set \passthrough{\lstinline!x:DataType!} on a scope:
\end{enumerate}

\begin{lstlisting}[language=XML]
<StackPanel DataContext="{Binding Person}" x:DataType="vm:PersonViewModel">
  <TextBlock Text="{CompiledBinding FullName}"/>
  <TextBox Text="{CompiledBinding FirstName}"/>
</StackPanel>
\end{lstlisting}

If \passthrough{\lstinline!x:DataType!} is set,
\passthrough{\lstinline!CompiledBinding!} uses compile-time checking and
generates binding code. Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/MarkupExtensions/CompiledBindingExtension.cs}{\passthrough{\lstinline!CompiledBindingExtension.cs!}}.

\subsection{8. MultiBinding and
PriorityBinding}\label{multibinding-and-prioritybinding}

\subsubsection{MultiBinding}\label{multibinding}

Combine multiple values into one target:

\begin{lstlisting}
public sealed class NameAgeFormatter : IMultiValueConverter
{
    public object? Convert(IList<object?> values, Type targetType, object? parameter, CultureInfo culture)
    {
        var name = values[0] as string ?? "";
        var age = values[1] as int? ?? 0;
        return $"{name} ({age})";
    }

    public object? ConvertBack(IList<object?> values, Type targetType, object? parameter, CultureInfo culture) => throw new NotSupportedException();
}
\end{lstlisting}

Register in resources:

\begin{lstlisting}[language=XML]
<Window.Resources>
  <conv:NameAgeFormatter x:Key="NameAgeFormatter"/>
</Window.Resources>
\end{lstlisting}

Use it:

\begin{lstlisting}[language=XML]
<TextBlock>
  <TextBlock.Text>
    <MultiBinding Converter="{StaticResource NameAgeFormatter}">
      <Binding Path="Person.FullName"/>
      <Binding Path="Person.Age"/>
    </MultiBinding>
  </TextBlock.Text>
</TextBlock>
\end{lstlisting}

\subsubsection{PriorityBinding}\label{prioritybinding}

Priority bindings try sources in order and use the first that yields a
value:

\begin{lstlisting}[language=XML]
<TextBlock>
  <TextBlock.Text>
    <PriorityBinding>
      <Binding Path="OverrideTitle"/>
      <Binding Path="Person.FullName"/>
      <Binding Path="Person.FirstName"/>
      <Binding Path="'Unknown user'"/>
    </PriorityBinding>
  </TextBlock.Text>
</TextBlock>
\end{lstlisting}

Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup/Data/PriorityBinding.cs}{\passthrough{\lstinline!PriorityBinding.cs!}}.

\subsection{9. Lists, selection, and
templates}\label{lists-selection-and-templates}

\passthrough{\lstinline!MainWindowViewModel!} exposes collections:

\begin{lstlisting}
public ObservableCollection<PersonViewModel> People { get; } = new()
{
    new PersonViewModel { FirstName = "Ada", LastName = "Lovelace", Age = 36 },
    new PersonViewModel { FirstName = "Grace", LastName = "Hopper", Age = 45 },
    new PersonViewModel { FirstName = "Linus", LastName = "Torvalds", Age = 32 }
};

private PersonViewModel? _selectedPerson;
public PersonViewModel? SelectedPerson
{
    get => _selectedPerson;
    set { if (_selectedPerson != value) { _selectedPerson = value; OnPropertyChanged(); } }
}
\end{lstlisting}

Template the list:

\begin{lstlisting}[language=XML]
<ListBox Items="{Binding People}"
         SelectedItem="{Binding SelectedPerson, Mode=TwoWay}"
         Height="180">
  <ListBox.ItemTemplate>
    <DataTemplate x:DataType="vm:PersonViewModel">
      <StackPanel Orientation="Horizontal" Spacing="12">
        <TextBlock Text="{CompiledBinding FullName}" FontWeight="SemiBold"/>
        <TextBlock Text="{CompiledBinding Age}"/>
      </StackPanel>
    </DataTemplate>
  </ListBox.ItemTemplate>
</ListBox>
\end{lstlisting}

Inside the details pane, bind to
\passthrough{\lstinline!SelectedPerson!} safely using null-conditional
binding (C\#) or triggers. XAML automatically handles null (shows
blank). Use \passthrough{\lstinline!x:DataType!} for compile-time
checks.

\subsubsection{\texorpdfstring{\texttt{SelectionModel}}{SelectionModel}}\label{selectionmodel}

For advanced selection (multi-select, range), use
\passthrough{\lstinline!SelectionModel<T>!} from
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Selection/SelectionModel.cs}{\passthrough{\lstinline!SelectionModel.cs!}}.
Example:

\begin{lstlisting}
public SelectionModel<PersonViewModel> PeopleSelection { get; } = new() { SelectionMode = SelectionMode.Multiple };
\end{lstlisting}

Bind it:

\begin{lstlisting}[language=XML]
<ListBox Items="{Binding People}" Selection="{Binding PeopleSelection}"/>
\end{lstlisting}

\subsection{\texorpdfstring{10. Validation with
\texttt{INotifyDataErrorInfo}}{10. Validation with INotifyDataErrorInfo}}\label{validation-with-inotifydataerrorinfo}

Implement \passthrough{\lstinline!INotifyDataErrorInfo!} for
asynchronous validation.

\begin{lstlisting}
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;

public class ValidatingPersonViewModel : PersonViewModel, INotifyDataErrorInfo
{
    private readonly Dictionary<string, List<string>> _errors = new();

    public bool HasErrors => _errors.Count > 0;

    public event EventHandler<DataErrorsChangedEventArgs>? ErrorsChanged;

    public IEnumerable GetErrors(string? propertyName)
        => propertyName is not null && _errors.TryGetValue(propertyName, out var errors) ? errors : Array.Empty<string>();

    protected override void OnPropertyChanged(string? propertyName)
    {
        base.OnPropertyChanged(propertyName);
        Validate(propertyName);
    }

    private void Validate(string? propertyName)
    {
        if (propertyName is nameof(Age))
        {
            if (Age < 0 || Age > 120)
                AddError(propertyName, "Age must be between 0 and 120");
            else
                ClearErrors(propertyName);
        }
    }

    private void AddError(string propertyName, string error)
    {
        if (!_errors.TryGetValue(propertyName, out var list))
            _errors[propertyName] = list = new List<string>();

        if (!list.Contains(error))
        {
            list.Add(error);
            ErrorsChanged?.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
        }
    }

    private void ClearErrors(string propertyName)
    {
        if (_errors.Remove(propertyName))
            ErrorsChanged?.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
    }
}
\end{lstlisting}

Bind the validation feedback automatically:

\begin{lstlisting}[language=XML]
<TextBox Text="{Binding ValidatingPerson.FirstName, Mode=TwoWay}"/>
<TextBox Text="{Binding ValidatingPerson.Age, Mode=TwoWay}"/>
<TextBlock Foreground="#B91C1C" Text="{Binding (Validation.Errors)[0].ErrorContent, RelativeSource={RelativeSource Self}}"/>
\end{lstlisting}

Avalonia surfaces validation errors via attached properties. For a full
pattern see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Validation}{\passthrough{\lstinline!Validation!}}.

\subsection{11. Asynchronous bindings}\label{asynchronous-bindings}

Use \passthrough{\lstinline!Task!}-returning properties with
\passthrough{\lstinline!Binding!} and
\passthrough{\lstinline!BindingPriority.AsyncLocalValue!}. Example view
model property:

\begin{lstlisting}
private string? _weather;
public string? Weather
{
    get => _weather;
    private set { if (_weather != value) { _weather = value; OnPropertyChanged(); } }
}

public async Task LoadWeatherAsync()
{
    Weather = "Loading...";
    var result = await _weatherService.GetForecastAsync();
    Weather = result;
}
\end{lstlisting}

Bind with fallback until the value arrives:

\begin{lstlisting}[language=XML]
<TextBlock Text="{Binding Weather, FallbackValue='Fetching forecast...'}"/>
\end{lstlisting}

You can also bind directly to \passthrough{\lstinline!Task!} results
using \passthrough{\lstinline!TaskObservableCollection!} or reactive
extensions (Chapter 17 covers background work).

\subsection{12. Binding diagnostics}\label{binding-diagnostics}

\begin{itemize}
\tightlist
\item
  \textbf{DevTools}: press F12 -\textgreater{} Diagnostics
  -\textgreater{} Binding Errors tab. Inspect live errors (missing
  properties, converters failing).
\item
  \textbf{Binding logging}: enable via
  \passthrough{\lstinline!BindingDiagnostics!}.
\end{itemize}

\begin{lstlisting}
using Avalonia.Diagnostics;

public override void OnFrameworkInitializationCompleted()
{
    BindingDiagnostics.Enable(
        log => Console.WriteLine(log.Message),
        new BindingDiagnosticOptions
        {
            Level = BindingDiagnosticLogLevel.Warning
        });

    base.OnFrameworkInitializationCompleted();
}
\end{lstlisting}

Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Diagnostics/Diagnostics/BindingDiagnostics.cs}{\passthrough{\lstinline!BindingDiagnostics.cs!}}.

Use \passthrough{\lstinline!TraceBindingFailures!} extension to log
failures for specific bindings.

\subsection{13. Practice exercises}\label{practice-exercises-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Compiled binding sweep}: add
  \passthrough{\lstinline!x:DataType!} to each data template and replace
  \passthrough{\lstinline!Binding!} with
  \passthrough{\lstinline!CompiledBinding!} where possible. Observe
  compile-time errors when property names are mistyped.
\item
  \textbf{MultiBinding formatting}: create a multi binding that formats
  \passthrough{\lstinline!FirstName!},
  \passthrough{\lstinline!LastName!}, and \passthrough{\lstinline!Age!}
  into a sentence like ``Ada Lovelace is 36 years old.'' Add a converter
  parameter for custom formats.
\item
  \textbf{Priority fallback}: allow a user-provided display name to
  override \passthrough{\lstinline!FullName!}, falling back to initials
  if names are empty.
\item
  \textbf{Validation UX}: display validation errors inline using
  \passthrough{\lstinline!INotifyDataErrorInfo!} and highlight inputs
  (\passthrough{\lstinline!Style Selector="TextBox:invalid"!}).
\item
  \textbf{Runtime binding helpers}: dynamically add a
  \passthrough{\lstinline!TextBlock!} for each person in a collection,
  use \passthrough{\lstinline!BindingOperations.SetBinding!} to wire
  \passthrough{\lstinline!TextBlock.Text!}, then
  \passthrough{\lstinline!ClearBinding!} when removing the item.
\item
  \textbf{Observable probes}: pipe
  \passthrough{\lstinline!TextBox.TextProperty!} through
  \passthrough{\lstinline!AvaloniaPropertyObservable.Observe!} and
  surface the text length in the UI.
\item
  \textbf{Diagnostics drill}: intentionally break a binding (typo) and
  use DevTools and \passthrough{\lstinline!BindingDiagnostics!} to find
  it. Fix the binding and confirm logs clear.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-6}

\begin{itemize}
\tightlist
\item
  Binding implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/Binding.cs}{\passthrough{\lstinline!Binding.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/BindingExpression.cs}{\passthrough{\lstinline!BindingExpression.cs!}}
\item
  Binding helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/BindingOperations.cs}{\passthrough{\lstinline!BindingOperations.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/ExpressionObserver.cs}{\passthrough{\lstinline!ExpressionObserver.cs!}}
\item
  Compiled bindings:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/MarkupExtensions/CompiledBindingExtension.cs}{\passthrough{\lstinline!CompiledBindingExtension.cs!}}
\item
  Multi/Priority binding:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup/Data/MultiBinding.cs}{\passthrough{\lstinline!MultiBinding.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup/Data/PriorityBinding.cs}{\passthrough{\lstinline!PriorityBinding.cs!}}
\item
  Reactive bridge:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Reactive/AvaloniaPropertyObservable.cs}{\passthrough{\lstinline!AvaloniaPropertyObservable.cs!}}
\item
  Selection model:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Selection/SelectionModel.cs}{\passthrough{\lstinline!SelectionModel.cs!}}
\item
  Validation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Validation/Validation.cs}{\passthrough{\lstinline!Validation.cs!}}
\item
  Diagnostics:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Diagnostics/Diagnostics/BindingDiagnostics.cs}{\passthrough{\lstinline!BindingDiagnostics.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-6}

\begin{itemize}
\tightlist
\item
  When would you choose \passthrough{\lstinline!CompiledBinding!} over
  \passthrough{\lstinline!Binding!}, and what prerequisites does it
  have?
\item
  How do \passthrough{\lstinline!ElementName!},
  \passthrough{\lstinline!RelativeSource!}, and attached property syntax
  change the binding source?
\item
  Which scenarios call for \passthrough{\lstinline!MultiBinding!},
  \passthrough{\lstinline!PriorityBinding!}, or programmatic calls to
  \passthrough{\lstinline!BindingOperations.SetBinding!}?
\item
  How does \passthrough{\lstinline!AvaloniaPropertyObservable.Observe!}
  integrate with the binding engine, and when would you prefer it over
  classic bindings?
\item
  Which tooling surfaces validation and binding errors during
  development, and how would you enable the relevant diagnostics?
\end{itemize}

What's next - Next: \href{Chapter09.md}{Chapter 9}

\newpage

\subsection{9. Commands, events, and user
input}\label{commands-events-and-user-input}

Goal - Understand how routed events flow through
\passthrough{\lstinline!InputElement!} and how gesture recognizers,
commands, and keyboard navigation fit together. - Choose between
MVVM-friendly commands and low-level events effectively (and bridge them
with hotkeys and toolkits). - Wire keyboard shortcuts, pointer gestures,
and access keys; capture pointer input for drag scenarios with
\passthrough{\lstinline!HotKeyManager!} and pointer capture APIs. -
Implement asynchronous commands and recycle CanExecute logic with
reactive or toolkit helpers. - Diagnose input issues with DevTools
(Events view), logging, and custom event tracing.

Why this matters - Robust input handling keeps UI responsive and
testable. - Commands keep business logic in view models; events cover
fine-grained gestures. - Knowing the pipeline (routed events
-\textgreater{} gesture recognizers -\textgreater{} commands) helps
debug ``nothing happened'' scenarios.

Prerequisites - Chapters 3-8 (layouts, controls, binding, theming). -
Basic MVVM knowledge and an
\passthrough{\lstinline!INotifyPropertyChanged!} view model.

\subsection{1. Input building blocks}\label{input-building-blocks}

Avalonia input pieces live under: - Routed events:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Interactivity}{\passthrough{\lstinline!Avalonia.Interactivity!}}
defines \passthrough{\lstinline!RoutedEvent!}, event descriptors, and
routing strategies. - Core element hierarchy:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/InputElement.cs}{\passthrough{\lstinline!InputElement!}}
(inherits \passthrough{\lstinline!Interactive!} →
\passthrough{\lstinline!Visual!} → \passthrough{\lstinline!Animatable!})
exposes focus, input, and command helpers that every control inherits. -
Devices \& state:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Input}{\passthrough{\lstinline!Avalonia.Base/Input!}}
provides \passthrough{\lstinline!Pointer!},
\passthrough{\lstinline!KeyboardDevice!},
\passthrough{\lstinline!KeyGesture!},
\passthrough{\lstinline!PointerPoint!}. - Gesture recognizers:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Input/GestureRecognizers}{\passthrough{\lstinline!GestureRecognizers!}}
translate raw pointer data into tap, scroll, drag behaviors. - Hotkeys
\& command sources:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/HotkeyManager.cs}{\passthrough{\lstinline!HotkeyManager!}}
walks the visual tree to resolve \passthrough{\lstinline!KeyGesture!}s
against \passthrough{\lstinline!ICommand!} targets.

Event flow: 1. Devices raise raw events
(\passthrough{\lstinline!PointerPressed!},
\passthrough{\lstinline!KeyDown!}). Each is registered as a
\passthrough{\lstinline!RoutedEvent!} with a routing strategy (tunnel,
bubble, direct). 2. \passthrough{\lstinline!InputElement!} hosts the
event metadata, raising class handlers and instance handlers. 3. Gesture
recognizers subscribe to pointer streams and emit semantic events
(\passthrough{\lstinline!Tapped!},
\passthrough{\lstinline!DoubleTapped!},
\passthrough{\lstinline!PointerPressedEventArgs!}). 4. Command sources
(\passthrough{\lstinline!Button.Command!},
\passthrough{\lstinline!KeyBinding!},
\passthrough{\lstinline!InputGesture!}) execute
\passthrough{\lstinline!ICommand!} implementations and update
\passthrough{\lstinline!CanExecute!}.

Creating custom events uses the static registration helpers:

\begin{lstlisting}
public static readonly RoutedEvent<RoutedEventArgs> DragStartedEvent =
    RoutedEvent.Register<Control, RoutedEventArgs>(
        nameof(DragStarted),
        RoutingStrategies.Bubble);

public event EventHandler<RoutedEventArgs> DragStarted
{
    add => AddHandler(DragStartedEvent, value);
    remove => RemoveHandler(DragStartedEvent, value);
}
\end{lstlisting}

\passthrough{\lstinline!RoutingStrategies!} live in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Interactivity/RoutedEvent.cs}{\passthrough{\lstinline!RoutedEvent.cs!}};
each handler chooses whether the event should travel from root to leaf
(tunnel) or leaf to root (bubble).

\subsection{2. Input playground setup}\label{input-playground-setup}

\begin{lstlisting}[language=bash]
dotnet new avalonia.mvvm -o InputPlayground
cd InputPlayground
\end{lstlisting}

\passthrough{\lstinline!MainWindowViewModel!} exposes commands and
state. Add \passthrough{\lstinline!CommunityToolkit.Mvvm!} or implement
your own \passthrough{\lstinline!AsyncRelayCommand!} to simplify
asynchronous logic. Hotkeys are attached in XAML using
\passthrough{\lstinline!HotKeyManager.HotKey!}, keeping the view model
free of UI dependencies.

\begin{lstlisting}
using System;
using System.Threading.Tasks;
using System.Windows.Input;

namespace InputPlayground.ViewModels;

public sealed class MainWindowViewModel : ViewModelBase
{
    private string _status = "Ready";
    public string Status
    {
        get => _status;
        private set => SetProperty(ref _status, value);
    }

    private bool _hasChanges;
    public bool HasChanges
    {
        get => _hasChanges;
        set
        {
            if (SetProperty(ref _hasChanges, value))
            {
                SaveCommand.RaiseCanExecuteChanged();
            }
        }
    }

    public RelayCommand SaveCommand { get; }
    public RelayCommand DeleteCommand { get; }
    public AsyncRelayCommand RefreshCommand { get; }

    public MainWindowViewModel()
    {
        SaveCommand = new RelayCommand(_ => Save(), _ => HasChanges);
        DeleteCommand = new RelayCommand(item => Delete(item));
        RefreshCommand = new AsyncRelayCommand(RefreshAsync, () => !IsBusy);
    }

    private bool _isBusy;
    public bool IsBusy
    {
        get => _isBusy;
        private set
        {
            if (SetProperty(ref _isBusy, value))
            {
                RefreshCommand.RaiseCanExecuteChanged();
            }
        }
    }

    private void Save()
    {
        Status = "Saved";
        HasChanges = false;
    }

    private void Delete(object? parameter)
    {
        Status = parameter is string name ? $"Deleted {name}" : "Deleted item";
        HasChanges = true;
    }

    private async Task RefreshAsync()
    {
        try
        {
            IsBusy = true;
            Status = "Refreshing...";
            await Task.Delay(1500);
            Status = "Data refreshed";
        }
        finally
        {
            IsBusy = false;
        }
    }
}
\end{lstlisting}

Supporting command classes (\passthrough{\lstinline!RelayCommand!},
\passthrough{\lstinline!AsyncRelayCommand!}) go in
\passthrough{\lstinline!Commands!} folder. You may reuse the ones from
CommunityToolkit.Mvvm or ReactiveUI.

\subsection{3. Commands vs events cheat
sheet}\label{commands-vs-events-cheat-sheet}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Use command when\ldots{}
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Use event when\ldots{}
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
You expose an action (Save/Delete) from view model & You need pointer
coordinates, delta, or low-level control \\
You want CanExecute/disable logic & You're implementing custom
gestures/drag interactions \\
The action runs from buttons, menus, shortcuts & Work is purely visual
or specific to a view \\
You plan to unit test the action & Data is transient or you need
immediate UI feedback \\
\end{longtable}

Most real views mix both: commands for operations, events for gestures.

\subsection{4. Binding commands in XAML}\label{binding-commands-in-xaml}

\begin{lstlisting}[language=XML]
<StackPanel Spacing="12">
  <TextBox Watermark="Name" Text="{Binding SelectedName, Mode=TwoWay}"/>

  <StackPanel Orientation="Horizontal" Spacing="12">
    <Button Content="Save" Command="{Binding SaveCommand}"/>
    <Button Content="Refresh" Command="{Binding RefreshCommand}" IsEnabled="{Binding !IsBusy}"/>
    <Button Content="Delete" Command="{Binding DeleteCommand}"
            CommandParameter="{Binding SelectedName}"/>
  </StackPanel>

  <TextBlock Text="{Binding Status}"/>
</StackPanel>
\end{lstlisting}

Buttons disable automatically when
\passthrough{\lstinline!SaveCommand.CanExecute!} returns false.

\subsection{5. Keyboard shortcuts, KeyGesture, and
HotKeyManager}\label{keyboard-shortcuts-keygesture-and-hotkeymanager}

\subsubsection{KeyBinding / KeyGesture}\label{keybinding-keygesture}

\begin{lstlisting}[language=XML]
<Window ...>
  <Window.InputBindings>
    <KeyBinding Gesture="Ctrl+S" Command="{Binding SaveCommand}"/>
    <KeyBinding Gesture="Ctrl+R" Command="{Binding RefreshCommand}"/>
    <KeyBinding Gesture="Ctrl+Delete" Command="{Binding DeleteCommand}" CommandParameter="{Binding SelectedName}"/>
  </Window.InputBindings>


</Window>
\end{lstlisting}

\passthrough{\lstinline!KeyGesture!} parsing is handled by
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyGesture.cs}{\passthrough{\lstinline!KeyGesture!}}
and
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyGestureConverter.cs}{\passthrough{\lstinline!KeyGestureConverter!}}.
For multiple gestures, add more \passthrough{\lstinline!KeyBinding!}
entries on the relevant \passthrough{\lstinline!InputElement!}.

\subsubsection{\texorpdfstring{\texttt{HotKeyManager} attached
property}{HotKeyManager attached property}}\label{hotkeymanager-attached-property}

\passthrough{\lstinline!KeyBinding!} only fires while the owning control
is focused. To register process-wide hotkeys that stay active as long as
a control is in the visual tree, attach a
\passthrough{\lstinline!KeyGesture!} via
\passthrough{\lstinline!HotKeyManager.HotKey!}:

\begin{lstlisting}[language=XML]
<Window xmlns:controls="clr-namespace:Avalonia.Controls;assembly=Avalonia.Controls">
  <Button Content="Save"
          Command="{Binding SaveCommand}"
          controls:HotKeyManager.HotKey="Ctrl+Shift+S"/>
</Window>
\end{lstlisting}

\passthrough{\lstinline!HotKeyManager!} walks up to the owning
\passthrough{\lstinline!TopLevel!} and injects a
\passthrough{\lstinline!KeyBinding!} for you, even when the button is
not focused. In code you can call
\passthrough{\lstinline!HotKeyManager.SetHotKey(button, new KeyGesture(Key.S, KeyModifiers.Control | KeyModifiers.Shift));!}.
Implementation lives in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/HotkeyManager.cs}{\passthrough{\lstinline!HotkeyManager.cs!}}.

Bring \passthrough{\lstinline!Avalonia.Input!} into scope when assigning
gestures programmatically so \passthrough{\lstinline!KeyGesture!} and
\passthrough{\lstinline!KeyModifiers!} resolve.

\subsubsection{Access keys (mnemonics)}\label{access-keys-mnemonics}

Use \passthrough{\lstinline!\_!} to define an access key in headers
(e.g., \passthrough{\lstinline!\_Save!}). Access keys work when Alt is
pressed.

\begin{lstlisting}[language=XML]
<Menu>
  <MenuItem Header="_File">
    <MenuItem Header="_Save" Command="{Binding SaveCommand}" InputGesture="Ctrl+S"/>
  </MenuItem>
</Menu>
\end{lstlisting}

Access keys are processed via \passthrough{\lstinline!AccessKeyHandler!}
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/AccessKeyHandler.cs}{\passthrough{\lstinline!AccessKeyHandler.cs!}}).
Combine them with \passthrough{\lstinline!HotKeyManager!} to offer both
menu accelerators and global commands.

\subsection{6. Pointer gestures, capture, and drag
initiation}\label{pointer-gestures-capture-and-drag-initiation}

Avalonia ships gesture recognizers derived from
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/GestureRecognizer.cs}{\passthrough{\lstinline!GestureRecognizer!}}.
Attach them via \passthrough{\lstinline!GestureRecognizers!} to
translate raw pointer data into commands:

\begin{lstlisting}[language=XML]
<Border Background="#1e293b" Padding="16">
  <Border.GestureRecognizers>
    <TapGestureRecognizer NumberOfTapsRequired="2" Command="{Binding DoubleTapCommand}" CommandParameter="Canvas"/>
    <ScrollGestureRecognizer CanHorizontallyScroll="True" CanVerticallyScroll="True"/>
  </Border.GestureRecognizers>

  <TextBlock Foreground="White" Text="Double-tap or scroll"/>
</Border>
\end{lstlisting}

Implementation:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/TapGestureRecognizer.cs}{\passthrough{\lstinline!TapGestureRecognizer.cs!}}.

For custom gestures (e.g., drag-to-reorder), handle
\passthrough{\lstinline!PointerPressed!}, call
\passthrough{\lstinline!e.Pointer.Capture(control)!} to capture input,
and release on \passthrough{\lstinline!PointerReleased!}. Pointer
capture ensures subsequent move/press events go to the capture target
even if the pointer leaves its bounds. Use
\passthrough{\lstinline!PointerEventArgs.GetCurrentPoint!} to inspect
buttons, pressure, tilt, or contact rectangles for richer interactions.

\begin{lstlisting}
private bool _isDragging;
private Point _dragStart;

private void Card_PointerPressed(object? sender, PointerPressedEventArgs e)
{
    _isDragging = true;
    _dragStart = e.GetPosition((Control)sender!);
    e.Pointer.Capture((IInputElement)sender!);
}

private void Card_PointerMoved(object? sender, PointerEventArgs e)
{
    if (_isDragging && sender is Control control)
    {
        var offset = e.GetPosition(control) - _dragStart;
        Canvas.SetLeft(control, offset.X);
        Canvas.SetTop(control, offset.Y);
    }
}

private void Card_PointerReleased(object? sender, PointerReleasedEventArgs e)
{
    _isDragging = false;
    e.Pointer.Capture(null);
}
\end{lstlisting}

To cancel capture, call
\passthrough{\lstinline!e.Pointer.Capture(null)!} or use
\passthrough{\lstinline!Pointer.Captured!}. See
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/Pointer/PointerDevice.cs}{\passthrough{\lstinline!PointerDevice.cs!}}
and
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/PointerEventArgs.cs}{\passthrough{\lstinline!PointerEventArgs.cs!}}
for details.

\subsection{7. Text input pipeline (IME \&
composition)}\label{text-input-pipeline-ime-composition}

Text entry flows through \passthrough{\lstinline!TextInput!} events. For
IME (Asian languages), Avalonia raises
\passthrough{\lstinline!TextInput!} with composition events. To hook
into the pipeline, subscribe to \passthrough{\lstinline!TextInput!} or
implement \passthrough{\lstinline!ITextInputMethodClient!} in custom
controls. Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputMethodClient.cs}{\passthrough{\lstinline!TextInputMethodClient.cs!}}.

\begin{lstlisting}[language=XML]
<TextBox TextInput="TextBox_TextInput"/>
\end{lstlisting}

\begin{lstlisting}
private void TextBox_TextInput(object? sender, TextInputEventArgs e)
{
    Debug.WriteLine($"TextInput: {e.Text}");
}
\end{lstlisting}

In most MVVM apps you rely on \passthrough{\lstinline!TextBox!} handling
IME; implement this only when creating custom text editors.

\subsection{8. Keyboard focus management and
navigation}\label{keyboard-focus-management-and-navigation}

\begin{itemize}
\tightlist
\item
  Call \passthrough{\lstinline!Focus()!} to move input programmatically.
  \passthrough{\lstinline!InputElement.Focus()!} delegates to
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/FocusManager.cs}{\passthrough{\lstinline!FocusManager!}}.
\item
  Use \passthrough{\lstinline!Focusable="False"!} on decorative elements
  so they are skipped in traversal.
\item
  Control tab order with \passthrough{\lstinline!TabIndex!} (lower
  numbers focus first); combine with
  \passthrough{\lstinline!KeyboardNavigation.TabNavigation!} to scope
  loops.
\item
  Create focus scopes (\passthrough{\lstinline!Focusable="True"!} +
  \passthrough{\lstinline!IsTabStop="True"!}) for popups/overlays so
  focus returns to the invoking control when closed.
\item
  Use \passthrough{\lstinline!TraversalRequest!} and
  \passthrough{\lstinline!KeyboardNavigationHandler!} to implement
  custom arrow-key navigation for grids or toolbars.
\end{itemize}

\begin{lstlisting}[language=XML]
<StackPanel KeyboardNavigation.TabNavigation="Cycle" Spacing="8">
  <TextBox x:Name="First" Watermark="First name"/>
  <TextBox x:Name="Second" Watermark="Last name"/>
  <Button Content="Focus second" Command="{Binding FocusSecondCommand}"/>
</StackPanel>
\end{lstlisting}

\begin{lstlisting}
public void FocusSecond()
{
    var scope = FocusManager.Instance.Current;
    var second = this.FindControl<TextBox>("Second");
    scope?.Focus(second);
}
\end{lstlisting}

For MVVM-safe focus changes, expose an interaction request (event or
\passthrough{\lstinline!Interaction<T>!} from ReactiveUI) and let the
view handle it. Keyboard navigation services live under
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/IKeyboardNavigationHandler.cs}{\passthrough{\lstinline!IKeyboardNavigationHandler!}}.

\subsection{9. Bridging commands with MVVM
frameworks}\label{bridging-commands-with-mvvm-frameworks}

\begin{itemize}
\tightlist
\item
  \textbf{CommunityToolkit.Mvvm} --
  \passthrough{\lstinline!RelayCommand!}/\passthrough{\lstinline!AsyncRelayCommand!}
  implement \passthrough{\lstinline!ICommand!} and expose
  \passthrough{\lstinline!CanExecuteChanged!}. Use
  \passthrough{\lstinline![RelayCommand]!} attributes to generate
  commands and wrap business logic in partial classes.
\item
  \textbf{ReactiveUI} -- \passthrough{\lstinline!ReactiveCommand!}
  exposes \passthrough{\lstinline!IObservable!} execution pipelines,
  throttling, and cancellation. Bind with
  \passthrough{\lstinline!\{Binding SaveCommand\}!} just like any other
  \passthrough{\lstinline!ICommand!}.
\item
  \textbf{Prism / DryIoc} -- \passthrough{\lstinline!DelegateCommand!}
  supports \passthrough{\lstinline!ObservesCanExecute!} and integrates
  with dependency injection lifetimes.
\end{itemize}

To unify event-heavy code paths with commands, expose interaction
helpers instead of code-behind:

\begin{lstlisting}
public Interaction<Unit, PointerPoint?> StartDragInteraction { get; } = new();

public async Task BeginDragAsync()
{
    var pointerPoint = await StartDragInteraction.Handle(Unit.Default);
    if (pointerPoint is { } point)
    {
        // Use pointer data to seed drag operation
    }
}
\end{lstlisting}

The example uses \passthrough{\lstinline!ReactiveUI.Interaction!} and
\passthrough{\lstinline!Avalonia.Input.PointerPoint!}; adapt the pattern
to your MVVM framework of choice.

In XAML, use \passthrough{\lstinline!Interaction!} behaviors
(\passthrough{\lstinline!<interactions:Interaction.Triggers>!} or
toolkit \passthrough{\lstinline!EventToCommandBehavior!}) to connect
events such as \passthrough{\lstinline!PointerPressed!} to
\passthrough{\lstinline!ReactiveCommand!}s without writing code-behind.
This keeps event routing logic discoverable while leaving testable
command logic in the view model.

\subsection{10. Routed commands and command
routing}\label{routed-commands-and-command-routing}

Avalonia supports routed commands similar to WPF. Define a
\passthrough{\lstinline!RoutedCommand!}
(\passthrough{\lstinline!RoutedCommandLibrary.Save!}, etc.) and attach
handlers via \passthrough{\lstinline!CommandBinding!}.

\begin{lstlisting}[language=XML]
<Window.CommandBindings>
  <CommandBinding Command="{x:Static commands:AppCommands.Save}" Executed="Save_Executed" CanExecute="Save_CanExecute"/>
</Window.CommandBindings>
\end{lstlisting}

\begin{lstlisting}
private void Save_Executed(object? sender, ExecutedRoutedEventArgs e)
{
    if (DataContext is MainWindowViewModel vm)
        vm.SaveCommand.Execute(null);
}

private void Save_CanExecute(object? sender, CanExecuteRoutedEventArgs e)
{
    e.CanExecute = (DataContext as MainWindowViewModel)?.SaveCommand.CanExecute(null) == true;
}
\end{lstlisting}

Routed commands bubble up the tree if not handled, allowing menu items
and toolbars to share command logic.

Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Interactivity/Input/RoutedCommand.cs}{\passthrough{\lstinline!RoutedCommand.cs!}}.

\subsection{11. Asynchronous command
patterns}\label{asynchronous-command-patterns}

Avoid blocking the UI thread. Use
\passthrough{\lstinline!AsyncRelayCommand!} or custom
\passthrough{\lstinline!ICommand!} that runs
\passthrough{\lstinline!Task!}.

\begin{lstlisting}
public sealed class AsyncRelayCommand : ICommand
{
    private readonly Func<Task> _execute;
    private readonly Func<bool>? _canExecute;
    private bool _isExecuting;

    public AsyncRelayCommand(Func<Task> execute, Func<bool>? canExecute = null)
    {
        _execute = execute;
        _canExecute = canExecute;
    }

    public bool CanExecute(object? parameter) => !_isExecuting && (_canExecute?.Invoke() ?? true);

    public async void Execute(object? parameter)
    {
        if (!CanExecute(parameter))
            return;

        try
        {
            _isExecuting = true;
            RaiseCanExecuteChanged();
            await _execute();
        }
        finally
        {
            _isExecuting = false;
            RaiseCanExecuteChanged();
        }
    }

    public event EventHandler? CanExecuteChanged;
    public void RaiseCanExecuteChanged() => CanExecuteChanged?.Invoke(this, EventArgs.Empty);
}
\end{lstlisting}

\subsection{12. Diagnostics: watch input
live}\label{diagnostics-watch-input-live}

DevTools (F12) -\textgreater{} \textbf{Events} tab let you monitor
events (PointerPressed, KeyDown). Select an element, toggle events to
watch.

Enable input logging:

\begin{lstlisting}
AppBuilder.Configure<App>()
    .UsePlatformDetect()
    .LogToTrace(LogEventLevel.Debug, new[] { LogArea.Input })
    .StartWithClassicDesktopLifetime(args);
\end{lstlisting}

\passthrough{\lstinline!LogArea.Input!} (source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Logging/LogArea.cs}{\passthrough{\lstinline!LogArea.cs!}})
emits detailed input information.

\subsection{13. Practice exercises}\label{practice-exercises-3}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Extend InputPlayground with a routed event logger: call
  \passthrough{\lstinline!AddHandler!} for
  \passthrough{\lstinline!PointerPressedEvent!}/\passthrough{\lstinline!KeyDownEvent!},
  display bubbling order, and compare to the DevTools Events tab.
\item
  Register a global \passthrough{\lstinline!Ctrl+Shift+S!} gesture with
  \passthrough{\lstinline!HotKeyManager.HotKey!} (in XAML or via
  \passthrough{\lstinline!HotKeyManager.SetHotKey!}), then toggle the
  button's \passthrough{\lstinline!IsEnabled!} state and confirm
  \passthrough{\lstinline!CanExecute!} updates propagate.
\item
  Build a drag-to-reorder list that uses pointer capture and
  \passthrough{\lstinline!PointerPoint.Properties!} to track left vs
  right button drags.
\item
  Integrate a \passthrough{\lstinline!ReactiveCommand!} or toolkit
  \passthrough{\lstinline!AsyncRelayCommand!} with a drag
  \passthrough{\lstinline!Interaction<T>!} so the view model decides
  when async work starts.
\item
  Configure
  \passthrough{\lstinline!KeyboardNavigation.TabNavigation="Cycle"!} on
  a popup and verify focus returns to the launcher when it closes.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-7}

\begin{itemize}
\tightlist
\item
  Routed events:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Interactivity/RoutedEvent.cs}{\passthrough{\lstinline!RoutedEvent.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Interactivity/RoutingStrategies.cs}{\passthrough{\lstinline!RoutingStrategies!}}
\item
  Commands:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Primitives/ButtonBase.cs}{\passthrough{\lstinline!ButtonBase.Command!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/MenuItem.cs}{\passthrough{\lstinline!MenuItem.Command!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Input/KeyBinding.cs}{\passthrough{\lstinline!KeyBinding!}}
\item
  Hotkeys:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyGesture.cs}{\passthrough{\lstinline!KeyGesture.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/HotkeyManager.cs}{\passthrough{\lstinline!HotkeyManager.cs!}}
\item
  Input elements \& gestures:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/InputElement.cs}{\passthrough{\lstinline!InputElement.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/GestureRecognizer.cs}{\passthrough{\lstinline!GestureRecognizer.cs!}}
\item
  Focus:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/FocusManager.cs}{\passthrough{\lstinline!FocusManager.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/IKeyboardNavigationHandler.cs}{\passthrough{\lstinline!IKeyboardNavigationHandler!}}
\item
  Text input pipeline:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputMethodClient.cs}{\passthrough{\lstinline!TextInputMethodClient.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-7}

\begin{itemize}
\tightlist
\item
  What advantages do commands offer over events in MVVM architectures?
\item
  When would you choose \passthrough{\lstinline!KeyBinding!} vs
  registering a gesture with \passthrough{\lstinline!HotKeyManager!}?
\item
  Which API captures \passthrough{\lstinline!PointerPoint!} data during
  drag initiation and why does it matter?
\item
  How would you bridge a pointer event to a
  \passthrough{\lstinline!ReactiveCommand!} or toolkit command without
  code-behind?
\item
  Which tooling surfaces routed events, and how do you enable verbose
  input logging?
\end{itemize}

What's next - Next: \href{Chapter10.md}{Chapter 10}

\newpage

\subsection{10. Working with resources, images, and
fonts}\label{working-with-resources-images-and-fonts}

Goal - Master \passthrough{\lstinline!avares://!} URIs,
\passthrough{\lstinline!AssetLoader!}/\passthrough{\lstinline!IAssetLoader!},
and \passthrough{\lstinline!ResourceDictionary!} lookup so you can
bundle assets cleanly. - Display raster and vector images, control
caching/interpolation, and brush surfaces with images (including SVG
pipelines). - Load custom fonts, configure
\passthrough{\lstinline!FontManagerOptions!}, and swap font families at
runtime. - Understand resource fallback order, dynamic
\passthrough{\lstinline!ResourceDictionary!} updates, and diagnostics
when a lookup fails. - Tune DPI scaling, bitmap interpolation, and
responsive asset strategies that scale across devices.

Why this matters - Assets and fonts give your app brand identity; doing
it right avoids blurry visuals or missing resources. - Avalonia's
resource system mirrors WPF/UWP but with cross-platform packaging; once
you know the patterns, you can deploy confidently.

Prerequisites - You can edit \passthrough{\lstinline!App.axaml!}, views,
and bind data (Ch. 3-9). - Familiarity with MVVM and theming (Ch. 7)
helps when wiring assets dynamically.

\subsection{\texorpdfstring{1. \texttt{avares://} URIs and project
structure}{1. avares:// URIs and project structure}}\label{avares-uris-and-project-structure}

Assets live under your project (e.g.,
\passthrough{\lstinline!Assets/Images!},
\passthrough{\lstinline!Assets/Fonts!}). Include them as
\passthrough{\lstinline!AvaloniaResource!} in the
\passthrough{\lstinline!.csproj!}:

\begin{lstlisting}[language=XML]
<ItemGroup>
  <AvaloniaResource Include="Assets/**" />
</ItemGroup>
\end{lstlisting}

URI structure:
\passthrough{\lstinline!avares://<AssemblyName>/<RelativePath>!}.

Example:
\passthrough{\lstinline!avares://InputPlayground/Assets/Images/logo.png!}.

\passthrough{\lstinline!avares://!} references the compiled resource
stream (not the file system). Use it consistently even within the same
assembly to avoid issues with resource lookups.

\subsection{2. Resource dictionaries and lookup
order}\label{resource-dictionaries-and-lookup-order}

\passthrough{\lstinline!ResourceDictionary!} derives from
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Controls/ResourceProvider.cs}{\passthrough{\lstinline!ResourceProvider!}}
and implements
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Controls/IResourceProvider.cs}{\passthrough{\lstinline!IResourceProvider!}}.
When you request \passthrough{\lstinline!\{StaticResource\}!} or call
\passthrough{\lstinline!TryGetResource!}, Avalonia walks this chain:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The requesting \passthrough{\lstinline!IResourceHost!} (control,
  style, or application).
\item
  Parent styles (\passthrough{\lstinline!<Style.Resources>!}), control
  templates, and data templates.
\item
  Theme dictionaries (\passthrough{\lstinline!ThemeVariantScope!},
  \passthrough{\lstinline!Application.Styles!},
  \passthrough{\lstinline!Application.Resources!}).
\item
  Merged dictionaries
  (\passthrough{\lstinline!<ResourceDictionary.MergedDictionaries>!} or
  \passthrough{\lstinline!<ResourceInclude>!}).
\item
  Global application resources and finally platform defaults
  (\passthrough{\lstinline!SystemResources!}).
\end{enumerate}

\passthrough{\lstinline!ResourceDictionary.cs!} and
\passthrough{\lstinline!ResourceNode.cs!} coordinate this traversal. Use
\passthrough{\lstinline!TryGetResource!} when retrieving values from
code:

\begin{lstlisting}
if (control.TryGetResource("AccentBrush", ThemeVariant.Dark, out var value) && value is IBrush brush)
{
    control.Background = brush;
}
\end{lstlisting}

\passthrough{\lstinline!ThemeVariant!} lets you request a
variant-specific value; pass
\passthrough{\lstinline!ThemeVariant.Default!} to follow the same logic
as \passthrough{\lstinline!\{DynamicResource\}!}.

Merge dictionaries to break assets into reusable packs:

\begin{lstlisting}[language=XML]
<ResourceDictionary>
  <ResourceDictionary.MergedDictionaries>
    <ResourceInclude Source="avares://AssetsDemo/Assets/Colors.axaml"/>
    <ResourceInclude Source="avares://AssetsDemo/Assets/Icons.axaml"/>
  </ResourceDictionary.MergedDictionaries>
</ResourceDictionary>
\end{lstlisting}

Each merged dictionary is loaded lazily via
\passthrough{\lstinline!IAssetLoader!}, so make sure the referenced file
is marked as \passthrough{\lstinline!AvaloniaResource!}.

\subsection{3. Loading assets in XAML and
code}\label{loading-assets-in-xaml-and-code}

\subsubsection{XAML}\label{xaml}

\begin{lstlisting}[language=XML]
<Image Source="avares://AssetsDemo/Assets/Images/logo.png"
       Stretch="Uniform" Width="160"/>
\end{lstlisting}

\subsubsection{\texorpdfstring{Code using
\texttt{AssetLoader}}{Code using AssetLoader}}\label{code-using-assetloader}

\begin{lstlisting}
using Avalonia;
using Avalonia.Media.Imaging;
using Avalonia.Platform;

var uri = new Uri("avares://AssetsDemo/Assets/Images/logo.png");
var assetLoader = AvaloniaLocator.Current.GetRequiredService<IAssetLoader>();

await using var stream = assetLoader.Open(uri);
LogoImage.Source = new Bitmap(stream);
\end{lstlisting}

\passthrough{\lstinline!AssetLoader!} is a static helper over the same
\passthrough{\lstinline!IAssetLoader!} service. Prefer the interface
when unit testing or when you need to mock resource access. Both live in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/AssetLoader.cs}{\passthrough{\lstinline!Avalonia.Platform!}}.

Need to probe for optional assets? Use
\passthrough{\lstinline!assetLoader.TryOpen(uri)!} or
\passthrough{\lstinline!AssetLoader.Exists(uri)!} to avoid exceptions.

\subsubsection{Resource dictionaries}\label{resource-dictionaries}

\begin{lstlisting}[language=XML]
<ResourceDictionary xmlns="https://github.com/avaloniaui">
  <Bitmap x:Key="LogoBitmap">avares://AssetsDemo/Assets/Images/logo.png</Bitmap>
</ResourceDictionary>
\end{lstlisting}

You can then \passthrough{\lstinline!StaticResource!} expose
\passthrough{\lstinline!LogoBitmap!}. Bitmaps created this way are
cached.

\subsection{4. Raster images, decoders, and
caching}\label{raster-images-decoders-and-caching}

\passthrough{\lstinline!Image!} renders
\passthrough{\lstinline!Avalonia.Media.Imaging.Bitmap!}. Decode streams
once and keep the bitmap alive when the pixels are reused, instead of
calling \passthrough{\lstinline!new Bitmap(stream)!} for every render.
Performance tips: - Set \passthrough{\lstinline!Stretch!} to avoid
unexpected distortions (Uniform, UniformToFill, Fill, None). - Use
\passthrough{\lstinline!RenderOptions.BitmapInterpolationMode!} for
scaling quality:

\begin{lstlisting}[language=XML]
<Image Source="avares://AssetsDemo/Assets/Images/photo.jpg"
       Width="240" Height="160"
       RenderOptions.BitmapInterpolationMode="HighQuality"/>
\end{lstlisting}

Interpolation modes defined in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/RenderOptions.cs}{\passthrough{\lstinline!RenderOptions.cs!}}.

Decode oversized images to a target width/height to save memory:

\begin{lstlisting}
await using var stream = assetLoader.Open(uri);
using var decoded = Bitmap.DecodeToWidth(stream, 512);
PhotoImage.Source = decoded;
\end{lstlisting}

\passthrough{\lstinline!Bitmap!} and decoder helpers live in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/Imaging/Bitmap.cs}{\passthrough{\lstinline!Bitmap.cs!}}.
Avalonia picks the right codec (PNG, JPEG, WebP, BMP, GIF) using Skia;
for unsupported formats supply a custom
\passthrough{\lstinline!IBitmapDecoder!}.

\subsection{5. ImageBrush and tiled
backgrounds}\label{imagebrush-and-tiled-backgrounds}

\passthrough{\lstinline!ImageBrush!} paints surfaces:

\begin{lstlisting}[language=XML]
<Ellipse Width="96" Height="96">
  <Ellipse.Fill>
    <ImageBrush Source="avares://AssetsDemo/Assets/Images/avatar.png"
                Stretch="UniformToFill" AlignmentX="Center" AlignmentY="Center"/>
  </Ellipse.Fill>
</Ellipse>
\end{lstlisting}

Tile backgrounds:

\begin{lstlisting}[language=XML]
<Border Width="200" Height="120">
  <Border.Background>
    <ImageBrush Source="avares://AssetsDemo/Assets/Images/pattern.png"
                TileMode="Tile"
                Stretch="None"
                Transform="{ScaleTransform 0.5,0.5}"/>
  </Border.Background>
</Border>
\end{lstlisting}

\passthrough{\lstinline!ImageBrush!} documentation:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/ImageBrush.cs}{\passthrough{\lstinline!ImageBrush.cs!}}.

\subsection{6. Vector graphics}\label{vector-graphics}

Vector art scales with DPI, can adapt to theme colors, and stays crisp.

\subsubsection{Inline geometry}\label{inline-geometry}

\begin{lstlisting}[language=XML]
<Path Data="M2 12 L9 19 L22 4"
      Stroke="{DynamicResource AccentBrush}"
      StrokeThickness="3"
      StrokeLineCap="Round" StrokeLineJoin="Round"/>
\end{lstlisting}

Store geometry in resources for reuse:

\begin{lstlisting}[language=XML]
<ResourceDictionary xmlns="https://github.com/avaloniaui">
  <Geometry x:Key="IconCheck">M2 12 L9 19 L22 4</Geometry>
</ResourceDictionary>
\end{lstlisting}

Vector classes live under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Media}{\passthrough{\lstinline!Avalonia.Media!}}.

\subsubsection{\texorpdfstring{\texttt{StreamGeometryContext} for
programmatic
icons}{StreamGeometryContext for programmatic icons}}\label{streamgeometrycontext-for-programmatic-icons}

Generate vector shapes in code when you need to compose icons
dynamically or reuse geometry logic:

\begin{lstlisting}
var geometry = new StreamGeometry();

using (var ctx = geometry.Open())
{
    ctx.BeginFigure(new Point(2, 12), isFilled: false);
    ctx.LineTo(new Point(9, 19));
    ctx.LineTo(new Point(22, 4));
    ctx.EndFigure(isClosed: false);
}

IconPath.Data = geometry;
\end{lstlisting}

\passthrough{\lstinline!StreamGeometry!} and
\passthrough{\lstinline!StreamGeometryContext!} live in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/StreamGeometryContext.cs}{\passthrough{\lstinline!StreamGeometryContext.cs!}}.
Remember to freeze geometry instances or share them via resources to
reduce allocations.

\subsubsection{SVG support}\label{svg-support}

Install the \passthrough{\lstinline!Avalonia.Svg.Skia!} package to
render SVG assets natively:

\begin{lstlisting}[language=XML]
<svg:SvgImage xmlns:svg="clr-namespace:Avalonia.Svg.Controls;assembly=Avalonia.Svg.Skia"
              Source="avares://AssetsDemo/Assets/Images/logo.svg"
              Stretch="Uniform" />
\end{lstlisting}

SVGs stay sharp at any DPI and can adapt colors if you parameterize them
(e.g., replace fill attributes at build time). For simple icons,
converting the path data into XAML keeps dependencies minimal.

\subsection{7. Fonts and typography}\label{fonts-and-typography}

Place fonts in \passthrough{\lstinline!Assets/Fonts!}. Register them in
\passthrough{\lstinline!App.axaml!} via
\passthrough{\lstinline!Global::Avalonia!} URI and specify the font face
after \passthrough{\lstinline!\#!}:

\begin{lstlisting}[language=XML]
<Application.Resources>
  <FontFamily x:Key="HeadingFont">avares://AssetsDemo/Assets/Fonts/Inter.ttf#Inter</FontFamily>
</Application.Resources>
\end{lstlisting}

Use the font in styles:

\begin{lstlisting}[language=XML]
<Application.Styles>
  <Style Selector="TextBlock.h1">
    <Setter Property="FontFamily" Value="{StaticResource HeadingFont}"/>
    <Setter Property="FontSize" Value="28"/>
    <Setter Property="FontWeight" Value="SemiBold"/>
  </Style>
</Application.Styles>
\end{lstlisting}

\subsubsection{FontManager options}\label{fontmanager-options}

Configure global font settings in \passthrough{\lstinline!AppBuilder!}:

\begin{lstlisting}
AppBuilder.Configure<App>()
    .UsePlatformDetect()
    .With(new FontManagerOptions
    {
        DefaultFamilyName = "avares://AssetsDemo/Assets/Fonts/Inter.ttf#Inter",
        FontFallbacks = new[] { new FontFallback { Family = "Segoe UI" }, new FontFallback { Family = "Roboto" } }
    })
    .StartWithClassicDesktopLifetime(args);
\end{lstlisting}

\passthrough{\lstinline!FontManagerOptions!} lives in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/FontManagerOptions.cs}{\passthrough{\lstinline!FontManagerOptions.cs!}}.

\subsubsection{Multi-weight fonts}\label{multi-weight-fonts}

If fonts include multiple weights, specify them with
\passthrough{\lstinline!FontWeight!}. If you ship multiple font files
(Regular, Bold), ensure the \passthrough{\lstinline!\#Family!} name is
consistent.

\subsubsection{Runtime font swaps and custom
collections}\label{runtime-font-swaps-and-custom-collections}

You can inject fonts at runtime without restarting the app. Register an
embedded collection and update resources:

\begin{lstlisting}
using Avalonia.Media;
using Avalonia.Media.Fonts;

var baseUri = new Uri("avares://AssetsDemo/Assets/BrandFonts/");
var collection = new EmbeddedFontCollection(new Uri("fonts:brand"), baseUri);

FontManager.Current.AddFontCollection(collection);

Application.Current!.Resources["BodyFont"] = new FontFamily("fonts:brand#Brand Sans");
\end{lstlisting}

\passthrough{\lstinline!EmbeddedFontCollection!} pulls all font files
under the provided URI using \passthrough{\lstinline!IAssetLoader!}.
Removing the collection via
\passthrough{\lstinline!FontManager.Current.RemoveFontCollection(new Uri("fonts:brand"))!}
detaches it again.

\subsection{8. DPI scaling, caching, and
performance}\label{dpi-scaling-caching-and-performance}

Avalonia measures layout in DIPs (1 DIP = 1/96 inch). High DPI monitors
scale automatically.

\begin{itemize}
\tightlist
\item
  Prefer vector assets or high-resolution bitmaps.
\item
  Use
  \passthrough{\lstinline!RenderOptions.BitmapInterpolationMode="None"!}
  for pixel art.
\item
  For expensive bitmaps (charts) consider caching via
  \passthrough{\lstinline!RenderTargetBitmap!} or
  \passthrough{\lstinline!WriteableBitmap!}.
\end{itemize}

\passthrough{\lstinline!RenderTargetBitmap!} and
\passthrough{\lstinline!WriteableBitmap!} under
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Base/Media/Imaging}{\passthrough{\lstinline!Avalonia.Media.Imaging!}}.

\subsection{9. Dynamic resources, theme variants, and runtime
updates}\label{dynamic-resources-theme-variants-and-runtime-updates}

Bind brushes via \passthrough{\lstinline!DynamicResource!} so assets
respond to theme changes. When a dictionary entry changes,
\passthrough{\lstinline!ResourceDictionary.ResourcesChanged!} notifies
every subscriber and controls update automatically:

\begin{lstlisting}[language=XML]
<Application.Resources>
  <SolidColorBrush x:Key="AvatarFallbackBrush" Color="#1F2937"/>
</Application.Resources>

<Ellipse Fill="{DynamicResource AvatarFallbackBrush}"/>
\end{lstlisting}

At runtime you can swap assets:

\begin{lstlisting}
Application.Current!.Resources["AvatarFallbackBrush"] = new SolidColorBrush(Color.Parse("#3B82F6"));
\end{lstlisting}

To scope variants, wrap content in a
\passthrough{\lstinline!ThemeVariantScope!} and supply dictionaries per
variant:

\begin{lstlisting}[language=XML]
<ThemeVariantScope RequestedThemeVariant="Dark">
  <ThemeVariantScope.Resources>
    <SolidColorBrush x:Key="AvatarFallbackBrush" Color="#E5E7EB"/>
  </ThemeVariantScope.Resources>
  <ContentPresenter Content="{Binding}"/>
</ThemeVariantScope>
\end{lstlisting}

\passthrough{\lstinline!ThemeVariantScope!} relies on
\passthrough{\lstinline!IResourceHost!} to merge dictionaries in order
(scope → parent scope → application). To inspect all merged resources in
DevTools, open \textbf{Resources} and observe how
\passthrough{\lstinline!RequestedThemeVariant!} switches dictionaries.

\subsection{10. Diagnostics}\label{diagnostics}

\begin{itemize}
\tightlist
\item
  DevTools -\textgreater{} Resources shows resolved resources.
\item
  Missing asset? Check the output logs
  (\passthrough{\lstinline!RenderOptions!} area) for ``not found''
  messages.
\item
  Use \passthrough{\lstinline!AssetLoader.Exists(uri)!} to verify at
  runtime:
\end{itemize}

\begin{lstlisting}
if (!AssetLoader.Exists(uri))
    throw new FileNotFoundException($"Asset {uri} not found");
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  Subscribe to
  \passthrough{\lstinline!Application.Current.Resources.ResourcesChanged!}
  (or scope-specific hosts) to log when dictionaries update, especially
  when debugging \passthrough{\lstinline!DynamicResource!} refreshes.
\end{itemize}

\subsection{11. Sample ``asset gallery''}\label{sample-asset-gallery}

\begin{lstlisting}[language=XML]
<Grid ColumnDefinitions="Auto,24,Auto" RowDefinitions="Auto,12,Auto">

  <Image Width="160" Height="80" Stretch="Uniform"
         Source="avares://AssetsDemo/Assets/Images/logo.png"/>

  <Rectangle Grid.Column="1" Grid.RowSpan="3" Width="24"/>


  <Ellipse Grid.Column="2" Width="96" Height="96">
    <Ellipse.Fill>
      <ImageBrush Source="avares://AssetsDemo/Assets/Images/avatar.png" Stretch="UniformToFill"/>
    </Ellipse.Fill>
  </Ellipse>

  <Rectangle Grid.Row="1" Grid.ColumnSpan="3" Height="12"/>


  <Canvas Grid.Row="2" Grid.Column="0" Width="28" Height="28">
    <Path Data="M2 14 L10 22 L26 6"
          Stroke="{DynamicResource AccentBrush}"
          StrokeThickness="3" StrokeLineCap="Round" StrokeLineJoin="Round"/>
  </Canvas>

  <TextBlock Grid.Row="2" Grid.Column="2" Classes="h1" Text="Asset gallery"/>
</Grid>
\end{lstlisting}

\subsection{12. Practice exercises}\label{practice-exercises-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Move brand colors into \passthrough{\lstinline!Assets/Brand.axaml!},
  include it with
  \passthrough{\lstinline!<ResourceInclude Source="avares://AssetsDemo/Assets/Brand.axaml"/>!},
  and verify lookups succeed from a control in another assembly.
\item
  Build an image component that prefers SVG
  (\passthrough{\lstinline!SvgImage!}) but falls back to a PNG
  \passthrough{\lstinline!Bitmap!} on platforms where the SVG package is
  missing.
\item
  Decode a high-resolution photo with
  \passthrough{\lstinline!Bitmap.DecodeToWidth!} and compare memory
  usage against eagerly loading the original stream.
\item
  Register an \passthrough{\lstinline!EmbeddedFontCollection!} at
  runtime and swap your typography resources by updating
  \passthrough{\lstinline!Application.Current.Resources["BodyFont"]!}.
\item
  Toggle
  \passthrough{\lstinline!ThemeVariantScope.RequestedThemeVariant!} at
  runtime and confirm \passthrough{\lstinline!DynamicResource!}-bound
  brushes and images update without recreating controls.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-8}

\begin{itemize}
\tightlist
\item
  Resource system:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Controls/ResourceProvider.cs}{\passthrough{\lstinline!ResourceProvider.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Controls/ResourceDictionary.cs}{\passthrough{\lstinline!ResourceDictionary.cs!}}
\item
  Asset loader and URIs:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/AssetLoader.cs}{\passthrough{\lstinline!AssetLoader.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Markup/ResourceInclude.cs}{\passthrough{\lstinline!ResourceInclude.cs!}}
\item
  Bitmap and imaging:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/Imaging/Bitmap.cs}{\passthrough{\lstinline!Bitmap.cs!}}
\item
  Vector geometry:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/StreamGeometryContext.cs}{\passthrough{\lstinline!StreamGeometryContext.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Shapes/Path.cs}{\passthrough{\lstinline!Path.cs!}}
\item
  Fonts \& text formatting:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/FontManager.cs}{\passthrough{\lstinline!FontManager.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/Fonts/EmbeddedFontCollection.cs}{\passthrough{\lstinline!EmbeddedFontCollection.cs!}}
\item
  Theme variants and resources:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/ThemeVariantScope.cs}{\passthrough{\lstinline!ThemeVariantScope.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Controls/ResourcesChangedHelper.cs}{\passthrough{\lstinline!ResourcesChangedHelper.cs!}}
\item
  Render options and DPI:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/RenderOptions.cs}{\passthrough{\lstinline!RenderOptions.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-8}

\begin{itemize}
\tightlist
\item
  What order does Avalonia search when resolving
  \passthrough{\lstinline!\{StaticResource\}!} and
  \passthrough{\lstinline!\{DynamicResource\}!}?
\item
  When do you reach for \passthrough{\lstinline!IAssetLoader!} instead
  of the static \passthrough{\lstinline!AssetLoader!} helper?
\item
  How would you build a responsive icon pipeline that prefers
  \passthrough{\lstinline!StreamGeometry!}/SVG but falls back to a
  bitmap?
\item
  Which APIs let you swap font families at runtime without restarting
  the app?
\item
  How can you confirm that dynamic resource updates propagated after
  changing \passthrough{\lstinline!Application.Current.Resources!}?
\end{itemize}

What's next - Next: \href{Chapter11.md}{Chapter 11}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part III — Application patterns that scale}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part III — Application patterns that scale}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{11. MVVM in depth (with or without
ReactiveUI)}\label{mvvm-in-depth-with-or-without-reactiveui}

Goal - Build production-ready MVVM layers using classic
\passthrough{\lstinline!INotifyPropertyChanged!}, CommunityToolkit.Mvvm
helpers, or ReactiveUI. - Map view models to views with data templates,
view locator patterns, and dependency injection. - Compose complex state
using property change notifications, derived properties, async commands,
and navigation stacks. - Test view models and reactive flows
confidently.

Why this matters - MVVM separates concerns so you can scale UI
complexity, swap views, and run automated tests. - Avalonia supports
multiple MVVM toolkits; understanding their trade-offs lets you choose
the right fit per feature.

Prerequisites - Binding basics (Chapter 8) and commands/input (Chapter
9). - Familiarity with resource organization (Chapter 7) for styles and
data templates.

\subsection{1. MVVM recap}\label{mvvm-recap}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Layer
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Role
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Contains
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Model & Core data/domain logic & POCOs, validation, persistence
models \\
ViewModel & Bindable state, commands &
\passthrough{\lstinline!INotifyPropertyChanged!},
\passthrough{\lstinline!ICommand!}, services \\
View & XAML + minimal code-behind & DataTemplates, layout, visuals \\
\end{longtable}

Focus on keeping business logic in view models/models; views remain
thin.

\subsection{2. Classic MVVM (manual or
CommunityToolkit.Mvvm)}\label{classic-mvvm-manual-or-communitytoolkit.mvvm}

\subsubsection{2.1 Property change base
class}\label{property-change-base-class}

\begin{lstlisting}
using System.ComponentModel;
using System.Runtime.CompilerServices;

public abstract class ObservableObject : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler? PropertyChanged;

    protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
    {
        if (Equals(field, value))
            return false;

        field = value;
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        return true;
    }
}
\end{lstlisting}

CommunityToolkit.Mvvm offers \passthrough{\lstinline!ObservableObject!},
\passthrough{\lstinline!ObservableProperty!} attribute, and
\passthrough{\lstinline!RelayCommand!} out of the box. If you prefer
built-in solutions, install
\passthrough{\lstinline!CommunityToolkit.Mvvm!} and inherit from
\passthrough{\lstinline!ObservableObject!} there.

\subsubsection{\texorpdfstring{2.2 Commands
(\texttt{RelayCommand})}{2.2 Commands (RelayCommand)}}\label{commands-relaycommand}

\begin{lstlisting}
public sealed class RelayCommand : ICommand
{
    private readonly Action<object?> _execute;
    private readonly Func<object?, bool>? _canExecute;

    public RelayCommand(Action<object?> execute, Func<object?, bool>? canExecute = null)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }

    public bool CanExecute(object? parameter) => _canExecute?.Invoke(parameter) ?? true;
    public void Execute(object? parameter) => _execute(parameter);

    public event EventHandler? CanExecuteChanged;
    public void RaiseCanExecuteChanged() => CanExecuteChanged?.Invoke(this, EventArgs.Empty);
}
\end{lstlisting}

\subsubsection{2.3 Sample: People view
model}\label{sample-people-view-model}

\begin{lstlisting}
using System.Collections.ObjectModel;

public sealed class Person : ObservableObject
{
    private string _firstName;
    private string _lastName;

    public Person(string first, string last)
    {
        _firstName = first;
        _lastName = last;
    }

    public string FirstName
    {
        get => _firstName;
        set => SetProperty(ref _firstName, value);
    }

    public string LastName
    {
        get => _lastName;
        set => SetProperty(ref _lastName, value);
    }

    public override string ToString() => $"{FirstName} {LastName}";
}

public sealed class PeopleViewModel : ObservableObject
{
    private Person? _selected;
    private readonly IPersonService _personService;

    public ObservableCollection<Person> People { get; } = new();
    public RelayCommand AddCommand { get; }
    public RelayCommand RemoveCommand { get; }

    public PeopleViewModel(IPersonService personService)
    {
        _personService = personService;
        AddCommand = new RelayCommand(_ => AddPerson());
        RemoveCommand = new RelayCommand(_ => RemovePerson(), _ => Selected is not null);

        LoadInitialPeople();
    }

    public Person? Selected
    {
        get => _selected;
        set
        {
            if (SetProperty(ref _selected, value))
                RemoveCommand.RaiseCanExecuteChanged();
        }
    }

    private void LoadInitialPeople()
    {
        foreach (var person in _personService.GetInitialPeople())
            People.Add(person);
    }

    private void AddPerson()
    {
        var newPerson = _personService.CreateNewPerson();
        People.Add(newPerson);
        Selected = newPerson;
    }

    private void RemovePerson()
    {
        if (Selected is null)
            return;

        _personService.DeletePerson(Selected);
        People.Remove(Selected);
        Selected = null;
    }
}
\end{lstlisting}

\passthrough{\lstinline!IPersonService!} represents data access. Inject
it via DI in \passthrough{\lstinline!App.axaml.cs!} (see Section 3).

\subsubsection{2.4 Binding notifications and
validation}\label{binding-notifications-and-validation}

Bindings surface both conversion errors and validation failures through
\passthrough{\lstinline!BindingNotification!} and the
\passthrough{\lstinline!DataValidationException!} payload. Listening to
those notifications helps you surface validation summaries in the UI and
quickly diagnose binding issues during development.

\begin{lstlisting}
public sealed class AccountViewModel : ObservableValidator
{
    private string _email = string.Empty;
    public ObservableCollection<string> ValidationMessages { get; } = new();

    [Required(ErrorMessage = "Email is required")]
    [EmailAddress(ErrorMessage = "Enter a valid email address")]
    public string Email
    {
        get => _email;
        set => SetProperty(ref _email, value, true);
    }
}
\end{lstlisting}

\passthrough{\lstinline!ObservableValidator!} lives in
CommunityToolkit.Mvvm and combines property change notification with
\passthrough{\lstinline!INotifyDataErrorInfo!} support. Expose
\passthrough{\lstinline!ValidationMessages!} (e.g., an
\passthrough{\lstinline!ObservableCollection<string>!}) to feed
summaries or inline hints.

\begin{lstlisting}[language=XML]
<TextBox x:Name="EmailBox"
         Text="{Binding Email, Mode=TwoWay, ValidatesOnNotifyDataErrors=True, UpdateSourceTrigger=PropertyChanged}"/>
<ItemsControl ItemsSource="{Binding ValidationMessages}"/>
\end{lstlisting}

\begin{lstlisting}
var subscription = EmailBox.GetBindingObservable(TextBox.TextProperty)
    .Subscribe(result =>
    {
        if (result.HasError && result.Error is BindingNotification notification)
        {
            if (notification.Error is ValidationException validation)
                ValidationMessages.Add(validation.Message);
            else
                Logger.LogError(notification.Error, "Binding failure for Email");
        }
    });

DataValidationErrors.GetObservable(EmailBox)
    .Subscribe(args => ValidationMessages.Add(args.Error.Content?.ToString() ?? string.Empty));
\end{lstlisting}

\passthrough{\lstinline!BindingNotification!} distinguishes between
binding errors and data validation errors
(\passthrough{\lstinline!BindingErrorType!}). Validation failures arrive
as \passthrough{\lstinline!DataValidationException!} instances on the
notification, exposing the offending property and message. Use
Avalonia's \passthrough{\lstinline!DataValidationErrors!} helper to
observe validation changes and feed a summary control or toast.

\subsubsection{2.5 Value converters and
formatting}\label{value-converters-and-formatting}

When view and view model types differ, implement
\passthrough{\lstinline!IValueConverter!} or
\passthrough{\lstinline!IBindingTypeConverter!} to keep view models
POCO-friendly.

\begin{lstlisting}
public sealed class TimestampToLocalTimeConverter : IValueConverter
{
    public object? Convert(object? value, Type targetType, object? parameter, CultureInfo culture)
        => value is DateTimeOffset dto ? dto.ToLocalTime().ToString("t", culture) : string.Empty;

    public object? ConvertBack(object? value, Type targetType, object? parameter, CultureInfo culture)
        => DateTimeOffset.TryParse(value as string, culture, DateTimeStyles.AssumeLocal, out var dto) ? dto : BindingOperations.DoNothing;
}
\end{lstlisting}

Register converters in resources and reuse them across DataTemplates:

\begin{lstlisting}[language=XML]
<Window.Resources>
  <local:TimestampToLocalTimeConverter x:Key="LocalTime"/>
</Window.Resources>

<TextBlock Text="{Binding LastSignIn, Converter={StaticResource LocalTime}}"/>
\end{lstlisting}

Converters keep view models focused on domain types while views shape
presentation. For complex pipelines, combine converters with
\passthrough{\lstinline!Binding.ConverterParameter!} or chained
bindings.

\subsubsection{2.6 Mapping view models to views via
DataTemplates}\label{mapping-view-models-to-views-via-datatemplates}

\begin{lstlisting}[language=XML]

<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:views="clr-namespace:MyApp.Views"
             xmlns:viewmodels="clr-namespace:MyApp.ViewModels"
             x:Class="MyApp.App">
  <Application.DataTemplates>
    <DataTemplate DataType="{x:Type viewmodels:PeopleViewModel}">
      <views:PeopleView />
    </DataTemplate>
  </Application.DataTemplates>
</Application>
\end{lstlisting}

In \passthrough{\lstinline!MainWindow.axaml!}:

\begin{lstlisting}[language=XML]
<ContentControl Content="{Binding CurrentViewModel}"/>
\end{lstlisting}

\passthrough{\lstinline!CurrentViewModel!} property determines which
view to display. This is the ViewModel-first approach: DataTemplates map
VM types to Views automatically. For advanced scenarios, register an
\passthrough{\lstinline!IGlobalDataTemplates!} implementation to provide
templates at runtime (e.g., when view models live in feature modules).

\begin{lstlisting}
public sealed class AppDataTemplates : IGlobalDataTemplates
{
    private readonly IServiceProvider _services;

    public AppDataTemplates(IServiceProvider services) => _services = services;

    public bool Match(object? data) => data is ViewModelBase;

    public Control Build(object? data)
        => data switch
        {
            HomeViewModel => _services.GetRequiredService<HomeView>(),
            SettingsViewModel => _services.GetRequiredService<SettingsView>(),
            _ => new TextBlock { Text = "No view registered." }
        };
}
\end{lstlisting}

Register the implementation in \passthrough{\lstinline!App!} or DI
container so Avalonia uses it when resolving content.

\subsubsection{2.7 Navigation service (classic
MVVM)}\label{navigation-service-classic-mvvm}

\begin{lstlisting}
public interface INavigationService
{
    void NavigateTo<TViewModel>() where TViewModel : class;
}

public sealed class NavigationService : ObservableObject, INavigationService
{
    private readonly IServiceProvider _services;
    private object? _currentViewModel;

    public object? CurrentViewModel
    {
        get => _currentViewModel;
        private set => SetProperty(ref _currentViewModel, value);
    }

    public NavigationService(IServiceProvider services)
    {
        _services = services;
    }

    public void NavigateTo<TViewModel>() where TViewModel : class
    {
        var vm = _services.GetRequiredService<TViewModel>();
        CurrentViewModel = vm;
    }
}
\end{lstlisting}

Register navigation service via dependency injection (next section).
View models call
\passthrough{\lstinline!navigationService.NavigateTo<PeopleViewModel>()!}
to swap views.

\subsection{3. Composition and state
management}\label{composition-and-state-management}

\subsubsection{3.1 Dependency injection and view model
factories}\label{dependency-injection-and-view-model-factories}

Use your favorite DI container. Example with
Microsoft.Extensions.DependencyInjection in
\passthrough{\lstinline!App.axaml.cs!}:

\begin{lstlisting}
using Microsoft.Extensions.DependencyInjection;

public partial class App : Application
{
    private IServiceProvider? _services;

    public override void OnFrameworkInitializationCompleted()
    {
        _services = ConfigureServices();

        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            desktop.MainWindow = _services.GetRequiredService<MainWindow>();
        }
        else if (ApplicationLifetime is ISingleViewApplicationLifetime singleView)
        {
            singleView.MainView = _services.GetRequiredService<ShellView>();
        }

        base.OnFrameworkInitializationCompleted();
    }

    private static IServiceProvider ConfigureServices()
    {
        var services = new ServiceCollection();
        services.AddSingleton<MainWindow>();
        services.AddSingleton<ShellView>();
        services.AddSingleton<INavigationService, NavigationService>();
        services.AddTransient<PeopleViewModel>();
        services.AddTransient<HomeViewModel>();
        services.AddSingleton<IPersonService, PersonService>();
        services.AddSingleton<IGlobalDataTemplates, AppDataTemplates>();
        return services.BuildServiceProvider();
    }
}
\end{lstlisting}

Inject \passthrough{\lstinline!INavigationService!} (or a more
opinionated router) into view models to drive navigation. Supplying
\passthrough{\lstinline!IGlobalDataTemplates!} from the service provider
keeps view discovery aligned with DI---views can request their own
dependencies on construction.

\subsubsection{3.2 State orchestration with
observables}\label{state-orchestration-with-observables}

Centralize shared state in dedicated services so view models remain
focused on UI coordination:

\begin{lstlisting}
public sealed class DocumentStore : ObservableObject
{
    private readonly ObservableCollection<DocumentViewModel> _documents = new();
    public ReadOnlyObservableCollection<DocumentViewModel> OpenDocuments { get; }

    public DocumentStore()
        => OpenDocuments = new ReadOnlyObservableCollection<DocumentViewModel>(_documents);

    public void Open(DocumentViewModel document)
    {
        if (!_documents.Contains(document))
            _documents.Add(document);
    }

    public void Close(DocumentViewModel document) => _documents.Remove(document);
}
\end{lstlisting}

Expose commands that call into the store instead of duplicating logic
across view models. For undo/redo, track a stack of undoable actions and
leverage property observables to record mutations:

\begin{lstlisting}
public interface IUndoableAction
{
    void Execute();
    void Undo();
}

public sealed class UndoRedoManager
{
    private readonly Stack<IUndoableAction> _undo = new();
    private readonly Stack<IUndoableAction> _redo = new();

    public void Do(IUndoableAction action)
    {
        action.Execute();
        _undo.Push(action);
        _redo.Clear();
    }

    public void Undo() => Execute(_undo, _redo);
    public void Redo() => Execute(_redo, _undo);

    private static void Execute(Stack<IUndoableAction> source, Stack<IUndoableAction> target)
    {
        if (source.TryPop(out var action))
        {
            action.Undo();
            target.Push(action);
        }
    }
}
\end{lstlisting}

Subscribe to \passthrough{\lstinline!INotifyPropertyChanged!} or use
\passthrough{\lstinline!Observable.FromEventPattern!} to capture state
snapshots whenever important properties change. This approach works
equally well for manual MVVM, CommunityToolkit, or ReactiveUI view
models.

\subsubsection{3.3 Bridging other MVVM
frameworks}\label{bridging-other-mvvm-frameworks}

\begin{itemize}
\tightlist
\item
  \textbf{Prism}: Register
  \passthrough{\lstinline!ViewModelLocator.AutoWireViewModel!} in XAML
  and let Prism resolve view models via Avalonia DI. Use Prism's region
  navigation on top of \passthrough{\lstinline!ContentControl!}-based
  shells.
\item
  \textbf{Caliburn.Micro / Stylet}: Hook their view locator into
  Avalonia by implementing
  \passthrough{\lstinline!IGlobalDataTemplates!} or setting
  \passthrough{\lstinline!ViewLocator.LocateForModelType!} to the
  framework's resolver.
\item
  \textbf{PropertyChanged.Fody / FSharp.ViewModule}: Combine source
  generators with Avalonia
  bindings---\passthrough{\lstinline!BindingNotification!} still
  surfaces validation errors, so logging and diagnostics remain
  consistent.
\end{itemize}

The key is to treat Avalonia's property system as the integration point:
as long as view models raise property change notifications, you can plug
in different MVVM toolkits without rewriting view code.

\subsection{4. Testing classic MVVM view
models}\label{testing-classic-mvvm-view-models}

A unit test using xUnit:

\begin{lstlisting}
[Fact]
public void RemovePerson_Disables_When_No_Selection()
{
    var service = Substitute.For<IPersonService>();
    var vm = new PeopleViewModel(service);

    vm.Selected = vm.People.First();
    Assert.True(vm.RemoveCommand.CanExecute(null));

    vm.Selected = null;
    Assert.False(vm.RemoveCommand.CanExecute(null));
}
\end{lstlisting}

Testing ensures command states and property changes behave correctly.

\subsection{5. ReactiveUI approach}\label{reactiveui-approach}

ReactiveUI provides \passthrough{\lstinline!ReactiveObject!},
\passthrough{\lstinline!ReactiveCommand!},
\passthrough{\lstinline!WhenAnyValue!}, and routing/interaction helpers.
Source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.ReactiveUI}{\passthrough{\lstinline!Avalonia.ReactiveUI!}}.

\subsubsection{5.1 Reactive object and derived
state}\label{reactive-object-and-derived-state}

\begin{lstlisting}
using ReactiveUI;
using System.Reactive.Linq;

public sealed class PersonViewModelRx : ReactiveObject
{
    private string _firstName = "Ada";
    private string _lastName = "Lovelace";

    public string FirstName
    {
        get => _firstName;
        set => this.RaiseAndSetIfChanged(ref _firstName, value);
    }

    public string LastName
    {
        get => _lastName;
        set => this.RaiseAndSetIfChanged(ref _lastName, value);
    }

    public string FullName => $"{FirstName} {LastName}";

    public PersonViewModelRx()
    {
        this.WhenAnyValue(x => x.FirstName, x => x.LastName)
            .Select(_ => Unit.Default)
            .Subscribe(_ => this.RaisePropertyChanged(nameof(FullName)));
    }
}
\end{lstlisting}

\passthrough{\lstinline!WhenAnyValue!} observes properties and
recomputes derived values.

\subsubsection{5.2 ReactiveCommand and async
workflows}\label{reactivecommand-and-async-workflows}

\begin{lstlisting}
using System.Reactive;
using System.Reactive.Linq;

public sealed class PeopleViewModelRx : ReactiveObject
{
    private PersonViewModelRx? _selected;

    public ObservableCollection<PersonViewModelRx> People { get; } = new()
    {
        new PersonViewModelRx { FirstName = "Ada", LastName = "Lovelace" },
        new PersonViewModelRx { FirstName = "Grace", LastName = "Hopper" }
    };

    public PersonViewModelRx? Selected
    {
        get => _selected;
        set => this.RaiseAndSetIfChanged(ref _selected, value);
    }

    public ReactiveCommand<Unit, Unit> AddCommand { get; }
    public ReactiveCommand<PersonViewModelRx, Unit> RemoveCommand { get; }
    public ReactiveCommand<Unit, IReadOnlyList<PersonViewModelRx>> LoadCommand { get; }

    public PeopleViewModelRx(IPersonService service)
    {
        AddCommand = ReactiveCommand.Create(() =>
        {
            var vm = new PersonViewModelRx { FirstName = "New", LastName = "Person" };
            People.Add(vm);
            Selected = vm;
        });

        var canRemove = this.WhenAnyValue(x => x.Selected).Select(selected => selected is not null);
        RemoveCommand = ReactiveCommand.Create<PersonViewModelRx>(person => People.Remove(person), canRemove);

        LoadCommand = ReactiveCommand.CreateFromTask(async () =>
        {
            var people = await service.FetchPeopleAsync();
            People.Clear();
            foreach (var p in people)
                People.Add(new PersonViewModelRx { FirstName = p.FirstName, LastName = p.LastName });
            return People.ToList();
        });

        LoadCommand.ThrownExceptions.Subscribe(ex => {/* handle errors */});
    }
}
\end{lstlisting}

\passthrough{\lstinline!ReactiveCommand!} exposes
\passthrough{\lstinline!IsExecuting!},
\passthrough{\lstinline!ThrownExceptions!}, and ensures asynchronous
flows stay on the UI thread.

\subsubsection{\texorpdfstring{5.3 \texttt{ReactiveUserControl} and
activation}{5.3 ReactiveUserControl and activation}}\label{reactiveusercontrol-and-activation}

\begin{lstlisting}
using ReactiveUI;
using System.Reactive.Disposables;

public partial class PeopleViewRx : ReactiveUserControl<PeopleViewModelRx>
{
    public PeopleViewRx()
    {
        InitializeComponent();

        this.WhenActivated(disposables =>
        {
            this.Bind(ViewModel, vm => vm.Selected, v => v.PersonList.SelectedItem)
                .DisposeWith(disposables);
            this.BindCommand(ViewModel, vm => vm.AddCommand, v => v.AddButton)
                .DisposeWith(disposables);
        });
    }
}
\end{lstlisting}

\passthrough{\lstinline!WhenActivated!} manages subscriptions.
\passthrough{\lstinline!Bind!}/\passthrough{\lstinline!BindCommand!}
reduce boilerplate. Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.ReactiveUI/ReactiveUserControl.cs}{\passthrough{\lstinline!ReactiveUserControl.cs!}}.

\subsubsection{5.4 View locator}\label{view-locator}

ReactiveUI auto resolves views via naming conventions. Register
\passthrough{\lstinline!IViewLocator!} in DI or implement your own to
map view models to views. Avalonia.ReactiveUI includes
\passthrough{\lstinline!ViewLocator!} class you can override.

\begin{lstlisting}
public class AppViewLocator : IViewLocator
{
    public IViewFor? ResolveView<T>(T viewModel, string? contract = null) where T : class
    {
        var name = viewModel.GetType().FullName.Replace("ViewModel", "View");
        var type = Type.GetType(name ?? string.Empty);
        return type is null ? null : (IViewFor?)Activator.CreateInstance(type);
    }
}
\end{lstlisting}

Register it:

\begin{lstlisting}
services.AddSingleton<IViewLocator, AppViewLocator>();
\end{lstlisting}

\subsubsection{5.5 Routing and navigation}\label{routing-and-navigation}

Routers manage stacks of \passthrough{\lstinline!IRoutableViewModel!}
instances. Example shell view model shown earlier. Use
\passthrough{\lstinline!<rxui:RoutedViewHost Router="\{Binding Router\}"/>!}
to display the current view.

ReactiveUI navigation supports back/forward, parameter passing, and
async transitions.

\subsubsection{5.6 Avalonia.ReactiveUI
helpers}\label{avalonia.reactiveui-helpers}

\passthrough{\lstinline!Avalonia.ReactiveUI!} ships opinionated base
classes such as \passthrough{\lstinline!ReactiveWindow<TViewModel>!},
\passthrough{\lstinline!ReactiveContentControl<TViewModel>!}, and
extension methods that bridge Avalonia's property system with
ReactiveUI's \passthrough{\lstinline!IObservable!} pipelines.

\begin{lstlisting}
public partial class ShellWindow : ReactiveWindow<ShellViewModel>
{
    public ShellWindow()
    {
        InitializeComponent();

        this.WhenActivated(disposables =>
        {
            this.OneWayBind(ViewModel, vm => vm.Router, v => v.RouterHost.Router)
                .DisposeWith(disposables);
            this.BindCommand(ViewModel, vm => vm.ExitCommand, v => v.ExitMenuItem)
                .DisposeWith(disposables);
        });
    }
}
\end{lstlisting}

Activation hooks route \passthrough{\lstinline!BindingNotification!}
instances through ReactiveUI's logging infrastructure, so binding
failures show up in
\passthrough{\lstinline!RxApp.DefaultExceptionHandler!}. Register
\passthrough{\lstinline!ActivationForViewFetcher!} when hosting custom
controls so ReactiveUI can discover activation semantics:

\begin{lstlisting}
Locator.CurrentMutable.Register(() => new ShellWindow(), typeof(IViewFor<ShellViewModel>));
Locator.CurrentMutable.RegisterConstant(new AvaloniaActivationForViewFetcher(), typeof(IActivationForViewFetcher));
\end{lstlisting}

These helpers keep Avalonia bindings, routing, and interactions in sync
with ReactiveUI conventions.

\subsection{6. Interactions and dialogs}\label{interactions-and-dialogs}

Use \passthrough{\lstinline!Interaction<TInput,TOutput>!} to request UI
interactions from view models.

\begin{lstlisting}
public Interaction<string, bool> ConfirmDelete { get; } = new();

DeleteCommand = ReactiveCommand.CreateFromTask(async () =>
{
    if (Selected is null)
        return;

    var ok = await ConfirmDelete.Handle($"Delete {Selected.FullName}?");
    if (ok)
        People.Remove(Selected);
});
\end{lstlisting}

In the view:

\begin{lstlisting}
this.WhenActivated(d =>
{
    d(ViewModel!.ConfirmDelete.RegisterHandler(async ctx =>
    {
        var dialog = new ConfirmDialog(ctx.Input);
        var result = await dialog.ShowDialog<bool>(this);
        ctx.SetOutput(result);
    }));
});
\end{lstlisting}

\subsection{7. Testing ReactiveUI view
models}\label{testing-reactiveui-view-models}

Use \passthrough{\lstinline!TestScheduler!} from
\passthrough{\lstinline!ReactiveUI.Testing!} to control time:

\begin{lstlisting}
[Test]
public void LoadCommand_PopulatesPeople()
{
    var scheduler = new TestScheduler();
    var service = Substitute.For<IPersonService>();
    service.FetchPeopleAsync().Returns(Task.FromResult(new[] { new Person("Alan", "Turing") }));

    var vm = new PeopleViewModelRx(service);
    vm.LoadCommand.Execute().Subscribe();

    scheduler.Start();

    Assert.Single(vm.People);
}
\end{lstlisting}

\subsection{8. Choosing between
toolkits}\label{choosing-between-toolkits}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Toolkit
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Pros
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Cons
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Manual / CommunityToolkit.Mvvm & Minimal dependencies, familiar, great
for straightforward forms & More boilerplate for async flows, manual
derived state \\
ReactiveUI & Powerful reactive composition, built-in
routing/interaction, great for complex async state & Learning curve,
more dependencies \\
\end{longtable}

Mixing is common: use classic MVVM for most pages; ReactiveUI for
reactive-heavy screens.

\subsection{9. Practice exercises}\label{practice-exercises-5}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Compose a multi-view shell that swaps
  \passthrough{\lstinline!HomeViewModel!}/\passthrough{\lstinline!SettingsViewModel!}
  via DI-backed \passthrough{\lstinline!IGlobalDataTemplates!} and an
  \passthrough{\lstinline!INavigationService!}.
\item
  Extend the account form to surface a validation summary by listening
  to \passthrough{\lstinline!DataValidationErrors.GetObservable!} and
  logging \passthrough{\lstinline!BindingNotification!} errors.
\item
  Author a currency \passthrough{\lstinline!IValueConverter!}, register
  it in resources, and verify formatting in both classic and ReactiveUI
  views.
\item
  Implement an async load pipeline with
  \passthrough{\lstinline!ReactiveCommand!}, binding
  \passthrough{\lstinline!IsExecuting!} to a progress indicator and
  asserting behaviour with \passthrough{\lstinline!TestScheduler!}.
\item
  Add undo/redo support to the People sample by capturing
  \passthrough{\lstinline!INotifyPropertyChanged!} via
  \passthrough{\lstinline!Observable.FromEventPattern!} and replaying
  changes.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-9}

\begin{itemize}
\tightlist
\item
  Binding diagnostics:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/BindingNotification.cs}{\passthrough{\lstinline!BindingNotification.cs!}}
\item
  Data validation surfaces:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/DataValidationErrors.cs}{\passthrough{\lstinline!DataValidationErrors.cs!}}
\item
  Avalonia + ReactiveUI integration:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.ReactiveUI}{\passthrough{\lstinline!Avalonia.ReactiveUI!}}
\item
  Global templates:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/IGlobalDataTemplates.cs}{\passthrough{\lstinline!IGlobalDataTemplates.cs!}}
\item
  Value conversion defaults:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/Converters/DefaultValueConverter.cs}{\passthrough{\lstinline!DefaultValueConverter.cs!}}
\item
  Reactive command implementation:
  \href{https://github.com/reactiveui/ReactiveUI/blob/main/src/ReactiveUI/ReactiveCommand.cs}{\passthrough{\lstinline!ReactiveCommand.cs!}}
\item
  Interaction pattern:
  \href{https://github.com/reactiveui/ReactiveUI/blob/main/src/ReactiveUI/Interaction.cs}{\passthrough{\lstinline!Interaction.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-9}

\begin{itemize}
\tightlist
\item
  What benefits does a view locator provide compared to manual view
  creation?
\item
  How do \passthrough{\lstinline!BindingNotification!} and
  \passthrough{\lstinline!DataValidationErrors!} help diagnose problems
  during binding?
\item
  How do \passthrough{\lstinline!ReactiveCommand!} and classic
  \passthrough{\lstinline!RelayCommand!} differ in async handling?
\item
  Why is DI helpful when constructing view models? How would you
  register services in Avalonia?
\item
  Which scenarios justify ReactiveUI's routing over simple
  \passthrough{\lstinline!ContentControl!} swaps?
\item
  What advantage does \passthrough{\lstinline!IGlobalDataTemplates!}
  offer over static XAML data templates?
\end{itemize}

What's next - Next: \href{Chapter12.md}{Chapter 12}

\newpage

\subsection{12. Navigation, windows, and
lifetimes}\label{navigation-windows-and-lifetimes}

Goal - Understand how Avalonia lifetimes (desktop, single-view, browser)
drive app startup and shutdown. - Manage windows: main, owned, modal,
dialogs; persist placement; respect multiple screens. - Implement
navigation patterns (content swapping, navigation services, transitions)
that work across platforms. - Leverage
\passthrough{\lstinline!TopLevel!} services (clipboard, storage,
screens) from view models via abstractions.

Why this matters - Predictable navigation and windowing keep apps
maintainable on desktop, mobile, and web. - Lifetimes differ per
platform; knowing them prevents ``works on Windows, fails on Android''
surprises. - Services like file pickers or clipboard should be
accessible through MVVM-friendly patterns.

Prerequisites - Chapter 4 (AppBuilder and lifetimes), Chapter 11 (MVVM
patterns), Chapter 16 (storage) is referenced later.

\subsection{1. Lifetimes recap}\label{lifetimes-recap}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Lifetime
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Use case
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Entry method
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!ClassicDesktopStyleApplicationLifetime!} &
Windows/macOS/Linux windowed apps &
\passthrough{\lstinline!StartWithClassicDesktopLifetime(args)!} \\
\passthrough{\lstinline!SingleViewApplicationLifetime!} & Mobile
(Android/iOS), embedded &
\passthrough{\lstinline!StartWithSingleViewLifetime(view)!} \\
\passthrough{\lstinline!BrowserSingleViewLifetime!} & WebAssembly &
\passthrough{\lstinline!BrowserAppBuilder!} setup \\
\passthrough{\lstinline!ISingleTopLevelApplicationLifetime!} & Single
top-level host (preview/embedded scenarios) & Exposed by the runtime;
inspect via
\passthrough{\lstinline!ApplicationLifetime as ISingleTopLevelApplicationLifetime!} \\
\end{longtable}

\passthrough{\lstinline!App.OnFrameworkInitializationCompleted!} should
handle all lifetimes:

\begin{lstlisting}
public override void OnFrameworkInitializationCompleted()
{
    var services = ConfigureServices();

    if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
    {
        var shell = services.GetRequiredService<MainWindow>();
        desktop.MainWindow = shell;

        // optional: intercept shutdown
        desktop.ShutdownMode = ShutdownMode.OnLastWindowClose;
    }
    else if (ApplicationLifetime is ISingleViewApplicationLifetime singleView)
    {
        singleView.MainView = services.GetRequiredService<ShellView>();
    }

    base.OnFrameworkInitializationCompleted();
}
\end{lstlisting}

\passthrough{\lstinline!ISingleTopLevelApplicationLifetime!} is
currently marked \passthrough{\lstinline![PrivateApi]!}, but you may see
it when Avalonia hosts supply a single
\passthrough{\lstinline!TopLevel!}. Treat it as read-only metadata
rather than something you implement yourself.

When targeting browser, use \passthrough{\lstinline!BrowserAppBuilder!}
with \passthrough{\lstinline!SetupBrowserApp!}.

\subsection{2. Desktop windows in depth}\label{desktop-windows-in-depth}

\subsubsection{2.1 Creating a main window with
MVVM}\label{creating-a-main-window-with-mvvm}

\begin{lstlisting}
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        Opened += (_, _) => RestorePlacement();
        Closing += (_, e) => SavePlacement();
    }

    private const string PlacementKey = "MainWindowPlacement";

    private void RestorePlacement()
    {
        if (LocalSettings.TryReadWindowPlacement(PlacementKey, out var placement))
        {
            Position = placement.Position;
            Width = placement.Size.Width;
            Height = placement.Size.Height;
        }
    }

    private void SavePlacement()
    {
        LocalSettings.WriteWindowPlacement(PlacementKey, new WindowPlacement
        {
            Position = Position,
            Size = new Size(Width, Height)
        });
    }
}
\end{lstlisting}

\passthrough{\lstinline!LocalSettings!} is a simple persistence helper
(file or user settings). Persisting placement keeps UX consistent.

\subsubsection{2.2 Owned windows, modal vs
modeless}\label{owned-windows-modal-vs-modeless}

\begin{lstlisting}
public sealed class AboutWindow : Window
{
    public AboutWindow()
    {
        Title = "About";
        Width = 360;
        Height = 200;
        WindowStartupLocation = WindowStartupLocation.CenterOwner;
        Content = new TextBlock { Margin = new Thickness(16), Text = "My App v1.0" };
    }
}

// From main window or service
public Task ShowAboutDialogAsync(Window owner)
    => new AboutWindow { Owner = owner }.ShowDialog(owner);
\end{lstlisting}

Modeless window:

\begin{lstlisting}
var tool = new ToolWindow { Owner = this };
tool.Show();
\end{lstlisting}

Always set \passthrough{\lstinline!Owner!} so modal blocks correctly and
centering works.

\subsubsection{2.3 Multiple screens \&
placement}\label{multiple-screens-placement}

Use \passthrough{\lstinline!Screens!} service from
\passthrough{\lstinline!TopLevel!}:

\begin{lstlisting}
var topLevel = TopLevel.GetTopLevel(this);
if (topLevel?.Screens is { } screens)
{
    var screen = screens.ScreenFromPoint(Position);
    var workingArea = screen.WorkingArea;
    Position = new PixelPoint(workingArea.X, workingArea.Y);
}
\end{lstlisting}

\passthrough{\lstinline!Screens!} live under
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Screens.cs}{\passthrough{\lstinline!Avalonia.Controls/Screens.cs!}}.

Subscribe to \passthrough{\lstinline!screens.Changed!} when you need to
react to hot-plugging monitors or DPI changes:

\begin{lstlisting}
screens.Changed += (_, _) =>
{
    var active = screens.ScreenFromWindow(this);
    Logger.LogInformation("Monitor layout changed. Active screen: {Bounds}", active.WorkingArea);
};
\end{lstlisting}

\passthrough{\lstinline!WindowBase.Screens!} always maps to the
platform's latest monitor topology, so you can reposition tool windows
or popups when displays change.

\subsubsection{2.4 Prevent closing with unsaved
changes}\label{prevent-closing-with-unsaved-changes}

\begin{lstlisting}
Closing += async (sender, e) =>
{
    if (DataContext is ShellViewModel vm && vm.HasUnsavedChanges)
    {
        var confirm = await MessageBox.ShowAsync(this, "Unsaved changes", "Exit without saving?", MessageBoxButtons.YesNo);
        if (!confirm)
            e.Cancel = true;
    }
};
\end{lstlisting}

Implement \passthrough{\lstinline!MessageBox!} yourself or using
Avalonia.MessageBox community package.

\subsubsection{\texorpdfstring{2.5 Window lifecycle events
(\texttt{WindowBase})}{2.5 Window lifecycle events (WindowBase)}}\label{window-lifecycle-events-windowbase}

\passthrough{\lstinline!WindowBase!} is the shared base type for
\passthrough{\lstinline!Window!} and other top-levels. It raises events
that fire before layout runs, letting you respond to activation,
resizing, and positioning at the window layer:

\begin{lstlisting}
public partial class ToolWindow : Window
{
    public ToolWindow()
    {
        InitializeComponent();
        Activated += (_, _) => StatusBar.Text = "Active";
        Deactivated += (_, _) => StatusBar.Text = "Inactive";
        PositionChanged += (_, e) => Logger.LogInformation("Moved to {Point}", e.Point);
        Resized += (_, e) => Metrics.Track(e.Size, e.Reason);
        Closed += (_, _) => _subscriptions.Dispose();
    }
}
\end{lstlisting}

\passthrough{\lstinline!WindowBase.Resized!} reports the reason the
platform resized your window (user drag, system DPI change, maximize).
Distinguish it from \passthrough{\lstinline!Control.SizeChanged!}, which
fires after layout completes. Use
\passthrough{\lstinline!WindowBase.IsActive!} to trigger focus-sensitive
behaviour such as pausing animations when the window moves to the
background.

\subsubsection{2.6 Platform-specific window
features}\label{platform-specific-window-features}

Avalonia exposes chrome customisation through
\passthrough{\lstinline!TopLevel!} properties:

\begin{lstlisting}
TransparencyLevelHint = new[] { WindowTransparencyLevel.Mica, WindowTransparencyLevel.Acrylic, WindowTransparencyLevel.Transparent };
SystemDecorations = SystemDecorations.None;
ExtendClientAreaToDecorationsHint = true;
ExtendClientAreaChromeHints = ExtendClientAreaChromeHints.SystemChrome | ExtendClientAreaChromeHints.OSXIssueUglyDropShadowHack;
WindowStartupLocation = WindowStartupLocation.CenterScreen;
\end{lstlisting}

Combine those settings with platform options to unlock OS-specific
effects:

\begin{itemize}
\tightlist
\item
  \textbf{Windows} (\passthrough{\lstinline!Win32PlatformOptions!}):
  enable \passthrough{\lstinline!CompositionBackdrop!} or
  \passthrough{\lstinline!UseWgl!} for specific GPU paths. Set
  \passthrough{\lstinline!WindowEffect = new MicaEffect();!} to match
  Windows 11 styling.
\item
  \textbf{macOS} (\passthrough{\lstinline!MacOSPlatformOptions!}):
  toggle \passthrough{\lstinline!ShowInDock!},
  \passthrough{\lstinline!DisableDefaultApplicationMenu!}, and
  \passthrough{\lstinline!UseNativeMenuBar!} per window.
\item
  \textbf{Linux/X11} (\passthrough{\lstinline!X11PlatformOptions!}):
  control \passthrough{\lstinline!EnableIME!},
  \passthrough{\lstinline!EnableTransparency!}, and
  \passthrough{\lstinline!DisableDecorations!} when providing custom
  chrome.
\end{itemize}

Always test transparency fallbacks---older GPUs may fall back to
\passthrough{\lstinline!Opaque!}. Query
\passthrough{\lstinline!ActualTransparencyLevel!} at runtime to reflect
final behaviour in the UI.

\subsubsection{\texorpdfstring{2.7 Coordinating shutdown with
\texttt{ShutdownRequestedEventArgs}}{2.7 Coordinating shutdown with ShutdownRequestedEventArgs}}\label{coordinating-shutdown-with-shutdownrequestedeventargs}

\passthrough{\lstinline!IClassicDesktopStyleApplicationLifetime!}
exposes a \passthrough{\lstinline!ShutdownRequested!} event. Cancel it
when critical work is in progress or when you must prompt the user:

\begin{lstlisting}
if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
{
    desktop.ShutdownRequested += (_, e) =>
    {
        if (_documentStore.HasDirtyDocuments && !ConfirmShutdown())
            e.Cancel = true;

        if (e.IsOSShutdown)
            Logger.LogWarning("OS initiated shutdown");
    };
}
\end{lstlisting}

Return \passthrough{\lstinline!true!} from
\passthrough{\lstinline!ConfirmShutdown()!} only after persisting state
or when the user explicitly approves. Pair this with
\passthrough{\lstinline!ShutdownMode!} to decide whether closing the
main window exits the entire application.

\subsection{3. Navigation patterns}\label{navigation-patterns}

\subsubsection{3.1 Content control navigation (shared for desktop \&
mobile)}\label{content-control-navigation-shared-for-desktop-mobile}

\begin{lstlisting}
public sealed class NavigationService : INavigationService
{
    private readonly IServiceProvider _services;
    private object? _current;

    public object? Current
    {
        get => _current;
        private set => _current = value;
    }

    public NavigationService(IServiceProvider services)
        => _services = services;

    public void NavigateTo<TViewModel>() where TViewModel : class
        => Current = _services.GetRequiredService<TViewModel>();
}
\end{lstlisting}

\passthrough{\lstinline!ShellViewModel!} coordinates navigation:

\begin{lstlisting}
public sealed class ShellViewModel : ObservableObject
{
    private readonly INavigationService _navigationService;
    public object? Current => _navigationService.Current;

    public RelayCommand GoHome { get; }
    public RelayCommand GoSettings { get; }

    public ShellViewModel(INavigationService navigationService)
    {
        _navigationService = navigationService;
        GoHome = new RelayCommand(_ => _navigationService.NavigateTo<HomeViewModel>());
        GoSettings = new RelayCommand(_ => _navigationService.NavigateTo<SettingsViewModel>());
        _navigationService.NavigateTo<HomeViewModel>();
    }
}
\end{lstlisting}

Bind in view:

\begin{lstlisting}[language=XML]
<DockPanel>
  <StackPanel DockPanel.Dock="Top" Orientation="Horizontal" Spacing="8">
    <Button Content="Home" Command="{Binding GoHome}"/>
    <Button Content="Settings" Command="{Binding GoSettings}"/>
  </StackPanel>
  <TransitioningContentControl Content="{Binding Current}">
    <TransitioningContentControl.Transitions>
      <PageSlide Transition="{Transitions:Slide FromRight}" Duration="0:0:0.2"/>
    </TransitioningContentControl.Transitions>
  </TransitioningContentControl>
</DockPanel>
\end{lstlisting}

\passthrough{\lstinline!TransitioningContentControl!} (from
\passthrough{\lstinline!Avalonia.Controls!}) adds page transitions.
Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TransitioningContentControl.cs}{\passthrough{\lstinline!TransitioningContentControl.cs!}}.

\subsubsection{3.2 View mapping via
DataTemplates}\label{view-mapping-via-datatemplates}

Register view-model-to-view templates (Chapter 11 showed details).
Example snippet:

\begin{lstlisting}[language=XML]
<Application.DataTemplates>
  <DataTemplate DataType="{x:Type vm:HomeViewModel}">
    <views:HomeView />
  </DataTemplate>
  <DataTemplate DataType="{x:Type vm:SettingsViewModel}">
    <views:SettingsView />
  </DataTemplate>
</Application.DataTemplates>
\end{lstlisting}

\subsubsection{3.3 SplitView shell
navigation}\label{splitview-shell-navigation}

For sidebars or hamburger menus, wrap the navigation service in a
\passthrough{\lstinline!SplitView!} so content and commands share a
host:

\begin{lstlisting}[language=XML]
<SplitView IsPaneOpen="{Binding IsPaneOpen}"
           DisplayMode="CompactOverlay"
           CompactPaneLength="48"
           OpenPaneLength="200">
  <SplitView.Pane>
    <ItemsControl ItemsSource="{Binding NavigationItems}">
      <ItemsControl.ItemTemplate>
        <DataTemplate>
          <Button Content="{Binding Title}"
                  Command="{Binding NavigateCommand}"/>
        </DataTemplate>
      </ItemsControl.ItemTemplate>
    </ItemsControl>
  </SplitView.Pane>
  <TransitioningContentControl Content="{Binding Current}"/>
</SplitView>
\end{lstlisting}

Expose \passthrough{\lstinline!NavigationItems!} as view-model
descriptors (title + command). Pair with
\passthrough{\lstinline!SplitView.PanePlacement!} to adapt between
desktop (left rail) and mobile (bottom sheet). Listen to
\passthrough{\lstinline!TopLevel.BackRequested!} to collapse the pane
when the host (Android, browser, web view) signals a system back
gesture.

\subsubsection{3.4 Dialog service
abstraction}\label{dialog-service-abstraction}

Expose a dialog API from view models without referencing
\passthrough{\lstinline!Window!}:

\begin{lstlisting}
public interface IDialogService
{
    Task<bool> ShowConfirmationAsync(string title, string message);
}

public sealed class DialogService : IDialogService
{
    private readonly Window _owner;
    public DialogService(Window owner) => _owner = owner;

    public async Task<bool> ShowConfirmationAsync(string title, string message)
    {
        var dialog = new ConfirmationWindow(title, message) { Owner = _owner };
        return await dialog.ShowDialog<bool>(_owner);
    }
}
\end{lstlisting}

Register a per-window dialog service in DI. For single-view scenarios,
use \passthrough{\lstinline!TopLevel.GetTopLevel(control)!} to retrieve
the root and use \passthrough{\lstinline!StorageProvider!} or custom
dialogs.

\subsection{4. Single-view navigation
(mobile/web)}\label{single-view-navigation-mobileweb}

For \passthrough{\lstinline!ISingleViewApplicationLifetime!}, use a root
\passthrough{\lstinline!UserControl!} (e.g.,
\passthrough{\lstinline!ShellView!}) with the same
\passthrough{\lstinline!TransitioningContentControl!} pattern. Keep
navigation inside that control.

\begin{lstlisting}[language=XML]
<UserControl xmlns="https://github.com/avaloniaui" x:Class="MyApp.Views.ShellView">
  <TransitioningContentControl Content="{Binding Current}"/>
</UserControl>
\end{lstlisting}

From view models, use \passthrough{\lstinline!INavigationService!} as
before; the lifetime determines whether a window or root view hosts the
content.

\subsection{5. TopLevel services: clipboard, storage,
screens}\label{toplevel-services-clipboard-storage-screens}

\passthrough{\lstinline!TopLevel.GetTopLevel(control)!} returns the
hosting top-level (Window or root). Useful for services.

\subsubsection{5.1 Clipboard}\label{clipboard}

\begin{lstlisting}
var topLevel = TopLevel.GetTopLevel(control);
if (topLevel?.Clipboard is { } clipboard)
{
    await clipboard.SetTextAsync("Copied text");
}
\end{lstlisting}

Clipboard API defined in
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/Platform/IClipboard.cs}{\passthrough{\lstinline!IClipboard!}}.

\subsubsection{5.2 Storage provider}\label{storage-provider}

Works in both desktop and single-view (browser has OS limitations):

\begin{lstlisting}
var topLevel = TopLevel.GetTopLevel(control);
if (topLevel?.StorageProvider is { } sp)
{
    var file = (await sp.OpenFilePickerAsync(new FilePickerOpenOptions
    {
        AllowMultiple = false,
        FileTypeFilter = new[] { FilePickerFileTypes.TextPlain }
    })).FirstOrDefault();
}
\end{lstlisting}

\subsubsection{5.3 Screens info}\label{screens-info}

\passthrough{\lstinline"topLevel!.Screens"} provides monitor layout. Use
for placing dialogs on active monitor or respecting working area.

\subsubsection{5.4 System back navigation}\label{system-back-navigation}

\passthrough{\lstinline!TopLevel.BackRequested!} bubbles up hardware or
browser navigation gestures through Avalonia's
\passthrough{\lstinline!ISystemNavigationManagerImpl!}. Subscribe to it
when embedding in Android, browser, or platform WebView hosts:

\begin{lstlisting}
var topLevel = TopLevel.GetTopLevel(control);
if (topLevel is { })
{
    topLevel.BackRequested += (_, e) =>
    {
        if (_navigation.Pop())
            e.Handled = true;
    };
}
\end{lstlisting}

Mark the event as handled when your navigation stack consumes the back
action; otherwise Avalonia lets the host perform its default behaviour
(e.g., browser history navigation).

\subsection{6. Browser (WebAssembly)
considerations}\label{browser-webassembly-considerations}

Use \passthrough{\lstinline!BrowserAppBuilder!} and
\passthrough{\lstinline!BrowserSingleViewLifetime!}:

\begin{lstlisting}
public static void Main(string[] args)
    => BuildAvaloniaApp().SetupBrowserApp("app");
\end{lstlisting}

Use \passthrough{\lstinline!TopLevel.StorageProvider!} for limited file
access (via JavaScript APIs). Use JS interop for features missing from
storage provider. \passthrough{\lstinline!TopLevel.BackRequested!} maps
to the browser's history stack---handle it to keep SPA navigation in
sync with the host's back button.

\subsection{7. Practice exercises}\label{practice-exercises-6}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Spawn a secondary tool window from the shell, handle
  \passthrough{\lstinline!WindowBase.Resized!}/\passthrough{\lstinline!PositionChanged!},
  and persist placement per monitor.
\item
  Hook \passthrough{\lstinline!ShutdownRequested!} to prompt about
  unsaved documents, cancelling the shutdown when the user declines.
\item
  Subscribe to \passthrough{\lstinline!Screens.Changed!} and reposition
  floating windows onto the active display when monitors are
  hot-plugged.
\item
  Build a \passthrough{\lstinline!SplitView!} navigation shell that
  collapses in response to
  \passthrough{\lstinline!TopLevel.BackRequested!} on Android or the
  browser.
\item
  Toggle \passthrough{\lstinline!TransparencyLevelHint!} and
  \passthrough{\lstinline!SystemDecorations!} per platform and display
  the resulting \passthrough{\lstinline!ActualTransparencyLevel!} in the
  UI.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-10}

\begin{itemize}
\tightlist
\item
  Window management:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Window.cs}{\passthrough{\lstinline!Window.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/WindowBase.cs}{\passthrough{\lstinline!WindowBase.cs!}}
\item
  Lifetimes \& shutdown:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs}{\passthrough{\lstinline!ClassicDesktopStyleApplicationLifetime.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ShutdownRequestedEventArgs.cs}{\passthrough{\lstinline!ShutdownRequestedEventArgs.cs!}}
\item
  Navigation surfaces:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TopLevel.cs}{\passthrough{\lstinline!TopLevel.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SplitView.cs}{\passthrough{\lstinline!SplitView.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/SystemNavigationManagerImpl.cs}{\passthrough{\lstinline!SystemNavigationManagerImpl.cs!}}
\item
  Screens API:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Screens.cs}{\passthrough{\lstinline!Screens.cs!}}
\item
  Transitioning content:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TransitioningContentControl.cs}{\passthrough{\lstinline!TransitioningContentControl.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-10}

\begin{itemize}
\tightlist
\item
  How does
  \passthrough{\lstinline!ClassicDesktopStyleApplicationLifetime!}
  differ from \passthrough{\lstinline!SingleViewApplicationLifetime!}
  when showing windows?
\item
  When should you use \passthrough{\lstinline!Show!} vs
  \passthrough{\lstinline!ShowDialog!}? Why set
  \passthrough{\lstinline!Owner!}?
\item
  Which \passthrough{\lstinline!WindowBase!} events fire before layout,
  and how do they differ from \passthrough{\lstinline!SizeChanged!}?
\item
  How can \passthrough{\lstinline!TopLevel.BackRequested!} improve the
  experience on Android or the browser?
\item
  What does
  \passthrough{\lstinline!ShutdownRequestedEventArgs.IsOSShutdown!} tell
  you, and how would you react to it?
\item
  Which \passthrough{\lstinline!TopLevel!} service would you use to
  access the clipboard or file picker from a view model?
\end{itemize}

What's next - Next: \href{Chapter13.md}{Chapter 13}

\newpage

\subsection{13. Menus, dialogs, tray icons, and system
features}\label{menus-dialogs-tray-icons-and-system-features}

Goal - Wire desktop menus, context menus, and native menu bars using
\passthrough{\lstinline!Menu!}, \passthrough{\lstinline!MenuItem!},
\passthrough{\lstinline!ContextMenu!}, and
\passthrough{\lstinline!NativeMenu!}. - Surface dialogs through
MVVM-friendly services that switch between
\passthrough{\lstinline!ManagedFileChooser!},
\passthrough{\lstinline!SystemDialog!}, and storage providers. -
Integrate tray icons, notifications, and app-level commands with the
\passthrough{\lstinline!TrayIcon!} API and
\passthrough{\lstinline!TopLevel!} services. - Document
platform-specific behaviour so menus, dialogs, and tray features degrade
gracefully.

Why this matters - Desktop users expect menu bars, keyboard
accelerators, and tray icons that follow their OS conventions. - Dialog
flows that stay inside services remain unit-testable and work across
desktop, mobile, and browser hosts. - System integrations (storage,
notifications, clipboard) require a clear view of per-platform
capabilities to avoid runtime surprises.

Prerequisites - Chapters 9 (commands and input), 11 (MVVM patterns), and
12 (lifetimes and windowing).

Key namespaces -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Menu.cs}{\passthrough{\lstinline!Menu.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/MenuItem.cs}{\passthrough{\lstinline!MenuItem.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/NativeMenu.cs}{\passthrough{\lstinline!NativeMenu.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ContextMenu.cs}{\passthrough{\lstinline!ContextMenu.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TrayIcon.cs}{\passthrough{\lstinline!TrayIcon.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SystemDialog.cs}{\passthrough{\lstinline!SystemDialog.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Dialogs/ManagedFileChooser.cs}{\passthrough{\lstinline!ManagedFileChooser.cs!}}

\subsection{1. Menu surfaces at a
glance}\label{menu-surfaces-at-a-glance}

\subsubsection{\texorpdfstring{1.1 In-window menus
(\texttt{Menu}/\texttt{MenuItem})}{1.1 In-window menus (Menu/MenuItem)}}\label{in-window-menus-menumenuitem}

\begin{lstlisting}[language=XML]
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Class="MyApp.MainWindow"
        Title="My App" Width="1000" Height="700">
  <DockPanel>
    <Menu DockPanel.Dock="Top">
      <MenuItem Header="_File">
        <MenuItem Header="_New" Command="{Binding AppCommands.New}" HotKey="Ctrl+N"/>
        <MenuItem Header="_Open..." Command="{Binding AppCommands.Open}" HotKey="Ctrl+O"/>
        <MenuItem Header="_Save" Command="{Binding AppCommands.Save}" HotKey="Ctrl+S"/>
        <MenuItem Header="Save _As..." Command="{Binding AppCommands.SaveAs}"/>
        <Separator/>
        <MenuItem Header="E_xit" Command="{Binding AppCommands.Exit}"/>
      </MenuItem>
      <MenuItem Header="_Edit">
        <MenuItem Header="_Undo" Command="{Binding AppCommands.Undo}"/>
        <MenuItem Header="_Redo" Command="{Binding AppCommands.Redo}"/>
      </MenuItem>
      <MenuItem Header="_Help">
        <MenuItem Header="_About" Command="{Binding AppCommands.ShowAbout}"/>
      </MenuItem>
    </Menu>

    <ContentControl Content="{Binding CurrentView}"/>
  </DockPanel>
</Window>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!MenuItem.HotKey!} accepts
  \passthrough{\lstinline!KeyGesture!} syntax, keeping accelerators in
  sync with displayed text.
\item
  \passthrough{\lstinline!AppCommands!} is a shared command aggregate in
  the view model layer; use the same instances for menus, toolbars, and
  tray commands so \passthrough{\lstinline!CanExecute!} state stays
  consistent.
\item
  Add \passthrough{\lstinline!KeyBinding!} entries on the window so
  shortcuts remain active even when focus is inside a text box:
\end{itemize}

\begin{lstlisting}[language=XML]
<Window.InputBindings>
  <KeyBinding Gesture="Ctrl+N" Command="{Binding AppCommands.New}"/>
  <KeyBinding Gesture="Ctrl+O" Command="{Binding AppCommands.Open}"/>
</Window.InputBindings>
\end{lstlisting}

\subsubsection{1.2 Native menus and the macOS menu
bar}\label{native-menus-and-the-macos-menu-bar}

\passthrough{\lstinline!NativeMenu!} exports menu metadata to the host
OS when available (macOS, some Linux environments). Attach it to the
\passthrough{\lstinline!TopLevel!} so Avalonia's native exporters keep
it in sync with window focus.

\begin{lstlisting}
public override void OnFrameworkInitializationCompleted()
{
    if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
    {
        var window = Services.GetRequiredService<MainWindow>();
        desktop.MainWindow = window;

        NativeMenu.SetMenu(window, BuildNativeMenu());
    }

    base.OnFrameworkInitializationCompleted();
}

private static NativeMenu BuildNativeMenu()
{
    var appMenu = new NativeMenu
    {
        new NativeMenuItem("About", (_, _) => Locator.Commands.ShowAbout.Execute(null)),
        new NativeMenuItemSeparator(),
        new NativeMenuItem("Quit", (_, _) => Locator.Commands.Exit.Execute(null))
    };

    var fileMenu = new NativeMenu
    {
        new NativeMenuItem("New", (_, _) => Locator.Commands.New.Execute(null))
        {
            Gesture = new KeyGesture(Key.N, KeyModifiers.Control)
        },
        new NativeMenuItem("Open...", (_, _) => Locator.Commands.Open.Execute(null))
    };

    return new NativeMenu
    {
        new NativeMenuItem("MyApp") { Menu = appMenu },
        new NativeMenuItem("File") { Menu = fileMenu }
    };
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!NativeMenuItem.Gesture!} mirrors
  \passthrough{\lstinline!MenuItem.HotKey!} and feeds the OS accelerator
  tables.
\item
  Use \passthrough{\lstinline!NativeMenuBar!} in XAML when you want
  markup control over the native bar:
\end{itemize}

\begin{lstlisting}[language=XML]
<native:NativeMenuBar DockPanel.Dock="Top">
  <native:NativeMenuBar.Menu>
    <native:NativeMenu>
      <native:NativeMenuItem Header="My App">
        <native:NativeMenuItem Header="About" Command="{Binding AppCommands.ShowAbout}"/>
      </native:NativeMenuItem>
      <native:NativeMenuItem Header="File">
        <native:NativeMenuItem Header="New" Command="{Binding AppCommands.New}"/>
      </native:NativeMenuItem>
    </native:NativeMenu>
  </native:NativeMenuBar.Menu>
</native:NativeMenuBar>
\end{lstlisting}

\subsubsection{1.3 Command state and
routing}\label{command-state-and-routing}

\passthrough{\lstinline!MenuItem!} observes
\passthrough{\lstinline!ICommand.CanExecute!}. Use commands that publish
notifications (\passthrough{\lstinline!ReactiveCommand!},
\passthrough{\lstinline!DelegateCommand!}) and call
\passthrough{\lstinline!RaiseCanExecuteChanged()!} whenever state
changes. Keep command instances long-lived (registered in DI or a
singleton \passthrough{\lstinline!AppCommands!} class) so every menu,
toolbar, context menu, and tray icon reflects the same enable/disable
state.

\subsection{2. Context menus and
flyouts}\label{context-menus-and-flyouts}

Attach \passthrough{\lstinline!ContextMenu!} to items directly or via
styles so each container gets the same commands:

\begin{lstlisting}[language=XML]
<ListBox Items="{Binding Documents}" SelectedItem="{Binding SelectedDocument}">
  <ListBox.Styles>
    <Style Selector="ListBoxItem">
      <Setter Property="ContextMenu">
        <ContextMenu>
          <MenuItem Header="Rename"
                    Command="{Binding DataContext.Rename, RelativeSource={RelativeSource AncestorType=ListBox}}"
                    CommandParameter="{Binding}"/>
          <MenuItem Header="Delete"
                    Command="{Binding DataContext.Delete, RelativeSource={RelativeSource AncestorType=ListBox}}"
                    CommandParameter="{Binding}"/>
        </ContextMenu>
      </Setter>
    </Style>
  </ListBox.Styles>
</ListBox>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!RelativeSource AncestorType=ListBox!} bridges
  from the item container back to the list's data context.
\item
  For richer layouts (toggles, sliders, forms) use
  \passthrough{\lstinline!Flyout!} or
  \passthrough{\lstinline!MenuFlyout!} -- both live in
  \passthrough{\lstinline!Avalonia.Controls!} and share placement logic
  with context menus.
\item
  Remember accessibility: set
  \passthrough{\lstinline!MenuItem.InputGestureText!} or
  \passthrough{\lstinline!HotKey!} so screen readers announce shortcuts.
\end{itemize}

\subsection{3. Dialog pipelines}\label{dialog-pipelines}

\subsubsection{3.1 Define a dialog service
interface}\label{define-a-dialog-service-interface}

\begin{lstlisting}
public interface IFileDialogService
{
    Task<IReadOnlyList<FilePickResult>> PickFilesAsync(FilePickerOpenOptions options, CancellationToken ct = default);
    Task<FilePickResult?> SaveFileAsync(FilePickerSaveOptions options, CancellationToken ct = default);
    Task<IReadOnlyList<FilePickResult>> PickFoldersAsync(FolderPickerOpenOptions options, CancellationToken ct = default);
}

public record FilePickResult(string Path, IStorageItem? Handle);
\end{lstlisting}

Expose the service through dependency injection so view models request
it instead of referencing \passthrough{\lstinline!Window!} or
\passthrough{\lstinline!TopLevel!}.

\subsubsection{\texorpdfstring{3.2 Choose between
\texttt{IStorageProvider}, \texttt{SystemDialog}, and
\texttt{ManagedFileChooser}}{3.2 Choose between IStorageProvider, SystemDialog, and ManagedFileChooser}}\label{choose-between-istorageprovider-systemdialog-and-managedfilechooser}

\passthrough{\lstinline!TopLevel.StorageProvider!} supplies the native
picker implementation (\passthrough{\lstinline!IStorageProvider!}). When
it is unavailable (custom hosts, limited backends), fall back to the
managed dialog stack built on
\passthrough{\lstinline!ManagedFileChooser!}. The extension method
\passthrough{\lstinline!OpenFileDialog.ShowManagedAsync!} renders the
managed UI and is enabled automatically when you call
\passthrough{\lstinline!AppBuilder.UseManagedSystemDialogs()!} during
startup.

\begin{lstlisting}
using Avalonia.Dialogs;
using Avalonia.Platform.Storage;

public sealed class FileDialogService : IFileDialogService
{
    private readonly TopLevel _topLevel;

    public FileDialogService(TopLevel topLevel) => _topLevel = topLevel;

    public async Task<IReadOnlyList<FilePickResult>> PickFilesAsync(FilePickerOpenOptions options, CancellationToken ct = default)
    {
        var provider = _topLevel.StorageProvider;
        if (provider is { CanOpen: true })
        {
            var files = await provider.OpenFilePickerAsync(options, ct);
            return files.Select(f => new FilePickResult(f.TryGetLocalPath() ?? f.Name, f)).ToArray();
        }

        if (_topLevel is Window window)
        {
            var dialog = new OpenFileDialog { AllowMultiple = options.AllowMultiple };
            var paths = await dialog.ShowManagedAsync(window, new ManagedFileDialogOptions());
            return paths.Select(p => new FilePickResult(p, handle: null)).ToArray();
        }

        return Array.Empty<FilePickResult>();
    }

    public async Task<FilePickResult?> SaveFileAsync(FilePickerSaveOptions options, CancellationToken ct = default)
    {
        var provider = _topLevel.StorageProvider;
        if (provider is { CanSave: true })
        {
            var file = await provider.SaveFilePickerAsync(options, ct);
            return file is null ? null : new FilePickResult(file.TryGetLocalPath() ?? file.Name, file);
        }

        if (_topLevel is Window window)
        {
            var dialog = new SaveFileDialog
            {
                DefaultExtension = options.DefaultExtension,
                InitialFileName = options.SuggestedFileName
            };
            var path = await dialog.ShowAsync(window);
            return path is null ? null : new FilePickResult(path, handle: null);
        }

        return null;
    }

    public async Task<IReadOnlyList<FilePickResult>> PickFoldersAsync(FolderPickerOpenOptions options, CancellationToken ct = default)
    {
        var provider = _topLevel.StorageProvider;
        if (provider is { CanPickFolder: true })
        {
            var folders = await provider.OpenFolderPickerAsync(options, ct);
            return folders.Select(f => new FilePickResult(f.TryGetLocalPath() ?? f.Name, f)).ToArray();
        }

        if (_topLevel is Window window)
        {
            var dialog = new OpenFolderDialog();
            var path = await dialog.ShowAsync(window);
            return path is null
                ? Array.Empty<FilePickResult>()
                : new[] { new FilePickResult(path, handle: null) };
        }

        return Array.Empty<FilePickResult>();
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!OpenFileDialog!},
  \passthrough{\lstinline!SaveFileDialog!}, and
  \passthrough{\lstinline!OpenFolderDialog!} derive from
  \passthrough{\lstinline!SystemDialog!}. They remain useful when you
  need to force specific behaviour or when the platform lacks a proper
  storage provider.
\item
  \passthrough{\lstinline!AppBuilder.UseManagedSystemDialogs()!}
  configures Avalonia to instantiate
  \passthrough{\lstinline!ManagedFileChooser!} by default whenever a
  native dialog is unavailable.
\item
  Treat \passthrough{\lstinline!FilePickResult.Handle!} as optional: on
  browser/mobile targets you might only receive virtual URIs, while
  desktop gives full file system access.
\end{itemize}

\subsection{4. Tray icons, notifications, and app
commands}\label{tray-icons-notifications-and-app-commands}

The tray API exports icons through the
\passthrough{\lstinline!Application!}. Add them during application
initialization so they follow the application lifetime automatically.

\begin{lstlisting}
public override void Initialize()
{
    base.Initialize();

    if (ApplicationLifetime is not IClassicDesktopStyleApplicationLifetime)
        return;

    var trayIcons = new TrayIcons
    {
        new TrayIcon
        {
            Icon = new WindowIcon("avares://MyApp/Assets/App.ico"),
            ToolTipText = "My App",
            Menu = new NativeMenu
            {
                new NativeMenuItem("Show", (_, _) => Locator.Commands.ShowMain.Execute(null)),
                new NativeMenuItemSeparator(),
                new NativeMenuItem("Exit", (_, _) => Locator.Commands.Exit.Execute(null))
            }
        }
    };

    TrayIcon.SetIcons(this, trayIcons);
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  Toggle \passthrough{\lstinline!TrayIcon.IsVisible!} in response to
  \passthrough{\lstinline!Window!} events to implement ``minimize to
  tray''. Guard the feature by checking
  \passthrough{\lstinline!TrayIcon.SetIcons!} only when running with a
  desktop lifetime.
\item
  \passthrough{\lstinline!NativeMenu!} attached to a tray icon becomes
  the right-click menu. Reuse the same command implementations that
  power your primary menu to avoid duplication.
\item
  Detect tray support by asking
  \passthrough{\lstinline!AvaloniaLocator.Current.GetService<IWindowingPlatform>()?.CreateTrayIcon()!}
  inside a try/catch before you rely on it.
\end{itemize}

In-app notifications come from
\passthrough{\lstinline!Avalonia.Controls.Notifications!}:

\begin{lstlisting}
using Avalonia.Controls.Notifications;

var manager = new WindowNotificationManager(_desktopLifetime.MainWindow!)
{
    Position = NotificationPosition.TopRight,
    MaxItems = 3
};

manager.Show(new Notification("Saved", "Document saved successfully", NotificationType.Success));
\end{lstlisting}

\subsection{5. Top-level services and system
integrations}\label{top-level-services-and-system-integrations}

\passthrough{\lstinline!TopLevel!} exposes cross-platform services you
should wrap behind interfaces for testability:

\begin{lstlisting}
public interface IClipboardService
{
    Task SetTextAsync(string text);
    Task<string?> GetTextAsync();
}

public sealed class ClipboardService : IClipboardService
{
    private readonly TopLevel _topLevel;
    public ClipboardService(TopLevel topLevel) => _topLevel = topLevel;

    public Task SetTextAsync(string text) => _topLevel.Clipboard?.SetTextAsync(text) ?? Task.CompletedTask;
    public Task<string?> GetTextAsync() => _topLevel.Clipboard?.GetTextAsync() ?? Task.FromResult<string?>(null);
}
\end{lstlisting}

Other helpful services on \passthrough{\lstinline!TopLevel!}: -
\passthrough{\lstinline!Screens!} for multi-monitor awareness and DPI
scaling. - \passthrough{\lstinline!DragDrop!} helpers (covered in
Chapter 16) for integrating system drag-and-drop. -
\passthrough{\lstinline!TryGetFeature<T>!} for platform-specific
features (\passthrough{\lstinline!ITrayIconImpl!},
\passthrough{\lstinline!IPlatformThemeVariant!}).

\subsection{6. Platform notes}\label{platform-notes}

\begin{itemize}
\tightlist
\item
  \textbf{Windows} -- In-window \passthrough{\lstinline!Menu!} is
  standard. Tray icons appear in the notification area and expect
  \passthrough{\lstinline!.ico!} assets with multiple sizes. Native
  system dialogs are available; managed dialogs appear only if you opt
  in.
\item
  \textbf{macOS} -- Use
  \passthrough{\lstinline!NativeMenu!}/\passthrough{\lstinline!NativeMenuBar!}
  so menu items land in the global menu bar. Provide monochrome template
  tray icons via
  \passthrough{\lstinline!MacOSProperties.SetIsTemplateIcon!}.
\item
  \textbf{Linux} -- Desktop environments vary. Ship an in-window
  \passthrough{\lstinline!Menu!} even if you export a
  \passthrough{\lstinline!NativeMenu!}. Tray support may require
  AppIndicator or extensions.
\item
  \textbf{Mobile (Android/iOS)} -- Skip menu bars and tray icons.
  Replace them with toolbars, flyouts, and platform navigation. Storage
  providers surface document pickers that may not expose local file
  paths.
\item
  \textbf{Browser} -- No native menus or tray. Use in-app overlays and
  rely on the browser storage APIs
  (\passthrough{\lstinline!BrowserStorageProvider!}). Managed dialogs
  are not available.
\end{itemize}

\subsection{7. Practice exercises}\label{practice-exercises-7}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Build a shared \passthrough{\lstinline!AppCommands!} class that drives
  in-window menus, a \passthrough{\lstinline!NativeMenu!}, and a
  toolbar, verifying that \passthrough{\lstinline!CanExecute!} disables
  items everywhere.
\item
  Implement the dialog service above and log whether each operation used
  \passthrough{\lstinline!IStorageProvider!},
  \passthrough{\lstinline!SystemDialog!}, or
  \passthrough{\lstinline!ManagedFileChooser!}. Run it on Windows,
  macOS, and Linux to compare behaviour.
\item
  Add a tray icon that toggles a ``compact mode'': closing the window
  hides it, the tray command re-opens it, and the tray menu reflects the
  current state.
\item
  Provide context menus for list items that reuse the same commands as
  the main menu. Confirm command parameters work for both entry points.
\item
  Surface toast notifications for long-running operations using
  \passthrough{\lstinline!WindowNotificationManager!}, and ensure they
  disappear automatically when the user navigates away.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-11}

\begin{itemize}
\tightlist
\item
  Menus and native export:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Menu.cs}{\passthrough{\lstinline!Menu.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/NativeMenu.Export.cs}{\passthrough{\lstinline!NativeMenu.Export.cs!}}
\item
  Context menus \& flyouts:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ContextMenu.cs}{\passthrough{\lstinline!ContextMenu.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Flyouts/FlyoutBase.cs}{\passthrough{\lstinline!FlyoutBase.cs!}}
\item
  Dialog infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/SystemDialog.cs}{\passthrough{\lstinline!SystemDialog.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Dialogs/ManagedFileChooser.cs}{\passthrough{\lstinline!ManagedFileChooser.cs!}}
\item
  Storage provider abstractions:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/IStorageProvider.cs}{\passthrough{\lstinline!IStorageProvider.cs!}}
\item
  Tray icons:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TrayIcon.cs}{\passthrough{\lstinline!TrayIcon.cs!}}
\item
  Notifications:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls.Notifications/WindowNotificationManager.cs}{\passthrough{\lstinline!WindowNotificationManager.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-11}

\begin{itemize}
\tightlist
\item
  How do \passthrough{\lstinline!MenuItem!} and
  \passthrough{\lstinline!NativeMenuItem!} share the same command
  instances, and why does that matter for
  \passthrough{\lstinline!CanExecute!}?
\item
  When would you enable
  \passthrough{\lstinline!UseManagedSystemDialogs!}, and what UX
  differences should you anticipate compared to native dialogs?
\item
  Which \passthrough{\lstinline!TopLevel!} services help you access
  storage, clipboard, and screens without referencing
  \passthrough{\lstinline!Window!} in view models?
\item
  How can you detect tray icon availability before exposing
  tray-dependent features?
\item
  What platform-specific adjustments do macOS and Linux require for
  menus and tray icons?
\end{itemize}

What's next - Next: \href{Chapter14.md}{Chapter 14}

\newpage

\subsection{14. Lists, virtualization, and
performance}\label{lists-virtualization-and-performance}

Goal - Choose the right items control
(\passthrough{\lstinline!ItemsControl!},
\passthrough{\lstinline!ListBox!}, \passthrough{\lstinline!TreeView!},
\passthrough{\lstinline!DataGrid!},
\passthrough{\lstinline!ItemsRepeater!}) for the data shape and user
interactions you need. - Understand the
\passthrough{\lstinline!ItemsControl!} pipeline
(\passthrough{\lstinline!ItemsSourceView!}, item container generator,
\passthrough{\lstinline!ItemsPresenter!}) and how virtualization keeps
UIs responsive. - Apply virtualization techniques
(\passthrough{\lstinline!VirtualizingStackPanel!},
\passthrough{\lstinline!ItemsRepeater!} layouts) alongside incremental
loading and selection synchronization with
\passthrough{\lstinline!SelectionModel!}. - Diagnose virtualization
regressions using DevTools, logging, and layout instrumentation.

Why this matters - Lists power dashboards, log viewers, chat apps, and
tables; poorly configured lists can freeze your UI. - Virtualization
keeps memory and CPU usage manageable even with hundreds of thousands of
rows. - Knowing the pipeline lets you extend list controls, add
grouping, or inject placeholders without breaking performance.

Prerequisites - Binding and commands (Chapters 8--9), MVVM patterns
(Chapter 11), styling and resources (Chapter 10).

Key namespaces -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ItemsControl.cs}{\passthrough{\lstinline!ItemsControl.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ItemsSourceView.cs}{\passthrough{\lstinline!ItemsSourceView.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Generators/ItemContainerGenerator.cs}{\passthrough{\lstinline!ItemContainerGenerator.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/VirtualizingStackPanel.cs}{\passthrough{\lstinline!VirtualizingStackPanel.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Primitives/ItemsPresenter.cs}{\passthrough{\lstinline!ItemsPresenter.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Selection/SelectionModel.cs}{\passthrough{\lstinline!SelectionModel.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Avalonia.Controls/ItemsRepeater}{\passthrough{\lstinline!ItemsRepeater!}}

\subsection{1. ItemsControl pipeline
overview}\label{itemscontrol-pipeline-overview}

Every items control follows the same data flow:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \passthrough{\lstinline!Items!}/\passthrough{\lstinline!ItemsSource!}
  is wrapped in an \passthrough{\lstinline!ItemsSourceView!} that
  projects the data as \passthrough{\lstinline!IReadOnlyList<object?>!},
  tracks the current item, and provides grouping hooks.
\item
  \passthrough{\lstinline!ItemContainerGenerator!} materializes
  containers (\passthrough{\lstinline!ListBoxItem!},
  \passthrough{\lstinline!TreeViewItem!}, etc.) for realized indices and
  recycles them when virtualization is enabled.
\item
  \passthrough{\lstinline!ItemsPresenter!} hosts the actual panel (by
  default \passthrough{\lstinline!StackPanel!} or
  \passthrough{\lstinline!VirtualizingStackPanel!}) and plugs into
  \passthrough{\lstinline!ScrollViewer!} to handle scrolling.
\item
  Templates render your view models inside each container.
\end{enumerate}

Inspecting the view and generator helps when debugging:

\begin{lstlisting}
var view = MyListBox.ItemsSourceView;
var current = view?.CurrentItem;

MyListBox.ItemContainerGenerator.Materialized += (_, e) =>
    Debug.WriteLine($"Realized range {e.StartIndex}..{e.StartIndex + e.Count - 1}");

MyListBox.ItemContainerGenerator.Dematerialized += (_, e) =>
    Debug.WriteLine($"Recycled {e.Count} containers");
\end{lstlisting}

Customize the items presenter when you need a different panel:

\begin{lstlisting}[language=XML]
<ListBox Items="{Binding Orders}">
  <ListBox.ItemsPanel>
    <ItemsPanelTemplate>
      <VirtualizingStackPanel Orientation="Vertical"/>
    </ItemsPanelTemplate>
  </ListBox.ItemsPanel>
</ListBox>
\end{lstlisting}

\passthrough{\lstinline!ItemsPresenter!} can also be styled to add
headers, footers, or empty-state placeholders while still respecting
virtualization.

\subsection{2. VirtualizingStackPanel in
practice}\label{virtualizingstackpanel-in-practice}

\passthrough{\lstinline!VirtualizingStackPanel!} implements
\passthrough{\lstinline!ILogicalScrollable!}, creating visuals only for
the viewport (plus a configurable buffer). Keep virtualization intact
by:

\begin{itemize}
\tightlist
\item
  Hosting the items panel directly inside a
  \passthrough{\lstinline!ScrollViewer!} (no extra wrappers between
  them).
\item
  Avoiding nested \passthrough{\lstinline!ScrollViewer!}s inside item
  templates.
\item
  Preferring fixed or predictable item sizes so layout calculations are
  cheap.
\end{itemize}

\begin{lstlisting}[language=XML]
<ListBox Items="{Binding People}"
         SelectedItem="{Binding Selected}"
         Height="360"
         ScrollViewer.HorizontalScrollBarVisibility="Disabled">
  <ListBox.ItemsPanel>
    <ItemsPanelTemplate>
      <VirtualizingStackPanel Orientation="Vertical"
                              AreHorizontalSnapPointsRegular="True"
                              CacheLength="1"/>
    </ItemsPanelTemplate>
  </ListBox.ItemsPanel>
  <ListBox.ItemTemplate>
    <DataTemplate x:DataType="vm:PersonViewModel">
      <Grid ColumnDefinitions="Auto,*,Auto" Height="48" Margin="4">
        <TextBlock Grid.Column="0" Text="{CompiledBinding Id}" Width="56" HorizontalAlignment="Right"/>
        <StackPanel Grid.Column="1" Orientation="Vertical" Margin="12,0" Spacing="2">
          <TextBlock Text="{CompiledBinding FullName}" FontWeight="SemiBold"/>
          <TextBlock Text="{CompiledBinding Email}" FontSize="12" Foreground="#6B7280"/>
        </StackPanel>
        <Button Grid.Column="2"
                Content="Open"
                Command="{Binding DataContext.Open, RelativeSource={RelativeSource AncestorType=ListBox}}"
                CommandParameter="{Binding}"/>
      </Grid>
    </DataTemplate>
  </ListBox.ItemTemplate>
</ListBox>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!CacheLength!} retains extra realized rows
  before and after the viewport (measured in viewport heights) for
  smoother scrolling.
\item
  \passthrough{\lstinline!ItemContainerGenerator.Materialized!} events
  confirm virtualization: the count should remain small even with large
  data sets.
\item
  Use \passthrough{\lstinline!CompiledBinding!} to avoid runtime
  reflection overhead when recycling containers.
\end{itemize}

\subsection{3. Optimising item
containers}\label{optimising-item-containers}

Container recycling reuses realized
\passthrough{\lstinline!ListBoxItem!} instances. Keep containers
lightweight:

\begin{itemize}
\tightlist
\item
  Offload expensive visuals into shared
  \passthrough{\lstinline!ControlTheme!} resources.
\item
  Style containers instead of adding extra elements for selection/hover
  state.
\end{itemize}

\begin{lstlisting}[language=XML]
<Style Selector="ListBoxItem:selected TextBlock.title">
  <Setter Property="Foreground" Value="{DynamicResource AccentBrush}"/>
</Style>
\end{lstlisting}

When you need to interact with containers manually, use
\passthrough{\lstinline!ItemContainerGenerator.ContainerFromIndex!}/\passthrough{\lstinline!IndexFromContainer!}
rather than walking the visual tree.

\subsection{4. ItemsRepeater for custom
layouts}\label{itemsrepeater-for-custom-layouts}

\passthrough{\lstinline!ItemsRepeater!} separates data virtualization
from layout so you can design custom grids or timelines.

\begin{lstlisting}[language=XML]
<controls:ItemsRepeater Items="{Binding Photos}"
                        xmlns:controls="clr-namespace:Avalonia.Controls;assembly=Avalonia.Controls">
  <controls:ItemsRepeater.Layout>
    <controls:UniformGridLayout Orientation="Vertical" MinItemWidth="220" MinItemHeight="180"/>
  </controls:ItemsRepeater.Layout>
  <controls:ItemsRepeater.ItemTemplate>
    <DataTemplate x:DataType="vm:PhotoViewModel">
      <Border Margin="8" Padding="8" Background="#111827" CornerRadius="6">
        <StackPanel>
          <Image Source="{CompiledBinding Thumbnail}" Width="204" Height="128" Stretch="UniformToFill"/>
          <TextBlock Text="{CompiledBinding Title}" Margin="0,8,0,0"/>
        </StackPanel>
      </Border>
    </DataTemplate>
  </controls:ItemsRepeater.ItemTemplate>
</controls:ItemsRepeater>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!ItemsRepeater.ItemsSourceView!} exposes the
  same API as \passthrough{\lstinline!ItemsControl!}, so you can layer
  grouping or filtering on top.
\item
  Implement a custom \passthrough{\lstinline!VirtualizingLayout!} when
  you need masonry or staggered layouts that still recycle elements.
\end{itemize}

\subsection{\texorpdfstring{5. Selection with
\texttt{SelectionModel}}{5. Selection with SelectionModel}}\label{selection-with-selectionmodel}

\passthrough{\lstinline!SelectionModel<T>!} tracks selection without
relying on realized containers, making it virtualization-friendly.

\begin{lstlisting}
public SelectionModel<PersonViewModel> PeopleSelection { get; } =
    new() { SelectionMode = SelectionMode.Multiple };
\end{lstlisting}

Bind directly:

\begin{lstlisting}[language=XML]
<ListBox Items="{Binding People}"
         Selection="{Binding PeopleSelection}"
         Height="360"/>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!SelectionModel.SelectedItems!} returns a
  snapshot of selected view models; use it for batch operations.
\item
  Hook \passthrough{\lstinline!SelectionModel.SelectionChanged!} to
  synchronize selection with other views or persisted state.
\item
  For custom surfaces (e.g., an \passthrough{\lstinline!ItemsRepeater!}
  dashboard), set
  \passthrough{\lstinline!selectionModel.Source = repeater.ItemsSourceView!}
  and drive selection manually.
\end{itemize}

\subsection{6. Incremental loading
patterns}\label{incremental-loading-patterns}

Load data in pages to keep virtualization responsive. The view model
owns the collection and exposes an async method that appends new items.

\begin{lstlisting}
public sealed class LogViewModel : ObservableObject
{
    private readonly ILogService _service;
    private readonly ObservableCollection<LogEntryViewModel> _entries = new();
    private bool _isLoading;
    private int _pageIndex;
    private const int PageSize = 500;

    public LogViewModel(ILogService service)
    {
        _service = service;
        Entries = new ReadOnlyObservableCollection<LogEntryViewModel>(_entries);
        _ = LoadMoreAsync();
    }

    public ReadOnlyObservableCollection<LogEntryViewModel> Entries { get; }
    public bool HasMore { get; private set; } = true;

    public async Task LoadMoreAsync()
    {
        if (_isLoading || !HasMore)
            return;

        _isLoading = true;
        try
        {
            var batch = await _service.GetEntriesAsync(_pageIndex, PageSize);
            foreach (var entry in batch)
                _entries.Add(new LogEntryViewModel(entry));

            _pageIndex++;
            HasMore = batch.Count == PageSize;
        }
        finally
        {
            _isLoading = false;
        }
    }
}
\end{lstlisting}

Trigger loading when the user scrolls near the end:

\begin{lstlisting}
private async void OnScrollChanged(object? sender, ScrollChangedEventArgs e)
{
    if (DataContext is LogViewModel vm &&
        vm.HasMore &&
        e.Source is ScrollViewer scroll &&
        scroll.Offset.Y + scroll.Viewport.Height >= scroll.Extent.Height - 200)
    {
        await vm.LoadMoreAsync();
    }
}
\end{lstlisting}

While loading, display lightweight placeholders (e.g., skeleton rows)
bound to \passthrough{\lstinline!IsLoading!} flags; keep them inside the
same template so virtualization still applies.

\subsection{7. Diagnosing virtualization
issues}\label{diagnosing-virtualization-issues}

When scrolling stutters or memory spikes:

\begin{itemize}
\tightlist
\item
  \textbf{DevTools ➔ Visual Tree}: select the list and open the
  \textbf{Diagnostics} tab to inspect realized item counts and
  virtualization mode.
\item
  Enable layout/render logging:
\end{itemize}

\begin{lstlisting}
AppBuilder.Configure<App>()
    .UsePlatformDetect()
    .LogToTrace(LogEventLevel.Debug, new[] { LogArea.Layout, LogArea.Rendering, LogArea.Control })
    .StartWithClassicDesktopLifetime(args);
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  Monitor
  \passthrough{\lstinline!ItemContainerGenerator.Materialized!}/\passthrough{\lstinline!Dematerialized!}
  events; if counts climb with scroll distance, virtualization is
  broken.
\item
  Verify the scroll host is the list's immediate parent; wrappers like
  \passthrough{\lstinline!StackPanel!} or \passthrough{\lstinline!Grid!}
  can disable virtualization.
\item
  Profile templates with \passthrough{\lstinline!dotnet-trace!} or
  \passthrough{\lstinline!dotnet-counters!} to spot expensive bindings
  or allocations while scrolling.
\end{itemize}

\subsection{8. Practice exercises}\label{practice-exercises-8}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Inspect \passthrough{\lstinline!ItemsControl.ItemsSourceView!} for a
  dashboard list and log the current item index whenever selection
  changes. Explain how it differs from binding directly to
  \passthrough{\lstinline!ItemsSource!}.
\item
  Convert a slow \passthrough{\lstinline!ItemsControl!} to a virtualized
  \passthrough{\lstinline!ListBox!} with
  \passthrough{\lstinline!VirtualizingStackPanel!} and record container
  creation counts before/after.
\item
  Build an \passthrough{\lstinline!ItemsRepeater!} gallery with
  \passthrough{\lstinline!UniformGridLayout!} and compare realized item
  counts against a \passthrough{\lstinline!WrapPanel!} version.
\item
  Replace \passthrough{\lstinline!SelectedItems!} with
  \passthrough{\lstinline!SelectionModel!} in a multi-select list, then
  synchronize the selection with a detail pane while keeping
  virtualization intact.
\item
  Implement the incremental log viewer above, including skeleton
  placeholders during fetch, and capture frame-time metrics before and
  after the optimization.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-12}

\begin{itemize}
\tightlist
\item
  Pipeline internals:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ItemsControl.cs}{\passthrough{\lstinline!ItemsControl.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Generators/ItemContainerGenerator.cs}{\passthrough{\lstinline!ItemContainerGenerator.cs!}}
\item
  Data views:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ItemsSourceView.cs}{\passthrough{\lstinline!ItemsSourceView.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Data/Core/CollectionView.cs}{\passthrough{\lstinline!CollectionView.cs!}}
\item
  Virtualization core:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/VirtualizingStackPanel.cs}{\passthrough{\lstinline!VirtualizingStackPanel.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ItemsRepeater/Layout/VirtualizingLayout.cs}{\passthrough{\lstinline!VirtualizingLayout.cs!}}
\item
  Selection infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Selection/SelectionModel.cs}{\passthrough{\lstinline!SelectionModel.cs!}}
\item
  Diagnostics tooling:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Diagnostics/Diagnostics/LayoutDiagnosticBridge.cs}{\passthrough{\lstinline!LayoutDiagnosticBridge.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-12}

\begin{itemize}
\tightlist
\item
  What distinguishes \passthrough{\lstinline!ItemsSource!} from
  \passthrough{\lstinline!ItemsSourceView!}, and when would you inspect
  the latter?
\item
  How does \passthrough{\lstinline!VirtualizingStackPanel!} decide which
  containers to recycle, and what breaks that logic?
\item
  Why does \passthrough{\lstinline!SelectionModel!} survive
  virtualization better than \passthrough{\lstinline!SelectedItems!}?
\item
  Which DevTools views help you confirm virtualization is active?
\item
  How can incremental loading keep long lists responsive without
  overwhelming the UI thread?
\end{itemize}

What's next - Next: \href{Chapter15.md}{Chapter 15}

\newpage

\subsection{15. Accessibility and
internationalization}\label{accessibility-and-internationalization}

Goal - Deliver interfaces that are usable with keyboard, screen readers,
and high-contrast themes. - Implement automation metadata
(\passthrough{\lstinline!AutomationProperties!}, custom
\passthrough{\lstinline!AutomationPeer!}s) so assistive technologies
understand your UI. - Localize content, formats, fonts, and layout
direction for multiple cultures while supporting IME and text services.
- Build a repeatable accessibility testing loop that spans platform
tooling and automated checks.

Why this matters - Accessibility ensures compliance (WCAG/ADA) and a
better experience for keyboard and assistive-technology users. -
Internationalization widens your reach and avoids locale-specific bugs
in formatting or layout direction. - Treating accessibility and
localization as first-class requirements keeps your app portable across
desktop, mobile, and browser targets.

Prerequisites - Keyboard input and commands (Chapter 9), resources
(Chapter 10), MVVM patterns (Chapter 11), navigation and lifetimes
(Chapter 12).

Key namespaces -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Automation/AutomationProperties.cs}{\passthrough{\lstinline!AutomationProperties.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Automation/Peers/AutomationPeer.cs}{\passthrough{\lstinline!AutomationPeer.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Automation/Peers/ControlAutomationPeer.cs}{\passthrough{\lstinline!ControlAutomationPeer.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputMethodClient.cs}{\passthrough{\lstinline!TextInputMethodClient.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputOptions.cs}{\passthrough{\lstinline!TextInputOptions.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/FontManagerOptions.cs}{\passthrough{\lstinline!FontManagerOptions.cs!}}
-
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Visuals/FlowDirection.cs}{\passthrough{\lstinline!FlowDirection.cs!}}

\subsection{1. Keyboard accessibility}\label{keyboard-accessibility}

\subsubsection{1.1 Focus order and tab
navigation}\label{focus-order-and-tab-navigation}

\begin{lstlisting}[language=XML]
<StackPanel Spacing="8" KeyboardNavigation.TabNavigation="Cycle">
  <TextBlock Text="_User name" RecognizesAccessKey="True"/>
  <TextBox x:Name="UserName" TabIndex="0"/>

  <TextBlock Text="_Password" RecognizesAccessKey="True"/>
  <PasswordBox x:Name="Password" TabIndex="1"/>

  <CheckBox TabIndex="2" Content="_Remember me"/>

  <StackPanel Orientation="Horizontal" Spacing="8">
    <Button TabIndex="3">
      <AccessText Text="_Sign in"/>
    </Button>
    <Button TabIndex="4">
      <AccessText Text="_Cancel"/>
    </Button>
  </StackPanel>
</StackPanel>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!KeyboardNavigation.TabNavigation="Cycle"!}
  keeps focus within the container, ideal for dialogs.
\item
  Use \passthrough{\lstinline!AccessText!} or
  \passthrough{\lstinline!RecognizesAccessKey="True"!} to expose
  mnemonic keys.
\item
  Disable focus for decorative elements via
  \passthrough{\lstinline!IsTabStop="False"!} or
  \passthrough{\lstinline!Focusable="False"!}.
\end{itemize}

\subsubsection{1.2 Keyboard navigation
helpers}\label{keyboard-navigation-helpers}

\passthrough{\lstinline!KeyboardNavigation!} (source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyboardNavigation.cs}{\passthrough{\lstinline!KeyboardNavigation.cs!}})
provides: - \passthrough{\lstinline!DirectionalNavigation="Cycle"!} for
arrow-key traversal in menus/panels. -
\passthrough{\lstinline!TabNavigation!} modes
(\passthrough{\lstinline!Continue!}, \passthrough{\lstinline!Once!},
\passthrough{\lstinline!Local!}, \passthrough{\lstinline!Cycle!},
\passthrough{\lstinline!None!}). -
\passthrough{\lstinline!Control.IsTabStop!} per element when you need to
skip items like labels or icons.

\subsection{2. Screen reader semantics}\label{screen-reader-semantics}

Attach \passthrough{\lstinline!AutomationProperties!} to expose names,
help text, and relationships:

\begin{lstlisting}[language=XML]
<StackPanel Spacing="10">
  <TextBlock x:Name="EmailLabel" Text="Email"/>
  <TextBox Text="{Binding Email}"
           AutomationProperties.LabeledBy="{Binding #EmailLabel}"
           AutomationProperties.AutomationId="EmailInput"/>

  <TextBlock x:Name="StatusLabel" Text="Status"/>
  <TextBlock Text="{Binding Status}"
             AutomationProperties.LabeledBy="{Binding #StatusLabel}"
             AutomationProperties.LiveSetting="Polite"/>
</StackPanel>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!AutomationProperties.Name!} provides a
  fallback label when there is no visible text.
\item
  \passthrough{\lstinline!AutomationProperties.HelpText!} supplies extra
  instructions for screen readers.
\item
  \passthrough{\lstinline!AutomationProperties.LiveSetting!}
  (\passthrough{\lstinline!Polite!},
  \passthrough{\lstinline!Assertive!}) controls how urgent announcements
  are.
\item
  \passthrough{\lstinline!AutomationProperties.ControlType!} lets you
  override the role in edge cases (use sparingly).
\end{itemize}

\passthrough{\lstinline!AutomationProperties!} map to automation peers.
The base \passthrough{\lstinline!ControlAutomationPeer!} inspects
properties and pseudo-classes to expose state.

\subsection{3. Custom automation peers}\label{custom-automation-peers}

Create peers when you author custom controls so assistive technology can
identify them correctly.

\begin{lstlisting}
public class ProgressBadge : TemplatedControl
{
    public static readonly StyledProperty<string?> TextProperty =
        AvaloniaProperty.Register<ProgressBadge, string?>(nameof(Text));

    public string? Text
    {
        get => GetValue(TextProperty);
        set => SetValue(TextProperty, value);
    }

    protected override AutomationPeer? OnCreateAutomationPeer()
        => new ProgressBadgeAutomationPeer(this);
}

public sealed class ProgressBadgeAutomationPeer : ControlAutomationPeer
{
    public ProgressBadgeAutomationPeer(ProgressBadge owner) : base(owner) { }

    protected override string? GetNameCore() => (Owner as ProgressBadge)?.Text;
    protected override AutomationControlType GetAutomationControlTypeCore() => AutomationControlType.Text;
    protected override AutomationLiveSetting GetLiveSettingCore() => AutomationLiveSetting.Polite;
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  Override \passthrough{\lstinline!PatternInterfaces!} (e.g.,
  \passthrough{\lstinline!IRangeValueProvider!},
  \passthrough{\lstinline!IValueProvider!}) when your control supports
  specific automation patterns.
\item
  Use \passthrough{\lstinline!AutomationProperties.AccessibilityView!}
  to control whether a control appears in the content vs.~control view.
\end{itemize}

\subsection{4. High contrast and theme
variants}\label{high-contrast-and-theme-variants}

Avalonia supports theme variants (\passthrough{\lstinline!Light!},
\passthrough{\lstinline!Dark!}, \passthrough{\lstinline!HighContrast!}).
Bind colors to resources instead of hard-coding values.

\begin{lstlisting}[language=XML]
<ResourceDictionary>
  <ResourceDictionary.ThemeDictionaries>
    <ResourceDictionary x:Key="Default">
      <SolidColorBrush x:Key="AccentBrush" Color="#2563EB"/>
    </ResourceDictionary>
    <ResourceDictionary x:Key="HighContrast">
      <SolidColorBrush x:Key="AccentBrush" Color="#00FF00"/>
    </ResourceDictionary>
  </ResourceDictionary.ThemeDictionaries>
</ResourceDictionary>
\end{lstlisting}

Switch variants for testing:

\begin{lstlisting}
Application.Current!.RequestedThemeVariant = ThemeVariant.HighContrast;
\end{lstlisting}

Provide clear focus visuals using pseudo-classes
(\passthrough{\lstinline!:focus!},
\passthrough{\lstinline!:pointerover!}) and ensure contrast ratios meet
WCAG (4.5:1 for body text). For Windows, respect system accent colors by
reading \passthrough{\lstinline!RequestedThemeVariant!} and
\passthrough{\lstinline!SystemBarColor!} (Chapter 7).

\subsection{5. Text input, IME, and text
services}\label{text-input-ime-and-text-services}

IME support matters for CJK languages and handwriting.
\passthrough{\lstinline!TextInputMethodClient!} is the bridge between
your control and platform IME surfaces. Text controls in Avalonia
already implement it; custom text editors should derive from
\passthrough{\lstinline!TextInputMethodClient!} (or reuse
\passthrough{\lstinline!TextPresenter!}).

\begin{lstlisting}
public sealed class CodeEditorTextInputClient : TextInputMethodClient
{
    private readonly CodeEditor _editor;

    public CodeEditorTextInputClient(CodeEditor editor) => _editor = editor;

    public override Visual TextViewVisual => _editor.TextLayer;
    public override bool SupportsPreedit => true;
    public override bool SupportsSurroundingText => true;
    public override string SurroundingText => _editor.Document.GetText();
    public override Rect CursorRectangle => _editor.GetCaretRect();
    public override TextSelection Selection
    {
        get => new(_editor.SelectionStart, _editor.SelectionEnd);
        set => _editor.SetSelection(value.Start, value.End);
    }

    public void UpdateCursor()
    {
        RaiseCursorRectangleChanged();
        RaiseSelectionChanged();
        RaiseSurroundingTextChanged();
    }
}
\end{lstlisting}

Configure text options with the attached
\passthrough{\lstinline!TextInputOptions!} properties:

\begin{lstlisting}[language=XML]
<TextBox Text="{Binding PhoneNumber}"
         InputMethod.TextInputOptions.ContentType="TelephoneNumber"
         InputMethod.TextInputOptions.ReturnKeyType="Done"
         InputMethod.TextInputOptions.IsCorrectionEnabled="False"/>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  On mobile, \passthrough{\lstinline!ReturnKeyType!} changes the soft
  keyboard button (e.g., ``Go'', ``Send'').
\item
  \passthrough{\lstinline!ContentType!} hints at expected input,
  enabling numeric keyboards or email layouts.
\item
  \passthrough{\lstinline!IsContentPredictionEnabled!}/\passthrough{\lstinline!IsSpellCheckEnabled!}
  toggle autocorrect.
\end{itemize}

When you detect IME-specific behaviour, test on Windows (IMM32), macOS,
Linux (IBus/Fcitx), Android, and iOS --- each backend surfaces slightly
different capabilities.

\subsection{6. Localization workflow}\label{localization-workflow}

\subsubsection{6.1 Resource management}\label{resource-management}

Use RESX resources or a localization service that surfaces
culture-specific strings.

\begin{lstlisting}
public sealed class Loc : INotifyPropertyChanged
{
    private CultureInfo _culture = CultureInfo.CurrentUICulture;
    public string this[string key] => Resources.ResourceManager.GetString(key, _culture) ?? key;

    public void SetCulture(CultureInfo culture)
    {
        if (_culture.Equals(culture))
            return;

        _culture = culture;
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(null));
    }

    public event PropertyChangedEventHandler? PropertyChanged;
}
\end{lstlisting}

Register in \passthrough{\lstinline!App.axaml!} and bind:

\begin{lstlisting}[language=XML]
<Application.Resources>
  <local:Loc x:Key="Loc"/>
</Application.Resources>

<TextBlock Text="{Binding [Ready], Source={StaticResource Loc}}"/>
\end{lstlisting}

Switch culture at runtime:

\begin{lstlisting}
var culture = new CultureInfo("fr-FR");
CultureInfo.CurrentCulture = CultureInfo.CurrentUICulture = culture;
((Loc)Application.Current!.Resources["Loc"]).SetCulture(culture);
\end{lstlisting}

\subsubsection{6.2 Formatting and layout
direction}\label{formatting-and-layout-direction}

\begin{itemize}
\tightlist
\item
  Use binding \passthrough{\lstinline!StringFormat!} or
  \passthrough{\lstinline!string.Format!} with the current culture for
  dates, numbers, and currency.
\item
  Set \passthrough{\lstinline!FlowDirection="RightToLeft"!} for RTL
  languages and override back to \passthrough{\lstinline!LeftToRight!}
  for controls that must remain LTR (e.g., numeric fields).
\item
  Mirror icons and layout padding when mirrored (use
  \passthrough{\lstinline!ScaleTransform!} or
  \passthrough{\lstinline!LayoutTransform!}).
\end{itemize}

\subsection{7. Fonts and fallbacks}\label{fonts-and-fallbacks}

Ensure glyph coverage with \passthrough{\lstinline!FontManagerOptions!}:

\begin{lstlisting}
AppBuilder.Configure<App>()
    .UsePlatformDetect()
    .With(new FontManagerOptions
    {
        DefaultFamilyName = "Noto Sans",
        FontFallbacks = new[]
        {
            new FontFallback { Family = "Noto Sans Arabic" },
            new FontFallback { Family = "Noto Sans CJK SC" }
        }
    })
    .StartWithClassicDesktopLifetime(args);
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  Ship branded fonts via
  \passthrough{\lstinline!FontFamily="avares://MyApp/Assets/Fonts/Brand.ttf\#Brand"!}.
\item
  Test scripts that require surrogate pairs (emoji, rare CJK ideographs)
  to ensure fallbacks load.
\item
  On Windows, consider \passthrough{\lstinline!TextRenderingMode!} for
  clarity vs.~smoothness.
\end{itemize}

\subsection{8. Testing accessibility}\label{testing-accessibility}

Tips for a repeatable test loop:

\begin{itemize}
\tightlist
\item
  \textbf{Keyboard} -- Tab through each screen, ensure focus indicators
  are visible, and verify shortcuts work.
\item
  \textbf{Screen readers} -- Use Narrator, NVDA, or JAWS on Windows;
  VoiceOver on macOS/iOS; TalkBack on Android; Orca on Linux. Confirm
  names, roles, and help text.
\item
  \textbf{Automation tree} -- Avalonia DevTools → \textbf{Automation}
  tab visualizes peers and properties.
\item
  \textbf{Contrast} -- Run
  \passthrough{\lstinline!Accessibility Insights!} (Windows),
  \passthrough{\lstinline!Color Oracle!}, or browser dev tools to verify
  contrast ratios.
\item
  \textbf{Automated} -- Combine
  \passthrough{\lstinline!Avalonia.Headless!} UI tests (Chapter 21) with
  assertions on \passthrough{\lstinline!AutomationId!} and localized
  content.
\end{itemize}

Document gaps (e.g., missing peers, insufficient contrast) and track
them like any other defect.

\subsection{9. Practice exercises}\label{practice-exercises-9}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Annotate a settings page with
  \passthrough{\lstinline!AutomationProperties.Name!},
  \passthrough{\lstinline!HelpText!}, and
  \passthrough{\lstinline!AutomationId!}; inspect the automation tree
  with DevTools and NVDA.
\item
  Derive a custom \passthrough{\lstinline!AutomationPeer!} for a
  progress pill control, exposing live updates and value patterns, then
  verify announcements in a screen reader.
\item
  Configure \passthrough{\lstinline!TextInputOptions!} for phone number
  input on Windows, Android, and iOS. Test with an IME
  (Japanese/Chinese) to ensure composition events render correctly.
\item
  Localize UI strings into two additional cultures (e.g., es-ES, ar-SA),
  toggle \passthrough{\lstinline!FlowDirection!}, and confirm mirrored
  layouts do not break focus order.
\item
  Set up \passthrough{\lstinline!FontManagerOptions!} with
  script-specific fallbacks and validate that Arabic, Cyrillic, and CJK
  text render without tofu glyphs.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-13}

\begin{itemize}
\tightlist
\item
  Keyboard navigation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyboardNavigation.cs}{\passthrough{\lstinline!KeyboardNavigation.cs!}}
\item
  Automation metadata:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Automation/AutomationProperties.cs}{\passthrough{\lstinline!AutomationProperties.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Automation/Peers/ControlAutomationPeer.cs}{\passthrough{\lstinline!ControlAutomationPeer.cs!}}
\item
  Text input \& IME:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputMethodClient.cs}{\passthrough{\lstinline!TextInputMethodClient.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputOptions.cs}{\passthrough{\lstinline!TextInputOptions.cs!}}
\item
  Localization:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Localization/CultureInfoExtensions.cs}{\passthrough{\lstinline!CultureInfoExtensions!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Runtime/PlatformServices.cs}{\passthrough{\lstinline!RuntimePlatformServices!}}
\item
  Font management:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/FontManagerOptions.cs}{\passthrough{\lstinline!FontManagerOptions.cs!}}
\item
  Flow direction:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Visuals/FlowDirection.cs}{\passthrough{\lstinline!FlowDirection.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-13}

\begin{itemize}
\tightlist
\item
  How do \passthrough{\lstinline!AutomationProperties.LabeledBy!} and
  \passthrough{\lstinline!AutomationId!} improve automated testing and
  screen reader output?
\item
  When should you implement a custom
  \passthrough{\lstinline!AutomationPeer!}, and which patterns do you
  need to expose for value-based controls?
\item
  Which \passthrough{\lstinline!TextInputOptions!} settings influence
  IME behaviour and soft keyboard layouts across platforms?
\item
  How do you switch UI language at runtime and ensure both text and
  layout update correctly?
\item
  Where do you configure font fallbacks to cover multiple scripts
  without shipping duplicate glyphs?
\end{itemize}

What's next - Next: \href{Chapter16.md}{Chapter 16}

\newpage

\subsection{16. Files, storage, drag/drop, and
clipboard}\label{files-storage-dragdrop-and-clipboard}

Goal - Use Avalonia's storage provider to open, save, and enumerate
files/folders across desktop, mobile, and browser. - Abstract file
dialogs behind services so MVVM view models remain testable. - Handle
drag-and-drop data (files, text, custom formats) and initiate drags from
your app. - Work with the clipboard safely, including multi-format
payloads.

Why this matters - Users expect native pickers, drag/drop, and clipboard
support. Implementing them well keeps experiences consistent across
platforms. - Proper abstractions keep storage logic off the UI thread
and ready for unit testing.

Prerequisites - Chapter 9 (commands/input), Chapter 11 (MVVM), Chapter
12 (TopLevel services).

\subsection{1. Storage provider
fundamentals}\label{storage-provider-fundamentals}

All pickers live on \passthrough{\lstinline!TopLevel.StorageProvider!}
(Window, control, etc.). The storage provider is an abstraction over
native dialogs and sandbox rules.

\begin{lstlisting}
var topLevel = TopLevel.GetTopLevel(control);
if (topLevel?.StorageProvider is { } storage)
{
    // storage.OpenFilePickerAsync(...)
}
\end{lstlisting}

If \passthrough{\lstinline!StorageProvider!} is null, ensure the control
is attached (e.g., call after
\passthrough{\lstinline!Loaded!}/\passthrough{\lstinline!Opened!}).

\passthrough{\lstinline!IStorageProvider!} exposes capability flags such
as \passthrough{\lstinline!CanOpen!}, \passthrough{\lstinline!CanSave!},
and \passthrough{\lstinline!CanPickFolder!}. Check them before
presenting commands so sandboxed targets (browser/mobile) can hide
unsupported options. Dialog methods accept option records
(\passthrough{\lstinline!FilePickerOpenOptions!},
\passthrough{\lstinline!FolderPickerOpenOptions!}, etc.) that describe
filters, suggested locations, and tokens for continuing previous
sessions.

\subsubsection{1.1 Service abstraction for
MVVM}\label{service-abstraction-for-mvvm}

\begin{lstlisting}
public interface IFileDialogService
{
    Task<IReadOnlyList<IStorageFile>> OpenFilesAsync(FilePickerOpenOptions options);
    Task<IStorageFile?> SaveFileAsync(FilePickerSaveOptions options);
    Task<IStorageFolder?> PickFolderAsync(FolderPickerOpenOptions options);
}

public sealed class FileDialogService : IFileDialogService
{
    private readonly TopLevel _topLevel;
    public FileDialogService(TopLevel topLevel) => _topLevel = topLevel;

    public Task<IReadOnlyList<IStorageFile>> OpenFilesAsync(FilePickerOpenOptions options)
        => _topLevel.StorageProvider?.OpenFilePickerAsync(options) ?? Task.FromResult<IReadOnlyList<IStorageFile>>(Array.Empty<IStorageFile>());

    public Task<IStorageFile?> SaveFileAsync(FilePickerSaveOptions options)
        => _topLevel.StorageProvider?.SaveFilePickerAsync(options) ?? Task.FromResult<IStorageFile?>(null);

    public async Task<IStorageFolder?> PickFolderAsync(FolderPickerOpenOptions options)
    {
        if (_topLevel.StorageProvider is null)
            return null;
        var folders = await _topLevel.StorageProvider.OpenFolderPickerAsync(options);
        return folders.FirstOrDefault();
    }
}
\end{lstlisting}

Register the service per window (in DI) so view models request dialogs
via \passthrough{\lstinline!IFileDialogService!} without touching UI
types.

\subsubsection{1.2 Launching files and
URIs}\label{launching-files-and-uris}

\passthrough{\lstinline!TopLevel.Launcher!} gives access to
\passthrough{\lstinline!ILauncher!}, which opens files, folders, or URIs
using the platform shell (Finder, Explorer, default browser, etc.).
Combine it with storage results to let users reveal files after saving.

\begin{lstlisting}
var topLevel = TopLevel.GetTopLevel(control);
if (topLevel?.Launcher is { } launcher && file is not null)
{
    await launcher.LaunchFileAsync(file);
    await launcher.LaunchUriAsync(new Uri("https://docs.avaloniaui.net"));
}
\end{lstlisting}

Return values indicate whether the launch succeeded; fall back to in-app
viewers when it returns false.

\subsection{2. Opening files (async
streams)}\label{opening-files-async-streams}

\begin{lstlisting}
public async Task<string?> ReadTextFileAsync(IStorageFile file, CancellationToken ct)
{
    await using var stream = await file.OpenReadAsync();
    using var reader = new StreamReader(stream, Encoding.UTF8, detectEncodingFromByteOrderMarks: true);
    return await reader.ReadToEndAsync(ct);
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  Always wrap streams in
  \passthrough{\lstinline!using!}/\passthrough{\lstinline!await using!}.
\item
  Pass \passthrough{\lstinline!CancellationToken!} to long operations.
\item
  For binary files, use \passthrough{\lstinline!BinaryReader!} or direct
  \passthrough{\lstinline!Stream!} APIs.
\end{itemize}

\subsubsection{2.1 Remote or sandboxed
locations}\label{remote-or-sandboxed-locations}

On Android/iOS/Browser the returned stream might be virtual (no direct
file path). Always rely on stream APIs; avoid
\passthrough{\lstinline!LocalPath!} if \passthrough{\lstinline!Path!} is
null.

\subsubsection{2.2 File type filters}\label{file-type-filters}

\begin{lstlisting}
var options = new FilePickerOpenOptions
{
    Title = "Open images",
    AllowMultiple = true,
    SuggestedStartLocation = await storage.TryGetWellKnownFolderAsync(WellKnownFolder.Pictures),
    FileTypeFilter = new[]
    {
        new FilePickerFileType("Images")
        {
            Patterns = new[] { "*.png", "*.jpg", "*.jpeg", "*.webp", "*.gif" }
        }
    }
};
\end{lstlisting}

\passthrough{\lstinline!TryGetWellKnownFolderAsync!} returns common
directories when supported (desktop/mobile). Source:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/WellKnownFolder.cs}{\passthrough{\lstinline!WellKnownFolder.cs!}}.

\subsection{3. Saving files}\label{saving-files}

\begin{lstlisting}
var saveOptions = new FilePickerSaveOptions
{
    Title = "Export report",
    SuggestedFileName = $"report-{DateTime.UtcNow:yyyyMMdd}.csv",
    DefaultExtension = "csv",
    FileTypeChoices = new[]
    {
        new FilePickerFileType("CSV") { Patterns = new[] { "*.csv" } },
        new FilePickerFileType("All files") { Patterns = new[] { "*" } }
    }
};

var file = await _dialogService.SaveFileAsync(saveOptions);
if (file is not null)
{
    await using var stream = await file.OpenWriteAsync();
    await using var writer = new StreamWriter(stream, Encoding.UTF8, leaveOpen: false);
    await writer.WriteLineAsync("Id,Name,Email");
    foreach (var row in rows)
        await writer.WriteLineAsync($"{row.Id},{row.Name},{row.Email}");
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!OpenWriteAsync!} truncates the existing file.
  Use \passthrough{\lstinline!OpenReadWriteAsync!} for editing.
\item
  Some platforms prompt for confirmation when writing to previously
  granted locations.
\end{itemize}

\subsection{4. Enumerating folders}\label{enumerating-folders}

\begin{lstlisting}
var folder = await storage.TryGetFolderFromPathAsync(new Uri("file:///C:/Logs"));
if (folder is not null)
{
    await foreach (var item in folder.GetItemsAsync())
    {
        switch (item)
        {
            case IStorageFile file:
                // Process file
                break;
            case IStorageFolder subfolder:
                // Recurse or display
                break;
        }
    }
}
\end{lstlisting}

\passthrough{\lstinline!GetItemsAsync()!} returns an async sequence;
iterate with \passthrough{\lstinline!await foreach!} on .NET 7+. Use
\passthrough{\lstinline!GetFilesAsync!}/\passthrough{\lstinline!GetFoldersAsync!}
to filter.

\subsection{5. Bookmarks and persisted
access}\label{bookmarks-and-persisted-access}

Some platforms revoke file permissions when your app suspends. If an
\passthrough{\lstinline!IStorageItem!} reports
\passthrough{\lstinline!CanBookmark!}, call
\passthrough{\lstinline!SaveBookmarkAsync()!} and store the returned
string (e.g., in preferences). Later, reopen it via
\passthrough{\lstinline!IStorageProvider.OpenFileBookmarkAsync!}/\passthrough{\lstinline!OpenFolderBookmarkAsync!}.

\begin{lstlisting}
var bookmarks = new Dictionary<string, string>();

if (file.CanBookmark)
{
    var bookmarkId = await file.SaveBookmarkAsync();
    if (!string.IsNullOrEmpty(bookmarkId))
        bookmarks[file.Path.ToString()] = bookmarkId;
}

var restored = await storage.OpenFileBookmarkAsync(bookmarkId);
\end{lstlisting}

Keep bookmarks updated when users revoke access. iOS and Android can
throw when bookmarks expire---wrap calls in try/catch and ask users to
reselect the folder. Desktop platforms typically return standard file
paths, but bookmarks still help retain portal-granted access (e.g.,
Flatpak).

\passthrough{\lstinline!IStorageItem.GetBasicPropertiesAsync()!} exposes
metadata (size, modified time) without opening streams---use it when
building file browsers.

\subsection{6. Platform notes}\label{platform-notes-1}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Platform
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Storage provider
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Considerations
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Windows/macOS/Linux & Native dialogs; file system access & Standard
read/write. Some Linux desktops require portals (Flatpak/Snap). \\
Android/iOS & Native pickers; sandboxed URIs & Streams may be content
URIs; persist permissions if needed. \\
Browser (WASM) & File System Access API & Requires user gestures; may
return handles that expire when page reloads. \\
\end{longtable}

Wrap storage calls in try/catch to handle permission denials or canceled
dialogs gracefully.

\subsection{7. Drag-and-drop: receiving
data}\label{drag-and-drop-receiving-data}

\begin{lstlisting}[language=XML]
<Border AllowDrop="True"
        DragOver="OnDragOver"
        Drop="OnDrop"
        Background="#111827" Padding="12">
  <TextBlock Text="Drop files or text" Foreground="#CBD5F5"/>
</Border>
\end{lstlisting}

\begin{lstlisting}
private void OnDragOver(object? sender, DragEventArgs e)
{
    if (e.Data.Contains(DataFormats.Files) || e.Data.Contains(DataFormats.Text))
        e.DragEffects = DragDropEffects.Copy;
    else
        e.DragEffects = DragDropEffects.None;
}

private async void OnDrop(object? sender, DragEventArgs e)
{
    var files = await e.Data.GetFilesAsync();
    if (files is not null)
    {
        foreach (var item in files.OfType<IStorageFile>())
        {
            await using var stream = await item.OpenReadAsync();
            // import
        }
        return;
    }

    if (e.Data.Contains(DataFormats.Text))
    {
        var text = await e.Data.GetTextAsync();
        // handle text
    }
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!GetFilesAsync()!} returns storage items; check
  for \passthrough{\lstinline!IStorageFile!}.
\item
  Inspect \passthrough{\lstinline!e.KeyModifiers!} to adjust behavior
  (e.g., Ctrl for copy).
\end{itemize}

\subsubsection{7.1 Initiating
drag-and-drop}\label{initiating-drag-and-drop}

\begin{lstlisting}
private async void DragSource_PointerPressed(object? sender, PointerPressedEventArgs e)
{
    if (sender is not Control control)
        return;

    var data = new DataObject();
    data.Set(DataFormats.Text, "Example text");

    var effects = await DragDrop.DoDragDrop(e, data, DragDropEffects.Copy | DragDropEffects.Move);
    if (effects.HasFlag(DragDropEffects.Move))
    {
        // remove item
    }
}
\end{lstlisting}

\passthrough{\lstinline!DataObject!} supports multiple formats (text,
files, custom types). For custom data, both source and target must agree
on a format string.

\subsubsection{7.2 Custom visuals and
adorners}\label{custom-visuals-and-adorners}

Wrap your layout in an \passthrough{\lstinline!AdornerDecorator!} and
render drop cues while a drag is in progress. Toggle overlays in
\passthrough{\lstinline!DragEnter!}/\passthrough{\lstinline!DragLeave!}
handlers to show hit targets or counts.

\begin{lstlisting}
private void OnDragEnter(object? sender, DragEventArgs e)
{
    _dropOverlay.IsVisible = true;
}

private void OnDragLeave(object? sender, RoutedEventArgs e)
{
    _dropOverlay.IsVisible = false;
}
\end{lstlisting}

You can also inspect \passthrough{\lstinline!e.DragEffects!} to switch
icons (copy vs move) or reject unsupported formats with a custom
message. For complex scenarios create a lightweight
\passthrough{\lstinline!Window!} as a drag adorner so the pointer stays
responsive on multi-monitor setups.

\subsection{8. Clipboard operations}\label{clipboard-operations}

\begin{lstlisting}
public interface IClipboardService
{
    Task SetTextAsync(string text);
    Task<string?> GetTextAsync();
    Task SetDataObjectAsync(IDataObject dataObject);
    Task<IReadOnlyList<string>> GetFormatsAsync();
}

public sealed class ClipboardService : IClipboardService
{
    private readonly TopLevel _topLevel;
    public ClipboardService(TopLevel topLevel) => _topLevel = topLevel;

    public Task SetTextAsync(string text) => _topLevel.Clipboard?.SetTextAsync(text) ?? Task.CompletedTask;
    public Task<string?> GetTextAsync() => _topLevel.Clipboard?.GetTextAsync() ?? Task.FromResult<string?>(null);
    public Task SetDataObjectAsync(IDataObject dataObject) => _topLevel.Clipboard?.SetDataObjectAsync(dataObject) ?? Task.CompletedTask;
    public Task<IReadOnlyList<string>> GetFormatsAsync() => _topLevel.Clipboard?.GetFormatsAsync() ?? Task.FromResult<IReadOnlyList<string>>(Array.Empty<string>());
}
\end{lstlisting}

\subsubsection{8.1 Multi-format clipboard
payload}\label{multi-format-clipboard-payload}

\begin{lstlisting}
var dataObject = new DataObject();
dataObject.Set(DataFormats.Text, "Plain text");
dataObject.Set("text/html", "<strong>Bold</strong>");
dataObject.Set("application/x-myapp-item", myItemId);

await clipboardService.SetDataObjectAsync(dataObject);
var formats = await clipboardService.GetFormatsAsync();
\end{lstlisting}

Browser restrictions: clipboard APIs require user gesture and may only
allow text formats.

\subsection{9. Error handling \& async
patterns}\label{error-handling-async-patterns}

\begin{itemize}
\tightlist
\item
  Wrap storage operations in try/catch for
  \passthrough{\lstinline!IOException!},
  \passthrough{\lstinline!UnauthorizedAccessException!}.
\item
  Offload heavy parsing to background threads with
  \passthrough{\lstinline!Task.Run!} (keep UI thread responsive).
\item
  Use \passthrough{\lstinline!Progress<T>!} to report progress to view
  models.
\end{itemize}

\begin{lstlisting}
var progress = new Progress<int>(value => ImportProgress = value);
await _importService.ImportAsync(file, progress, cancellationToken);
\end{lstlisting}

\subsection{10. Diagnostics}\label{diagnostics-1}

\begin{itemize}
\tightlist
\item
  Log storage/drag errors with
  \passthrough{\lstinline!LogArea.Platform!} or custom logger.
\item
  DevTools -\textgreater{} Events tab shows drag/drop events.
\item
  On Linux portals (Flatpak/Snap), check console logs for portal errors.
\end{itemize}

\subsection{11. Practice exercises}\label{practice-exercises-10}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Implement \passthrough{\lstinline!IFileDialogService!} and expose
  commands for Open, Save, and Pick Folder; update the UI with results.
\item
  Build a file manager pane that enumerates folders asynchronously,
  persists bookmarks for sandboxed platforms, and mirrors changes via
  drag/drop.
\item
  Create a clipboard history panel that stores the last N text snippets
  using the \passthrough{\lstinline!IClipboard!} service.
\item
  Add drag support from a list to the OS shell (export files) with a
  custom adorner overlay showing the item count.
\item
  Implement cancellation for long-running file imports and confirm
  resources are disposed when canceled.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-14}

\begin{itemize}
\tightlist
\item
  Storage provider:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/IStorageProvider.cs}{\passthrough{\lstinline!IStorageProvider!}}
\item
  File/folder abstractions:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/FileIO/IStorageFile.cs}{\passthrough{\lstinline!IStorageFile!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/FileIO/IStorageFolder.cs}{\passthrough{\lstinline!IStorageFolder!}}
\item
  Bookmarks \& metadata:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/IStorageItem.cs}{\passthrough{\lstinline!IStorageItem!}}
\item
  Picker options:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/FilePickerOpenOptions.cs}{\passthrough{\lstinline!FilePickerOpenOptions!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/FilePickerSaveOptions.cs}{\passthrough{\lstinline!FilePickerSaveOptions!}}
\item
  Drag/drop:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/DragDrop.cs}{\passthrough{\lstinline!DragDrop.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/DataObject.cs}{\passthrough{\lstinline!DataObject.cs!}}
\item
  Clipboard:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/IClipboard.cs}{\passthrough{\lstinline!IClipboard!}}
\item
  Launcher:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Platform/Storage/ILauncher.cs}{\passthrough{\lstinline!ILauncher!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-14}

\begin{itemize}
\tightlist
\item
  How do you obtain an \passthrough{\lstinline!IStorageProvider!} when
  you only have a view model?
\item
  What are the advantages of using asynchronous streams
  (\passthrough{\lstinline!await using!}) when reading/writing files?
\item
  How can you detect which drag/drop formats are available during a drop
  event?
\item
  Which APIs let you enumerate well-known folders cross-platform?
\item
  What restrictions exist for clipboard and storage operations on
  browser/mobile?
\end{itemize}

What's next - Next: \href{Chapter17.md}{Chapter 17}

\newpage

\subsection{17. Background work and
networking}\label{background-work-and-networking}

Goal - Keep the UI responsive while doing heavy or long-running tasks
using async/await, Task.Run, and progress reporting. - Surface status,
progress, and cancellation to users. - Call web APIs with HttpClient,
handle retries/timeouts, and stream downloads/upload. - Respond to
connectivity changes and test background logic predictably.

Why this matters - Real apps load data, crunch files, and hit APIs.
Blocking the UI thread ruins UX. - Async-first code scales across
desktop, mobile, and browser with minimal changes.

Prerequisites - Chapters 8-9 (binding \& commands), Chapter 11 (MVVM),
Chapter 16 (file IO).

\subsection{1. The UI thread and
Dispatcher}\label{the-ui-thread-and-dispatcher}

Avalonia has a single UI thread managed by
\passthrough{\lstinline!Dispatcher.UIThread!}. UI elements and bound
properties must be updated on this thread.

Rules of thumb: - Prefer async I/O (await network/file operations). -
For CPU-bound work, use \passthrough{\lstinline!Task.Run!} to offload to
a thread pool thread. - Use
\passthrough{\lstinline!Dispatcher.UIThread.Post/InvokeAsync!} to
marshal back to the UI thread if needed (though
\passthrough{\lstinline!Progress<T>!} usually keeps you on the UI
thread).

\begin{lstlisting}
await Dispatcher.UIThread.InvokeAsync(() => Status = "Ready");
\end{lstlisting}

\subsubsection{1.1 Dispatcher priorities}\label{dispatcher-priorities}

\passthrough{\lstinline!DispatcherPriority!} controls when queued work
runs relative to layout, input, and rendering. Use
\passthrough{\lstinline!Dispatcher.UIThread.Post!} with an explicit
priority when you want work to wait until after animations or to run
ahead of rendering.

\begin{lstlisting}
Dispatcher.UIThread.Post(
    () => Notifications.Clear(),
    priority: DispatcherPriority.Background);

Dispatcher.UIThread.Post(
    () => Toasts.Enqueue(message),
    priority: DispatcherPriority.Input);
\end{lstlisting}

Avoid defaulting everything to
\passthrough{\lstinline!DispatcherPriority.Send!} (synchronous) because
it can starve input processing.

\subsubsection{1.2 SynchronizationContext
awareness}\label{synchronizationcontext-awareness}

\passthrough{\lstinline!DispatcherSynchronizationContext!} is installed
on the UI thread; async continuations captured there automatically hop
back to Avalonia when you \passthrough{\lstinline!await!}. When running
background tasks (e.g., unit tests or hosted services) ensure you resume
on the UI thread by capturing the context:

\begin{lstlisting}
var uiContext = SynchronizationContext.Current;

await Task.Run(async () =>
{
    var result = await LoadAsync(ct).ConfigureAwait(false);
    uiContext?.Post(_ => ViewModel.Result = result, null);
});
\end{lstlisting}

When you intentionally want to stay on a background thread, use
\passthrough{\lstinline!ConfigureAwait(false)!} to avoid marshaling
back.

\subsection{2. Async workflow pattern
(ViewModel)}\label{async-workflow-pattern-viewmodel}

\begin{lstlisting}
public sealed class WorkViewModel : ObservableObject
{
    private CancellationTokenSource? _cts;
    private double _progress;
    private string _status = "Idle";
    private bool _isBusy;

    public double Progress { get => _progress; set => SetProperty(ref _progress, value); }
    public string Status { get => _status; set => SetProperty(ref _status, value); }
    public bool IsBusy { get => _isBusy; set => SetProperty(ref _isBusy, value); }

    public RelayCommand StartCommand { get; }
    public RelayCommand CancelCommand { get; }

    public WorkViewModel()
    {
        StartCommand = new RelayCommand(async _ => await StartAsync(), _ => !IsBusy);
        CancelCommand = new RelayCommand(_ => _cts?.Cancel(), _ => IsBusy);
    }

    private async Task StartAsync()
    {
        IsBusy = true;
        _cts = new CancellationTokenSource();
        var progress = new Progress<double>(value => Progress = value * 100);

        try
        {
            Status = "Processing...";
            await FakeWorkAsync(progress, _cts.Token);
            Status = "Completed";
        }
        catch (OperationCanceledException)
        {
            Status = "Canceled";
        }
        catch (Exception ex)
        {
            Status = $"Error: {ex.Message}";
        }
        finally
        {
            IsBusy = false;
            _cts = null;
        }
    }

    private static async Task FakeWorkAsync(IProgress<double> progress, CancellationToken ct)
    {
        const int total = 1000;
        await Task.Run(async () =>
        {
            for (int i = 0; i < total; i++)
            {
                ct.ThrowIfCancellationRequested();
                await Task.Delay(2, ct).ConfigureAwait(false);
                progress.Report((i + 1) / (double)total);
            }
        }, ct);
    }
}
\end{lstlisting}

\passthrough{\lstinline!Task.Run!} offloads CPU work to the thread pool;
\passthrough{\lstinline!ConfigureAwait(false)!} keeps the inner loop on
the background thread. \passthrough{\lstinline!Progress<T>!} marshals
results back to UI thread automatically.

\subsection{3. UI binding (XAML)}\label{ui-binding-xaml}

\begin{lstlisting}[language=XML]
<StackPanel Spacing="12">
  <ProgressBar Minimum="0" Maximum="100" Value="{Binding Progress}" IsIndeterminate="{Binding IsBusy}"/>
  <TextBlock Text="{Binding Status}"/>
  <StackPanel Orientation="Horizontal" Spacing="8">
    <Button Content="Start" Command="{Binding StartCommand}"/>
    <Button Content="Cancel" Command="{Binding CancelCommand}"/>
  </StackPanel>
</StackPanel>
\end{lstlisting}

\subsection{4. HTTP networking patterns}\label{http-networking-patterns}

\subsubsection{4.1 HttpClient lifetime}\label{httpclient-lifetime}

Reuse HttpClient (per host/service) to avoid socket exhaustion. Inject
or hold static instance.

\begin{lstlisting}
public static class ApiClient
{
    public static HttpClient Instance { get; } = new HttpClient
    {
        Timeout = TimeSpan.FromSeconds(30)
    };
}
\end{lstlisting}

\subsubsection{4.2 GET + JSON}\label{get-json}

\begin{lstlisting}
public async Task<T?> GetJsonAsync<T>(string url, CancellationToken ct)
{
    using var resp = await ApiClient.Instance.GetAsync(url, HttpCompletionOption.ResponseHeadersRead, ct);
    resp.EnsureSuccessStatusCode();
    await using var stream = await resp.Content.ReadAsStreamAsync(ct);
    return await JsonSerializer.DeserializeAsync<T>(stream, cancellationToken: ct);
}
\end{lstlisting}

\subsubsection{4.3 POST JSON with retry}\label{post-json-with-retry}

\begin{lstlisting}
public async Task PostWithRetryAsync<T>(string url, T payload, CancellationToken ct)
{
    var policy = Policy
        .Handle<HttpRequestException>()
        .Or<TaskCanceledException>()
        .WaitAndRetryAsync(3, attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt))); // exponential backoff

    await policy.ExecuteAsync(async token =>
    {
        using var response = await ApiClient.Instance.PostAsJsonAsync(url, payload, token);
        response.EnsureSuccessStatusCode();
    }, ct);
}
\end{lstlisting}

Use \passthrough{\lstinline!Polly!} or custom retry logic. Timeouts and
cancellation tokens help stop hanging requests.

\subsubsection{4.4 Download with progress}\label{download-with-progress}

\begin{lstlisting}
public async Task DownloadAsync(Uri uri, IStorageFile destination, IProgress<double> progress, CancellationToken ct)
{
    using var response = await ApiClient.Instance.GetAsync(uri, HttpCompletionOption.ResponseHeadersRead, ct);
    response.EnsureSuccessStatusCode();

    var contentLength = response.Content.Headers.ContentLength;
    await using var httpStream = await response.Content.ReadAsStreamAsync(ct);
    await using var fileStream = await destination.OpenWriteAsync();

    var buffer = new byte[81920];
    long totalRead = 0;
    int read;
    while ((read = await httpStream.ReadAsync(buffer.AsMemory(0, buffer.Length), ct)) > 0)
    {
        await fileStream.WriteAsync(buffer.AsMemory(0, read), ct);
        totalRead += read;
        if (contentLength.HasValue)
            progress.Report(totalRead / (double)contentLength.Value);
    }
}
\end{lstlisting}

\subsection{5. Connectivity awareness}\label{connectivity-awareness}

Avalonia doesn't ship built-in connectivity events; rely on platform
APIs or ping endpoints.

\begin{itemize}
\tightlist
\item
  Desktop: use
  \passthrough{\lstinline!System.Net.NetworkInformation.NetworkChange!}
  events.
\item
  Mobile: Xamarin/MAUI style libraries or platform-specific checks.
\item
  Browser: \passthrough{\lstinline!navigator.onLine!} via JS interop.
\end{itemize}

Expose a service to signal connectivity changes to view models; keep
offline caching in mind.

\begin{lstlisting}
public interface INetworkStatusService
{
    IObservable<bool> ConnectivityChanges { get; }
}

public sealed class NetworkStatusService : INetworkStatusService
{
    public IObservable<bool> ConnectivityChanges { get; }

    public NetworkStatusService()
    {
        ConnectivityChanges = Observable
            .FromEventPattern<NetworkAvailabilityChangedEventHandler, NetworkAvailabilityEventArgs>(
                handler => NetworkChange.NetworkAvailabilityChanged += handler,
                handler => NetworkChange.NetworkAvailabilityChanged -= handler)
            .Select(args => args.EventArgs.IsAvailable)
            .StartWith(NetworkInterface.GetIsNetworkAvailable());
    }
}
\end{lstlisting}

Register different implementations per target in DI
(\passthrough{\lstinline!\#if!} or platform-specific partial classes).
On mobile, back the observable with platform connectivity APIs; on
WebAssembly, bridge to \passthrough{\lstinline!navigator.onLine!} via JS
interop. View models can subscribe once and stay platform-agnostic.

\subsection{6. Background services \& scheduled
work}\label{background-services-scheduled-work}

For periodic tasks, use \passthrough{\lstinline!DispatcherTimer!} on UI
thread or \passthrough{\lstinline!Task.Run!} loops with delays.

\begin{lstlisting}
var timer = new DispatcherTimer(TimeSpan.FromMinutes(5), DispatcherPriority.Background, (_, _) => RefreshCommand.Execute(null));
timer.Start();
\end{lstlisting}

Long-running background work should check
\passthrough{\lstinline!CancellationToken!} frequently, especially when
app might suspend (mobile).

\subsubsection{6.1 Orchestrating services across
targets}\label{orchestrating-services-across-targets}

For cross-platform apps, wrap periodic or startup work in services that
plug into each lifetime. Example using
\passthrough{\lstinline!IHostedService!} semantics:

\begin{lstlisting}
public interface IBackgroundTask
{
    Task StartAsync(CancellationToken token);
    Task StopAsync(CancellationToken token);
}

public sealed class SyncBackgroundTask : IBackgroundTask
{
    private readonly IDataSync _sync;
    public SyncBackgroundTask(IDataSync sync) => _sync = sync;

    public Task StartAsync(CancellationToken token)
        => Task.Run(() => _sync.RunLoopAsync(token), token);

    public Task StopAsync(CancellationToken token)
        => _sync.StopAsync(token);
}

public static class BackgroundTaskExtensions
{
    public static void Attach(this IBackgroundTask task, IApplicationLifetime lifetime)
    {
        switch (lifetime)
        {
            case IClassicDesktopStyleApplicationLifetime desktop:
                desktop.Startup += async (_, _) => await task.StartAsync(CancellationToken.None);
                desktop.Exit += async (_, _) => await task.StopAsync(CancellationToken.None);
                break;
            case ISingleViewApplicationLifetime singleView when singleView.MainView is { } view:
                view.AttachedToVisualTree += async (_, _) => await task.StartAsync(CancellationToken.None);
                view.DetachedFromVisualTree += async (_, _) => await task.StopAsync(CancellationToken.None);
                break;
        }
    }
}
\end{lstlisting}

Desktop lifetimes expose
\passthrough{\lstinline!Startup!}/\passthrough{\lstinline!Exit!};
single-view/mobile lifetimes expose
\passthrough{\lstinline!FrameworkInitializationCompleted!}/\passthrough{\lstinline!OnStopped!}.
Provide adapters per lifetime so the task implementation stays portable,
and inject platform helpers (connectivity, storage) through interfaces.

\subsection{7. Reactive event streams}\label{reactive-event-streams}

\passthrough{\lstinline!Observable.FromEventPattern!} converts callbacks
into composable streams. Combine it with
\passthrough{\lstinline!DispatcherScheduler.Current!} (from
System.Reactive) so observations switch back to the UI thread.

\begin{lstlisting}
var pointerStream = Observable
    .FromEventPattern<PointerEventArgs>(handler => control.PointerMoved += handler,
                                       handler => control.PointerMoved -= handler)
    .Select(args => args.EventArgs.GetPosition(control))
    .Throttle(TimeSpan.FromMilliseconds(50))
    .ObserveOn(DispatcherScheduler.Current)
    .Subscribe(point => PointerPosition = point);

Disposables.Add(pointerStream);
\end{lstlisting}

This pattern keeps heavy processing (\passthrough{\lstinline!Throttle!},
network calls) off the UI thread while delivering results back in order.
For view models, expose \passthrough{\lstinline!IObservable<T>!}
properties and let the view subscribe using
\passthrough{\lstinline!ReactiveUI.WhenAnyValue!} or manual
subscriptions. \passthrough{\lstinline!Disposables!} here is a
\passthrough{\lstinline!CompositeDisposable!} that you dispose when the
view/control unloads.

\subsection{8. Testing background code}\label{testing-background-code}

Use \passthrough{\lstinline!Task.Delay!} injection or
\passthrough{\lstinline!ITestScheduler!} (ReactiveUI) to control time.
For plain async code, wrap delays in an interface to mock in tests.

\begin{lstlisting}
public interface IDelayProvider
{
    Task Delay(TimeSpan time, CancellationToken ct);
}

public sealed class DelayProvider : IDelayProvider
{
    public Task Delay(TimeSpan time, CancellationToken ct) => Task.Delay(time, ct);
}
\end{lstlisting}

Inject and replace with deterministic delays in tests.

\subsection{9. Browser (WebAssembly)
considerations}\label{browser-webassembly-considerations-1}

\begin{itemize}
\tightlist
\item
  HttpClient uses fetch; CORS applies.
\item
  WebSockets available via \passthrough{\lstinline!ClientWebSocket!}
  when allowed by browser.
\item
  Long-running loops should yield frequently
  (\passthrough{\lstinline!await Task.Yield()!}) to avoid blocking JS
  event loop.
\end{itemize}

\subsection{10. Practice exercises}\label{practice-exercises-11}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Build a data sync command that fetches JSON from an API, parses it,
  and updates view models without freezing UI.
\item
  Add cancellation and progress reporting to a file import feature
  (Chapter 16) using \passthrough{\lstinline!IProgress<double>!}.
\item
  Implement retry with exponential backoff around a flaky endpoint and
  show status messages when retries occur.
\item
  Detect connectivity loss and display an offline banner; queue commands
  to run when back online.
\item
  Transform pointer move events into an
  \passthrough{\lstinline!Observable!} pipeline with throttling and
  verify updates stay on the UI thread.
\item
  Write a unit test that confirms cancellation stops a long-running
  operation before completion.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-15}

\begin{itemize}
\tightlist
\item
  Dispatcher \& UI thread:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Threading/Dispatcher.cs}{\passthrough{\lstinline!Dispatcher.cs!}}
\item
  Priorities \& timers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Threading/DispatcherPriority.cs}{\passthrough{\lstinline!DispatcherPriority.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Threading/DispatcherTimer.cs}{\passthrough{\lstinline!DispatcherTimer.cs!}}
\item
  Lifetimes:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs}{\passthrough{\lstinline!IClassicDesktopStyleApplicationLifetime!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ISingleViewApplicationLifetime.cs}{\passthrough{\lstinline!ISingleViewApplicationLifetime!}}
\item
  Progress reporting:
  \href{https://learn.microsoft.com/dotnet/api/system.progress-1}{\passthrough{\lstinline!Progress<T>!}}
\item
  HttpClient guidance:
  \href{https://learn.microsoft.com/dotnet/fundamentals/networking/http/httpclient}{.NET
  HttpClient docs}
\item
  Cancellation tokens:
  \href{https://learn.microsoft.com/dotnet/standard/threading/cancellation-in-managed-threads}{.NET
  cancellation docs}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-15}

\begin{itemize}
\tightlist
\item
  Why does blocking the UI thread freeze the app? How do you keep it
  responsive?
\item
  How do you propagate cancellation through nested async calls?
\item
  Which HttpClient features help prevent hung requests?
\item
  How can you provide progress updates without touching
  \passthrough{\lstinline!Dispatcher.UIThread!} manually?
\item
  What adjustments are needed when running the same code on the browser?
\end{itemize}

What's next - Next: \href{Chapter18.md}{Chapter 18}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part IV — Cross‑platform deployment without headaches}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part IV — Cross‑platform deployment without headaches}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{18. Desktop targets: Windows, macOS,
Linux}\label{desktop-targets-windows-macos-linux}

Goal - Master Avalonia's desktop-specific features: window chrome,
transparency, DPI/multi-monitor handling, platform capabilities, and
packaging essentials. - Understand per-platform caveats so your desktop
app feels native on Windows, macOS, and Linux.

Why this matters - Desktop users expect native window behavior, correct
scaling, and integration with OS features (taskbar/dock, notifications).
- Avalonia abstracts the basics but you still need to apply
platform-specific tweaks.

Prerequisites - Chapter 4 (lifetimes), Chapter 12 (window navigation),
Chapter 13 (menus/dialogs), Chapter 16 (storage).

\subsection{1. Desktop backends at a
glance}\label{desktop-backends-at-a-glance}

Avalonia ships multiple desktop backends;
\passthrough{\lstinline!AppBuilder.UsePlatformDetect()!} selects the
correct platform at runtime. Understanding the differences helps when
you tweak options or debug native interop.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2500}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Platform
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Backend type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Namespace
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Notes
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Windows & \passthrough{\lstinline!Win32Platform!} &
\passthrough{\lstinline!Avalonia.Win32!} & Win32 windowing with optional
WinUI composition, ANGLE/OpenGL bridges, tray icon helpers. \\
Windows/macOS & \passthrough{\lstinline!AvaloniaNativePlatform!} &
\passthrough{\lstinline!Avalonia.Native!} & Shared native host (AppKit
on macOS). Used for windowless scenarios and for macOS desktop
builds. \\
Linux (X11) & \passthrough{\lstinline!X11Platform!} &
\passthrough{\lstinline!Avalonia.X11!} & Traditional X11 windowing;
integrates with FreeDesktop protocols. \\
Linux portals & \passthrough{\lstinline!FreeDesktopPlatform!} &
\passthrough{\lstinline!Avalonia.FreeDesktop!} & Supplements X11/Wayland
with portal services (dialogs, notifications). \\
\end{longtable}

Startup options customize each backend:

\begin{lstlisting}
AppBuilder.Configure<App>()
    .UsePlatformDetect()
    .With(new Win32PlatformOptions
    {
        RenderingMode = new[] { Win32RenderingMode.AngleEgl, Win32RenderingMode.Software },
        CompositionMode = new[] { Win32CompositionMode.WinUIComposition, Win32CompositionMode.RedirectionSurface },
        OverlayPopups = true
    })
    .With(new MacOSPlatformOptions
    {
        DisableDefaultApplicationMenuItems = false,
        ShowInDock = true
    })
    .With(new X11PlatformOptions
    {
        RenderingMode = new[] { X11RenderingMode.Glx, X11RenderingMode.Software },
        UseDBusMenu = true,
        WmClass = "MyAvaloniaApp"
    });
\end{lstlisting}

These options map to platform implementations in
\passthrough{\lstinline!Avalonia.Win32!},
\passthrough{\lstinline!Avalonia.Native!}, and
\passthrough{\lstinline!Avalonia.X11!}. Tune them when enabling extended
client area, portals, or GPU interop.

\subsection{2. Window fundamentals}\label{window-fundamentals}

\begin{lstlisting}[language=XML]
<Window xmlns="https://github.com/avaloniaui"
        x:Class="MyApp.MainWindow"
        Width="1024" Height="720"
        CanResize="True"
        SizeToContent="Manual"
        WindowStartupLocation="CenterScreen"
        ShowInTaskbar="True"
        Topmost="False"
        Title="My App">

</Window>
\end{lstlisting}

Properties: - \passthrough{\lstinline!WindowState!}: Normal, Minimized,
Maximized, FullScreen. - \passthrough{\lstinline!CanResize!},
\passthrough{\lstinline!CanMinimize!},
\passthrough{\lstinline!CanMaximize!} control system caption buttons. -
\passthrough{\lstinline!SizeToContent!}:
\passthrough{\lstinline!Manual!}, \passthrough{\lstinline!Width!},
\passthrough{\lstinline!Height!},
\passthrough{\lstinline!WidthAndHeight!} (works best before window is
shown). - \passthrough{\lstinline!WindowStartupLocation!}:
\passthrough{\lstinline!Manual!} (default),
\passthrough{\lstinline!CenterScreen!},
\passthrough{\lstinline!CenterOwner!}. -
\passthrough{\lstinline!ShowInTaskbar!}: show/hide taskbar/dock icon. -
\passthrough{\lstinline!Topmost!}: keep above other windows.

Persist position/size between runs:

\begin{lstlisting}
protected override void OnOpened(EventArgs e)
{
    base.OnOpened(e);
    if (LocalSettings.TryReadWindowPlacement(out var placement))
    {
        Position = placement.Position;
        Width = placement.Width;
        Height = placement.Height;
        WindowState = placement.State;
    }
}

protected override void OnClosing(WindowClosingEventArgs e)
{
    base.OnClosing(e);
    LocalSettings.WriteWindowPlacement(new WindowPlacement
    {
        Position = Position,
        Width = Width,
        Height = Height,
        State = WindowState
    });
}
\end{lstlisting}

\subsection{3. Custom title bars and
chrome}\label{custom-title-bars-and-chrome}

\passthrough{\lstinline!SystemDecorations="None"!} removes native
chrome; use extend-client-area hints for custom title bars.

\begin{lstlisting}[language=XML]
<Window SystemDecorations="None"
        ExtendClientAreaToDecorationsHint="True"
        ExtendClientAreaChromeHints="PreferSystemChrome"
        ExtendClientAreaTitleBarHeightHint="32">
  <Grid>
    <Border Background="#1F2937" Height="32" VerticalAlignment="Top"
            PointerPressed="TitleBar_PointerPressed">
      <StackPanel Orientation="Horizontal" Margin="12,0" VerticalAlignment="Center" Spacing="12">
        <TextBlock Text="My App" Foreground="White"/>

        <Border x:Name="CloseButton" Width="32" Height="24" Background="Transparent"
                PointerPressed="CloseButton_PointerPressed">
          <Path Stroke="White" StrokeThickness="2" Data="M2,2 L10,10 M10,2 L2,10" HorizontalAlignment="Center" VerticalAlignment="Center"/>
        </Border>
      </StackPanel>
    </Border>

  </Grid>
</Window>
\end{lstlisting}

\begin{lstlisting}
private void TitleBar_PointerPressed(object? sender, PointerPressedEventArgs e)
{
    if (e.GetCurrentPoint(this).Properties.IsLeftButtonPressed)
        BeginMoveDrag(e);
}

private void CloseButton_PointerPressed(object? sender, PointerPressedEventArgs e)
{
    Close();
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  Provide hover/pressed styles for buttons.
\item
  Add keyboard/screen reader support (AutomationProperties).
\end{itemize}

\subsection{4. Window transparency \&
effects}\label{window-transparency-effects}

\begin{lstlisting}[language=XML]
<Window TransparencyLevelHint="Mica, AcrylicBlur, Blur, Transparent">

</Window>
\end{lstlisting}

\begin{lstlisting}
TransparencyLevelHint = new[]
{
    WindowTransparencyLevel.Mica,
    WindowTransparencyLevel.AcrylicBlur,
    WindowTransparencyLevel.Blur,
    WindowTransparencyLevel.Transparent
};

this.GetObservable(TopLevel.ActualTransparencyLevelProperty)
    .Subscribe(level => Debug.WriteLine($"Transparency: {level}"));
\end{lstlisting}

Platform support summary (subject to OS version, composition mode): -
Windows 10/11: Transparent, Blur, AcrylicBlur, Mica (Win11). - macOS:
Transparent, Blur (vibrancy). - Linux (compositor dependent):
Transparent, Blur.

Design for fallback: ActualTransparencyLevel may be
\passthrough{\lstinline!None!}--ensure backgrounds look good without
blur.

\subsection{5. Screens, DPI, and scaling}\label{screens-dpi-and-scaling}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!Screens!}: enumerate monitors
  (\passthrough{\lstinline!Screens.All!},
  \passthrough{\lstinline!Screens.Primary!}).
\item
  \passthrough{\lstinline!Screen.WorkingArea!}: available area excluding
  taskbar/dock.
\item
  \passthrough{\lstinline!Screen.Scaling!}: per-monitor scale.
\item
  \passthrough{\lstinline!Window.DesktopScaling!}: DIP to physical pixel
  ratio for positioning.
\item
  \passthrough{\lstinline!TopLevel.RenderScaling!}: DPI scaling for
  rendering (affects pixel alignment).
\end{itemize}

Center on active screen:

\begin{lstlisting}
protected override void OnOpened(EventArgs e)
{
    base.OnOpened(e);
    var currentScreen = Screens?.ScreenFromWindow(this) ?? Screens?.Primary;
    if (currentScreen is null)
        return;

    var frameSize = PixelSize.FromSize(ClientSize, DesktopScaling);
    var target = currentScreen.WorkingArea.CenterRect(frameSize);
    Position = target.Position;
}
\end{lstlisting}

Handle scaling changes when moving between monitors:

\begin{lstlisting}
ScalingChanged += (_, _) =>
{
    // Renderer scaling updated; adjust cached bitmaps if necessary.
};
\end{lstlisting}

\subsection{6. Platform integration}\label{platform-integration}

\subsubsection{6.1 Windows}\label{windows-1}

\begin{itemize}
\tightlist
\item
  Taskbar/dock menus: use Jump Lists via
  \passthrough{\lstinline!System.Windows.Shell!} interop or community
  packages.
\item
  Notifications: \passthrough{\lstinline!WindowNotificationManager!} or
  Windows toast (via WinRT APIs).
\item
  Acrylic/Mica: require Windows 10 or 11; fallback on earlier versions.
\item
  System backdrops: set \passthrough{\lstinline!TransparencyLevelHint!}
  and ensure the OS supports it; consider theme-aware backgrounds.
\item
  \passthrough{\lstinline!Win32PlatformOptions!} exposes rendering
  toggles (\passthrough{\lstinline!RenderingMode!},
  \passthrough{\lstinline!CompositionMode!},
  \passthrough{\lstinline!OverlayPopups!}). Keep
  \passthrough{\lstinline!Software!} in the list as a fallback for
  Remote Desktop.
\item
  Use \passthrough{\lstinline!TryGetPlatformHandle()!} to retrieve HWNDs
  when integrating with native libraries; avoid depending on internal
  \passthrough{\lstinline!WindowImpl!} types.
\end{itemize}

\subsubsection{6.2 macOS}\label{macos-1}

\begin{itemize}
\tightlist
\item
  Menu bar: use \passthrough{\lstinline!NativeMenuBar!} (Chapter 13).
\item
  Dock menu: \passthrough{\lstinline!NativeMenuBar.Menu!} can include
  items that appear in dock menu.
\item
  Application events (Quit, About): integrate with
  \passthrough{\lstinline!AvaloniaNativeMenuCommands!} or handle native
  application events.
\item
  Fullscreen: Mac expects toggle via green traffic-light button;
  \passthrough{\lstinline!WindowState.FullScreen!} works, but ensure
  custom chrome still accessible.
\item
  \passthrough{\lstinline!MacOSPlatformOptions!} lets you hide dock
  icons, disable the default menu items, or reuse an existing
  \passthrough{\lstinline!NSApplication!} delegate.
\item
  Pair \passthrough{\lstinline!AvaloniaNativeRenderingMode!} with a
  \passthrough{\lstinline!UseSkia!} configuration so you always include
  \passthrough{\lstinline!Software!} fallback alongside
  \passthrough{\lstinline!Metal!}/\passthrough{\lstinline!OpenGl!} for
  older GPUs.
\end{itemize}

\subsubsection{6.3 Linux}\label{linux}

\begin{itemize}
\tightlist
\item
  Variety of window managers; test SystemDecorations/ExtendClientArea on
  GNOME/KDE.
\item
  Transparency requires compositor (e.g., Mutter, KWin). Provide
  fallback.
\item
  Fractional scaling support varies; check
  \passthrough{\lstinline!RenderScaling!} for the active monitor.
\item
  Packaging (Flatpak, Snap, AppImage) may affect file dialog behavior
  (portal APIs).
\item
  \passthrough{\lstinline!X11PlatformOptions!} controls GLX/EGL
  fallbacks, DBus menus, and IME support; pair it with Avalonia's
  FreeDesktop portal helpers when running inside Flatpak/Snap.
\item
  Use \passthrough{\lstinline!WmClass!} (on
  \passthrough{\lstinline!X11PlatformOptions!}) to integrate with
  desktop launchers and icon themes.
\end{itemize}

\subsection{7. Rendering \& GPU
selection}\label{rendering-gpu-selection}

Avalonia renders through Skia; each backend exposes toggles for GPU
acceleration and composition. Tune them to balance visuals versus
compatibility.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Platform
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Rendering options
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
When to change
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Windows (\passthrough{\lstinline!Win32PlatformOptions!}) &
\passthrough{\lstinline!RenderingMode!}
(\passthrough{\lstinline!AngleEgl!}, \passthrough{\lstinline!Wgl!},
\passthrough{\lstinline!Vulkan!}, \passthrough{\lstinline!Software!}),
\passthrough{\lstinline!CompositionMode!}
(\passthrough{\lstinline!WinUIComposition!}, etc.),
\passthrough{\lstinline!GraphicsAdapterSelectionCallback!},
\passthrough{\lstinline!WinUICompositionBackdropCornerRadius!} & Choose
ANGLE + WinUI for blur effects, fall back to software for remote
desktops, pick dedicated GPU in multi-adapter rigs. \\
macOS (\passthrough{\lstinline!AvaloniaNativePlatformOptions!}) &
\passthrough{\lstinline!RenderingMode!} (Metal, OpenGL, Software) &
Prefer Metal on modern macOS; include Software as fallback for virtual
machines. \\
Linux (\passthrough{\lstinline!X11PlatformOptions!}) &
\passthrough{\lstinline!RenderingMode!} (\passthrough{\lstinline!Glx!},
\passthrough{\lstinline!Egl!}, \passthrough{\lstinline!Vulkan!},
\passthrough{\lstinline!Software!}),
\passthrough{\lstinline!GlxRendererBlacklist!},
\passthrough{\lstinline!UseDBusMenu!},
\passthrough{\lstinline!UseDBusFilePicker!} & Disable GLX on problematic
drivers, force software when GPU drivers are unstable. \\
\end{longtable}

\passthrough{\lstinline!UseSkia!} accepts
\passthrough{\lstinline!SkiaOptions!} for further tuning:

\begin{lstlisting}
AppBuilder.Configure<App>()
    .UsePlatformDetect()
    .With(new SkiaOptions
    {
        MaxGpuResourceSizeBytes = 128 * 1024 * 1024, // cap VRAM usage
        UseOpacitySaveLayer = true
    })
    .UseSkia()
    .LogToTrace();
\end{lstlisting}

Inside a window you can inspect the actual implementation for
diagnostics:

\begin{lstlisting}
if (TryGetPlatformHandle() is { Handle: var hwnd, HandleDescriptor: "HWND" })
    Debug.WriteLine($"HWND: 0x{hwnd.ToInt64():X}");
\end{lstlisting}

Log area \passthrough{\lstinline!Avalonia.Rendering.Platform!} reports
which backend was selected; capture it during startup when debugging
GPU-related issues.

\subsection{8. Packaging \& deployment
overview}\label{packaging-deployment-overview}

\begin{itemize}
\tightlist
\item
  Windows:
  \passthrough{\lstinline!dotnet publish -r win-x64 --self-contained!}
  or MSIX via
  \passthrough{\lstinline!dotnet publish /p:PublishTrimmed=false /p:WindowsPackageType=msix!}.
  Bundle ANGLE DLLs (\passthrough{\lstinline!libEGL.dll!},
  \passthrough{\lstinline!libGLESv2.dll!}) and
  \passthrough{\lstinline!d3dcompiler\_47.dll!} when using GPU
  composition; ship \passthrough{\lstinline!vc\_redist!} prerequisites
  for older OS versions.
\item
  macOS: \passthrough{\lstinline!.app!} bundle; codesign and notarize
  for distribution
  (\passthrough{\lstinline!dotnet publish -r osx-x64 --self-contained!}
  followed by bundle packaging via Avalonia templates or scripts).
  Include \passthrough{\lstinline!libAvaloniaNative.dylib!}, ensure
  \passthrough{\lstinline!Info.plist!} declares
  \passthrough{\lstinline!NSHighResolutionCapable!}, and register custom
  URL schemes if you rely on \passthrough{\lstinline!ILauncher!}.
\item
  Linux: produce .deb/.rpm, AppImage, or Flatpak; ensure dependencies
  (\passthrough{\lstinline!libAvaloniaNative.so!}, libSkia) are present.
  Flatpak portals rely on \passthrough{\lstinline!xdg-desktop-portal!};
  declare it as a runtime dependency and verify DBus access so storage
  pickers keep working.
\end{itemize}

Reference docs: Avalonia publishing guide
(\href{https://github.com/AvaloniaUI/Avalonia/blob/master/docs/publish.md}{docs/publish.md}).

\subsection{9. Multiple window management
tips}\label{multiple-window-management-tips}

\begin{itemize}
\tightlist
\item
  Track open windows via
  \passthrough{\lstinline!ApplicationLifetime.Windows!} (desktop only).
\item
  Use
  \passthrough{\lstinline!IClassicDesktopStyleApplicationLifetime.Exit!}
  to exit the app.
\item
  Owner/child relationships ensure modality, centering, and Z-order
  (Chapter 12).
\item
  Provide ``Move to Next Monitor'' command by cycling through
  \passthrough{\lstinline!Screens.All!} and setting
  \passthrough{\lstinline!Position!} accordingly.
\end{itemize}

\subsection{10. Troubleshooting}\label{troubleshooting-2}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Issue
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Fix
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Window blurry on high DPI & Use vector assets; adjust RenderScaling;
ensure \passthrough{\lstinline!UseCompositor!} is default \\
Transparency ignored & Check ActualTransparencyLevel; verify OS support;
remove conflicting settings \\
Custom chrome drag fails & Ensure
\passthrough{\lstinline!BeginMoveDrag!} only on left button down; avoid
starting drag from interactive controls \\
Incorrect monitor on startup & Set
\passthrough{\lstinline!WindowStartupLocation!} or compute position
using \passthrough{\lstinline!Screens!} before showing window \\
Linux packaging fails & Include
\passthrough{\lstinline!libAvaloniaNative.so!} dependencies; use
Avalonia Debian/RPM packaging scripts \\
\end{longtable}

\subsection{11. Practice exercises}\label{practice-exercises-12}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Build a window with custom title bar, including minimize, maximize,
  close, and move/resize handles.
\item
  Request Mica/Acrylic, detect fallback, and apply theme-specific
  backgrounds for each transparency level.
\item
  Implement a ``Move to Next Monitor'' command cycling through available
  screens.
\item
  Persist window placement (position/size/state) to disk and restore on
  startup.
\item
  Log which backend (\passthrough{\lstinline!Win32RenderingMode!},
  \passthrough{\lstinline!X11RenderingMode!}, etc.) starts under
  different option combinations and document the impact on transparency
  and input latency.
\item
  Create deployment artifacts: MSIX (Windows), .app (macOS), and
  AppImage/Flatpak (Linux) for a simple app.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-16}

\begin{itemize}
\tightlist
\item
  Window \& TopLevel:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Window.cs}{\passthrough{\lstinline!Window.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/TopLevel.cs}{\passthrough{\lstinline!TopLevel.cs!}}
\item
  Transparency enums:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/WindowTransparencyLevel.cs}{\passthrough{\lstinline!WindowTransparencyLevel.cs!}}
\item
  Screens API:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Screens.cs}{\passthrough{\lstinline!Screens.cs!}}
\item
  Extend client area hints:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Window.cs}{\passthrough{\lstinline!Window.cs!}
  lines around ExtendClientArea properties}
\item
  Desktop lifetime:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/ClassicDesktopStyleApplicationLifetime.cs}{\passthrough{\lstinline!ClassicDesktopStyleApplicationLifetime.cs!}}
\item
  Backend options:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Windows/Avalonia.Win32/Win32PlatformOptions.cs}{\passthrough{\lstinline!Win32PlatformOptions!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Native/AvaloniaNativePlatformExtensions.cs}{\passthrough{\lstinline!AvaloniaNativePlatformExtensions!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.X11/X11Platform.cs}{\passthrough{\lstinline!X11Platform.cs!}}
\item
  Skia configuration:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Skia/Avalonia.Skia/SkiaOptions.cs}{\passthrough{\lstinline!SkiaOptions!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-16}

\begin{itemize}
\tightlist
\item
  How do you request and detect the achieved transparency level on each
  platform?
\item
  What steps are needed to build a custom title bar that supports drag
  and resize?
\item
  How do you center a window on the active monitor using
  \passthrough{\lstinline!Screens!} and scaling info?
\item
  What packaging options are available per desktop platform?
\item
  Which option sets control rendering fallbacks on Windows and Linux
  backends?
\end{itemize}

What's next - Next: \href{Chapter19.md}{Chapter 19}

\newpage

\subsection{19. Mobile targets: Android and
iOS}\label{mobile-targets-android-and-ios}

Goal - Configure, build, and run Avalonia apps on Android and iOS using
the single-project workflow. - Understand
\passthrough{\lstinline!AvaloniaActivity!},
\passthrough{\lstinline!AvaloniaApplication!}, and
\passthrough{\lstinline!AvaloniaAppDelegate!} lifetimes so your shared
code boots correctly on each platform. - Integrate platform services
(back button, clipboard, storage, notifications) while respecting safe
areas, touch input, and trimming constraints.

Why this matters - Mobile devices have different UI expectations (single
window, touch, safe areas, OS-managed lifecycle). - Avalonia lets you
share code across desktop and mobile, but you must adjust hosting
lifetimes, navigation, and platform service wiring.

Prerequisites - Chapter 12 (lifetimes/navigation), Chapter 16 (storage
provider), Chapter 17 (async/networking).

\subsection{1. Projects and workload
setup}\label{projects-and-workload-setup}

Install .NET workloads and mobile SDKs:

\begin{lstlisting}[language=bash]
## Android
sudo dotnet workload install android

## iOS (macOS only)
sudo dotnet workload install ios

## Optional: wasm-tools for browser
sudo dotnet workload install wasm-tools
\end{lstlisting}

Check workloads with \passthrough{\lstinline!dotnet workload list!}.

Project structure: - Shared project (e.g.,
\passthrough{\lstinline!MyApp!}): Avalonia cross-platform code. -
Platform heads (Android, iOS): host the Avalonia app, provide manifests,
icons, metadata.

\passthrough{\lstinline!dotnet new avalonia.app --multiplatform!}
creates the shared project plus heads
(\passthrough{\lstinline!MyApp.Android!},
\passthrough{\lstinline!MyApp.iOS!}, optional
\passthrough{\lstinline!MyApp.Browser!}). The Android head references
\passthrough{\lstinline!Avalonia.Android!} (which contains
\passthrough{\lstinline!AvaloniaActivity!} and
\passthrough{\lstinline!AvaloniaApplication!}); the iOS head references
\passthrough{\lstinline!Avalonia.iOS!} (which contains
\passthrough{\lstinline!AvaloniaAppDelegate!}).

Keep trimming/linker settings in
\passthrough{\lstinline!Directory.Build.props!} so shared code doesn't
lose reflection-heavy ViewModels. Example additions:

\begin{lstlisting}[language=XML]
<PropertyGroup>
  <TrimMode>partial</TrimMode>
  <IlcInvariantGlobalization>true</IlcInvariantGlobalization>
  <PublishTrimmed>true</PublishTrimmed>
</PropertyGroup>
\end{lstlisting}

Use \passthrough{\lstinline!TrimmerRootAssembly!} or
\passthrough{\lstinline!DynamicDependency!} attributes if you depend on
reflection-heavy frameworks (e.g., ReactiveUI). Test Release builds on
devices early to catch linker issues.

\subsection{2. Single-view lifetime}\label{single-view-lifetime}

\passthrough{\lstinline!ISingleViewApplicationLifetime!} hosts one root
view. Configure in
\passthrough{\lstinline!App.OnFrameworkInitializationCompleted!}
(Chapter 4 showed desktop branch).

\begin{lstlisting}
public override void OnFrameworkInitializationCompleted()
{
    var services = ConfigureServices();

    if (ApplicationLifetime is ISingleViewApplicationLifetime singleView)
    {
        singleView.MainView = services.GetRequiredService<ShellView>();
    }
    else if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
    {
        desktop.MainWindow = services.GetRequiredService<MainWindow>();
    }

    base.OnFrameworkInitializationCompleted();
}
\end{lstlisting}

\passthrough{\lstinline!ShellView!} is a
\passthrough{\lstinline!UserControl!} with mobile-friendly layout and
navigation.

Hot reload: on Android, Rider/Visual Studio can use .NET Hot Reload
against \passthrough{\lstinline!MyApp.Android!}. For XAML hot reload in
Previewer, add
\passthrough{\lstinline!<ItemGroup><XamlIlAssemblyInfo>true</XamlIlAssemblyInfo></ItemGroup>!}
to the shared project and keep the head running via
\passthrough{\lstinline!dotnet build -t:Run!}.

\subsection{3. Mobile navigation
patterns}\label{mobile-navigation-patterns}

Use view-model-first navigation (Chapter 12) but ensure a visible Back
control.

\begin{lstlisting}[language=XML]
<UserControl xmlns="https://github.com/avaloniaui" x:Class="MyApp.Views.ShellView">
  <Grid RowDefinitions="Auto,*">
    <StackPanel Orientation="Horizontal" Spacing="8" Margin="16">
      <Button Content="Back"
              Command="{Binding BackCommand}"
              IsVisible="{Binding CanGoBack}"/>
      <TextBlock Text="{Binding Title}" FontSize="20" VerticalAlignment="Center"/>
    </StackPanel>
    <TransitioningContentControl Grid.Row="1" Content="{Binding Current}"/>
  </Grid>
</UserControl>
\end{lstlisting}

\passthrough{\lstinline!ShellViewModel!} keeps a stack of view models
and implements
\passthrough{\lstinline!BackCommand!}/\passthrough{\lstinline!NavigateTo!}.
Hook Android back button (Next section) to
\passthrough{\lstinline!BackCommand!} and mirror the same logic inside
\passthrough{\lstinline!AvaloniaAppDelegate!} to react to swipe-back
gestures on iOS.

\subsection{4. Safe areas and input
insets}\label{safe-areas-and-input-insets}

Phones have notches and OS-controlled bars. Use
\passthrough{\lstinline!IInsetsManager!} to apply safe-area padding.

\begin{lstlisting}
public partial class ShellView : UserControl
{
    public ShellView()
    {
        InitializeComponent();
        this.AttachedToVisualTree += (_, __) =>
        {
            var top = TopLevel.GetTopLevel(this);
            var insets = top?.InsetsManager;
            if (insets is null) return;

            void ApplyInsets()
            {
                RootPanel.Padding = new Thickness(
                    insets.SafeAreaPadding.Left,
                    insets.SafeAreaPadding.Top,
                    insets.SafeAreaPadding.Right,
                    insets.SafeAreaPadding.Bottom);
            }

            ApplyInsets();
            insets.Changed += (_, __) => ApplyInsets();
        };
    }
}
\end{lstlisting}

Soft keyboard (IME) adjustments: subscribe to
\passthrough{\lstinline!TopLevel.InputPane.Showing/Hiding!} and adjust
margins above keyboard.

\begin{lstlisting}
var pane = top?.InputPane;
if (pane is not null)
{
    pane.Showing += (_, args) => RootPanel.Margin = new Thickness(0, 0, 0, args.OccludedRect.Height);
    pane.Hiding += (_, __) => RootPanel.Margin = new Thickness(0);
}
\end{lstlisting}

Touch input specifics: prefer gesture recognizers
(\passthrough{\lstinline!Tapped!},
\passthrough{\lstinline!DoubleTapped!},
\passthrough{\lstinline!PointerGestureRecognizer!}) over mouse events,
and test with real hardware---emulators may not surface haptics or
multi-touch.

\subsection{5. Platform head
customization}\label{platform-head-customization}

\subsubsection{5.1 Android head
(MyApp.Android)}\label{android-head-myapp.android}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!MainActivity.cs!} inherits from
  \passthrough{\lstinline!AvaloniaActivity!}. Override
  \passthrough{\lstinline!AppBuilder CustomizeAppBuilder(AppBuilder builder)!}
  to inject logging or DI.
\item
  \passthrough{\lstinline!MyApplication.cs!} can inherit from
  \passthrough{\lstinline!AvaloniaApplication!} to bootstrap services
  before the activity creates the view.
\item
  \passthrough{\lstinline!AndroidManifest.xml!}: declare permissions
  (\passthrough{\lstinline!INTERNET!},
  \passthrough{\lstinline!READ\_EXTERNAL\_STORAGE!}), orientation,
  minimum SDK.
\item
  App icons/splash: \passthrough{\lstinline!Resources/mipmap-*!},
  \passthrough{\lstinline!Resources/xml/splashscreen.xml!} for Android
  12+ splash.
\item
  Enable fast deployment/device hot reload by setting
  \passthrough{\lstinline!<AndroidEnableProfiler>true</AndroidEnableProfiler>!}
  in Debug configuration.
\item
  Intercept hardware Back button by overriding
  \passthrough{\lstinline!OnBackPressed!} or using
  \passthrough{\lstinline!AvaloniaLocator.Current.GetService<IMobileNavigation>()!}.
\end{itemize}

\begin{lstlisting}
public override void OnBackPressed()
{
    if (!AvaloniaApp.Current?.TryGoBack() ?? true)
        base.OnBackPressed();
}
\end{lstlisting}

\passthrough{\lstinline!TryGoBack!} calls into shared navigation service
and returns true if you consumed the event. To embed Avalonia inside an
existing native activity, host \passthrough{\lstinline!AvaloniaView!}
inside a layout and call
\passthrough{\lstinline!AvaloniaView.Initialize(this, AppBuilder.Configure<App>()...)!}.

\subsubsection{5.2 iOS head (MyApp.iOS)}\label{ios-head-myapp.ios}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!AppDelegate.cs!} inherits from
  \passthrough{\lstinline!AvaloniaAppDelegate!}. Override
  \passthrough{\lstinline!CustomizeAppBuilder!} to inject services or
  register platform-specific singletons.
\item
  \passthrough{\lstinline!Program.cs!} wraps
  \passthrough{\lstinline!UIApplication.Main(args, null, typeof(AppDelegate))!}
  so the delegate boots Avalonia.
\item
  \passthrough{\lstinline!Info.plist!}: permissions (e.g., camera),
  orientation, status bar style.
\item
  Launch screen via \passthrough{\lstinline!LaunchScreen.storyboard!} or
  SwiftUI resources in Xcode.
\item
  Use \passthrough{\lstinline!AvaloniaViewController!} to embed Avalonia
  content inside UIKit navigation stacks or tab controllers.
\end{itemize}

Handle universal links or background tasks by bridging to shared
services in \passthrough{\lstinline!AppDelegate!}. For swipe-back
gestures, implement \passthrough{\lstinline!TryGoBack!} inside
\passthrough{\lstinline!AvaloniaNavigationController!} or intercept
\passthrough{\lstinline!UINavigationControllerDelegate!} callbacks.

\subsubsection{5.3 Sharing services across
heads}\label{sharing-services-across-heads}

Inject platform implementations for
\passthrough{\lstinline!IClipboard!},
\passthrough{\lstinline!IStorageProvider!}, notifications, and share
targets via dependency injection. Register them in
\passthrough{\lstinline!AvaloniaLocator.CurrentMutable!} inside
\passthrough{\lstinline!CustomizeAppBuilder!} to keep shared code
unaware of head-specific services.

\subsection{6. Permissions \& storage}\label{permissions-storage}

\begin{itemize}
\tightlist
\item
  StorageProvider works but returns sandboxed streams. Request platform
  permissions:

  \begin{itemize}
  \tightlist
  \item
    Android: declare
    \passthrough{\lstinline!<uses-permission android:name="android.permission.READ\_EXTERNAL\_STORAGE"/>!}
    and use runtime requests.
  \item
    iOS: add entries to Info.plist (e.g.,
    \passthrough{\lstinline!NSPhotoLibraryUsageDescription!}).
  \end{itemize}
\item
  Consider packaging specific data (e.g., from
  \passthrough{\lstinline!AppBundle!}) instead of relying on arbitrary
  file system access.
\item
  Use \passthrough{\lstinline!EssentialsPermissions!} helper libraries
  carefully---Release builds with trimming must preserve permission
  classes. Validate by running
  \passthrough{\lstinline!dotnet publish -c Release!} on
  device/emulator.
\item
  Push notifications and background fetch require platform services:
  expose custom interfaces (e.g.,
  \passthrough{\lstinline!IPushNotificationService!}) that platform
  heads implement and inject into shared locator.
\end{itemize}

\subsection{7. Touch and gesture design}\label{touch-and-gesture-design}

\begin{itemize}
\tightlist
\item
  Ensure controls are at least 44x44 DIP.
\item
  Provide ripple/highlight states for buttons (Fluent theme handles
  this). Avoid hover-only interactions.
\item
  Use
  \passthrough{\lstinline!Tapped!}/\passthrough{\lstinline!DoubleTapped!}
  events for simple gestures;
  \passthrough{\lstinline!PointerGestureRecognizer!} for advanced ones.
\item
  Keep layout responsive: use \passthrough{\lstinline!TopLevel.Screen!}
  to detect orientation/size classes and expose them via your view
  models.
\end{itemize}

\subsection{8. Performance \& profiling}\label{performance-profiling}

\begin{itemize}
\tightlist
\item
  Keep navigation stacks small; heavy animations may impact lower-end
  devices.
\item
  Profile with Android Studio's profiler / Xcode Instruments for CPU,
  memory, GPU.
\item
  When using \passthrough{\lstinline!Task.Run!}, consider battery
  impact; use async I/O where possible.
\item
  Enable GPU frame stats with
  \passthrough{\lstinline!adb shell dumpsys gfxinfo!} or Xcode's Metal
  throughput counters to detect rendering bottlenecks.
\end{itemize}

\subsection{9. Packaging and deployment}\label{packaging-and-deployment}

\subsubsection{Android}\label{android}

\begin{lstlisting}[language=bash]
cd MyApp.Android
## Debug build to device
msbuild /t:Run /p:Configuration=Debug

## Release APK/AAB
msbuild /t:Publish /p:Configuration=Release /p:AndroidPackageFormat=aab
\end{lstlisting}

Sign with keystore for app store.

\subsubsection{iOS}\label{ios}

\begin{itemize}
\tightlist
\item
  Use Xcode to build and deploy to simulator/device.
  \passthrough{\lstinline!dotnet build -t:Run -f net8.0-ios!} works on
  macOS with Xcode installed.
\item
  Provisioning profiles \& certificates required for devices/app store.
\item
  Linker errors often show up only in Release; enable
  \passthrough{\lstinline!--warnaserror!} on linker warnings to catch
  missing assemblies early.
\end{itemize}

\subsubsection{Optional: Tizen}\label{optional-tizen}

Avalonia's Tizen backend (\passthrough{\lstinline!Avalonia.Tizen!})
targets smart TVs/wearables. The structure mirrors Android/iOS:
implement a Tizen \passthrough{\lstinline!Program.cs!} that calls
\passthrough{\lstinline!AppBuilder.Configure<App>().UseTizen<TizenApplication>()!}
and handles platform storage/permissions via Tizen APIs.

\subsection{10. Browser compatibility
(bonus)}\label{browser-compatibility-bonus}

Mobile code often reuses single-view logic for WebAssembly. Check
\passthrough{\lstinline!ApplicationLifetime!} for
\passthrough{\lstinline!BrowserSingleViewLifetime!} and swap to a
\passthrough{\lstinline!ShellView!}. Storage/clipboard behave like
Chapter 16 with browser limitations.

\subsection{11. Practice exercises}\label{practice-exercises-13}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Configure the Android/iOS heads and run the app on emulator/simulator
  with a shared \passthrough{\lstinline!ShellView!}.
\item
  Implement a navigation service with back stack and wire Android back
  button to it.
\item
  Adjust safe-area padding and keyboard insets for a login screen
  (Inputs remain visible when keyboard shows).
\item
  Add file pickers via \passthrough{\lstinline!StorageProvider!} and
  test on device (consider permission prompts).
\item
  Package a release build (.aab for Android, .ipa for iOS), validate
  icons/splash screens, and confirm Release trimming did not strip
  services.
\item
  (Stretch) Embed Avalonia inside a native screen
  (\passthrough{\lstinline!AvaloniaView!} on Android,
  \passthrough{\lstinline!AvaloniaViewController!} on iOS) and pass data
  between native and Avalonia layers.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-17}

\begin{itemize}
\tightlist
\item
  Android hosting:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Android/Avalonia.Android/AvaloniaActivity.cs}{\passthrough{\lstinline!AvaloniaActivity!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Android/Avalonia.Android/AvaloniaApplication.cs}{\passthrough{\lstinline!AvaloniaApplication!}}
\item
  iOS hosting:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/iOS/Avalonia.iOS/AvaloniaAppDelegate.cs}{\passthrough{\lstinline!AvaloniaAppDelegate!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/iOS/Avalonia.iOS/AvaloniaViewController.cs}{\passthrough{\lstinline!AvaloniaViewController!}}
\item
  Single-view lifetime:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/ApplicationLifetimes/SingleViewApplicationLifetime.cs}{\passthrough{\lstinline!SingleViewApplicationLifetime.cs!}}
\item
  Insets and input pane:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Platform/IInsetsManager.cs}{\passthrough{\lstinline!IInsetsManager!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Platform/IInputPane.cs}{\passthrough{\lstinline!IInputPane!}}
\item
  Platform services:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/AvaloniaLocator.cs}{\passthrough{\lstinline!AvaloniaLocator!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Input/IClipboard.cs}{\passthrough{\lstinline!IClipboard!}}
\item
  Tizen backend:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Tizen}{\passthrough{\lstinline!Avalonia.Tizen!}}
\item
  Mobile samples:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples/ControlCatalog.Android}{\passthrough{\lstinline!samples/ControlCatalog.Android!}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples/ControlCatalog.iOS}{\passthrough{\lstinline!samples/ControlCatalog.iOS!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-17}

\begin{itemize}
\tightlist
\item
  How does the navigation pattern differ between desktop and mobile? How
  do you surface back navigation?
\item
  How do you ensure inputs remain visible when the on-screen keyboard
  appears?
\item
  What permission declarations are required for file access on
  Android/iOS?
\item
  Where in the platform heads do you configure icons, splash screens,
  and orientation?
\end{itemize}

What's next - Next: \href{Chapter20.md}{Chapter 20}

\newpage

\subsection{20. Browser (WebAssembly)
target}\label{browser-webassembly-target}

Goal - Run your Avalonia app in the browser using WebAssembly (WASM)
with minimal changes to shared code. - Understand browser-specific
lifetimes, hosting options, rendering modes, and platform limitations
(files, networking, threading, DOM interop). - Debug, profile, and
deploy a browser build with confidence.

Why this matters - Web delivery eliminates install friction for demos,
tooling, and dashboards. - Browser rules (sandboxing, CORS, user
gestures) require tweaks compared to desktop/mobile, and understanding
how Avalonia binds to the JS runtime keeps those differences manageable.

Prerequisites - Chapter 19 (single-view navigation), Chapter 16 (storage
provider), Chapter 17 (async/networking).

\subsection{1. Project structure and
setup}\label{project-structure-and-setup}

Install \passthrough{\lstinline!wasm-tools!} workload:

\begin{lstlisting}[language=bash]
sudo dotnet workload install wasm-tools
\end{lstlisting}

A multi-target solution has: - Shared project
(\passthrough{\lstinline!MyApp!}): Avalonia code. - Browser head
(\passthrough{\lstinline!MyApp.Browser!}): hosts the app
(\passthrough{\lstinline!Program.cs!},
\passthrough{\lstinline!index.html!}, static assets).

Avalonia template
(\passthrough{\lstinline!dotnet new avalonia.app --multiplatform!}) can
create the browser head for you. \passthrough{\lstinline!MyApp.Browser!}
references \passthrough{\lstinline!Avalonia.Browser!}, which wraps the
WebAssembly host (\passthrough{\lstinline!BrowserAppBuilder!},
\passthrough{\lstinline!BrowserSingleViewLifetime!},
\passthrough{\lstinline!BrowserNativeControlHost!}).

When adding the head manually, target
\passthrough{\lstinline!net8.0-browserwasm!}, configure
\passthrough{\lstinline!<WasmMainJSPath>wwwroot/main.js</WasmMainJSPath>!},
and keep trimming hints (e.g.,
\passthrough{\lstinline!<InvariantGlobalization>true</InvariantGlobalization>!}).
Browser heads use the NativeAOT toolchain; Release builds can set
\passthrough{\lstinline!<PublishAot>true</PublishAot>!} for faster
startup and smaller payloads.

\subsection{2. Start the browser app}\label{start-the-browser-app}

\passthrough{\lstinline!StartBrowserAppAsync!} attaches Avalonia to a
DOM element by ID.

\begin{lstlisting}
using Avalonia;
using Avalonia.Browser;

internal sealed class Program
{
    private static AppBuilder BuildAvaloniaApp()
        => AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .LogToTrace();

    public static Task Main(string[] args)
        => BuildAvaloniaApp()
            .StartBrowserAppAsync("out");
}
\end{lstlisting}

Ensure host HTML contains
\passthrough{\lstinline!<div id="out"></div>!}.

For advanced embedding, use \passthrough{\lstinline!BrowserAppBuilder!}
directly:

\begin{lstlisting}
await BrowserAppBuilder.Configure<App>()
    .SetupBrowserAppAsync(options =>
    {
        options.MainAssembly = typeof(App).Assembly;
        options.AppBuilder = AppBuilder.Configure<App>().LogToTrace();
        options.Selector = "#out";
    });
\end{lstlisting}

\passthrough{\lstinline!SetupBrowserAppAsync!} lets you delay
instantiation (wait for configuration, auth, etc.) or mount multiple
roots in different DOM nodes.

\subsection{3. Single view lifetime}\label{single-view-lifetime-1}

Browser uses \passthrough{\lstinline!ISingleViewApplicationLifetime!}
(same as mobile). Configure in
\passthrough{\lstinline!App.OnFrameworkInitializationCompleted!}:

\begin{lstlisting}
public override void OnFrameworkInitializationCompleted()
{
    if (ApplicationLifetime is ISingleViewApplicationLifetime singleView)
        singleView.MainView = new ShellView { DataContext = new ShellViewModel() };
    else if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        desktop.MainWindow = new MainWindow { DataContext = new ShellViewModel() };

    base.OnFrameworkInitializationCompleted();
}
\end{lstlisting}

Navigation patterns from Chapter 19 apply (content control with back
stack).

\subsection{4. Rendering options}\label{rendering-options}

Configure \passthrough{\lstinline!BrowserPlatformOptions!} to choose
rendering mode and polyfills.

\begin{lstlisting}
await BuildAvaloniaApp().StartBrowserAppAsync(
    "out",
    new BrowserPlatformOptions
    {
        RenderingMode = new[]
        {
            BrowserRenderingMode.WebGL2,
            BrowserRenderingMode.WebGL1,
            BrowserRenderingMode.Software2D
        },
        RegisterAvaloniaServiceWorker = true,
        AvaloniaServiceWorkerScope = "/",
        PreferFileDialogPolyfill = false,
        PreferManagedThreadDispatcher = true
    });
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  WebGL2: best performance (default when supported).
\item
  WebGL1: fallback for older browsers.
\item
  Software2D: ultimate fallback (slower).
\item
  Service worker: required for save-file polyfill; serve over
  HTTPS/localhost.
\item
  \passthrough{\lstinline!PreferManagedThreadDispatcher!}: run
  dispatcher on worker thread when WASM threading enabled (requires
  server sending COOP/COEP headers).
\item
  \passthrough{\lstinline!PreferFileDialogPolyfill!}: toggle between
  File System Access API and download/upload fallback for unsupported
  browsers.
\end{itemize}

\subsection{5. Storage and file dialogs}\label{storage-and-file-dialogs}

\passthrough{\lstinline!IStorageProvider!} uses the File System Access
API when available; otherwise a polyfill (service worker + download
anchor) handles saves.

Limitations: - Browsers require user gestures (click) to open dialogs. -
File handles may not persist between sessions; use IDs and re-request
access if needed. - No direct file system access outside the user-chosen
handles.

Example save using polyfill-friendly code (Chapter 16 shows full
pattern). Test with/without service worker to ensure both paths work.

\subsection{6. Clipboard \& drag-drop}\label{clipboard-drag-drop}

Clipboard operations require user gestures and may only support text
formats. - \passthrough{\lstinline!Clipboard.SetTextAsync!} works after
user interaction (button click). - Advanced formats require clipboard
permissions or aren't supported.

Drag/drop from browser to app is supported, but dragging files out of
the app is limited by browser APIs.

\subsection{7. Networking \& CORS}\label{networking-cors}

\begin{itemize}
\tightlist
\item
  HttpClient uses \passthrough{\lstinline!fetch!}. All requests obey
  CORS. Configure server with correct
  \passthrough{\lstinline!Access-Control-Allow-*!} headers.
\item
  WebSockets supported via \passthrough{\lstinline!ClientWebSocket!} if
  server enables them.
\item
  HTTPS recommended; some APIs (clipboard, file access) require secure
  context.
\item
  \passthrough{\lstinline!HttpClient!} respects browser caching rules.
  Adjust \passthrough{\lstinline!Cache-Control!} headers or add
  cache-busting query parameters during development to avoid stale
  responses.
\end{itemize}

\subsection{8. JavaScript interop}\label{javascript-interop}

Call JS via \passthrough{\lstinline!window.JSObject!} or
\passthrough{\lstinline!JSRuntime!} helpers (Avalonia.Browser exposes
interop helpers). Example:

\begin{lstlisting}
using Avalonia.Browser.Interop;

await JSRuntime.InvokeVoidAsync("console.log", "Hello from Avalonia");
\end{lstlisting}

Use interop to integrate with existing web components or to access Web
APIs not wrapped by Avalonia.

To host native DOM content inside Avalonia, use
\passthrough{\lstinline!BrowserNativeControlHost!} with a
\passthrough{\lstinline!JSObjectControlHandle!}:

\begin{lstlisting}
var handle = await JSRuntime.CreateControlHandleAsync("div", new { @class = "web-frame" });
var host = new BrowserNativeControlHost { Handle = handle };
\end{lstlisting}

This enables hybrid UI scenarios (rich HTML editors, video elements)
while keeping sizing/layout under Avalonia control.

\subsection{9. Hosting in Blazor
(optional)}\label{hosting-in-blazor-optional}

\passthrough{\lstinline!Avalonia.Browser.Blazor!} lets you embed
Avalonia controls in a Blazor app. Example sample:
\passthrough{\lstinline!ControlCatalog.Browser.Blazor!}. Use when you
need Blazor's routing/layout but Avalonia UI inside components.

\subsection{10. Hosting strategies}\label{hosting-strategies}

\begin{itemize}
\tightlist
\item
  Static hosting: publish bundle to \passthrough{\lstinline!AppBundle!}
  and serve from any static host (GitHub Pages, S3 + CloudFront, Azure
  Static Web Apps). Ensure service worker scope matches site root.
\item
  ASP.NET Core: use
  \passthrough{\lstinline!MapFallbackToFile("index.html")!} or
  \passthrough{\lstinline!UseBlazorFrameworkFiles()!} to serve the
  bundle from a Minimal API or MVC backend.
\item
  Reverse proxies: configure caching (Brotli, gzip) and set
  \passthrough{\lstinline!Cross-Origin-Embedder-Policy!}/\passthrough{\lstinline!Cross-Origin-Opener-Policy!}
  headers when enabling multithreaded WASM.
\end{itemize}

During development, \passthrough{\lstinline!dotnet run!} on the browser
head launches a Kestrel server with live reload and proxies console logs
back to the terminal.

\subsection{11. Debugging and
diagnostics}\label{debugging-and-diagnostics}

\begin{itemize}
\tightlist
\item
  Inspector: use browser devtools (F12). Evaluate DOM, watch console
  logs.
\item
  Source maps: publish with
  \passthrough{\lstinline!dotnet publish -c Debug!} to get wasm
  debugging symbols for supported browsers.
\item
  Logging: \passthrough{\lstinline!AppBuilder.LogToTrace()!} outputs to
  console.
\item
  Performance: use Performance tab to profile frames, memory, CPU.
\item
  Pass \passthrough{\lstinline!--logger:WebAssembly!} to
  \passthrough{\lstinline!dotnet run!} for runtime messages (assembly
  loading, exception details).
\item
  Use \passthrough{\lstinline!wasm-tools wasm-strip!} or
  \passthrough{\lstinline!wasm-tools wasm-opt!} (installed via
  \passthrough{\lstinline!dotnet wasm build-tools --install!}) to
  analyze and reduce bundle sizes.
\end{itemize}

\subsection{12. Performance tips}\label{performance-tips}

\begin{itemize}
\tightlist
\item
  Measure download size: inspect \passthrough{\lstinline!AppBundle!},
  track \passthrough{\lstinline!.wasm!}, \passthrough{\lstinline!.dat!},
  and compressed assets.
\item
  Prefer compiled bindings and avoid reflection-heavy converters to keep
  the IL linker effective.
\item
  Enable multithreading (COOP/COEP headers) when animations or
  background tasks stutter; Avalonia will schedule the render loop on a
  dedicated worker thread.
\item
  Integrate \passthrough{\lstinline!BrowserSystemNavigationManager!}
  with your navigation service so browser back/forward controls work as
  expected.
\end{itemize}

\subsection{13. Deployment}\label{deployment}

Publish the browser head:

\begin{lstlisting}[language=bash]
cd MyApp.Browser
## Debug
dotnet run
## Release bundle
dotnet publish -c Release
\end{lstlisting}

Output under
\passthrough{\lstinline!bin/Release/net8.0/browser-wasm/AppBundle!}.
Serve via static web server (ASP.NET, Node, Nginx, GitHub Pages). Ensure
service worker scope matches hosting path.

Remember to enable compression (Brotli) for faster load times.

\subsection{14. Platform limitations}\label{platform-limitations}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Feature
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Browser behavior
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Windows/Dialogs & Single view only; no OS windows, tray icons, native
menus \\
File system & User-selection only via pickers; no arbitrary file
access \\
Threading & Multi-threaded WASM requires server headers (COOP/COEP) and
browser support \\
Clipboard & Requires user gesture; limited formats \\
Notifications & Use Web Notifications API via JS interop \\
Storage & LocalStorage/IndexedDB via JS interop for persistence \\
\end{longtable}

Design for progressive enhancement: provide alternative flows if feature
unsupported.

\subsection{15. Practice exercises}\label{practice-exercises-14}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add a browser head and run the app in Chrome/Firefox, verifying
  rendering fallbacks.
\item
  Implement file export via \passthrough{\lstinline!IStorageProvider!}
  and test save polyfill with service worker enabled/disabled.
\item
  Add logging to report
  \passthrough{\lstinline!BrowserPlatformOptions.RenderingMode!} and
  \passthrough{\lstinline!ActualTransparencyLevel!} (should be
  \passthrough{\lstinline!None!}).
\item
  Integrate a JavaScript API (e.g., Web Notifications) via interop and
  show a notification after user action.
\item
  Publish a release build and deploy to a static host (GitHub Pages or
  local web server), verifying service worker scope and COOP/COEP
  headers.
\item
  Use \passthrough{\lstinline!wasm-tools wasm-strip!} (or
  \passthrough{\lstinline!wasm-opt!}) to inspect bundle size
  before/after trimming and record the change.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-18}

\begin{itemize}
\tightlist
\item
  Browser app builder:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserAppBuilder.cs}{\passthrough{\lstinline!BrowserAppBuilder.cs!}}
\item
  DOM interop:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/Interop/JSObjectControlHandle.cs}{\passthrough{\lstinline!JSObjectControlHandle.cs!}}
\item
  Browser lifetime:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserSingleViewLifetime.cs}{\passthrough{\lstinline!BrowserSingleViewLifetime.cs!}}
\item
  Native control host:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserNativeControlHost.cs}{\passthrough{\lstinline!BrowserNativeControlHost.cs!}}
\item
  Storage provider:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/Storage/BrowserStorageProvider.cs}{\passthrough{\lstinline!BrowserStorageProvider.cs!}}
\item
  System navigation manager:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserSystemNavigationManager.cs}{\passthrough{\lstinline!BrowserSystemNavigationManager.cs!}}
\item
  Input pane \& insets:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserInputPane.cs}{\passthrough{\lstinline!BrowserInputPane.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Browser/Avalonia.Browser/BrowserInsetsManager.cs}{\passthrough{\lstinline!BrowserInsetsManager.cs!}}
\item
  Blazor integration:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Browser/Avalonia.Browser.Blazor}{\passthrough{\lstinline!Avalonia.Browser.Blazor!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-18}

\begin{itemize}
\tightlist
\item
  How do you configure rendering fallbacks for the browser target?
\item
  What limitations exist for file access and how does the polyfill help?
\item
  Which headers or hosting requirements enable WASM multi-threading? Why
  might you set \passthrough{\lstinline!PreferManagedThreadDispatcher!}?
\item
  How do CORS rules affect HttpClient calls in the browser?
\item
  What deployment steps are required to serve a browser bundle with
  service worker support and COOP/COEP headers?
\end{itemize}

What's next - Next: \href{Chapter21.md}{Chapter 21}

\newpage

\subsection{21. Headless and testing}\label{headless-and-testing}

Goal - Test Avalonia UI components without a display server using
\passthrough{\lstinline!Avalonia.Headless!}
(\passthrough{\lstinline!AvaloniaHeadlessPlatformExtensions.UseHeadless!}).
- Simulate user input, capture rendered frames, and integrate UI tests
into CI (xUnit, NUnit, other frameworks). - Organize your test strategy:
view models, control-level tests, visual regression, automation, fast
feedback.

Why this matters - UI you can't test will regress. Headless testing runs
anywhere (CI, Docker) and stays deterministic. - Automated UI tests
catch regressions in bindings, styles, commands, and layout quickly.

Prerequisites - Chapter 11 (MVVM patterns), Chapter 17 (async patterns),
Chapter 16 (storage) for file-based assertions.

\subsection{1. Packages and setup}\label{packages-and-setup}

Add packages to your test project: -
\passthrough{\lstinline!Avalonia.Headless!} -
\passthrough{\lstinline!Avalonia.Headless.XUnit!} or
\passthrough{\lstinline!Avalonia.Headless.NUnit!} -
\passthrough{\lstinline!Avalonia.Skia!} (only if you need rendered
frames)

\subsubsection{\texorpdfstring{xUnit setup
(\texttt{AssemblyInfo.cs})}{xUnit setup (AssemblyInfo.cs)}}\label{xunit-setup-assemblyinfo.cs}

\begin{lstlisting}
using Avalonia;
using Avalonia.Headless;
using Avalonia.Headless.XUnit;

[assembly: AvaloniaTestApplication(typeof(TestApp))]

public sealed class TestApp : Application
{
    public static AppBuilder BuildAvaloniaApp() => AppBuilder.Configure<TestApp>()
        .UseHeadless(new AvaloniaHeadlessPlatformOptions
        {
            UseHeadlessDrawing = true, // set false + UseSkia for frame capture
            UseCpuDisabledRenderLoop = true
        })
        .AfterSetup(_ => Dispatcher.UIThread.VerifyAccess());
}
\end{lstlisting}

\passthrough{\lstinline!UseHeadlessDrawing = true!} skips Skia (fast).
For pixel tests, set false and call
\passthrough{\lstinline!.UseSkia()!}.

\subsubsection{NUnit setup}\label{nunit-setup}

Use \passthrough{\lstinline![AvaloniaTestApp]!} attribute (from
\passthrough{\lstinline!Avalonia.Headless.NUnit!}) and the provided
\passthrough{\lstinline!AvaloniaTestFixture!} base.

\subsection{2. Writing a simple headless
test}\label{writing-a-simple-headless-test}

\begin{lstlisting}
public class TextBoxTests
{
    [AvaloniaFact]
    public async Task TextBox_Receives_Typed_Text()
    {
        var textBox = new TextBox { Width = 200, Height = 24 };
        var window = new Window { Content = textBox };
        window.Show();

        // Focus on UI thread
        await Dispatcher.UIThread.InvokeAsync(() => textBox.Focus());

        window.KeyTextInput("Avalonia");
        AvaloniaHeadlessPlatform.ForceRenderTimerTick();

        Assert.Equal("Avalonia", textBox.Text);
    }
}
\end{lstlisting}

Helpers from \passthrough{\lstinline!Avalonia.Headless!} add extension
methods to
\passthrough{\lstinline!TopLevel!}/\passthrough{\lstinline!Window!}
(\passthrough{\lstinline!KeyTextInput!},
\passthrough{\lstinline!KeyPress!}, \passthrough{\lstinline!MouseDown!},
etc.). Always call \passthrough{\lstinline!ForceRenderTimerTick()!}
after inputs to flush layout/bindings.

\subsection{3. Simulating pointer input}\label{simulating-pointer-input}

\begin{lstlisting}
[ AvaloniaFact ]
public async Task Button_Click_Executes_Command()
{
    var commandExecuted = false;
    var button = new Button
    {
        Width = 100,
        Height = 30,
        Content = "Click me",
        Command = ReactiveCommand.Create(() => commandExecuted = true)
    };

    var window = new Window { Content = button };
    window.Show();

    await Dispatcher.UIThread.InvokeAsync(() => button.Focus());
    window.MouseDown(button.Bounds.Center, MouseButton.Left);
    window.MouseUp(button.Bounds.Center, MouseButton.Left);
    AvaloniaHeadlessPlatform.ForceRenderTimerTick();

    Assert.True(commandExecuted);
}
\end{lstlisting}

\passthrough{\lstinline!Bounds.Center!} obtains center point from
\passthrough{\lstinline!Control.Bounds!}. For container-based
coordinates, offset appropriately.

\subsection{4. Frame capture \& visual
regression}\label{frame-capture-visual-regression}

Configure Skia rendering in test app builder:

\begin{lstlisting}
public static AppBuilder BuildAvaloniaApp() => AppBuilder.Configure<TestApp>()
    .UseSkia()
    .UseHeadless(new AvaloniaHeadlessPlatformOptions
    {
        UseHeadlessDrawing = false,
        UseCpuDisabledRenderLoop = true
    });
\end{lstlisting}

Capture frames:

\begin{lstlisting}
[ AvaloniaFact ]
public void Border_Renders_Correct_Size()
{
    var border = new Border
    {
        Width = 200,
        Height = 100,
        Background = Brushes.Red
    };

    var window = new Window { Content = border };
    window.Show();
    AvaloniaHeadlessPlatform.ForceRenderTimerTick();

    using var frame = window.GetLastRenderedFrame();
    Assert.Equal(200, frame.Size.Width);
    Assert.Equal(100, frame.Size.Height);

    // Optional: save to disk for debugging
    // frame.Save("border.png");
}
\end{lstlisting}

Compare pixels to baseline image using e.g.,
\passthrough{\lstinline!ImageMagick!} or custom diff with tolerance.
Keep baselines per theme/resolution to avoid false positives.

If you need Avalonia to drive the render loop before reading pixels,
call \passthrough{\lstinline!CaptureRenderedFrame()!} instead of
\passthrough{\lstinline!GetLastRenderedFrame()!}---it schedules a
composition pass and forces a render tick. This mirrors what desktop
renderers do when they flush the
\passthrough{\lstinline!CompositionTarget!}, keeping the snapshot
pipeline close to production.

\subsection{5. Organizing tests}\label{organizing-tests}

\begin{itemize}
\tightlist
\item
  \textbf{ViewModel tests}: no Avalonia dependencies; test commands and
  property changes (fastest).
\item
  \textbf{Control tests}: headless platform; simulate inputs to verify
  states.
\item
  \textbf{Visual regression}: limited number; capture frames and
  compare.
\item
  \textbf{Integration/E2E}: run full app with navigation; keep few due
  to complexity.
\end{itemize}

\subsection{6. Custom fixtures and automation
hooks}\label{custom-fixtures-and-automation-hooks}

\begin{itemize}
\tightlist
\item
  Build reusable fixtures around
  \passthrough{\lstinline!HeadlessUnitTestSession.StartNew(typeof(App))!}
  when you need deterministic startup logic outside the provided
  xUnit/NUnit attributes. Wrap it in
  \passthrough{\lstinline!IAsyncLifetime!} so tests share a dispatcher
  loop safely.
\item
  Register platform services for tests inside the session by entering an
  \passthrough{\lstinline!AvaloniaLocator!} scope and injecting fakes
  (e.g., mock \passthrough{\lstinline!IClipboard!}, stub
  \passthrough{\lstinline!IStorageProvider!}).
\item
  Expose convenience methods (e.g.,
  \passthrough{\lstinline!ShowControlAsync<TControl>()!}) that create a
  \passthrough{\lstinline!Window!}, attach the control, call
  \passthrough{\lstinline!ForceRenderTimerTick!}, and return the control
  for assertions.
\item
  For automation cues, use Avalonia's UI automation peers: call
  \passthrough{\lstinline!AutomationPeer.CreatePeerForElement(control)!}
  and assert patterns (\passthrough{\lstinline!InvokePattern!},
  \passthrough{\lstinline!ValuePattern!}) without relying on visual tree
  traversal.
\item
  Study the headless unit tests in
  \passthrough{\lstinline!external/Avalonia/tests/Avalonia.Headless.UnitTests!}
  for patterns that wrap \passthrough{\lstinline!AppBuilder!} and expose
  helpers for reuse across cases.
\end{itemize}

\subsection{7. Advanced headless
scenarios}\label{advanced-headless-scenarios}

\subsubsection{7.1 VNC mode}\label{vnc-mode}

For debugging, you can run headless with a VNC server and observe the
UI.

\begin{lstlisting}
AppBuilder.Configure<App>()
    .UseHeadless(new AvaloniaHeadlessPlatformOptions { UseVnc = true, UseSkia = true })
    .StartWithClassicDesktopLifetime(args);
\end{lstlisting}

Connect with a VNC client to view frames and interact.

\subsubsection{7.2 Simulating time \&
timers}\label{simulating-time-timers}

Use
\passthrough{\lstinline!AvaloniaHeadlessPlatform.ForceRenderTimerTick()!}
to advance timers. For \passthrough{\lstinline!DispatcherTimer!} or
animations, call it repeatedly.

\subsubsection{7.3 File system in tests}\label{file-system-in-tests}

For file-based assertions, use in-memory streams or temp directories.
Avoid writing to the repo path; tests should be self-cleaning.

\subsection{8. Testing async flows}\label{testing-async-flows}

\begin{itemize}
\tightlist
\item
  Use \passthrough{\lstinline!Dispatcher.UIThread.InvokeAsync!} for UI
  updates.
\item
  Await tasks; avoid \passthrough{\lstinline!.Result!} or
  \passthrough{\lstinline!.Wait()!}.
\item
  To wait for state changes, poll with timeout:
\end{itemize}

\begin{lstlisting}
async Task WaitForAsync(Func<bool> condition, TimeSpan timeout)
{
    var deadline = DateTime.UtcNow + timeout;
    while (!condition())
    {
        if (DateTime.UtcNow > deadline)
            throw new TimeoutException("Condition not met");
        AvaloniaHeadlessPlatform.ForceRenderTimerTick();
        await Task.Delay(10);
    }
}
\end{lstlisting}

\subsection{9. CI integration}\label{ci-integration}

\begin{itemize}
\tightlist
\item
  Headless tests run under \passthrough{\lstinline!dotnet test!} in
  GitHub Actions/Azure Pipelines/GitLab.
\item
  On Linux CI, no display server required (no
  \passthrough{\lstinline!Xvfb!}).
\item
  Provide environment variables or test-specific configuration as
  needed.
\item
  Collect snapshots as build artifacts when tests fail (optional).
\end{itemize}

\subsection{10. Practice exercises}\label{practice-exercises-15}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a headless test that types into a TextBox, presses Enter, and
  asserts a command executed.
\item
  Simulate a drag-and-drop using \passthrough{\lstinline!DragDrop!}
  helpers and confirm target list received data.
\item
  Capture a frame of an entire form and compare to a baseline image
  stored under \passthrough{\lstinline!tests/BaselineImages!}.
\item
  Create a test fixture that launches the app's main view, navigates to
  a secondary page, and verifies a label text.
\item
  Add headless tests to CI and configure the pipeline to upload snapshot
  diffs for failing cases.
\item
  Write an automation-focused test that inspects
  \passthrough{\lstinline!AutomationPeer!} patterns (Invoke/Value) to
  validate accessibility contracts alongside visual assertions.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-19}

\begin{itemize}
\tightlist
\item
  Headless platform setup:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Headless/Avalonia.Headless/AvaloniaHeadlessPlatform.cs}{\passthrough{\lstinline!AvaloniaHeadlessPlatform.cs!}}
\item
  Session control:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Headless/Avalonia.Headless/HeadlessUnitTestSession.cs}{\passthrough{\lstinline!HeadlessUnitTestSession.cs!}}
\item
  Input helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Headless/Avalonia.Headless/HeadlessWindowExtensions.cs}{\passthrough{\lstinline!HeadlessWindowExtensions!}}
\item
  Test adapters:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Headless/Avalonia.Headless.XUnit}{\passthrough{\lstinline!Avalonia.Headless.XUnit!}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/src/Headless/Avalonia.Headless.NUnit}{\passthrough{\lstinline!Avalonia.Headless.NUnit!}}
\item
  Samples:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/tests/Avalonia.Headless.UnitTests}{\passthrough{\lstinline!tests/Avalonia.Headless.UnitTests!}},
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/tests/Avalonia.Headless.XUnit.UnitTests}{\passthrough{\lstinline!tests/Avalonia.Headless.XUnit.UnitTests!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-19}

\begin{itemize}
\tightlist
\item
  How do you initialize the headless platform for xUnit? Which attribute
  is required?
\item
  How do you simulate keyboard and pointer input in headless tests?
\item
  What steps are needed to capture rendered frames? Why might you use
  them sparingly?
\item
  How can you run the headless platform visually (e.g., via VNC) for
  debugging?
\item
  How does your test strategy balance view model tests, control tests,
  and visual regression tests?
\item
  When would you reach for AutomationPeers in headless tests instead of
  asserting on visuals alone?
\end{itemize}

What's next - Next: \href{Chapter22.md}{Chapter 22}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part V — Rendering, tooling, optimization, and contributing}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part V — Rendering, tooling, optimization, and contributing}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{22. Rendering pipeline in plain
words}\label{rendering-pipeline-in-plain-words}

Goal - Understand how Avalonia turns your visual tree into frames across
every backend. - Know the responsibilities of the UI thread, render
loop, compositor, renderer, and GPU interface. - Learn how to tune
rendering with \passthrough{\lstinline!SkiaOptions!},
\passthrough{\lstinline!RenderOptions!}, timers, and diagnostics tools.

Why this matters - Smooth, power-efficient UI depends on understanding
what triggers redraws and how Avalonia schedules work. - Debugging
rendering glitches is easier when you know each component's role.

Prerequisites - Chapter 17 (async/background) for thread awareness,
Chapter 18/19 (platform differences).

\subsection{1. Mental model}\label{mental-model}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{UI thread} builds and updates the visual tree
  (\passthrough{\lstinline!Visual!}s/\passthrough{\lstinline!Control!}s).
  When properties change, visuals mark themselves dirty (e.g., via
  \passthrough{\lstinline!InvalidateVisual!}).
\item
  \textbf{Scene graph} represents visuals and draw operations in a
  batched form (\passthrough{\lstinline!SceneGraph.cs!}).
\item
  \textbf{Compositor} commits scene graph updates to the render thread
  and keeps track of dirty rectangles.
\item
  \textbf{Render loop} (driven by an
  \passthrough{\lstinline!IRenderTimer!}) asks the renderer to draw
  frames while work is pending.
\item
  \textbf{Renderer} walks the scene graph, issues drawing commands, and
  marshals them to Skia or another backend.
\item
  \textbf{Skia/render interface} rasterizes shapes/text/images into GPU
  textures (or CPU bitmaps) before the platform swapchain presents the
  frame.
\end{enumerate}

Avalonia uses two main threads: UI thread and render thread. Keep the UI
thread free of long-running work so animations, input dispatch, and
composition stay responsive.

\subsection{2. UI thread: creating and invalidating
visuals}\label{ui-thread-creating-and-invalidating-visuals}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!Visual!}s have properties
  (\passthrough{\lstinline!Bounds!}, \passthrough{\lstinline!Opacity!},
  \passthrough{\lstinline!Transform!}, etc.) that trigger redraw when
  changed.
\item
  \passthrough{\lstinline!InvalidateVisual()!} marks a visual dirty.
  Most controls call this automatically when a property changes.
\item
  Layout changes may also mark visuals dirty (e.g., size change).
\end{itemize}

\subsection{3. Render thread and renderer
pipeline}\label{render-thread-and-renderer-pipeline}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!IRenderer!} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/IRenderer.cs}{\passthrough{\lstinline!IRenderer.cs!}})
  exposes methods:

  \begin{itemize}
  \tightlist
  \item
    \passthrough{\lstinline!AddDirty(Visual visual)!} --- mark dirty
    region.
  \item
    \passthrough{\lstinline!Paint!} --- handle paint request (e.g., OS
    says ``redraw now'').
  \item
    \passthrough{\lstinline!Resized!} --- update when target size
    changes.
  \item
    \passthrough{\lstinline!Start!}/\passthrough{\lstinline!Stop!} ---
    hook into render loop lifetime.
  \end{itemize}
\end{itemize}

Avalonia ships both \passthrough{\lstinline!CompositingRenderer!}
(default) and \passthrough{\lstinline!DeferredRenderer!}. The renderer
uses dirty rectangles to redraw minimal regions and produces scene graph
nodes consumed by Skia.

\subsubsection{CompositionTarget}\label{compositiontarget}

\passthrough{\lstinline!CompositionTarget!} abstracts the surface being
rendered. It holds references to swapchains, frame buffers, and frame
timing metrics. You usually observe it through
\passthrough{\lstinline!IRenderer.Diagnostics!} (frame times, dirty rect
counts) or via DevTools/remote diagnostics rather than accessing the
object directly.

\subsubsection{Immediate renderer}\label{immediate-renderer}

\passthrough{\lstinline!ImmediateRenderer!} renders a visual subtree
synchronously into a \passthrough{\lstinline!DrawingContext!}. Used for
\passthrough{\lstinline!RenderTargetBitmap!},
\passthrough{\lstinline!VisualBrush!}, etc. Not used for normal window
presentation.

\subsection{4. Compositor and render
loop}\label{compositor-and-render-loop}

The compositor orchestrates UI → render thread updates (see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/Composition/Compositor.cs}{\passthrough{\lstinline!Compositor.cs!}}).

\begin{itemize}
\tightlist
\item
  Batches (serialized UI tree updates) are committed to the render
  thread.
\item
  \passthrough{\lstinline!RenderLoop!} ticks at platform-defined cadence
  (vsync/animation timers). When there's dirty content or
  \passthrough{\lstinline!CompositionTarget!} animations, it schedules a
  frame.
\item
  Render loop ensures frames draw at stable cadence even if the UI
  thread is momentarily busy.
\end{itemize}

\subsubsection{Render timers}\label{render-timers}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!IRenderTimer!} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/IRenderTimer.cs}{\passthrough{\lstinline!IRenderTimer.cs!}})
  abstracts ticking. Implementations include
  \passthrough{\lstinline!DefaultRenderTimer!},
  \passthrough{\lstinline!DispatcherRenderTimer!}, and headless timers
  used in tests.
\item
  Customize via
  \passthrough{\lstinline!AppBuilder.UseRenderLoop(new RenderLoop(new DispatcherRenderTimer()))!}
  to integrate external timing sources (e.g., game loops).
\item
  Timers raise \passthrough{\lstinline!Tick!} on the render thread.
  Avoid heavy work in handlers: queue work through the UI thread if
  necessary.
\end{itemize}

\subsubsection{Scene graph commits}\label{scene-graph-commits}

Each \passthrough{\lstinline!RenderLoop!} tick calls
\passthrough{\lstinline!Compositor.CommitScenes!}. The compositor
transforms dirty visuals into render passes, prunes unchanged branches,
and tracks retained GPU resources for reuse across frames.

\subsection{5. Backend selection and GPU
interfaces}\label{backend-selection-and-gpu-interfaces}

Avalonia targets multiple render interfaces via
\passthrough{\lstinline!IRenderInterface!}. Skia is the default
implementation and chooses GPU versus CPU paths per platform.

\subsubsection{Backend selection logic}\label{backend-selection-logic}

\begin{itemize}
\tightlist
\item
  Desktop defaults to GPU (OpenGL/ANGLE on Windows, OpenGL/Vulkan on
  Linux, Metal on macOS).
\item
  Mobile uses OpenGL ES (Android) or Metal (iOS/macOS Catalyst).
\item
  Browser compiles Skia to WebAssembly and falls back to
  WebGL2/WebGL1/software.
\item
  Server/headless falls back to CPU rendering.
\end{itemize}

Force a backend with
\passthrough{\lstinline!UseSkia(new SkiaOptions \{ RenderMode = RenderMode.Software \})!}
or by setting \passthrough{\lstinline!AVALONIA\_RENDERER!} environment
variable (e.g., \passthrough{\lstinline!software!},
\passthrough{\lstinline!open\_gl!}). Always pair overrides with tests on
target hardware.

\subsubsection{GPU resource management}\label{gpu-resource-management}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!SkiaOptions!} exposes GPU cache limits and
  toggles like \passthrough{\lstinline!UseOpacitySaveLayer!}.
\item
  \passthrough{\lstinline!IRenderSurface!} implementations (swapchains,
  framebuffers) own platform handles; leaks appear as rising
  \passthrough{\lstinline!RendererDiagnostics.SceneGraphDirtyRectCount!}.
\end{itemize}

\subsubsection{Skia configuration}\label{skia-configuration}

Avalonia uses Skia for cross-platform drawing: - GPU or CPU rendering
depending on platform capabilities. - GPU backend chosen automatically
(OpenGL, ANGLE, Metal, Vulkan, WebGL, etc.). -
\passthrough{\lstinline!UseSkia(new SkiaOptions \{ ... \})!} in
\passthrough{\lstinline!AppBuilder!} to tune.

\subsubsection{SkiaOptions}\label{skiaoptions}

\begin{lstlisting}
AppBuilder.Configure<App>()
    .UsePlatformDetect()
    .UseSkia(new SkiaOptions
    {
        MaxGpuResourceSizeBytes = 64L * 1024 * 1024,
        UseOpacitySaveLayer = false
    })
    .LogToTrace();
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!MaxGpuResourceSizeBytes!}: limit Skia resource
  cache.
\item
  \passthrough{\lstinline!UseOpacitySaveLayer!}: forces Skia to use save
  layers for opacity stacking (accuracy vs performance).
\end{itemize}

\subsection{6. RenderOptions (per
Visual)}\label{renderoptions-per-visual}

\passthrough{\lstinline!RenderOptions!} attached properties influence
interpolation and text rendering: -
\passthrough{\lstinline!BitmapInterpolationMode!}: Low/Medium/High
quality vs default. - \passthrough{\lstinline!BitmapBlendingMode!}:
blend mode for images. - \passthrough{\lstinline!TextRenderingMode!}:
Default, Antialias, SubpixelAntialias, Aliased. -
\passthrough{\lstinline!EdgeMode!}: Antialias vs Aliased for geometry
edges. - \passthrough{\lstinline!RequiresFullOpacityHandling!}: handle
complex opacity composition.

Example:

\begin{lstlisting}
RenderOptions.SetBitmapInterpolationMode(image, BitmapInterpolationMode.HighQuality);
RenderOptions.SetTextRenderingMode(smallText, TextRenderingMode.Aliased);
\end{lstlisting}

RenderOptions apply to a visual and flow down to children unless
overridden.

\subsection{7. When does a frame
render?}\label{when-does-a-frame-render}

\begin{itemize}
\tightlist
\item
  Property changes on visuals (brush, text, transform).
\item
  Layout updates affecting size/position.
\item
  Animations (composition or binding-driven) schedule continuous frames.
\item
  Input (pointer events) may cause immediate redraw (e.g., ripple
  effect).
\item
  External events: window resize, DPI change.
\end{itemize}

Prevent unnecessary redraws: - Avoid toggling properties frequently
without change. - Batch updates on UI thread; let binding/animation
handle smooth changes. - Free large bitmaps once no longer needed.

\subsection{8. Frame timing
instrumentation}\label{frame-timing-instrumentation}

\subsubsection{Renderer diagnostics}\label{renderer-diagnostics}

\begin{itemize}
\tightlist
\item
  Enable \passthrough{\lstinline!RendererDiagnostics!} (see
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDiagnostics.cs}{\passthrough{\lstinline!RendererDiagnostics.cs!}})
  via \passthrough{\lstinline!RenderRoot.Renderer.Diagnostics!}. Metrics
  include dirty rectangle counts, render phase durations, and draw call
  tallies.
\item
  Pair diagnostics with
  \passthrough{\lstinline!SceneInvalidated!}/\passthrough{\lstinline!RenderLoop!}
  timestamps to push frame data into tracing systems such as
  \passthrough{\lstinline!EventSource!} or Prometheus exporters.
\end{itemize}

\subsubsection{DevTools}\label{devtools}

\begin{itemize}
\tightlist
\item
  Press \passthrough{\lstinline!F12!} to open DevTools.
\item
  \passthrough{\lstinline!Diagnostics!} panel toggles overlays and
  displays frame timing graphs.
\item
  \passthrough{\lstinline!Rendering!} view (when available) shows render
  loop cadence, render thread load, and GPU backend in use.
\end{itemize}

\subsubsection{Logging}\label{logging}

\begin{lstlisting}
AppBuilder.Configure<App>()
    .UsePlatformDetect()
    .LogToTrace(LogEventLevel.Debug, new[] { LogArea.Rendering, LogArea.Layout })
    .StartWithClassicDesktopLifetime(args);
\end{lstlisting}

\subsubsection{Render overlays}\label{render-overlays}

\passthrough{\lstinline!RendererDebugOverlays!} (see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDebugOverlays.cs}{\passthrough{\lstinline!RendererDebugOverlays.cs!}})
enable overlays showing dirty rectangles, FPS, layout costs.

\begin{lstlisting}
if (TopLevel is { Renderer: { } renderer })
    renderer.DebugOverlays = RendererDebugOverlays.Fps | RendererDebugOverlays.LayoutTimeGraph;
\end{lstlisting}

\subsubsection{Tools}\label{tools}

\begin{itemize}
\tightlist
\item
  Use .NET memory profiler or \passthrough{\lstinline!dotnet-counters!}
  to monitor GC while animating UI.
\item
  GPU profilers (RenderDoc) can capture Skia GPU commands (advanced
  scenario).
\item
  \passthrough{\lstinline!Avalonia.Diagnostics.RenderingDebugOverlays!}
  integrates with \passthrough{\lstinline!Avalonia.Remote.Protocol!}.
  Use \passthrough{\lstinline!avalonia-devtools://!} clients to stream
  metrics from remote devices (Chapter 24).
\end{itemize}

\subsection{9. Immediate rendering
utilities}\label{immediate-rendering-utilities}

\subsubsection{RenderTargetBitmap}\label{rendertargetbitmap}

\begin{lstlisting}
var bitmap = new RenderTargetBitmap(new PixelSize(300, 200), new Vector(96, 96));
await bitmap.RenderAsync(myControl);
bitmap.Save("snapshot.png");
\end{lstlisting}

Uses \passthrough{\lstinline!ImmediateRenderer!} to render a control
off-screen.

\subsubsection{Drawing manually}\label{drawing-manually}

\passthrough{\lstinline!DrawingContext!} allows custom drawing via
immediate renderer.

\subsection{10. Platform-specific notes}\label{platform-specific-notes}

\begin{itemize}
\tightlist
\item
  Windows: GPU backend typically ANGLE (OpenGL) or D3D via Skia;
  transparency support (Mica/Acrylic) may involve compositor-level
  effects.
\item
  macOS: uses Metal via Skia; retina scaling via
  \passthrough{\lstinline!RenderScaling!}.
\item
  Linux: OpenGL (or Vulkan) depending on driver; virtualization/backends
  vary.
\item
  Mobile: OpenGL ES on Android, Metal on iOS; consider battery impact
  when scheduling animations.
\item
  Browser: WebGL2/WebGL1/Software2D (Chapter 20); one-threaded unless
  WASM threading enabled.
\end{itemize}

\subsection{11. Practice exercises}\label{practice-exercises-16}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Replace the render timer with a custom
  \passthrough{\lstinline!IRenderTimer!} implementation and graph frame
  cadence using timestamps collected from
  \passthrough{\lstinline!SceneInvalidated!}.
\item
  Override \passthrough{\lstinline!SkiaOptions.RenderMode!} to force
  software rendering, then switch back to GPU; profile render time using
  overlays in both modes.
\item
  Capture frame diagnostics
  (\passthrough{\lstinline!RendererDebugOverlays.LayoutTimeGraph | RenderTimeGraph!})
  during an animation and export metrics for analysis.
\item
  Instrument \passthrough{\lstinline!RenderRoot.Renderer.Diagnostics!}
  to log dirty rectangle counts when toggling
  \passthrough{\lstinline!InvalidateVisual!}; correlate with DevTools
  overlays.
\item
  Use DevTools remote transport to attach from another process (Chapter
  24) and verify frame timing matches local instrumentation.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-20}

\begin{itemize}
\tightlist
\item
  Renderer interface:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/IRenderer.cs}{\passthrough{\lstinline!IRenderer.cs!}}
\item
  Compositor:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/Composition/Compositor.cs}{\passthrough{\lstinline!Compositor.cs!}}
\item
  Scene graph:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/Composition/Drawing/RenderDataDrawingContext.cs}{\passthrough{\lstinline!RenderDataDrawingContext.cs!}}
\item
  Immediate renderer:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/ImmediateRenderer.cs}{\passthrough{\lstinline!ImmediateRenderer.cs!}}
\item
  Render loop:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RenderLoop.cs}{\passthrough{\lstinline!RenderLoop.cs!}}
\item
  Render timer abstraction:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/IRenderTimer.cs}{\passthrough{\lstinline!IRenderTimer.cs!}}
\item
  Render options:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/RenderOptions.cs}{\passthrough{\lstinline!RenderOptions.cs!}}
\item
  Skia options and platform interface:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Skia/Avalonia.Skia/SkiaOptions.cs}{\passthrough{\lstinline!SkiaOptions.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Skia/Avalonia.Skia/PlatformRenderInterface.cs}{\passthrough{\lstinline!PlatformRenderInterface.cs!}}
\item
  Renderer diagnostics:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDiagnostics.cs}{\passthrough{\lstinline!RendererDiagnostics.cs!}}
\item
  Debug overlays:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDebugOverlays.cs}{\passthrough{\lstinline!RendererDebugOverlays.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-20}

\begin{itemize}
\tightlist
\item
  What components run on the UI thread vs render thread?
\item
  How does \passthrough{\lstinline!InvalidateVisual!} lead to a new
  frame?
\item
  When would you adjust
  \passthrough{\lstinline!SkiaOptions.MaxGpuResourceSizeBytes!} vs
  \passthrough{\lstinline!RenderOptions.BitmapInterpolationMode!}?
\item
  What tools help you diagnose rendering bottlenecks?
\end{itemize}

What's next - Next: \href{Chapter23.md}{Chapter 23}

\newpage

\subsection{23. Custom drawing and custom
controls}\label{custom-drawing-and-custom-controls}

Goal - Decide when to custom draw (override
\passthrough{\lstinline!Render!}) versus build templated controls (pure
XAML). - Master \passthrough{\lstinline!DrawingContext!}, invalidation
(\passthrough{\lstinline!AffectsRender!},
\passthrough{\lstinline!InvalidateVisual!}), and caching for
performance. - Structure a restylable
\passthrough{\lstinline!TemplatedControl!}, expose properties, and
support theming/accessibility.

Why this matters - Charts, gauges, and other visuals often need custom
drawing. Understanding rendering and templating keeps your controls fast
and customizable. - Well-structured controls enable reuse and consistent
theming.

Prerequisites - Chapter 22 (rendering pipeline), Chapter 15
(accessibility), Chapter 16 (storage for exporting images if needed).

\subsection{1. Choosing an approach}\label{choosing-an-approach}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Scenario & Draw (override \passthrough{\lstinline!Render!}) & Template
(\passthrough{\lstinline!ControlTemplate!}) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Pixel-perfect graphics, charts & {[}x{]} & \\
Animations driven by drawing primitives & {[}x{]} & \\
Standard widgets composed of existing controls & & {[}x{]} \\
Consumer needs to restyle via XAML & & {[}x{]} \\
Complex interaction per element (buttons in control) & & {[}x{]} \\
\end{longtable}

Hybrid: templated control containing a custom-drawn child for
performance-critical surface.

\subsection{2. Invalidation basics}\label{invalidation-basics}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!InvalidateVisual()!} schedules redraw.
\item
  Register property changes via
  \passthrough{\lstinline!AffectsRender<TControl>(property1, ...)!} in
  static constructor to auto-invalidate on property change.
\item
  For layout changes, use \passthrough{\lstinline!InvalidateMeasure!}
  similarly (handled automatically for
  \passthrough{\lstinline!StyledProperty!}s registered with
  \passthrough{\lstinline!AffectsMeasure!}).
\end{itemize}

\subsection{3. DrawingContext
essentials}\label{drawingcontext-essentials}

\passthrough{\lstinline!DrawingContext!} primitives: -
\passthrough{\lstinline!DrawGeometry(brush, pen, geometry)!} -
\passthrough{\lstinline!DrawRectangle!}/\passthrough{\lstinline!DrawEllipse!}
- \passthrough{\lstinline!DrawImage(image, sourceRect, destRect)!} -
\passthrough{\lstinline!DrawText(formattedText, origin)!} -
\passthrough{\lstinline!PushClip!},
\passthrough{\lstinline!PushOpacity!},
\passthrough{\lstinline!PushOpacityMask!},
\passthrough{\lstinline!PushTransform!} -- use in
\passthrough{\lstinline!using!} blocks to auto-pop state.

Example pattern:

\begin{lstlisting}
public override void Render(DrawingContext ctx)
{
    base.Render(ctx);
    using (ctx.PushClip(new Rect(Bounds.Size)))
    {
        ctx.DrawRectangle(Brushes.Black, null, Bounds);
        ctx.DrawText(_formattedText, new Point(10, 10));
    }
}
\end{lstlisting}

\subsection{4. Template lifecycle, presenters, and template
results}\label{template-lifecycle-presenters-and-template-results}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!TemplatedControl!} raises
  \passthrough{\lstinline!TemplateApplied!} when the
  \passthrough{\lstinline!ControlTemplate!} is inflated. Override
  \passthrough{\lstinline!OnApplyTemplate(TemplateAppliedEventArgs e)!}
  to wire named parts via \passthrough{\lstinline!e.NameScope!}.
\item
  Templates compiled from XAML return a
  \passthrough{\lstinline!TemplateResult<Control>!} behind the scenes
  (\passthrough{\lstinline!ControlTemplate.Build!}). It carries a
  \passthrough{\lstinline!NameScope!} so you can fetch presenters
  (\passthrough{\lstinline!e.NameScope.Find<ContentPresenter>("PART\_Content")!}).
\item
  Common presenters include \passthrough{\lstinline!ContentPresenter!},
  \passthrough{\lstinline!ItemsPresenter!},
  \passthrough{\lstinline!ScrollContentPresenter!}, and
  \passthrough{\lstinline!ToggleSwitchPresenter!}. They bridge templated
  surfaces with logical children (content, items, scrollable regions).
\item
  Use \passthrough{\lstinline!TemplateApplied!} to subscribe to events
  on named parts, but always detach previous handlers before attaching
  new ones to prevent leaks.
\end{itemize}

Example:

\begin{lstlisting}
protected override void OnApplyTemplate(TemplateAppliedEventArgs e)
{
    base.OnApplyTemplate(e);
    _toggleRoot?.PointerPressed -= OnToggle;
    _toggleRoot = e.NameScope.Find<Border>("PART_ToggleRoot");
    _toggleRoot?.PointerPressed += OnToggle;
}
\end{lstlisting}

For library-ready controls publish a
\passthrough{\lstinline!ControlTheme!} default template so consumers can
restyle without copying large XAML fragments.

\subsection{5. Example: Sparkline (custom
draw)}\label{example-sparkline-custom-draw}

\begin{lstlisting}
public sealed class Sparkline : Control
{
    public static readonly StyledProperty<IReadOnlyList<double>?> ValuesProperty =
        AvaloniaProperty.Register<Sparkline, IReadOnlyList<double>?>(nameof(Values));

    public static readonly StyledProperty<IBrush> StrokeProperty =
        AvaloniaProperty.Register<Sparkline, IBrush>(nameof(Stroke), Brushes.DeepSkyBlue);

    public static readonly StyledProperty<double> StrokeThicknessProperty =
        AvaloniaProperty.Register<Sparkline, double>(nameof(StrokeThickness), 2.0);

    static Sparkline()
    {
        AffectsRender<Sparkline>(ValuesProperty, StrokeProperty, StrokeThicknessProperty);
    }

    public IReadOnlyList<double>? Values
    {
        get => GetValue(ValuesProperty);
        set => SetValue(ValuesProperty, value);
    }

    public IBrush Stroke
    {
        get => GetValue(StrokeProperty);
        set => SetValue(StrokeProperty, value);
    }

    public double StrokeThickness
    {
        get => GetValue(StrokeThicknessProperty);
        set => SetValue(StrokeThicknessProperty, value);
    }

    public override void Render(DrawingContext ctx)
    {
        base.Render(ctx);
        var values = Values;
        var bounds = Bounds;
        if (values is null || values.Count < 2 || bounds.Width <= 0 || bounds.Height <= 0)
            return;

        double min = values.Min();
        double max = values.Max();
        double range = Math.Max(1e-9, max - min);

        using var geometry = new StreamGeometry();
        using (var gctx = geometry.Open())
        {
            for (int i = 0; i < values.Count; i++)
            {
                double t = i / (double)(values.Count - 1);
                double x = bounds.X + t * bounds.Width;
                double yNorm = (values[i] - min) / range;
                double y = bounds.Y + (1 - yNorm) * bounds.Height;
                if (i == 0)
                    gctx.BeginFigure(new Point(x, y), isFilled: false);
                else
                    gctx.LineTo(new Point(x, y));
            }
            gctx.EndFigure(false);
        }

        var pen = new Pen(Stroke, StrokeThickness);
        ctx.DrawGeometry(null, pen, geometry);
    }
}
\end{lstlisting}

Usage:

\begin{lstlisting}[language=XML]
<local:Sparkline Width="160" Height="36" Values="3,7,4,8,12" StrokeThickness="2"/>
\end{lstlisting}

\subsubsection{Performance tips}\label{performance-tips-1}

\begin{itemize}
\tightlist
\item
  Avoid allocations inside \passthrough{\lstinline!Render!}. Cache
  \passthrough{\lstinline!Pen!}, \passthrough{\lstinline!FormattedText!}
  when possible.
\item
  Use \passthrough{\lstinline!StreamGeometry!} and reuse if values
  rarely change (rebuild when invalidated).
\end{itemize}

\subsection{6. Templated control example:
Badge}\label{templated-control-example-badge}

Create \passthrough{\lstinline!Badge : TemplatedControl!} with
properties (\passthrough{\lstinline!Content!},
\passthrough{\lstinline!Background!},
\passthrough{\lstinline!Foreground!},
\passthrough{\lstinline!CornerRadius!},
\passthrough{\lstinline!MaxWidth!}, etc.). Default style in
\passthrough{\lstinline!Styles.axaml!}:

\begin{lstlisting}[language=XML]
<ControlTheme TargetType="local:Badge">
  <Setter Property="Template">
    <ControlTemplate TargetType="local:Badge">
      <Border x:Name="PART_Border"
              Background="{TemplateBinding Background}"
              CornerRadius="{TemplateBinding CornerRadius}"
              Padding="6,0"
              MinHeight="16" MinWidth="20"
              HorizontalAlignment="Left"
              VerticalAlignment="Top">
        <ContentPresenter x:Name="PART_Content"
                          Content="{TemplateBinding Content}"
                          HorizontalAlignment="Center"
                          VerticalAlignment="Center"
                          Foreground="{TemplateBinding Foreground}"/>
      </Border>
    </ControlTemplate>
  </Setter>
  <Setter Property="Background" Value="#E53935"/>
  <Setter Property="Foreground" Value="White"/>
  <Setter Property="CornerRadius" Value="8"/>
  <Setter Property="FontSize" Value="12"/>
  <Setter Property="HorizontalAlignment" Value="Left"/>
</ControlTheme>
\end{lstlisting}

In code, capture named parts once the template applies:

\begin{lstlisting}
public sealed class Badge : TemplatedControl
{
    public static readonly StyledProperty<object?> ContentProperty =
        AvaloniaProperty.Register<Badge, object?>(nameof(Content));

    Border? _border;

    public object? Content
    {
        get => GetValue(ContentProperty);
        set => SetValue(ContentProperty, value);
    }

    protected override void OnApplyTemplate(TemplateAppliedEventArgs e)
    {
        base.OnApplyTemplate(e);
        _border = e.NameScope.Find<Border>("PART_Border");
    }
}
\end{lstlisting}

Expose additional state through
\passthrough{\lstinline!StyledProperty!}s so themes and animations can
target them.

\subsection{7. Visual states and control
themes}\label{visual-states-and-control-themes}

\begin{itemize}
\tightlist
\item
  Use \passthrough{\lstinline!PseudoClasses!} (e.g.,
  \passthrough{\lstinline!PseudoClasses.Set(":badge-has-content", true)!})
  to signal template states that styles can observe.
\item
  Combine \passthrough{\lstinline!PseudoClasses!} with
  \passthrough{\lstinline!Transitions!} or
  \passthrough{\lstinline!Animations!} to create hover/pressed effects
  without rewriting templates.
\item
  Ship alternate appearances via additional
  \passthrough{\lstinline!ControlTheme!} resources referencing the same
  \passthrough{\lstinline!TemplatedControl!} type.
\item
  For re-usable primitive parts, create internal
  \passthrough{\lstinline!Visual!} subclasses (e.g.,
  \passthrough{\lstinline!BadgeGlyph!}) and expose them as named
  template parts.
\end{itemize}

\subsection{8. Accessibility \& input}\label{accessibility-input}

\begin{itemize}
\tightlist
\item
  Set \passthrough{\lstinline!Focusable!} as appropriate; override
  \passthrough{\lstinline!OnPointerPressed!}/\passthrough{\lstinline!OnKeyDown!}
  for interaction or to update pseudo classes.
\item
  Expose automation metadata via
  \passthrough{\lstinline!AutomationProperties.Name!},
  \passthrough{\lstinline!HelpText!}, or custom
  \passthrough{\lstinline!AutomationPeer!} for drawn controls.
\item
  Override \passthrough{\lstinline!OnCreateAutomationPeer!} when your
  control represents a unique semantic
  (\passthrough{\lstinline!BadgeAutomationPeer!} describing count,
  severity).
\end{itemize}

\subsection{9. Measure/arrange}\label{measurearrange}

Custom controls should override
\passthrough{\lstinline!MeasureOverride!}/\passthrough{\lstinline!ArrangeOverride!}
when size depends on content/drawing.

\begin{lstlisting}
protected override Size MeasureOverride(Size availableSize)
{
    var values = Values;
    if (values is null || values.Count == 0)
        return Size.Empty;
    return new Size(Math.Min(availableSize.Width, 120), Math.Min(availableSize.Height, 36));
}
\end{lstlisting}

\passthrough{\lstinline!TemplatedControl!} handles measurement via its
template (border + content). For custom-drawn controls, define desired
size heuristics.

\subsection{10. Rendering to bitmaps /
exporting}\label{rendering-to-bitmaps-exporting}

Use \passthrough{\lstinline!RenderTargetBitmap!} for saving custom
visuals:

\begin{lstlisting}
var rtb = new RenderTargetBitmap(new PixelSize(200, 100), new Vector(96, 96));
await rtb.RenderAsync(sparkline);
await using var stream = File.OpenWrite("spark.png");
await rtb.SaveAsync(stream);
\end{lstlisting}

Use \passthrough{\lstinline!RenderOptions!} to adjust interpolation for
exported graphics if needed.

\subsection{11. Combining drawing \& template
(hybrid)}\label{combining-drawing-template-hybrid}

Example: \passthrough{\lstinline!ChartControl!} template contains
toolbar (Buttons, ComboBox) and a custom
\passthrough{\lstinline!ChartCanvas!} child that handles
drawing/selection. - Template XAML composes layout. - Drawn child
handles heavy rendering \& direct pointer handling. - Chart exposes
data/selection via view models.

\subsection{12. Troubleshooting \& best
practices}\label{troubleshooting-best-practices}

\begin{itemize}
\tightlist
\item
  Flickering or wrong clip: ensure you clip to
  \passthrough{\lstinline!Bounds!} using
  \passthrough{\lstinline!PushClip!} when necessary.
\item
  Aliasing issues: adjust
  \passthrough{\lstinline!RenderOptions.SetEdgeMode!} and align lines to
  device pixels (e.g., \passthrough{\lstinline!Math.Round(x) + 0.5!} for
  1px strokes at 1.0 scale).
\item
  Performance: profile by measuring allocations, consider caching
  \passthrough{\lstinline!StreamGeometry!}/\passthrough{\lstinline!FormattedText!}.
\item
  Template issues: ensure template names line up with
  \passthrough{\lstinline!TemplateBinding!}; use DevTools
  -\textgreater{} \passthrough{\lstinline!Style Inspector!} to check
  which template applies.
\end{itemize}

\subsection{13. Practice exercises}\label{practice-exercises-17}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Build a templated notification badge that swaps between ``pill'' and
  ``dot'' visuals by toggling \passthrough{\lstinline!PseudoClasses!}
  within \passthrough{\lstinline!OnApplyTemplate!}.
\item
  Embed a custom drawn sparkline into that badge (composed via
  \passthrough{\lstinline!RenderTargetBitmap!} or direct drawing) and
  expose it as a named part in the template.
\item
  Implement \passthrough{\lstinline!OnCreateAutomationPeer!} so
  assistive tech can report badge count and severity; verify with the
  accessibility tree in DevTools.
\item
  Use DevTools \passthrough{\lstinline!Logical Tree!} to confirm your
  presenter hierarchy (content vs drawn part) matches expectations and
  retains bindings when themes change.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-21}

\begin{itemize}
\tightlist
\item
  Visual/render infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Visual.cs}{\passthrough{\lstinline!Visual.cs!}}
\item
  DrawingContext API:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/DrawingContext.cs}{\passthrough{\lstinline!DrawingContext.cs!}}
\item
  StreamGeometry:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/Geometry/StreamGeometryContextImpl.cs}{\passthrough{\lstinline!StreamGeometryContextImpl!}}
\item
  Template loading:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml/Templates/ControlTemplate.cs}{\passthrough{\lstinline!ControlTemplate.cs!}}
\item
  Template applied hook:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Primitives/TemplateAppliedEventArgs.cs}{\passthrough{\lstinline!TemplateAppliedEventArgs.cs!}}
\item
  Name scopes:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/NameScope.cs}{\passthrough{\lstinline!NameScope.cs!}}
\item
  Templated control base:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Primitives/TemplatedControl.cs}{\passthrough{\lstinline!TemplatedControl.cs!}}
\item
  Control theme infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/ControlTheme.cs}{\passthrough{\lstinline!ControlTheme.cs!}}
\item
  Pseudo classes:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Styling/StyledElement.cs}{\passthrough{\lstinline!StyledElement.cs!}}
\item
  Automation peers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Automation/Peers/ControlAutomationPeer.cs}{\passthrough{\lstinline!ControlAutomationPeer.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-21}

\begin{itemize}
\tightlist
\item
  When do you override \passthrough{\lstinline!Render!} versus
  \passthrough{\lstinline!ControlTemplate!}?
\item
  How does \passthrough{\lstinline!AffectsRender!} simplify
  invalidation?
\item
  What caches can you introduce to prevent allocations in
  \passthrough{\lstinline!Render!}?
\item
  How do you expose accessibility information for drawn controls?
\item
  How can consumers restyle your templated control without touching C\#?
\end{itemize}

What's next - Next: \href{Chapter24.md}{Chapter 24}

\newpage

\subsection{24. Performance, diagnostics, and
DevTools}\label{performance-diagnostics-and-devtools}

Goal - Diagnose and fix Avalonia performance issues using measurement,
logging, DevTools, and overlays. - Focus on the usual suspects:
non-virtualized lists, layout churn, binding storms, expensive
rendering. - Build repeatable measurement habits (Release builds, small
reproducible tests).

Why this matters - ``UI feels slow'' is common feedback. Without data,
fixes are guesswork. - Avalonia provides built-in diagnostics (DevTools,
overlays) and logging hooks--learn to leverage them.

Prerequisites - Chapter 22 (rendering pipeline), Chapter 17 (async
patterns), Chapter 16 (custom controls and lists).

\subsection{1. Measure before changing
anything}\label{measure-before-changing-anything}

\begin{itemize}
\tightlist
\item
  Run in Release (\passthrough{\lstinline!dotnet run -c Release!}). JIT
  optimizations affect responsiveness.
\item
  Use a small repro: isolate the view or control and reproduce with
  minimal data before optimizing.
\item
  Use high-resolution timers only around suspect code sections; avoid
  timing entire app startup on the first pass.
\item
  Change one variable at a time and re-measure to confirm impact.
\end{itemize}

\subsection{2. Logging}\label{logging-1}

Enable logging per area using \passthrough{\lstinline!AppBuilder!}
extensions (see
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/LoggingExtensions.cs}{\passthrough{\lstinline!LoggingExtensions.cs!}}).

\begin{lstlisting}
AppBuilder.Configure<App>()
    .UsePlatformDetect()
    .LogToTrace(LogEventLevel.Information, new[] { LogArea.Binding, LogArea.Layout, LogArea.Render, LogArea.Property })
    .StartWithClassicDesktopLifetime(args);
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  Areas: see \passthrough{\lstinline!Avalonia.Logging.LogArea!}
  (\passthrough{\lstinline!Binding!}, \passthrough{\lstinline!Layout!},
  \passthrough{\lstinline!Render!}, \passthrough{\lstinline!Property!},
  \passthrough{\lstinline!Control!}, etc.).
\item
  Reduce noise by lowering level (\passthrough{\lstinline!Warning!}) or
  limiting areas once you identify culprit.
\item
  Optionally log to file via \passthrough{\lstinline!LogToTextWriter!}.
\end{itemize}

\subsection{3. DevTools (F12)}\label{devtools-f12}

Attach DevTools after app initialization:

\begin{lstlisting}
public override void OnFrameworkInitializationCompleted()
{
    // configure windows/root view
    this.AttachDevTools();
    base.OnFrameworkInitializationCompleted();
}
\end{lstlisting}

Supports options:
\passthrough{\lstinline!AttachDevTools(new DevToolsOptions \{ StartupScreenIndex = 1 \})!}
for multi-monitor setups.

\subsubsection{DevTools tour}\label{devtools-tour}

\begin{itemize}
\tightlist
\item
  \textbf{Visual Tree}: inspect hierarchy, properties, pseudo-classes,
  and layout bounds.
\item
  \textbf{Logical Tree}: understand DataContext/template relationships.
\item
  \textbf{Layout Explorer}: measure/arrange info, constraints, actual
  sizes.
\item
  \textbf{Events}: view event flow; detect repeated pointer/keyboard
  events.
\item
  \textbf{Styles \& Resources}: view applied styles/resources; test
  pseudo-class states.
\item
  \textbf{Hotkeys/Settings}: adjust F12 gesture.
\end{itemize}

Use the target picker to select elements on screen and inspect
descendants/ancestors.

\subsection{4. Renderer diagnostics API}\label{renderer-diagnostics-api}

\begin{itemize}
\tightlist
\item
  Every \passthrough{\lstinline!TopLevel!} exposes
  \passthrough{\lstinline!IRenderer Diagnostics!}. Subscribe to
  \passthrough{\lstinline!PropertyChanged!} to stream overlay toggles or
  other diagnostics to logs, counters, or dashboards.
\item
  Toggle overlays without opening DevTools: set
  \passthrough{\lstinline!renderer.Diagnostics.DebugOverlays!} from code
  or configuration.
\item
  Hook \passthrough{\lstinline!SceneInvalidated!} when you need
  per-frame insight into which rectangles triggered redraws. Pair this
  with your own timers to understand long layout/render passes.
\item
  Enable \passthrough{\lstinline!LogArea.Composition!} in logging when
  you need to correlate compositor operations (scene graph updates,
  render thread work) with on-screen symptoms.
\end{itemize}

\begin{lstlisting}
using System.Diagnostics;

if (TopLevel is { Renderer: { } renderer })
{
    renderer.SceneInvalidated += (_, e) =>
    {
        Debug.WriteLine($"Invalidated {e.Rect}");
    };

    renderer.Diagnostics.PropertyChanged += (_, e) =>
    {
        if (e.PropertyName == nameof(RendererDiagnostics.DebugOverlays))
        {
            Debug.WriteLine($"Overlays now: {renderer.Diagnostics.DebugOverlays}");
        }
    };
}
\end{lstlisting}

\subsection{\texorpdfstring{5. Debug overlays
(\texttt{RendererDebugOverlays})}{5. Debug overlays (RendererDebugOverlays)}}\label{debug-overlays-rendererdebugoverlays}

Access via DevTools ``Diagnostics'' pane or programmatically:

\begin{lstlisting}
if (this.ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
{
    desktop.MainWindow.AttachedToVisualTree += (_, __) =>
    {
        if (desktop.MainWindow?.Renderer is { } renderer)
            renderer.DebugOverlays = RendererDebugOverlays.Fps | RendererDebugOverlays.DirtyRects;
    };
}
\end{lstlisting}

Overlays include: - \passthrough{\lstinline!Fps!} -- frames per second.
- \passthrough{\lstinline!DirtyRects!} -- regions redrawn each frame. -
\passthrough{\lstinline!LayoutTimeGraph!} -- layout duration per frame.
- \passthrough{\lstinline!RenderTimeGraph!} -- render duration per
frame.

Interpretation: - Large dirty rects = huge redraw areas; find what
invalidates entire window. - LayoutTime spikes = heavy measure/arrange;
check Layout Explorer to spot bottleneck. - RenderTime spikes =
expensive drawing (big bitmaps, custom rendering).

\subsection{\texorpdfstring{6. Remote diagnostics
(\texttt{Avalonia.Remote.Protocol})}{6. Remote diagnostics (Avalonia.Remote.Protocol)}}\label{remote-diagnostics-avalonia.remote.protocol}

\begin{itemize}
\tightlist
\item
  Remote DevTools streams frames and inspection data over the transports
  defined in \passthrough{\lstinline!Avalonia.Remote.Protocol!}
  (BSON/TCP by default).
\item
  Use \passthrough{\lstinline!Avalonia.Controls.Remote.RemoteServer!}
  with a \passthrough{\lstinline!BsonTcpTransport!} to expose an
  interactive surface when debugging devices without a local inspector
  (mobile, kiosk). Connect using an Avalonia DevTools client (dotnet
  \passthrough{\lstinline!avalonia!} tool or IDE integration) pointing
  at \passthrough{\lstinline!tcp-bson://host:port!}.
\item
  Messages such as \passthrough{\lstinline!TransportMessages.cs!}
  describe the payloads (frame buffers, input, diagnostics). Extend them
  if you build custom tooling.
\item
  Remote sessions respect overlay and logging flags, so enabling
  \passthrough{\lstinline!RendererDebugOverlays!} locally will surface
  in the remote stream as well.
\item
  For secure deployments, wrap
  \passthrough{\lstinline!TcpTransportBase!} in an authenticated tunnel
  (SSH port forward, reverse proxy) and disable remote servers in
  production builds.
\end{itemize}

\subsection{7. Performance checklist}\label{performance-checklist}

Lists \& templates - Use virtualization
(\passthrough{\lstinline!VirtualizingStackPanel!}) for list controls. -
Keep item templates light; avoid nested panels and convert heavy
converters to cached data. - Pre-compute value strings/colors in view
models to avoid per-frame conversion.

Layout \& binding - Minimize property changes that re-trigger layout of
large trees. - Avoid swapping entire templates when simple property
changes suffice. - Watch for binding storms (log
\passthrough{\lstinline!LogArea.Binding!}). Debounce or use state flags.

Rendering - Use vector assets where possible; for bitmaps, match display
resolution. - Set
\passthrough{\lstinline!RenderOptions.BitmapInterpolationMode!} for
scaling to avoid blurry or overly expensive scaling. - Cache expensive
geometries (\passthrough{\lstinline!StreamGeometry!}),
\passthrough{\lstinline!FormattedText!}, etc.

Async \& threading - Move heavy work off UI thread (async/await,
\passthrough{\lstinline!Task.Run!} for CPU-bound tasks). - Use
\passthrough{\lstinline!IProgress<T>!} to report progress instead of
manual UI thread dispatch.

Profiling - Use \passthrough{\lstinline!.NET!} profilers (dotTrace,
PerfView, dotnet-trace) to capture CPU/memory. - For GPU, use platform
tools if necessary (RenderDoc for GL/DirectX when supported).

\subsection{8. Considerations per
platform}\label{considerations-per-platform}

\begin{itemize}
\tightlist
\item
  Windows: ensure GPU acceleration enabled; check drivers. Acrylic/Mica
  can cost extra GPU time.
\item
  macOS: retina scaling multiplies pixel counts; ensure vector assets
  and efficient drawing.
\item
  Linux: varying window managers/compositors. If using software
  rendering, expect lower FPS--optimize accordingly.
\item
  Mobile \& Browser: treat CPU/GPU resources as more limited; avoid
  constant redraw loops.
\end{itemize}

\subsection{9. Automation \& CI}\label{automation-ci}

\begin{itemize}
\tightlist
\item
  Combine unit tests with headless UI tests (Chapter 21).
\item
  Create regression tests for performance-critical features (measure
  time for known operations, fail if above threshold).
\item
  Capture baseline metrics (FPS, load time) and compare across commits;
  tools like BenchmarkDotNet can help (for logic-level measurements).
\end{itemize}

\subsection{10. Workflow summary}\label{workflow-summary}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Reproduce in Release with logging disabled -\textgreater{} measure
  baseline.
\item
  Enable DevTools overlays (FPS, dirty rects, layout/render graphs)
  -\textgreater{} identify pattern.
\item
  Enable targeted logging (Binding/Layout/Render) -\textgreater{}
  correlate with overlays.
\item
  Apply fix (virtualization, caching, reducing layout churn)
\item
  Re-measure with overlays/logs to confirm improvements.
\item
  Capture notes and, if beneficial, automate tests for future
  regressions.
\end{enumerate}

\subsection{11. Practice exercises}\label{practice-exercises-18}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Attach DevTools, toggle
  \passthrough{\lstinline!RendererDebugOverlays.Fps | LayoutTimeGraph!},
  and record metrics before/after enabling virtualization in a long
  list.
\item
  Capture binding noise by raising
  \passthrough{\lstinline!LogArea.Binding!} to
  \passthrough{\lstinline!Debug!}, then fix the source and verify the
  log stream quiets down.
\item
  Spin up a \passthrough{\lstinline!RemoteServer!} with
  \passthrough{\lstinline!BsonTcpTransport!}, connect using an Avalonia
  DevTools client (dotnet \passthrough{\lstinline!avalonia!} tool or IDE
  integration), and confirm overlays/logging data mirror the local
  session.
\item
  Profile the same interaction with
  \passthrough{\lstinline!dotnet-trace!} and align CPU spikes with
  render diagnostics to validate the chosen fix.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-22}

\begin{itemize}
\tightlist
\item
  DevTools attach helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Diagnostics/DevToolsExtensions.cs}{\passthrough{\lstinline!DevToolsExtensions.cs!}}
\item
  DevTools view models (toggling overlays):
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Diagnostics/Diagnostics/ViewModels/MainViewModel.cs}{\passthrough{\lstinline!MainViewModel.cs!}}
\item
  Renderer diagnostics:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDiagnostics.cs}{\passthrough{\lstinline!RendererDiagnostics.cs!}}
\item
  Renderer overlays:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Rendering/RendererDebugOverlays.cs}{\passthrough{\lstinline!RendererDebugOverlays.cs!}}
\item
  Logging infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Logging/LogArea.cs}{\passthrough{\lstinline!LogArea!}}
\item
  RenderOptions (quality settings):
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Media/RenderOptions.cs}{\passthrough{\lstinline!RenderOptions.cs!}}
\item
  Layout diagnostics:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Layout/LayoutHelper.cs}{\passthrough{\lstinline!LayoutHelper!}}
\item
  Remote transport messages:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Remote.Protocol/TransportMessages.cs}{\passthrough{\lstinline!TransportMessages.cs!}}
\item
  Remote server host:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Remote/RemoteServer.cs}{\passthrough{\lstinline!RemoteServer.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-22}

\begin{itemize}
\tightlist
\item
  Why must performance measurements be done in Release builds?
\item
  Which overlay would you enable to track layout time spikes? What about
  render time spikes?
\item
  How do DevTools and logging complement each other?
\item
  List three common causes of UI lag and their fixes.
\item
  How would you automate detection of a performance regression?
\end{itemize}

What's next - Next: \href{Chapter25.md}{Chapter 25}

\newpage

\subsection{25. Design-time tooling and the XAML
Previewer}\label{design-time-tooling-and-the-xaml-previewer}

Goal - Use Avalonia's XAML Previewer (designer) effectively in VS,
Rider, and VS Code. - Feed realistic sample data and preview
styles/resources without running your full backend. - Understand design
mode plumbing, avoid previewer crashes, and sharpen your design
workflow.

Why this matters - Fast iteration on UI keeps you productive. The
previewer drastically reduces build/run cycles if you set it up
correctly. - Design-time data prevents ``black boxes'' in the previewer
and reveals layout problems early.

Prerequisites - Familiarity with XAML bindings (Chapter 8) and templates
(Chapter 23).

\subsection{1. Previewer pipeline and
transport}\label{previewer-pipeline-and-transport}

IDE hosts spawn a preview process that loads your view or resource
dictionary over the remote protocol.
\passthrough{\lstinline!DesignWindowLoader!} spins up
\passthrough{\lstinline!RemoteDesignerEntryPoint!}, which compiles your
project with the design configuration, loads the control, then streams
rendered frames back to the IDE through
\passthrough{\lstinline!Avalonia.Remote.Protocol.DesignMessages!}.

Key components: -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Design.cs}{\passthrough{\lstinline!Design.cs!}}
toggles design mode (\passthrough{\lstinline!Design.IsDesignMode!}) and
surfaces attached properties consumed only by the previewer. -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.DesignerSupport/DesignWindowLoader.cs}{\passthrough{\lstinline!DesignWindowLoader!}}
boots the preview process, configures the runtime XAML loader, and
registers services. -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.DesignerSupport/PreviewerWindowImpl.cs}{\passthrough{\lstinline!PreviewerWindowImpl!}}
hosts the live surface, translating remote transport messages into
frames. -
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.DesignerSupport/Remote/RemoteDesignerEntryPoint.cs}{\passthrough{\lstinline!RemoteDesignerEntryPoint!}}
sets up \passthrough{\lstinline!RuntimeXamlLoader!} and dependency
injection so types resolve the same way they will at runtime.

Because the previewer compiles your project, build errors surface
exactly as in \passthrough{\lstinline!dotnet build!}. Keep
\passthrough{\lstinline!AvaloniaResource!} items and generated code in
sync or the previewer will refuse to load.

\subsection{\texorpdfstring{2. Mock data with
\texttt{Design.DataContext}}{2. Mock data with Design.DataContext}}\label{mock-data-with-design.datacontext}

Provide lightweight POCOs or design view models for preview without
touching production services.

Sample POCO:

\begin{lstlisting}
namespace MyApp.Design;

public sealed class SamplePerson
{
    public string Name { get; set; } = "Ada Lovelace";
    public string Email { get; set; } = "ada@example.com";
    public int Age { get; set; } = 37;
}
\end{lstlisting}

Usage in XAML:

\begin{lstlisting}[language=XML]
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:design="clr-namespace:Avalonia.Controls;assembly=Avalonia.Controls"
             xmlns:samples="clr-namespace:MyApp.Design" x:Class="MyApp.Views.ProfileView">
  <design:Design.DataContext>
    <samples:SamplePerson/>
  </design:Design.DataContext>

  <StackPanel Spacing="12" Margin="16">
    <TextBlock Classes="h1" Text="{Binding Name}"/>
    <TextBlock Text="{Binding Email}"/>
    <TextBlock Text="Age: {Binding Age}"/>
  </StackPanel>
</UserControl>
\end{lstlisting}

At runtime the transformer removes
\passthrough{\lstinline!Design.DataContext!}; real view models take
over. For complex forms, expose design view models with stub services
but avoid heavy logic. When you need multiple sample contexts, expose
them as static properties on a design-time provider class and bind with
\passthrough{\lstinline!\{x:Static\}!}.

\subsubsection{Design.IsDesignMode
checks}\label{design.isdesignmode-checks}

Guard expensive operations:

\begin{lstlisting}
if (Design.IsDesignMode)
    return; // skip service setup, timers, network
\end{lstlisting}

Place guards in view constructors,
\passthrough{\lstinline!OnApplyTemplate!}, or view model initialization.

\subsection{\texorpdfstring{3. Design.Width/Height \&
\texttt{DesignStyle}}{3. Design.Width/Height \& DesignStyle}}\label{design.widthheight-designstyle}

Set design canvas size:

\begin{lstlisting}[language=XML]
<StackPanel design:Design.Width="320"
            design:Design.Height="480"
            design:Design.DesignStyle="{StaticResource DesignOutlineStyle}">

</StackPanel>
\end{lstlisting}

\passthrough{\lstinline!DesignStyle!} can add dashed borders or
backgrounds for preview only (define style in resources).

Example design style:

\begin{lstlisting}[language=XML]
<Style x:Key="DesignOutlineStyle">
  <Setter Property="Border.BorderThickness" Value="1"/>
  <Setter Property="Border.BorderBrush" Value="#808080"/>
</Style>
\end{lstlisting}

\subsection{\texorpdfstring{4. Preview resource dictionaries with
\texttt{Design.PreviewWith}}{4. Preview resource dictionaries with Design.PreviewWith}}\label{preview-resource-dictionaries-with-design.previewwith}

Previewing a dictionary or style requires a host control:

\begin{lstlisting}[language=XML]
<ResourceDictionary xmlns="https://github.com/avaloniaui"
                    xmlns:design="clr-namespace:Avalonia.Controls;assembly=Avalonia.Controls"
                    xmlns:views="clr-namespace:MyApp.Views">
  <design:Design.PreviewWith>
    <Border Padding="16" Background="#1f2937">
      <StackPanel Spacing="8">
        <views:Badge Content="1" Classes="success"/>
        <views:Badge Content="Warning" Classes="warning"/>
      </StackPanel>
    </Border>
  </design:Design.PreviewWith>


</ResourceDictionary>
\end{lstlisting}

\passthrough{\lstinline!PreviewWith!} ensures the previewer renders the
host when you open the dictionary alone.

\subsection{5. Inspect previewer logs and compilation
errors}\label{inspect-previewer-logs-and-compilation-errors}

\begin{itemize}
\tightlist
\item
  Visual Studio and Rider show previewer logs in the dedicated
  ``Avalonia Previewer'' tool window; VS Code prints to the Output panel
  (\passthrough{\lstinline!Avalonia Previewer!} channel).
\item
  Logs come from \passthrough{\lstinline!DesignMessages!}; look for
  \passthrough{\lstinline!JsonRpcError!} entries when bindings
  fail---those line numbers map to generated XAML.
\item
  If compilation fails, open the temporary build directory path printed
  in the log. Running
  \passthrough{\lstinline!dotnet build /p:Configuration=Design!}
  replicates the preview build.
\item
  Enable \passthrough{\lstinline!Diagnostics -> Capture frames!} to
  export a \passthrough{\lstinline!.png!} snapshot of the preview
  surface when you troubleshoot rendering glitches.
\end{itemize}

\subsection{6. Extend design-time
services}\label{extend-design-time-services}

\passthrough{\lstinline!RemoteDesignerEntryPoint!} registers services in
a tiny IoC container separate from your production DI. Override or
extend them by wiring a helper that only executes when
\passthrough{\lstinline!Design.IsDesignMode!} is true:

\begin{lstlisting}
using Avalonia;
using Avalonia.Controls;

public static class DesignTimeServices
{
    public static void Register()
    {
        if (!Design.IsDesignMode)
            return;

        AvaloniaLocator.CurrentMutable
            .Bind<INavigationService>()
            .ToConstant(new FakeNavigationService());
    }
}
\end{lstlisting}

Call \passthrough{\lstinline!DesignTimeServices.Register();!} inside
\passthrough{\lstinline!BuildAvaloniaApp().AfterSetup(...)!} so the
previewer receives the fake services without altering production setup.
Use this pattern to swap HTTP clients, repositories, or configuration
with in-memory fakes while keeping runtime untouched.

\subsection{7. IDE-specific tips}\label{ide-specific-tips}

\subsubsection{Visual Studio}\label{visual-studio-1}

\begin{itemize}
\tightlist
\item
  Ensure ``Avalonia Previewer'' extension is installed.
\item
  F12 toggles DevTools; \passthrough{\lstinline!Alt+Space!} opens
  previewer hotkeys.
\item
  If previewer doesn't refresh, rebuild project; VS sometimes caches the
  design assembly.
\item
  Enable verbose logs via
  \passthrough{\lstinline!Previewer -> Options -> Enable Diagnostics!}
  to capture transport traces when the preview window stays blank.
\end{itemize}

\subsubsection{Rider}\label{rider-1}

\begin{itemize}
\tightlist
\item
  Avalonia plugin required; previewer window shows automatically when
  editing XAML.
\item
  Use the data context drop-down to quickly switch between sample
  contexts if multiple available.
\item
  Rider caches preview assemblies under
  \passthrough{\lstinline!\%LOCALAPPDATA\%/Avalonia!}. Use ``Invalidate
  caches'' if you ship new resource dictionaries and the previewer shows
  stale data.
\end{itemize}

\subsubsection{VS Code}\label{vs-code-1}

\begin{itemize}
\tightlist
\item
  Avalonia \passthrough{\lstinline!.vsix!} extension hosts the previewer
  through the dotnet CLI; keep the extension and SDK workloads in sync.
\item
  Run \passthrough{\lstinline!dotnet workload install wasm-tools!}
  (previewer uses WASM-hosted renderer). Use the
  \passthrough{\lstinline!Avalonia Previewer: Show Log!} command if the
  embedded browser surface fails.
\end{itemize}

General - Keep constructors light; heavy constructors crash previewer. -
Use \passthrough{\lstinline!Design.DataContext!} to avoid hitting DI
container or real services. - Split complex layouts into smaller user
controls and preview them individually.

\subsection{8. Troubleshooting \& best
practices}\label{troubleshooting-best-practices-1}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Issue
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Fix
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Previewer blank/crashes & Guard code with
\passthrough{\lstinline!Design.IsDesignMode!}; simplify layout; ensure
no blocking calls in constructor \\
Design-only styles appear at runtime &
\passthrough{\lstinline!Design.*!} stripped at runtime; if they leak,
inspect generated \passthrough{\lstinline!.g.cs!} to confirm transformer
ran \\
Resource dictionary preview fails & Add
\passthrough{\lstinline!Design.PreviewWith!}; ensure resources compiled
(check \passthrough{\lstinline!AvaloniaResource!} includes) \\
Sample data not showing & Confirm namespace mapping correct, sample
object constructs without exceptions, and preview log shows
\passthrough{\lstinline!DataContext!} attachment \\
Slow preview & Remove animations/effects temporarily; large data sets or
virtualization can slow preview host \\
Transport errors (\passthrough{\lstinline!SocketException!}) & Restart
previewer. Firewalls can block the loopback port used by
\passthrough{\lstinline!Avalonia.Remote.Protocol!} \\
\end{longtable}

\subsection{9. Automation}\label{automation}

\begin{itemize}
\tightlist
\item
  Document designer defaults using \passthrough{\lstinline!README!} for
  your UI project. Include instructions for sample data.
\item
  Use git hooks/CI to catch accidental runtime usages of
  \passthrough{\lstinline!Design.*!}. For instance, forbid
  \passthrough{\lstinline!Design.IsDesignMode!} checks in
  release-critical code by scanning for patterns if needed.
\item
  Add an automated smoke test that loads critical views with
  \passthrough{\lstinline!Design.IsDesignModeProperty!} set to true via
  \passthrough{\lstinline!RuntimeXamlLoader!} to detect regressions
  before IDE users do.
\end{itemize}

\subsection{10. Practice exercises}\label{practice-exercises-19}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Add \passthrough{\lstinline!Design.DataContext!} to a complex form,
  providing realistic sample data (names, email, totals). Ensure preview
  shows formatted values.
\item
  Set \passthrough{\lstinline!Design.Width/Height!} to 360x720 for a
  mobile view; use \passthrough{\lstinline!Design.DesignStyle!} to
  highlight layout boundaries.
\item
  Create a resource dictionary for badges; use
  \passthrough{\lstinline!Design.PreviewWith!} to render multiple badge
  variants side-by-side.
\item
  Open the previewer diagnostics window, reproduce a binding failure,
  and note how \passthrough{\lstinline!DesignMessages!} trace the
  failing binding path.
\item
  Guard service initialization with
  \passthrough{\lstinline!if (Design.IsDesignMode)!} and confirm preview
  load improves.
\item
  Bonus: implement a design-only service override and register it from
  \passthrough{\lstinline!BuildAvaloniaApp().AfterSetup(...)!}.
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-23}

\begin{itemize}
\tightlist
\item
  Design property helpers:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Controls/Design.cs}{\passthrough{\lstinline!Design.cs!}}
\item
  Preview transport wiring:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.DesignerSupport/DesignWindowLoader.cs}{\passthrough{\lstinline!DesignWindowLoader.cs!}}
\item
  Previewer bootstrapping:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.DesignerSupport/Remote/RemoteDesignerEntryPoint.cs}{\passthrough{\lstinline!RemoteDesignerEntryPoint.cs!}}
\item
  Design-time property transformer:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Markup/Avalonia.Markup.Xaml.Loader/CompilerExtensions/Transformers/AvaloniaXamlIlDesignPropertiesTransformer.cs}{\passthrough{\lstinline!AvaloniaXamlIlDesignPropertiesTransformer.cs!}}
\item
  Previewer window implementation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.DesignerSupport/Remote/PreviewerWindowImpl.cs}{\passthrough{\lstinline!PreviewerWindowImpl.cs!}}
\item
  Protocol messages:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Remote.Protocol/DesignMessages.cs}{\passthrough{\lstinline!Avalonia.Remote.Protocol/DesignMessages.cs!}}
\item
  Samples: ControlCatalog resources demonstrate
  \passthrough{\lstinline!Design.PreviewWith!} usage
  (\passthrough{\lstinline!samples/ControlCatalog/Styles/...!})
\end{itemize}

\subsection{Check yourself}\label{check-yourself-23}

\begin{itemize}
\tightlist
\item
  How do you provide sample data without running production services?
\item
  How do you prevent design-only code from running in production?
\item
  When do you use \passthrough{\lstinline!Design.PreviewWith!}?
\item
  What are the most common previewer crashes and how do you avoid them?
\end{itemize}

What's next - Next: \href{Chapter26.md}{Chapter 26}

\newpage

\subsection{26. Build, publish, and
deploy}\label{build-publish-and-deploy}

Goal - Produce distributable builds for every platform Avalonia supports
(desktop, mobile, browser). - Understand .NET publish options
(framework-dependent vs self-contained, single-file, ReadyToRun,
trimming). - Package and ship your app (MSIX, DMG, AppImage, AAB/IPA,
browser bundles) and automate via CI/CD.

Why this matters - Reliable builds avoid ``works on my machine''
syndrome. - Choosing the right publish options balances size, startup
time, and compatibility.

Prerequisites - Chapters 18-20 for platform nuances, Chapter 17 for
async/networking (relevant to release builds).

\subsection{1. Build vs publish}\label{build-vs-publish}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!dotnet build!}: compiles assemblies, typically
  run for local development.
\item
  \passthrough{\lstinline!dotnet publish!}: creates a self-contained
  folder/app ready to run on target machines (Optionally includes .NET
  runtime).
\item
  Always test in \passthrough{\lstinline!Release!} configuration:
  \passthrough{\lstinline!dotnet publish -c Release!}.
\end{itemize}

\subsection{2. Avalonia build tooling \& project file
essentials}\label{avalonia-build-tooling-project-file-essentials}

Avalonia ships MSBuild targets that compile XAML and pack resources
alongside your assemblies. Understanding them keeps design-time and
publish-time behavior in sync.

\begin{itemize}
\tightlist
\item
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Build.Tasks/CompileAvaloniaXamlTask.cs}{\passthrough{\lstinline!CompileAvaloniaXamlTask!}}
  runs during \passthrough{\lstinline!BeforeCompile!} to turn
  \passthrough{\lstinline!.axaml!} into generated
  \passthrough{\lstinline!.g.cs!}. If a publish build reports missing
  generated files, confirm the Avalonia NuGet packages are referenced
  and the project imports
  \passthrough{\lstinline!Avalonia.props/targets!}.
\item
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Build.Tasks/AvaloniaResource.cs}{\passthrough{\lstinline!AvaloniaResource!}}
  items embed static content. Include them explicitly so publish outputs
  contain everything:
\end{itemize}

\begin{lstlisting}[language=XML]
<ItemGroup>
  <AvaloniaResource Include="Assets/**" />
  <AvaloniaResource Include="Themes/**/*.axaml" />
</ItemGroup>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  Shared targets such as
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/build/BuildTargets.targets}{\passthrough{\lstinline!build/BuildTargets.targets!}}
  tweak platform packaging. Review them before overriding publish
  stages.
\item
  Use property flags like
  \passthrough{\lstinline!<AvaloniaUseCompiledBindings>true</AvaloniaUseCompiledBindings>!}
  consistently across Debug/Release so the previewer and publish builds
  agree.
\item
  For custom steps (version stamping, signing) extend
  \passthrough{\lstinline!Target Name="AfterPublish"!} or a
  Directory.Build.targets file; Avalonia emits its files before your
  target runs, so you can safely zip or notarize afterward.
\end{itemize}

\subsection{3. Runtime identifiers
(RIDs)}\label{runtime-identifiers-rids}

Common RIDs: - Windows: \passthrough{\lstinline!win-x64!},
\passthrough{\lstinline!win-arm64!}. - macOS:
\passthrough{\lstinline!osx-x64!} (Intel),
\passthrough{\lstinline!osx-arm64!} (Apple Silicon),
\passthrough{\lstinline!osx.12-arm64!} (specific OS version), etc. -
Linux: \passthrough{\lstinline!linux-x64!},
\passthrough{\lstinline!linux-arm64!} (distribution-neutral), or
distro-specific RIDs (\passthrough{\lstinline!linux-musl-x64!}). -
Android: \passthrough{\lstinline!android-arm64!},
\passthrough{\lstinline!android-x86!}, etc. (handled in platform head).
- iOS: \passthrough{\lstinline!ios-arm64!},
\passthrough{\lstinline!iossimulator-x64!}. - Browser (WASM):
\passthrough{\lstinline!browser-wasm!} (handled by browser head).

\subsection{4. Publish configurations}\label{publish-configurations}

\subsubsection{Framework-dependent (requires installed .NET
runtime)}\label{framework-dependent-requires-installed-.net-runtime}

\begin{lstlisting}[language=bash]
dotnet publish -c Release -r win-x64 --self-contained false
\end{lstlisting}

Smaller download; target machine must have matching .NET runtime. Good
for enterprise scenarios.

\subsubsection{Self-contained (bundled
runtime)}\label{self-contained-bundled-runtime}

\begin{lstlisting}[language=bash]
dotnet publish -c Release -r osx-arm64 --self-contained true
\end{lstlisting}

Larger download; runs on machines without .NET. Standard for consumer
apps.

\subsubsection{Single-file}\label{single-file}

\begin{lstlisting}[language=bash]
dotnet publish -c Release -r linux-x64 /p:SelfContained=true /p:PublishSingleFile=true
\end{lstlisting}

Creates one executable (plus a few native libraries depending on
platform). Avalonia may extract resources native libs to temp; test
startup.

\subsubsection{ReadyToRun}\label{readytorun}

\begin{lstlisting}[language=bash]
dotnet publish -c Release -r win-x64 /p:SelfContained=true /p:PublishReadyToRun=true
\end{lstlisting}

Precompiles IL to native code; faster cold start at cost of larger size.
Measure before deciding.

\subsubsection{Trimming (advanced)}\label{trimming-advanced}

\begin{lstlisting}[language=bash]
dotnet publish -c Release -r osx-arm64 /p:SelfContained=true /p:PublishTrimmed=true
\end{lstlisting}

Aggressive size reduction; risky because Avalonia/XAML relies on
reflection. Requires careful annotation/preservation with
\passthrough{\lstinline!DynamicDependency!} or
\passthrough{\lstinline!ILLinkTrim!} files. Start without trimming;
enable later with thorough testing.

\subsubsection{Publish options matrix
(example)}\label{publish-options-matrix-example}

\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Option & Pros & Cons \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Framework-dependent & Small & Requires runtime install \\
Self-contained & Runs anywhere & Larger downloads \\
Single-file & Simple distribution & Extracts natives; more memory \\
ReadyToRun & Faster cold start & Larger size \\
Trimmed & Smaller & Risk of missing types \\
\end{longtable}

\subsection{5. Output directories and manifest
validation}\label{output-directories-and-manifest-validation}

Publish outputs to
\passthrough{\lstinline!bin/Release/<TFramework>/<RID>/publish!}.

Examples: - \passthrough{\lstinline!bin/Release/net8.0/win-x64/publish!}
- \passthrough{\lstinline!bin/Release/net8.0/linux-x64/publish!} -
\passthrough{\lstinline!bin/Release/net8.0/osx-arm64/publish!}

Verify resources (images, fonts) present; confirm
\passthrough{\lstinline!AvaloniaResource!} includes them. Use
\passthrough{\lstinline!dotnet publish /bl:publish.binlog!} and inspect
the binlog with MSBuild Structured Log to confirm each resource path is
copied.

\begin{itemize}
\tightlist
\item
  Check the generated \passthrough{\lstinline!appsettings.json!},
  \passthrough{\lstinline!MyApp.runtimeconfig.json!}, and
  \passthrough{\lstinline!.deps.json!} to ensure trimming or single-file
  options didn't remove dependencies.
\item
  For RID-specific bundles, review the platform manifests (e.g.,
  \passthrough{\lstinline!MyApp.app/Contents/Info.plist!},
  \passthrough{\lstinline!MyApp.msix!}) before shipping.
\end{itemize}

\subsection{6. Asset packing and
resources}\label{asset-packing-and-resources}

\begin{itemize}
\tightlist
\item
  Group related resources into folders and wildcard them via
  \passthrough{\lstinline!AvaloniaResource Include="Assets/Icons/**/*"!}.
  The build task preserves folder structure when copying to publish
  output.
\item
  Embedded assets larger than a few MB (videos, large fonts) can remain
  external files by setting
  \passthrough{\lstinline!<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>!}
  alongside \passthrough{\lstinline!AvaloniaResource!}. That avoids
  bloating assemblies and keeps startup fast.
\item
  When you refactor project layout, set explicit logical paths:
  \passthrough{\lstinline!<AvaloniaResource Update="Assets/logo.svg" LogicalPath="resm:MyApp.Assets.logo.svg">!}.
  Logical paths become the keys your app uses with
  \passthrough{\lstinline!AssetLoader!}.
\item
  Hook a custom
  \passthrough{\lstinline!Target Name="VerifyAvaloniaResources" AfterTargets="ResolveAvaloniaResource"!}
  to ensure required files exist; failing early prevents subtle runtime
  crashes after publish.
\end{itemize}

\subsection{7. Platform packaging}\label{platform-packaging}

\subsubsection{Windows}\label{windows-2}

\begin{itemize}
\tightlist
\item
  Basic distribution: zip the publish folder or single-file EXE.
\item
  MSIX: use
  \passthrough{\lstinline!dotnet publish /p:WindowsPackageType=msix!} or
  MSIX packaging tool. Enables automatic updates, store distribution.
\item
  MSI/Wix: for enterprise installs.
\item
  Code signing recommended (Authenticode certificate) to avoid
  SmartScreen warnings.
\end{itemize}

\subsubsection{macOS}\label{macos-2}

\begin{itemize}
\tightlist
\item
  Create \passthrough{\lstinline!.app!} bundle with
  \passthrough{\lstinline!Avalonia.DesktopRuntime.MacOS!} packaging
  scripts.
\item
  Code sign and notarize: use Apple Developer ID certificate,
  \passthrough{\lstinline!codesign!},
  \passthrough{\lstinline!xcrun altool!}/\passthrough{\lstinline!notarytool!}.
\item
  Provide DMG for distribution.
\end{itemize}

\subsubsection{Linux}\label{linux-1}

\begin{itemize}
\tightlist
\item
  Zip/tarball publish folder with run script.
\item
  AppImage: use \passthrough{\lstinline!Avalonia.AppTemplate.AppImage!}
  or AppImage tooling to bundle.
\item
  Flatpak: create manifest (flatpak-builder). Ensure dependencies
  included via \passthrough{\lstinline!org.freedesktop.Platform!}
  runtime.
\item
  Snap: use \passthrough{\lstinline!snapcraft.yaml!} to bundle.
\end{itemize}

\subsubsection{Android}\label{android-1}

\begin{itemize}
\tightlist
\item
  Platform head (\passthrough{\lstinline!MyApp.Android!}) builds APK/AAB
  using Android tooling.
\item
  Publish release AAB and sign with keystore
  (\passthrough{\lstinline!./gradlew bundleRelease!} or
  \passthrough{\lstinline!dotnet publish!} using .NET Android tooling).
\item
  Upload to Google Play or sideload.
\end{itemize}

\subsubsection{iOS}\label{ios-1}

\begin{itemize}
\tightlist
\item
  Platform head (\passthrough{\lstinline!MyApp.iOS!}) builds .ipa using
  Xcode or
  \passthrough{\lstinline!dotnet publish -f net8.0-ios -c Release!} with
  workload.
\item
  Requires macOS, Xcode, signing certificates, provisioning profiles.
\item
  Deploy to App Store via Transporter/Xcode.
\end{itemize}

\subsubsection{Browser (WASM)}\label{browser-wasm}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!dotnet publish -c Release!} in browser head
  (\passthrough{\lstinline!MyApp.Browser!}). Output in
  \passthrough{\lstinline!bin/Release/net8.0/browser-wasm/AppBundle!}.
\item
  Deploy to static host (GitHub Pages, S3, etc.). Use service worker for
  caching if desired.
\end{itemize}

\subsection{8. Automation (CI/CD)}\label{automation-cicd}

\begin{itemize}
\tightlist
\item
  Use GitHub Actions/Azure Pipelines/GitLab CI to run
  \passthrough{\lstinline!dotnet publish!} per target.
\item
  Example GitHub Actions matrix aligned with Avalonia's build tasks:
\end{itemize}

\begin{lstlisting}
jobs:
  publish:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: windows-latest
            rid: win-x64
          - os: macos-latest
            rid: osx-arm64
          - os: ubuntu-latest
            rid: linux-x64
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'
      - name: Restore workloads
        run: dotnet workload restore
      - name: Publish
        run: |
          dotnet publish src/MyApp/MyApp.csproj \
            -c Release \
            -r ${{ matrix.rid }} \
            --self-contained true \
            /p:PublishSingleFile=true \
            /p:InformationalVersion=${{ github.sha }}
      - name: Collect binlog on failure
        if: failure()
        run: dotnet publish src/MyApp/MyApp.csproj -c Release -r ${{ matrix.rid }} /bl:publish-${{ matrix.rid }}.binlog
      - uses: actions/upload-artifact@v4
        with:
          name: myapp-${{ matrix.rid }}
          path: src/MyApp/bin/Release/net8.0/${{ matrix.rid }}/publish
      - name: Upload binlog
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: publish-logs-${{ matrix.rid }}
          path: publish-${{ matrix.rid }}.binlog
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  Add packaging steps (MSIX, DMG) via platform-specific actions/tools.
\item
  Sign artifacts in CI where possible (store certificates securely).
\item
  Azure Pipelines alternative: copy patterns from
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/azure-pipelines.yml}{\passthrough{\lstinline!azure-pipelines.yml!}}
  to reuse matrix publishing, signing, and artifact staging.
\item
  For custom MSBuild integration, define
  \passthrough{\lstinline!Target Name="SignArtifacts" AfterTargets="Publish"!}
  or \passthrough{\lstinline!AfterTargets="BundleApp"!} in
  \passthrough{\lstinline!Directory.Build.targets!} so both local builds
  and CI run the same packaging hooks.
\end{itemize}

\subsection{9. Verification checklist}\label{verification-checklist}

\begin{itemize}
\tightlist
\item
  Run published app on real machines/VMs for each RID.
\item
  Check fonts, DPI, plugins, network resources.
\item
  Validate updates to config/resources; ensure relative paths work from
  publish folder.
\item
  If using trimming, run automated UITests (Chapter 21) and manual smoke
  tests.
\item
  Run \passthrough{\lstinline!dotnet publish!} with
  \passthrough{\lstinline!--self-contained!} false/true to compare sizes
  and startup times; pick best trade-off.
\item
  Capture a SHA/hash of the publish folder (or installer) and include it
  in release notes so users can verify downloads.
\end{itemize}

\subsection{10. Troubleshooting}\label{troubleshooting-3}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Problem
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Fix
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Missing native libs on Linux & Install required packages
(\passthrough{\lstinline!libicu!}, \passthrough{\lstinline!fontconfig!},
\passthrough{\lstinline!libx11!}, etc.). Document dependencies. \\
Startup crash only in Release & Enable logging to file; check for
missing assets; ensure \passthrough{\lstinline!AvaloniaResource!}
includes. \\
High CPU at startup & Investigate ReadyToRun vs normal build; pre-load
data asynchronously vs synchronously. \\
Code signing errors (macOS/Windows) & Confirm certificates,
entitlements, notarization steps. \\
Publisher mismatch (store upload) & Align package IDs, manifest metadata
with store requirements. \\
\passthrough{\lstinline!CompileAvaloniaXamlTask!} failure & Clean
\passthrough{\lstinline!obj/!}, fix XAML build errors, and examine the
\passthrough{\lstinline!/bl!} binlog to inspect generated task
arguments. \\
Native dependency failure (Skia/WASM) & Use
\passthrough{\lstinline!ldd!}/\passthrough{\lstinline!otool!}/\passthrough{\lstinline!wasm-ld!}
reports to list missing libraries; bundle them or switch to
self-contained publishes. \\
\end{longtable}

\subsection{11. Practice exercises}\label{practice-exercises-20}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Publish self-contained builds for \passthrough{\lstinline!win-x64!},
  \passthrough{\lstinline!osx-arm64!},
  \passthrough{\lstinline!linux-x64!}. Run each and note
  size/performance differences.
\item
  Enable \passthrough{\lstinline!PublishSingleFile!} and
  \passthrough{\lstinline!PublishReadyToRun!} for one target; compare
  startup time and size.
\item
  Experiment with trimming on a small sample; protect reflective types
  with \passthrough{\lstinline!DynamicDependency!} or
  \passthrough{\lstinline!ILLinkTrim!} descriptors and verify at
  runtime.
\item
  Set up a GitHub Actions workflow to publish RID-specific artifacts,
  collect binlogs on failure, and attach a checksum file.
\item
  Optional: create MSIX (Windows) or DMG (macOS) packages, sign them,
  and run locally to test installation/updates.
\item
  Bonus: add a custom MSBuild target that zips the publish folder and
  uploads a checksum to your CI artifacts.
\end{enumerate}

\subsection{Look under the hood (source \&
docs)}\label{look-under-the-hood-source-docs}

\begin{itemize}
\tightlist
\item
  Build docs:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/docs/build.md}{\passthrough{\lstinline!docs/build.md!}}
\item
  XAML compiler task:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Build.Tasks/CompileAvaloniaXamlTask.cs}{\passthrough{\lstinline!CompileAvaloniaXamlTask.cs!}}
\item
  Resource pipeline:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Build.Tasks/AvaloniaResource.cs}{\passthrough{\lstinline!AvaloniaResource.cs!}}
\item
  Shared targets:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/build/BuildTargets.targets}{\passthrough{\lstinline!build/BuildTargets.targets!}}
\item
  Samples for packaging patterns:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples/ControlCatalog}{\passthrough{\lstinline!samples/ControlCatalog!}}
\item
  CI reference:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/azure-pipelines.yml}{\passthrough{\lstinline!azure-pipelines.yml!}}
\item
  .NET publish docs:
  \href{https://learn.microsoft.com/dotnet/core/tools/dotnet-publish}{dotnet
  publish reference}
\item
  App packaging: Microsoft MSIX docs, Apple code signing docs,
  AppImage/Flatpak/Snap guidelines.
\end{itemize}

\subsection{Check yourself}\label{check-yourself-24}

\begin{itemize}
\tightlist
\item
  What's the difference between framework-dependent and self-contained
  publishes? When do you choose each?
\item
  How do single-file, ReadyToRun, and trimming impact size/performance?
\item
  Which MSBuild tasks make sure \passthrough{\lstinline!.axaml!} files
  and resources reach your publish output?
\item
  Which RIDs are needed for your user base?
\item
  What packaging format suits your distribution channel (installer, app
  store, raw executable)?
\item
  How can CI/CD automate builds and packaging per platform?
\end{itemize}

What's next - Next: \href{Chapter27.md}{Chapter 27}

\newpage

\subsection{27. Read the source, contribute, and
grow}\label{read-the-source-contribute-and-grow}

Goal - Navigate the Avalonia repo confidently, understand how to
build/test locally, and contribute fixes, features, docs, or samples. -
Step into framework sources while debugging your app, and know how to
file issues or PRs effectively. - Stay engaged with the community to
keep learning.

Why this matters - Framework knowledge deepens your debugging skills and
shapes better app architecture. - Contributions improve the ecosystem
and strengthen your expertise.

Prerequisites - Familiarity with Git, .NET tooling
(\passthrough{\lstinline!dotnet build/publish/test!}).

\subsection{1. Repository tour}\label{repository-tour}

Avalonia repo highlights: - Core source:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/src}{\passthrough{\lstinline!src/!}}
contains assemblies such as \passthrough{\lstinline!Avalonia.Base!},
\passthrough{\lstinline!Avalonia.Controls!},
\passthrough{\lstinline!Avalonia.Markup.Xaml!}, platform heads, and
backend integrations (\passthrough{\lstinline!Skia!},
\passthrough{\lstinline!WinUI!}, browser). - Tests:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/tests}{\passthrough{\lstinline!tests/!}}
mixes unit tests, headless UI tests, integration tests, and rendering
verification harnesses. Tests often reveal intended behavior and edge
cases. - Samples:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples}{\passthrough{\lstinline!samples/!}}
hosts ControlCatalog, BindingDemo, and scenario-driven apps. They double
as regression repros. - Tooling:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/build}{\passthrough{\lstinline!build/!}}
and
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/build/NukeBuild}{\passthrough{\lstinline!build/NukeBuild!}}
power CI, packaging, and developer workflows. - Docs:
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/docs}{\passthrough{\lstinline!docs/!}}
complements the separate
\href{https://github.com/AvaloniaUI/avalonia-docs}{avalonia-docs} site.
- Contributor policy:
\href{https://github.com/AvaloniaUI/Avalonia/blob/master/CONTRIBUTING.md}{\passthrough{\lstinline!CONTRIBUTING.md!}},
coding conventions, and \passthrough{\lstinline!.editorconfig!} enforce
consistent style (spacing, naming) across submissions.

\subsection{2. Building the framework
locally}\label{building-the-framework-locally}

Scripts in repo root: - \passthrough{\lstinline!build.ps1!} (Windows),
\passthrough{\lstinline!build.sh!} (Unix),
\passthrough{\lstinline!build.cmd!}. - These restore NuGet packages,
compile, run tests (optionally), and produce packages. - The repo also
ships
\href{https://github.com/AvaloniaUI/Avalonia/tree/master/build/NukeBuild}{\passthrough{\lstinline!build/NukeBuild!}}.
Run \passthrough{\lstinline!dotnet run --project build/NukeBuild!} or
\passthrough{\lstinline!.\\build.ps1 --target Test!} to execute curated
pipelines (\passthrough{\lstinline!Compile!},
\passthrough{\lstinline!Test!}, \passthrough{\lstinline!Package!}, etc.)
identical to CI.

Manual build:

\begin{lstlisting}[language=bash]
## Restore dependencies
dotnet restore Avalonia.sln

## Build core
cd src/Avalonia.Controls
dotnet build -c Debug

## Run tests
cd tests/Avalonia.Headless.UnitTests
dotnet test -c Release

## Run sample
cd samples/ControlCatalog
 dotnet run
\end{lstlisting}

Follow \passthrough{\lstinline!docs/build.md!} for environment
requirements.

\subsection{3. Testing strategy
overview}\label{testing-strategy-overview}

Avalonia's quality gates rely on multiple test layers: - Unit tests
(\passthrough{\lstinline!tests/Avalonia.Base.UnitTests!}, etc.) validate
core property system, styling, and helper utilities. - Headless
interaction tests
(\passthrough{\lstinline!tests/Avalonia.Headless.UnitTests!}) simulate
input/rendering without a visible window. - Integration/UI tests
leverage the \passthrough{\lstinline!Avalonia.IntegrationTests.Appium!}
harness for cross-platform smoke tests. - Performance benchmarks (look
under \passthrough{\lstinline!tests/Avalonia.Benchmarks!}) measure
layout, rendering, and binding regressions.

When contributing, prefer adding or updating the test nearest to the
code you touch. For visual bugs, a headless interaction test plus a
ControlCatalog sample usually gives maintainers confidence.

\subsection{4. Reading source with
purpose}\label{reading-source-with-purpose}

Common entry points: - Controls/styling:
\passthrough{\lstinline!src/Avalonia.Controls/!} (Control classes,
templates, themes). - Layout:
\passthrough{\lstinline!src/Avalonia.Base/Layout/!} (Measurement/arrange
logic). - Rendering:
\passthrough{\lstinline!src/Avalonia.Base/Rendering/!},
\passthrough{\lstinline!src/Skia/Avalonia.Skia/!}. - Input:
\passthrough{\lstinline!src/Avalonia.Base/Input/!} (Pointer, keyboard,
gesture recognizers).

Use IDE features (Go to Definition, Find Usages) to jump between user
code and framework internals.

\subsection{5. Debugging into Avalonia}\label{debugging-into-avalonia}

\begin{itemize}
\tightlist
\item
  Enable symbol loading for Avalonia assemblies. NuGet packages ship
  SourceLink metadata---turn on ``Load symbols from Microsoft symbol
  servers'' (VS) or configure Rider's symbol caches so
  \passthrough{\lstinline!.pdb!} files download automatically.
\item
  Add a fallback source path pointing at your local clone
  (\passthrough{\lstinline!external/Avalonia/src!}) to guarantee line
  numbers match when you build from source.
\item
  Set breakpoints in your app, step into framework code to inspect
  layout/renderer behavior. Combine with DevTools overlays to correlate
  visual state with code paths.
\item
  When debugging ControlCatalog or your own sample against a local
  build, reference the project outputs directly
  (\passthrough{\lstinline!dotnet pack!} +
  \passthrough{\lstinline!nuget add source!}) so you test the same bits
  you'll propose in a PR.
\end{itemize}

\subsection{6. Filing issues}\label{filing-issues}

Best practice checklist: - Minimal reproducible sample (GitHub repo,
.zip, or steps to recreate with ControlCatalog). - Include platform(s),
.NET version, Avalonia version, self-contained vs framework-dependent. -
Summarize expected vs actual behavior. Provide logs
(Binding/Layout/Render) or screenshot/video when relevant. - Tag
regression vs new bug; mention if release-only or debug-only.

\subsection{7. Contributing pull
requests}\label{contributing-pull-requests}

Steps: 1. Check CONTRIBUTING.md for branching/style. 2. Fork repo,
create feature branch. 3. Implement change (small, focused scope). 4.
Add/update tests under \passthrough{\lstinline!tests/!} (headless tests
for controls, unit tests for logic). 5. Run
\passthrough{\lstinline!dotnet build!} and
\passthrough{\lstinline!dotnet test!} (or
\passthrough{\lstinline!.\\build.ps1 --target Test!} /
\passthrough{\lstinline!nuke Test!}). 6. Update docs/samples if behavior
changed. 7. Submit PR with clear description, referencing issue
IDs/sites. 8. Respond to feedback promptly.

\subsubsection{Writing tests}\label{writing-tests}

\begin{itemize}
\tightlist
\item
  Use headless tests for visual/interaction behavior (Chapter 21 covers
  pattern).
\item
  Add regression tests for fixed bugs to prevent future breakage.
\item
  Consider measuring performance (BenchmarkDotNet) if change affects
  rendering/layout.
\end{itemize}

\subsubsection{Doc-only or sample-only
PRs}\label{doc-only-or-sample-only-prs}

\begin{itemize}
\tightlist
\item
  Target \passthrough{\lstinline!avalonia-docs!} or
  \passthrough{\lstinline!docs/!} when API behavior changes. Reference
  the code PR in your documentation PR so reviewers can coordinate
  releases.
\item
  For book/doc updates that do not touch runtime code, label the PR
  \passthrough{\lstinline!Documentation!} and mention ``no runtime
  changes'' in the description; CI can skip heavy legs when reviewers
  apply the label.
\item
  Keep screenshots or GIFs small and check them into
  \passthrough{\lstinline!docs/images/!} or the appropriate sample
  folder. Update markdown links accordingly.
\end{itemize}

\subsection{8. Docs \& sample
contributions}\label{docs-sample-contributions}

\begin{itemize}
\tightlist
\item
  Docs source:
  \href{https://github.com/AvaloniaUI/avalonia-docs}{avalonia-docs
  repository}. Preview the site locally with
  \passthrough{\lstinline!npm install!} +
  \passthrough{\lstinline!npm start!} to validate links before
  submitting.
\item
  In-repo docs under \passthrough{\lstinline!docs/!} explain build and
  architecture topics; align book/new content with these guides.
\item
  Samples: add new sample to \passthrough{\lstinline!samples/!}
  illustrating advanced patterns or new controls. Update
  \passthrough{\lstinline!samples/README.md!} when you add something
  new.
\item
  Keep docs in sync with code changes for features/bug fixes and
  cross-link PRs so reviewers merge them together.
\end{itemize}

\subsection{9. Community \& learning}\label{community-learning}

\begin{itemize}
\tightlist
\item
  GitHub discussions:
  \href{https://github.com/AvaloniaUI/Avalonia/discussions}{AvaloniaUI
  discussions}.
\item
  Discord community: link in README.
\item
  Follow release notes and blog posts for new features (subscribe to
  repo releases).
\item
  Speak at meetups, write blog posts, or answer questions to grow
  visibility and knowledge.
\end{itemize}

\subsection{10. Sustainable contribution
workflow}\label{sustainable-contribution-workflow}

Checklist before submitting work: - {[} {]} Reproduced issue with
minimal sample. - {[} {]} Wrote or updated tests covering change. - {[}
{]} Verified on all affected platforms
(Windows/macOS/Linux/Mobile/Browser where applicable). - {[} {]}
Performance measured if relevant. - {[} {]} Docs/samples updated.

\subsection{11. Practice exercises}\label{practice-exercises-21}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Clone the Avalonia repo and run
  \passthrough{\lstinline!.\\build.ps1 --target Compile!} (or
  \passthrough{\lstinline!dotnet run --project build/NukeBuild Compile!}).
  Verify the build succeeds and inspect the generated artifacts.
\item
  Launch ControlCatalog from the sample folder, then step into the code
  for one control you use frequently.
\item
  Configure symbol/source mapping in your IDE and step into
  \passthrough{\lstinline!TextBlock!} rendering while running
  ControlCatalog.
\item
  File a sample issue in a sandbox repo (practice minimal repro).
  Outline expected vs actual behavior clearly.
\item
  Write a headless unit test for a simple control (e.g., verifying a
  custom control draws expected output) and run it locally.
\item
  Draft a doc-only PR in \passthrough{\lstinline!avalonia-docs!}
  describing a workflow you improved (link back to the code sample or
  issue).
\end{enumerate}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-24}

\begin{itemize}
\tightlist
\item
  Repo root:
  \href{https://github.com/AvaloniaUI/Avalonia}{github.com/AvaloniaUI/Avalonia}
\item
  Build scripts:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/build.ps1}{\passthrough{\lstinline!build.ps1!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/build.sh}{\passthrough{\lstinline!build.sh!}}
\item
  NUKE entry point:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/build/NukeBuild}{\passthrough{\lstinline!build/NukeBuild!}}
\item
  Tests index:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/tests}{\passthrough{\lstinline!tests/!}}
\item
  Sample gallery:
  \href{https://github.com/AvaloniaUI/Avalonia/tree/master/samples}{\passthrough{\lstinline!samples/!}}
\item
  Issue templates: \passthrough{\lstinline!.github/ISSUE\_TEMPLATE!}
  directory (bug/feature request).
\item
  PR template:
  \passthrough{\lstinline!.github/pull\_request\_template.md!}.
\end{itemize}

\subsection{Check yourself}\label{check-yourself-25}

\begin{itemize}
\tightlist
\item
  Where do you find tests or samples relevant to a control you're
  debugging?
\item
  How do you step into Avalonia sources from your app?
\item
  What makes a strong issue/PR description?
\item
  How can you contribute documentation or samples beyond code?
\item
  When would you reach for the NUKE build scripts instead of calling
  \passthrough{\lstinline!dotnet build!} directly?
\item
  Which community channels help you stay informed about releases and
  roadmap?
\end{itemize}

What's next - Next: \href{Chapter28.md}{Chapter28}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part VI — Advanced interactivity, markup, and platform integration}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part VI — Advanced interactivity, markup, and platform integration}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{28. Advanced input system and
interactivity}\label{advanced-input-system-and-interactivity}

Goal - Coordinate pointer, keyboard, gamepad/remote, and text input so
complex UI stays responsive. - Build custom gestures and capture
strategies that feel natural across mouse, touch, and pen. - Keep
advanced interactions accessible by mirroring behaviour across input
modalities and IME scenarios.

Why this matters - Modern apps must work with touch, pen, mouse,
keyboard, remotes, and assistive tech simultaneously. - Avalonia's input
stack is highly extensible; understanding the pipeline prevents subtle
bugs (ghost captures, lost focus, broken gestures). - When you marry
gestures with automation, you avoid excluding keyboard- or
screen-reader-only users.

Prerequisites - Chapter 9 (commands, events, and user input) for
routed-event basics. - Chapter 15 (accessibility) to validate
keyboard/automation parity. - Chapter 23 (custom controls) if you plan
to surface bespoke surfaces that drive input directly.

\subsection{1. How Avalonia routes
input}\label{how-avalonia-routes-input}

Avalonia turns OS-specific events into a three-stage pipeline
(\passthrough{\lstinline!InputManager.ProcessInput!}).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Raw input} arrives as
  \passthrough{\lstinline!RawInputEventArgs!} (mouse, touch, pen,
  keyboard, gamepad). Each \passthrough{\lstinline!IRenderRoot!} has
  devices that call \passthrough{\lstinline!Device.ProcessRawEvent!}.
\item
  \textbf{Pre-process observers}
  (\passthrough{\lstinline!InputManager.Instance?.PreProcess!}) can
  inspect or cancel before routing. Use this sparingly for diagnostics,
  not business logic.
\item
  \textbf{Device routing} converts raw data into routed events
  (\passthrough{\lstinline!PointerPressedEvent!},
  \passthrough{\lstinline!KeyDownEvent!},
  \passthrough{\lstinline!TextInputMethodClientRequestedEvent!}).
\item
  \textbf{Process/PostProcess observers} see events after
  routing---handy for analytics or global shortcuts.
\end{enumerate}

Because the input manager lives in
\passthrough{\lstinline!AvaloniaLocator!}, you can temporarily
subscribe:

\begin{lstlisting}
using IDisposable? sub = InputManager.Instance?
    .PreProcess.Subscribe(raw => _log.Debug("Raw input {Device} {Type}", raw.Device, raw.RoutedEvent));
\end{lstlisting}

Remember to dispose subscriptions; the pipeline never terminates while
the app runs.

\subsection{2. Pointer fundamentals and event
order}\label{pointer-fundamentals-and-event-order}

\passthrough{\lstinline!InputElement!} exposes pointer events (bubble
strategy by default).

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Event
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Trigger
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Key data
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!PointerEntered!} /
\passthrough{\lstinline!PointerExited!} & Pointer crosses hit-test
boundary & \passthrough{\lstinline!Pointer.Type!},
\passthrough{\lstinline!KeyModifiers!},
\passthrough{\lstinline!Pointer.IsPrimary!} \\
\passthrough{\lstinline!PointerPressed!} & Button/contact press &
\passthrough{\lstinline!PointerUpdateKind!},
\passthrough{\lstinline!PointerPointProperties!},
\passthrough{\lstinline!ClickCount!} in
\passthrough{\lstinline!PointerPressedEventArgs!} \\
\passthrough{\lstinline!PointerMoved!} & Pointer moves while inside or
captured & \passthrough{\lstinline!GetPosition!},
\passthrough{\lstinline!GetIntermediatePoints!} \\
\passthrough{\lstinline!PointerWheelChanged!} & Mouse wheel / precision
scroll & \passthrough{\lstinline!Vector delta!},
\passthrough{\lstinline!PointerPoint.Properties!} \\
\passthrough{\lstinline!PointerReleased!} & Button/contact release &
\passthrough{\lstinline!Pointer.IsPrimary!},
\passthrough{\lstinline!Pointer.Captured!} \\
\passthrough{\lstinline!PointerCaptureLost!} & Capture re-routed,
element removed, or pointer disposed &
\passthrough{\lstinline!PointerCaptureLostEventArgs.Pointer!} \\
\end{longtable}

Event routing is tunable:

\begin{lstlisting}
protected override void OnInitialized()
{
    base.OnInitialized();
    AddHandler(PointerPressedEvent, OnPreviewPressed, handledEventsToo: true);
    AddHandler(PointerPressedEvent, OnPressed, routingStrategies: RoutingStrategies.Tunnel | RoutingStrategies.Bubble);
}
\end{lstlisting}

Use tunnel handlers (\passthrough{\lstinline!RoutingStrategies.Tunnel!})
for global shortcuts (e.g., closing flyouts). Keep bubbling logic per
control.

\subsubsection{Working with pointer
positions}\label{working-with-pointer-positions}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!e.GetPosition(this)!} projects coordinates
  into any visual's space; pass \passthrough{\lstinline!null!} for
  top-level coordinates.
\item
  \passthrough{\lstinline!e.GetIntermediatePoints(this)!} yields
  historical samples---crucial for smoothing freehand ink.
\item
  \passthrough{\lstinline!PointerPoint.Properties!} exposes pressure,
  tilt, contact rectangles, and button states. Always verify
  availability
  (\passthrough{\lstinline!Pointer.Type == PointerType.Pen!} before
  reading pressure).
\end{itemize}

\subsection{3. Pointer capture and lifetime
handling}\label{pointer-capture-and-lifetime-handling}

Capturing sends subsequent input to an element regardless of pointer
location---vital for drags.

\begin{lstlisting}
protected override void OnPointerPressed(PointerPressedEventArgs e)
{
    if (e.Pointer.Type == PointerType.Touch)
    {
        e.Pointer.Capture(this);
        _dragStart = e.GetPosition(this);
        e.Handled = true;
    }
}

protected override void OnPointerReleased(PointerReleasedEventArgs e)
{
    if (ReferenceEquals(e.Pointer.Captured, this))
    {
        e.Pointer.Capture(null);
        CompleteDrag(e.GetPosition(this));
        e.Handled = true;
    }
}
\end{lstlisting}

Key rules: - Always release capture
(\passthrough{\lstinline!Capture(null)!}) on completion or cancellation.
- Watch \passthrough{\lstinline!PointerCaptureLost!}---it fires if the
element leaves the tree or another control steals capture. - Don't
forget to handle the gesture recognizer case: if a recognizer captures
the pointer, your control stops receiving
\passthrough{\lstinline!PointerMoved!} events until capture returns. -
When chaining capture up the tree (\passthrough{\lstinline!Control!} →
\passthrough{\lstinline!Window!}), consider
\passthrough{\lstinline!e.Pointer.Capture(this)!} in the top-level to
avoid anomalies when children are removed mid-gesture.

\subsection{4. Multi-touch, pen, and high-precision
data}\label{multi-touch-pen-and-high-precision-data}

Avalonia assigns unique IDs per contact
(\passthrough{\lstinline!Pointer.Id!}) and marks a primary contact
(\passthrough{\lstinline!Pointer.IsPrimary!}). Keep per-pointer state in
a dictionary:

\begin{lstlisting}
private readonly Dictionary<int, PointerTracker> _active = new();

protected override void OnPointerPressed(PointerPressedEventArgs e)
{
    _active[e.Pointer.Id] = new PointerTracker(e.Pointer.Type, e.GetPosition(this));
    UpdateManipulation();
}

protected override void OnPointerReleased(PointerReleasedEventArgs e)
{
    _active.Remove(e.Pointer.Id);
    UpdateManipulation();
}
\end{lstlisting}

Pen-specific data lives in
\passthrough{\lstinline!PointerPoint.Properties!}:

\begin{lstlisting}
var sample = e.GetCurrentPoint(this);
float pressure = sample.Properties.Pressure; // 0-1
bool isEraser = sample.Properties.IsEraser;
\end{lstlisting}

Touch sends a contact rectangle (\passthrough{\lstinline!ContactRect!})
you can use for palm rejection or handle-size aware UI.

\subsection{5. Gesture recognizers in
depth}\label{gesture-recognizers-in-depth}

Two gesture models coexist:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Predefined routed events} in
  \passthrough{\lstinline!Avalonia.Input.Gestures!}
  (\passthrough{\lstinline!Tapped!},
  \passthrough{\lstinline!DoubleTapped!},
  \passthrough{\lstinline!RightTapped!}). Attach with
  \passthrough{\lstinline!Gestures.AddDoubleTappedHandler!} or
  \passthrough{\lstinline!AddHandler!}.
\item
  \textbf{Composable recognizers}
  (\passthrough{\lstinline!InputElement.GestureRecognizers!}) for
  continuous gestures (pinch, pull-to-refresh, scroll).
\end{enumerate}

To attach built-in recognizers:

\begin{lstlisting}
GestureRecognizers.Add(new PinchGestureRecognizer
{
    // Your subclasses can expose properties via styled setters
});
\end{lstlisting}

Creating your own recognizer lets you coordinate multiple pointers and
maintain internal state:

\begin{lstlisting}
public class PressAndHoldRecognizer : GestureRecognizer
{
    public static readonly RoutedEvent<RoutedEventArgs> PressAndHoldEvent =
        RoutedEvent.Register<InputElement, RoutedEventArgs>(
            nameof(PressAndHoldEvent), RoutingStrategies.Bubble);

    public TimeSpan Threshold { get; set; } = TimeSpan.FromMilliseconds(600);

    private CancellationTokenSource? _hold;
    private Point _pressOrigin;

    protected override async void PointerPressed(PointerPressedEventArgs e)
    {
        if (Target is not Visual visual)
            return;

        _pressOrigin = e.GetPosition(visual);
        Capture(e.Pointer);

        _hold = new CancellationTokenSource();
        try
        {
            await Task.Delay(Threshold, _hold.Token);
            Target?.RaiseEvent(new RoutedEventArgs(PressAndHoldEvent));
        }
        catch (TaskCanceledException)
        {
            // Swallow cancellation when pointer moves or releases early.
        }
    }

    protected override void PointerMoved(PointerEventArgs e)
    {
        if (Target is not Visual visual || _hold is null || _hold.IsCancellationRequested)
            return;

        var current = e.GetPosition(visual);
        if ((current - _pressOrigin).Length > 8)
            _hold.Cancel();
    }

    protected override void PointerReleased(PointerReleasedEventArgs e) => _hold?.Cancel();
    protected override void PointerCaptureLost(IPointer pointer) => _hold?.Cancel();
}
\end{lstlisting}

Register the routed event (\passthrough{\lstinline!PressAndHoldEvent!})
on your control and listen just like other events. Note the call to
\passthrough{\lstinline!Capture(e.Pointer)!} which also calls
\passthrough{\lstinline!PreventGestureRecognition()!} to stop competing
recognizers.

\subsubsection{Manipulation gestures and
inertia}\label{manipulation-gestures-and-inertia}

Avalonia exposes higher-level manipulation data through gesture
recognizers so you do not have to rebuild velocity tracking yourself.

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!ScrollGestureRecognizer!} raises
  \passthrough{\lstinline!ScrollGestureEventArgs!} with linear deltas
  and velocities---ideal for kinetic scrolling or canvas panning.
\item
  \passthrough{\lstinline!PinchGestureRecognizer!} produces
  \passthrough{\lstinline!PinchEventArgs!} that report scale, rotation,
  and centroid changes for zoom surfaces.
\item
  \passthrough{\lstinline!PullGestureRecognizer!} keeps track of
  displacement against a threshold
  (\passthrough{\lstinline!PullGestureRecognizer.TriggerDistance!}) so
  you can drive pull-to-refresh visuals without reimplementing spring
  physics.
\item
  Internally, each recognizer uses
  \passthrough{\lstinline!VelocityTracker!} to compute momentum; you can
  hook \passthrough{\lstinline!GestureRecognizer.Completed!} to project
  inertia with your own easing.
\end{itemize}

Attach event handlers directly on the recognizer when you need raw data:

\begin{lstlisting}
var scroll = new ScrollGestureRecognizer();
scroll.Scroll += (_, e) => _viewport += e.DeltaTranslation;
scroll.Inertia += (_, e) => StartInertiaAnimation(e.Velocity);
GestureRecognizers.Add(scroll);
\end{lstlisting}

Manipulation events coexist with pointer events. Mark the gesture event
as handled when you consume it so the default scroll viewer does not
fight your logic. For custom behaviors (elastic edges, snap points),
tune \passthrough{\lstinline!ScrollGestureRecognizer.IsContinuous!},
\passthrough{\lstinline!ScrollGestureRecognizer.CanHorizontallyScroll!},
and
\passthrough{\lstinline!ScrollGestureRecognizer.CanVerticallyScroll!} to
match your layout.

\subsection{6. Designing complex pointer
experiences}\label{designing-complex-pointer-experiences}

Strategies for common scenarios:

\begin{itemize}
\tightlist
\item
  \textbf{Drag handles on templated controls:} capture the pointer in
  the handle \passthrough{\lstinline!Thumb!}, raise a routed
  \passthrough{\lstinline!DragDelta!} event, and update layout in
  response. Release capture in \passthrough{\lstinline!PointerReleased!}
  and \passthrough{\lstinline!PointerCaptureLost!}.
\item
  \textbf{Drawing canvases:} store sampled points per pointer ID, use
  \passthrough{\lstinline!GetIntermediatePoints!} for smooth curves, and
  throttle invalidation with \passthrough{\lstinline!DispatcherTimer!}
  to keep the UI responsive.
\item
  \textbf{Canvas panning + zooming:} differentiate gestures by pointer
  count---single pointer pans, two pointers feed
  \passthrough{\lstinline!PinchGestureRecognizer!} for zoom. Combine
  with \passthrough{\lstinline!MatrixTransform!} on the content.
\item
  \textbf{Edge swipe or pull-to-refresh:} use
  \passthrough{\lstinline!PullGestureRecognizer!} with
  \passthrough{\lstinline!PullDirection!} to recognise deflection and
  expose progress to the view model.
\item
  \textbf{Hover tooltips:} \passthrough{\lstinline!PointerEntered!}
  kicks off a timer, \passthrough{\lstinline!PointerExited!} cancels it;
  inspect
  \passthrough{\lstinline!e.GetCurrentPoint(this).Properties.PointerUpdateKind!}
  to ignore quick flicks.
\end{itemize}

Platform differences worth noting: - \textbf{Windows/macOS/Linux} share
pointer semantics, but only touch-capable hardware raises
\passthrough{\lstinline!PointerType.Touch!}. Guard pen-specific paths
behind \passthrough{\lstinline!Pointer.Type == PointerType.Pen!} because
Linux/X11 backends can omit advanced pen properties. - \textbf{Mobile
backends} (Android/iOS) dispatch multi-touch contacts without a mouse
concept; ensure commands have keyboard fallbacks if you reuse the view
for desktop. - \textbf{Browser (WASM)} lacks raw access to OS cursors
and some pen metrics;
\passthrough{\lstinline!PointerPoint.Properties.Pressure!} may always be
\passthrough{\lstinline!1.0!}. - \textbf{Tizen} requires declaring the
\passthrough{\lstinline!http://tizen.org/privilege/haptic!} privilege
before you can trigger haptics from pull or press gestures.

\subsection{7. Keyboard navigation, focus, and
shortcuts}\label{keyboard-navigation-focus-and-shortcuts}

Avalonia's focus engine is pluggable.

\begin{itemize}
\tightlist
\item
  Each \passthrough{\lstinline!TopLevel!} exposes a
  \passthrough{\lstinline!FocusManager!} (via
  \passthrough{\lstinline!(this.GetVisualRoot() as IInputRoot)?.FocusManager!})
  that drives tab order (\passthrough{\lstinline!TabIndex!},
  \passthrough{\lstinline!IsTabStop!}).
\item
  \passthrough{\lstinline!IKeyboardNavigationHandler!} orchestrates
  directional nav; register your own implementation before building the
  app,
  e.g.~\passthrough{\lstinline!AvaloniaLocator.CurrentMutable.Bind<IKeyboardNavigationHandler>().ToSingleton<CustomHandler>();!}.
\item
  \passthrough{\lstinline!XYFocus!} attached properties override
  directional targets for gamepad/remote scenarios:
\end{itemize}

\begin{lstlisting}[language=XML]
<StackPanel
    input:XYFocus.Up="{Binding ElementName=SearchBox}"
    input:XYFocus.NavigationModes="Keyboard,Gamepad" />
\end{lstlisting}

Key bindings complement commands without requiring specific controls:

\begin{lstlisting}
KeyBindings.Add(new KeyBinding
{
    Gesture = new KeyGesture(Key.N, KeyModifiers.Control | KeyModifiers.Shift),
    Command = ViewModel.NewNoteCommand
});
\end{lstlisting}

\passthrough{\lstinline!HotKeyManager!} subscribes globally:

\begin{lstlisting}
HotKeyManager.SetHotKey(this, KeyGesture.Parse("F2"));
\end{lstlisting}

Ensure the target control implements
\passthrough{\lstinline!ICommandSource!} or
\passthrough{\lstinline!IClickableControl!}; Avalonia wires the gesture
into the containing \passthrough{\lstinline!TopLevel!} and executes the
command or raises \passthrough{\lstinline!Click!}.

Ensure focus cues remain visible: call
\passthrough{\lstinline!NavigationMethod.Tab!} when moving focus
programmatically so keyboard users see an adorner.

\subsection{8. Gamepad, remote, and spatial
focus}\label{gamepad-remote-and-spatial-focus}

When Avalonia detects non-keyboard key devices, it sets
\passthrough{\lstinline!KeyDeviceType!} on key events. Use
\passthrough{\lstinline!FocusManager.GetFocusManager(this)?.Focus(elem, NavigationMethod.Directional, modifiers)!}
to respect D-Pad navigation.

Configure XY focus per visual:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Property
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!XYFocus.Up/Down/Left/Right!} & Explicit
neighbours when layout is irregular \\
\passthrough{\lstinline!XYFocus.NavigationModes!} & Enable keyboard,
gamepad, remote individually \\
\passthrough{\lstinline!XYFocus.LeftNavigationStrategy!} & Choose
default algorithm (closest edge, projection, navigation axis) \\
\end{longtable}

For dense grids (e.g., TV apps), set
\passthrough{\lstinline!XYFocus.NavigationModes="Gamepad,Remote"!} and
assign explicit neighbours to avoid diagonal jumps. Pair with
\passthrough{\lstinline!KeyBindings!} for shortcuts like
\passthrough{\lstinline!Back!} or \passthrough{\lstinline!Menu!} buttons
on controllers (map gamepad keys via key modifiers on the key event).

Where hardware exposes haptic feedback (mobile, TV remotes), query the
platform implementation with
\passthrough{\lstinline!TopLevel.PlatformImpl?.TryGetFeature<TFeature>()!}.
Some backends surface rumble/vibration helpers; when none are available,
fall back gracefully so keyboard-only users are not blocked.

\subsection{9. Text input services and IME
integration}\label{text-input-services-and-ime-integration}

Text input flows through \passthrough{\lstinline!InputMethod!},
\passthrough{\lstinline!TextInputMethodClient!}, and
\passthrough{\lstinline!TextInputOptions!}.

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!TextInputOptions!} attached properties
  describe desired keyboard UI.
\item
  \passthrough{\lstinline!TextInputMethodClient!} adapts a text view to
  IMEs (caret rectangle, surrounding text, reconversion).
\item
  \passthrough{\lstinline!InputMethod.GetIsInputMethodEnabled!} lets you
  disable the IME for password fields.
\end{itemize}

Set options in XAML:

\begin{lstlisting}[language=XML]
<TextBox
    Text=""
    input:TextInputOptions.ContentType="Email"
    input:TextInputOptions.ReturnKeyType="Send"
    input:TextInputOptions.ShowSuggestions="True"
    input:TextInputOptions.IsSensitive="False" />
\end{lstlisting}

When you implement custom text surfaces (code editors, chat bubbles):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Implement \passthrough{\lstinline!TextInputMethodClient!} to expose
  text range, caret rect, and surrounding text.
\item
  Handle \passthrough{\lstinline!TextInputMethodClientRequested!} in
  your control to supply the client.
\item
  Call
  \passthrough{\lstinline!InputMethod.SetIsInputMethodEnabled(this, true)!}
  and update the client's \passthrough{\lstinline!TextViewVisual!} so
  IME windows track the caret.
\item
  On geometry changes, raise
  \passthrough{\lstinline!TextInputMethodClient.CursorRectangleChanged!}
  so the backend updates composition windows.
\end{enumerate}

Remember to honor
\passthrough{\lstinline!TextInputOptions.IsSensitive!}---set it when
editing secrets so onboard keyboards hide predictions.

\subsection{10. Accessibility and multi-modal
parity}\label{accessibility-and-multi-modal-parity}

Advanced interactions must fall back to keyboard and automation:

\begin{itemize}
\tightlist
\item
  Offer parallel commands (\passthrough{\lstinline!KeyBindings!},
  buttons) for pointer-only gestures.
\item
  When adding custom gestures, raise semantic routed events (e.g.,
  \passthrough{\lstinline!CopyRequested!}) so automation peers can
  invoke them.
\item
  Keep automation peers updated
  (\passthrough{\lstinline!AutomationProperties.ControlType!},
  \passthrough{\lstinline!AutomationProperties.IsControlElement!}) when
  capture changes visual state.
\item
  Respect \passthrough{\lstinline!FocusManager!} decisions---never
  suppress focus adorners merely because a pointer started the
  interaction.
\item
  Use \passthrough{\lstinline!InputMethod.SetIsInputMethodEnabled!} and
  \passthrough{\lstinline!TextInputOptions!} to support assistive text
  input (switch control, dictation).
\end{itemize}

\subsection{11. Multi-modal input lab
(practice)}\label{multi-modal-input-lab-practice}

Create a playground that exercises every surface:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Project setup}: scaffold
  \passthrough{\lstinline!dotnet new avalonia.mvvm -n InputLab!}. Add a
  \passthrough{\lstinline!CanvasView!} control hosting drawing, a side
  panel for logs, and a bottom toolbar.
\item
  \textbf{Pointer canvas}: capture touch/pen input, buffer points per
  pointer ID, and render trails using
  \passthrough{\lstinline!DrawingContext.DrawGeometry!}. Display
  pressure as stroke thickness.
\item
  \textbf{Custom gesture}: add the
  \passthrough{\lstinline!PressAndHoldRecognizer!} (above) to show
  context commands after 600 ms. Hook the resulting routed event to
  toggle a radial menu.
\item
  \textbf{Pinch \& scroll}: attach
  \passthrough{\lstinline!PinchGestureRecognizer!} and
  \passthrough{\lstinline!ScrollGestureRecognizer!} to pan/zoom the
  canvas. Update a \passthrough{\lstinline!MatrixTransform!} as gesture
  delta arrives.
\item
  \textbf{Keyboard navigation}: define
  \passthrough{\lstinline!KeyBindings!} for
  \passthrough{\lstinline!Ctrl+Z!},
  \passthrough{\lstinline!Ctrl+Shift+Z!}, and arrow-key panning. Update
  \passthrough{\lstinline!XYFocus!} properties so D-Pad moves between
  toolbar buttons.
\item
  \textbf{Gamepad test}: using a controller or emulator, verify focus
  flows across the UI. Log \passthrough{\lstinline!KeyDeviceType!} in
  \passthrough{\lstinline!KeyDown!} to confirm Avalonia recognises it as
  Gamepad.
\item
  \textbf{IME sandbox}: place a chat-style
  \passthrough{\lstinline!TextBox!} with
  \passthrough{\lstinline!TextInputOptions.ReturnKeyType="Send"!}, plus
  a custom \passthrough{\lstinline!MentionTextBox!} implementing
  \passthrough{\lstinline!TextInputMethodClient!} to surface inline
  completions.
\item
  \textbf{Accessibility pass}: ensure every action has a keyboard
  alternative, set automation names on dynamically created controls, and
  test the capture cycle with screen reader cursor.
\item
  \textbf{Diagnostics}: subscribe to
  \passthrough{\lstinline!InputManager.Instance?.Process!} and log
  pointer ID, update kind, and capture target into a side list for
  debugging.
\end{enumerate}

Document findings in README (which gestures compete, how capture behaves
on focus loss) so the team can adjust default UX.

\subsection{12. Troubleshooting \& best
practices}\label{troubleshooting-best-practices-2}

\begin{itemize}
\tightlist
\item
  \textbf{Missing pointer events}: ensure
  \passthrough{\lstinline!IsHitTestVisible!} is true and that no
  transparent sibling intercepts input. For overlays, set
  \passthrough{\lstinline!IsHitTestVisible="False"!}.
\item
  \textbf{Stuck capture}: always release capture during
  \passthrough{\lstinline!PointerCaptureLost!} and when the control
  unloads. Wrap capture in \passthrough{\lstinline!try/finally!} on
  operations that may throw.
\item
  \textbf{Gesture conflicts}: call
  \passthrough{\lstinline!e.PreventGestureRecognition()!} when manual
  pointer logic should trump recognizers---or avoid attaching
  recognizers to nested elements.
\item
  \textbf{High-DPI offsets}: convert to screen coordinates using
  \passthrough{\lstinline!Visual.PointToScreen!} when working across
  popups; pointer positions are per-visual, not global.
\item
  \textbf{Keyboard focus lost after drag}: store
  \passthrough{\lstinline!(this.GetVisualRoot() as IInputRoot)?.FocusManager?.GetFocusedElement()!}
  before capture and restore it when the operation completes to preserve
  keyboard flow.
\item
  \textbf{IME composition rectangles misplaced}: update
  \passthrough{\lstinline!TextInputMethodClient.TextViewVisual!}
  whenever layout changes; failing to do so leaves composition windows
  floating in the old position.
\end{itemize}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-25}

\begin{itemize}
\tightlist
\item
  Pointer lifecycle:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/Pointer.cs}{\passthrough{\lstinline!Pointer.cs!}}
\item
  Pointer events \& properties:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/PointerEventArgs.cs}{\passthrough{\lstinline!PointerEventArgs.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/PointerPoint.cs}{\passthrough{\lstinline!PointerPoint.cs!}}
\item
  Gesture infrastructure:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/GestureRecognizer.cs}{\passthrough{\lstinline!GestureRecognizer.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/Gestures.cs}{\passthrough{\lstinline!Gestures.cs!}}
\item
  Continuous gestures:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/ScrollGestureRecognizer.cs}{\passthrough{\lstinline!ScrollGestureRecognizer.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/PinchGestureRecognizer.cs}{\passthrough{\lstinline!PinchGestureRecognizer.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/GestureRecognizers/PullGestureRecognizer.cs}{\passthrough{\lstinline!PullGestureRecognizer.cs!}}
\item
  Keyboard \& XY navigation:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/IKeyboardNavigationHandler.cs}{\passthrough{\lstinline!IKeyboardNavigationHandler.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/Navigation/XYFocus.Properties.cs}{\passthrough{\lstinline!XYFocus.Properties.cs!}}
\item
  Device data:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyEventArgs.cs}{\passthrough{\lstinline!KeyEventArgs.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/KeyDeviceType.cs}{\passthrough{\lstinline!KeyDeviceType.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TouchDevice.cs}{\passthrough{\lstinline!TouchDevice.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/PenDevice.cs}{\passthrough{\lstinline!PenDevice.cs!}}
\item
  Text input pipeline:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/TextInputOptions.cs}{\passthrough{\lstinline!TextInputOptions.cs!}},
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/TextInput/InputMethodManager.cs}{\passthrough{\lstinline!TextInputMethodManager.cs!}}
\item
  Input manager stages:
  \href{https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Base/Input/InputManager.cs}{\passthrough{\lstinline!InputManager.cs!}}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-26}

\begin{itemize}
\tightlist
\item
  How do tunnelling handlers differ from bubbling handlers when mixing
  pointer capture and gestures?
\item
  Which \passthrough{\lstinline!PointerPointProperties!} matter for pen
  input and how do you guard against unsupported platforms?
\item
  What steps are required to surface a custom
  \passthrough{\lstinline!TextInputMethodClient!} in your control?
\item
  How can you ensure a drag interaction remains keyboard-accessible?
\item
  When would you replace the default
  \passthrough{\lstinline!IKeyboardNavigationHandler!}?
\end{itemize}

What's next - Next: \href{Chapter29.md}{Chapter29}

\newpage

\subsection{29. Animations, transitions, and
composition}\label{animations-transitions-and-composition}

Goal - Shape motion with Avalonia's keyframe animations, property
transitions, and composition effects. - Decide when to stay in the
styling layer versus dropping to the compositor for GPU-driven effects.
- Orchestrate smooth navigation and reactive UI feedback without
sacrificing performance.

Why this matters - Motion guides attention, expresses hierarchy, and
communicates state changes; Avalonia gives you several layers to
accomplish that. - Choosing the right animation surface (XAML,
transitions, or composition) avoids wasted CPU, jank, and
hard-to-maintain code. - Composition unlocks scenarios---material blurs,
connected animations, fluid navigation---that are hard to express with
traditional rendering.

Prerequisites - Chapter 22 (Rendering pipeline) for the frame loop and
renderer semantics. - Chapter 23 (Custom drawing) for custom visuals
that you might animate. - Chapter 8 (Data binding) for reactive
triggers, and Chapter 24 (Diagnostics) for measuring performance.

\subsection{1. Keyframe animation building
blocks}\label{keyframe-animation-building-blocks}

Avalonia's declarative animation stack lives in
\passthrough{\lstinline!Avalonia.Animation.Animation!} and friends.
Every control derives from \passthrough{\lstinline!Animatable!}, so you
can plug animations into styles or run them directly in code.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Concept
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Type
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Highlights
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Timeline & \passthrough{\lstinline!Animation!}
(\passthrough{\lstinline!Animation.cs!}) &
\passthrough{\lstinline!Duration!}, \passthrough{\lstinline!Delay!},
\passthrough{\lstinline!IterationCount!},
\passthrough{\lstinline!PlaybackDirection!},
\passthrough{\lstinline!FillMode!},
\passthrough{\lstinline!SpeedRatio!} \\
Track & \passthrough{\lstinline!KeyFrame!}
(\passthrough{\lstinline!KeyFrames.cs!}) & Specifies a cue
(\passthrough{\lstinline!0\%!}..\passthrough{\lstinline!100\%!}) with
one or more \passthrough{\lstinline!Setter!}s \\
Interpolation & \passthrough{\lstinline!Animator<T>!}
(\passthrough{\lstinline!Animators/DoubleAnimator.cs!}, etc.) & Avalonia
ships animators for primitives, transforms, brushes, shadows \\
Easing & \passthrough{\lstinline!Easing!}
(\passthrough{\lstinline!Animation/Easings/*!}) & Over 30 easing curves,
plus \passthrough{\lstinline!SplineEasing!} for custom cubic Bezier \\
Clock & \passthrough{\lstinline!IClock!} /
\passthrough{\lstinline!Clock!} (\passthrough{\lstinline!Clock.cs!}) &
Drives animations, default is the global clock \\
\end{longtable}

A minimal style animation:

\begin{lstlisting}[language=XML]
<Window xmlns="https://github.com/avaloniaui">
  <Window.Styles>
    <Style Selector="Rectangle.alert">
      <Setter Property="Fill" Value="Red"/>
      <Style.Animations>
        <Animation Duration="0:0:0.6"
                   IterationCount="INFINITE"
                   PlaybackDirection="Alternate">
          <KeyFrame Cue="0%">
            <Setter Property="Opacity" Value="0.4"/>
            <Setter Property="RenderTransform.ScaleX" Value="1"/>
            <Setter Property="RenderTransform.ScaleY" Value="1"/>
          </KeyFrame>
          <KeyFrame Cue="100%">
            <Setter Property="Opacity" Value="1"/>
            <Setter Property="RenderTransform.ScaleX" Value="1.05"/>
            <Setter Property="RenderTransform.ScaleY" Value="1.05"/>
          </KeyFrame>
        </Animation>
      </Style.Animations>
    </Style>
  </Window.Styles>
</Window>
\end{lstlisting}

Key points: -
\passthrough{\lstinline!Animation.IterationCount="INFINITE"!} loops
forever; avoid pairing with \passthrough{\lstinline!Animation.RunAsync!}
(throws by design). - \passthrough{\lstinline!FillMode!} controls which
keyframe value sticks before/after the timeline. Use
\passthrough{\lstinline!FillMode="Both"!} for a resting value. - You can
scope animations to a resource dictionary and reference them by
\passthrough{\lstinline!\{StaticResource\}!} from templates or code.

\subsection{2. Controlling playback from
code}\label{controlling-playback-from-code}

\passthrough{\lstinline!Animation.RunAsync!} and
\passthrough{\lstinline!Animation.Apply!} let you start, await, or
conditionally run animations from code-behind or view models
(\passthrough{\lstinline!Animation.cs!},
\passthrough{\lstinline!RunAsync!}).

\begin{lstlisting}
public class ToastController
{
    private readonly Animation _slideIn;
    private readonly Animation _slideOut;
    private readonly Border _host;

    public ToastController(Border host, Animation slideIn, Animation slideOut)
    {
        _host = host;
        _slideIn = slideIn;
        _slideOut = slideOut;
    }

    public async Task ShowAsync(CancellationToken token)
    {
        await _slideIn.RunAsync(_host, token); // awaits completion
        await Task.Delay(TimeSpan.FromSeconds(3), token);
        await _slideOut.RunAsync(_host, token); // reuse the same host, different cues
    }
}
\end{lstlisting}

Behind the scenes \passthrough{\lstinline!RunAsync!} applies the
animation with an \passthrough{\lstinline!IClock!} (defaults to
\passthrough{\lstinline!Clock.GlobalClock!}) and completes when the last
animator reports completion. Create the
\passthrough{\lstinline!\_slideOut!} animation by cloning
\passthrough{\lstinline!\_slideIn!}, switching its cues, or temporarily
setting
\passthrough{\lstinline!PlaybackDirection = PlaybackDirection.Reverse!}
before calling \passthrough{\lstinline!RunAsync!}.

Reactive triggers map easily to animations by using
\passthrough{\lstinline!Apply(control, clock, IObservable<bool> match, Action onComplete)!}:

\begin{lstlisting}
var animation = (Animation)Resources["HighlightAnimation"];
var match = viewModel.WhenAnyValue(vm => vm.IsDirty);
var subscription = animation.Apply(border, null, match, null);
_disposables.Add(subscription);
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  The observable controls when the animation should run
  (\passthrough{\lstinline!true!} pulses start it,
  \passthrough{\lstinline!false!} cancels).
\item
  Supply your own \passthrough{\lstinline!Clock!} to coordinate multiple
  animations (e.g., \passthrough{\lstinline!new Clock(globalClock)!}
  with \passthrough{\lstinline!PlayState.Pause!} to scrub).
\item
  Use the cancellation overload to stop animating when the control
  unloads or the view model changes.
\end{itemize}

\subsection{3. Implicit transitions and styling
triggers}\label{implicit-transitions-and-styling-triggers}

For property tweaks (hover states, theme switches)
\passthrough{\lstinline!Animatable.Transitions!}
(\passthrough{\lstinline!Animatable.cs!}) is lighter weight than
keyframes. A \passthrough{\lstinline!Transition<T>!} blends from the old
value to a new one automatically.

\begin{lstlisting}[language=XML]
<Button Classes="primary">
  <Button.Transitions>
    <Transitions>
      <DoubleTransition Property="Opacity" Duration="0:0:0.150"/>
      <TransformOperationsTransition Property="RenderTransform" Duration="0:0:0.200"/>
    </Transitions>
  </Button.Transitions>
</Button>
\end{lstlisting}

Rules of thumb: - Transitions cannot target direct properties
(validation happens in \passthrough{\lstinline!Transitions.cs!}). Use
styled properties or wrappers. - Attach them at the control level
(\passthrough{\lstinline!Button.Transitions!}) or in a style
(\passthrough{\lstinline!<Setter Property="Transitions">!}). - Combine
with selectors to drive implicit animation from pseudo-classes:

\begin{lstlisting}[language=XML]
<Style Selector="Button:pointerover">
  <Setter Property="Opacity" Value="1"/>
  <Setter Property="RenderTransform">
    <Setter.Value>
      <ScaleTransform ScaleX="1.02" ScaleY="1.02"/>
    </Setter.Value>
  </Setter>
</Style>
\end{lstlisting}

When the property switches, the matching
\passthrough{\lstinline!Transition<T>!} eases between the two values.
Avalonia ships transitions for numeric types, brushes, thickness,
transforms, box shadows, and more
(\passthrough{\lstinline!Animation/Transitions/*.cs!}).

\subsubsection{Animator-driven
transitions}\label{animator-driven-transitions}

\passthrough{\lstinline!AnimatorDrivenTransition!} lets you reuse
keyframe logic as an implicit transition. Add an
\passthrough{\lstinline!Animation!} to
\passthrough{\lstinline!Transition!} by setting
\passthrough{\lstinline!Property!} and plugging a custom
\passthrough{\lstinline!Animator<T>!} if you need non-linear
interpolation or multi-stop blends.

\subsection{4. Page transitions and content
choreography}\label{page-transitions-and-content-choreography}

Navigation surfaces
(\passthrough{\lstinline!TransitioningContentControl!},
\passthrough{\lstinline!Frame!},
\passthrough{\lstinline!NavigationView!}) rely on
\passthrough{\lstinline!IPageTransition!}
(\passthrough{\lstinline!PageSlide.cs!},
\passthrough{\lstinline!CrossFade.cs!}).

\begin{lstlisting}[language=XML]
<TransitioningContentControl Content="{Binding CurrentPage}">
  <TransitioningContentControl.PageTransition>
    <CompositePageTransition>
      <CompositePageTransition.PageTransitions>
        <PageSlide Duration="0:0:0.25" Orientation="Horizontal" Offset="32"/>
        <CrossFade Duration="0:0:0.20"/>
      </CompositePageTransition.PageTransitions>
    </CompositePageTransition>
  </TransitioningContentControl.PageTransition>
</TransitioningContentControl>
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!PageSlide!} shifts content in/out; set
  \passthrough{\lstinline!Orientation!} and
  \passthrough{\lstinline!Offset!} to control direction.
\item
  \passthrough{\lstinline!CrossFade!} fades the outgoing and incoming
  visuals.
\item
  Compose transitions with
  \passthrough{\lstinline!CompositePageTransition!} to layer multiple
  effects.
\item
  Listen to
  \passthrough{\lstinline!TransitioningContentControl.TransitionCompleted!}
  to dispose view models or preload the next page.
\end{itemize}

For navigation stacks, pair page transitions with parameterized
view-model lifetimes so you can cancel transitions on route changes
(\passthrough{\lstinline!TransitioningContentControl.cs!}).

\subsection{5. Reactive animation flows}\label{reactive-animation-flows}

Because each animation pipes through
\passthrough{\lstinline!IObservable<bool>!} internally, you can stitch
motion into reactive pipelines:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!match!} observables allow gating by business
  rules (focus state, validation errors, elapsed time).
\item
  Use
  \passthrough{\lstinline!Animation.Apply(control, clock, observable, onComplete)!}
  to bind to \passthrough{\lstinline!WhenAnyValue!},
  \passthrough{\lstinline!Observable.Interval!}, or custom subjects.
\item
  Compose animations: the returned \passthrough{\lstinline!IDisposable!}
  unsubscribes transitions when your view deactivates (critical for
  \passthrough{\lstinline!Animatable.DisableTransitions!}).
\end{itemize}

Example: flash a text box when validation fails, but only once every
second.

\begin{lstlisting}
var throttle = validationFailures
    .Select(_ => true)
    .Throttle(TimeSpan.FromSeconds(1))
    .StartWith(false);
animation.Apply(textBox, null, throttle, null);
\end{lstlisting}

\subsection{6. Composition vs classic
rendering}\label{composition-vs-classic-rendering}

Avalonia's compositor (\passthrough{\lstinline!Compositor.cs!}) mirrors
the Windows Composition model: a scene graph of
\passthrough{\lstinline!CompositionVisual!} objects runs on a dedicated
thread and talks directly to GPU backends. Advantages:

\begin{itemize}
\tightlist
\item
  Animations stay smooth even when the UI thread is busy.
\item
  Effects (blur, shadows, opacity masks) render in hardware.
\item
  You can build visuals that never appear in the standard logical tree
  (overlays, particles, diagnostics).
\end{itemize}

Getting the compositor:

\begin{lstlisting}
var elementVisual = ElementComposition.GetElementVisual(myControl);
var compositor = elementVisual?.Compositor;
\end{lstlisting}

You can inject custom visuals under an existing control:

\begin{lstlisting}
var compositor = ElementComposition.GetElementVisual(host)!.Compositor;
var root = ElementComposition.GetElementVisual(host) as CompositionContainerVisual;

var sprite = compositor.CreateSolidColorVisual();
sprite.Color = Colors.DeepSkyBlue;
sprite.Size = new Vector2((float)host.Bounds.Width, 4);
sprite.Offset = new Vector3(0, (float)host.Bounds.Height - 4, 0);
root!.Children.Add(sprite);
\end{lstlisting}

When mixing visuals, ensure they come from the same
\passthrough{\lstinline!Compositor!} instance
(\passthrough{\lstinline!ElementCompositionPreview.cs!}).

\subsubsection{Composition target and hit
testing}\label{composition-target-and-hit-testing}

\passthrough{\lstinline!CompositionTarget!}
(\passthrough{\lstinline!CompositionTarget.cs!}) owns the visual tree
that the compositor renders. It handles hit testing, coordinate
transforms, and redraw scheduling. Most apps use the compositor
implicitly via the built-in renderer, but custom hosts (e.g., embedding
Avalonia) can create their own target
(\passthrough{\lstinline!Compositor.CreateCompositionTarget!}).

\subsubsection{Composition brushes, effects, and
materials}\label{composition-brushes-effects-and-materials}

The compositor supports more than simple solids:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!CompositionColorBrush!} and
  \passthrough{\lstinline!CompositionGradientBrush!} mirror familiar
  WPF/UWP concepts and can be animated directly on the render thread.
\item
  \passthrough{\lstinline!CompositionEffectBrush!} applies blend modes
  and image effects defined in
  \passthrough{\lstinline!Composition.Effects!}. Use it to build
  blur/glow pipelines without blocking the UI thread.
\item
  \passthrough{\lstinline!CompositionExperimentalAcrylicVisual!} ships a
  ready-made fluent-style acrylic material. Combine it with backdrop
  animations for frosted surfaces.
\item
  \passthrough{\lstinline!CompositionDrawListVisual!} lets you record
  drawing commands once and replay them efficiently; great for particle
  systems or dashboards.
\end{itemize}

Use \passthrough{\lstinline!Compositor.TryCreateBlurEffect()!}
(platform-provided helpers) to probe support before enabling expensive
effects. Not every backend exposes every effect type; guard features
behind capability checks.

\subsubsection{Backend considerations}\label{backend-considerations}

Composition runs on different engines per platform:

\begin{itemize}
\tightlist
\item
  \textbf{Windows} defaults to Direct3D via Angle; transparency and
  acrylic require desktop composition (check
  \passthrough{\lstinline!DwmIsCompositionEnabled!}).
\item
  \textbf{macOS/iOS} lean on Metal; some blend modes fall back to
  software when Metal is unavailable.
\item
  \textbf{Linux/X11} routes through OpenGL or Vulkan depending on the
  build; verify \passthrough{\lstinline!TransparencyLevel!} and
  composition availability via
  \passthrough{\lstinline!X11Globals.IsCompositionEnabled!}.
\item
  \textbf{Browser} currently renders via WebGL and omits
  composition-only APIs. Always branch your motion layer so WebAssembly
  users still see essential transitions.
\end{itemize}

When features are missing, prefer classic transitions so the experience
remains functional.

\subsection{7. Composition animations and implicit
animations}\label{composition-animations-and-implicit-animations}

Composition animations live in
\passthrough{\lstinline!Avalonia.Rendering.Composition.Animations!}:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!ExpressionAnimation!} lets you drive
  properties with formulas (e.g., parallax, inverse transforms).
\item
  \passthrough{\lstinline!KeyFrameAnimation!} offers high-frequency GPU
  keyframes.
\item
  \passthrough{\lstinline!ImplicitAnimationCollection!} attaches
  animations to property names and fires when the property changes
  (\passthrough{\lstinline!CompositionObject.ImplicitAnimations!}).
\end{itemize}

Example: create a parallax highlight that lags slightly behind its host.

\begin{lstlisting}
var compositor = ElementComposition.GetElementVisual(header)!.Compositor;
var hostVisual = ElementComposition.GetElementVisual(header)!;

var glow = compositor.CreateSolidColorVisual();
glow.Color = Colors.Gold;
glow.Size = new Vector2((float)header.Bounds.Width, 4);
ElementComposition.SetElementChildVisual(header, glow);

var parallax = compositor.CreateExpressionAnimation("Vector3(host.Offset.X * 0.05, host.Offset.Y * 0.05, 0)");
parallax.SetReferenceParameter("host", hostVisual);
parallax.Target = nameof(CompositionVisual.Offset);
glow.StartAnimation(nameof(CompositionVisual.Offset), parallax);
\end{lstlisting}

For property-driven motion, use implicit animations: create an
\passthrough{\lstinline!ImplicitAnimationCollection!}, add an animation
keyed by the composition property name (for example
\passthrough{\lstinline!nameof(CompositionVisual.Opacity)!}), then
assign the collection to
\passthrough{\lstinline!visual.ImplicitAnimations!}. Each time that
property changes, the compositor automatically plays the animation using
\passthrough{\lstinline!this.FinalValue!} inside the expression to
reference the target value
(\passthrough{\lstinline!ImplicitAnimationCollection.cs!}).

\passthrough{\lstinline!StartAnimation!} pushes the animation to the
render thread. Use \passthrough{\lstinline!CompositionAnimationGroup!}
to start multiple animations atomically, and
\passthrough{\lstinline!Compositor.RequestCommitAsync()!} to flush
batched changes before measuring results.

\subsection{8. Performance and
diagnostics}\label{performance-and-diagnostics}

\begin{itemize}
\tightlist
\item
  Prefer animating transforms
  (\passthrough{\lstinline!RenderTransform!},
  \passthrough{\lstinline!Opacity!}) over layout-affecting properties
  (\passthrough{\lstinline!Width!}, \passthrough{\lstinline!Height!}).
  Layout invalidation happens on the UI thread and can stutter.
\item
  Reuse animation instances; parsing keyframes or easings each time
  allocates. Store them as static resources.
\item
  Disable transitions when loading data-heavy lists to avoid dozens of
  simultaneous animations
  (\passthrough{\lstinline!Animatable.DisableTransitions!}). Re-enable
  after the initial bind.
\item
  For composition, batch changes and let
  \passthrough{\lstinline!Compositor.RequestCommitAsync()!} coalesce
  writes instead of spamming per-frame updates.
\item
  Use \passthrough{\lstinline!RendererDiagnostics!} overlays (Chapter
  24) to spot dropped frames and long render passes. Composition visuals
  show up as separate layers, so you can verify they batch correctly.
\item
  Brush transitions fall back to discrete jumps for incompatible brush
  types (\passthrough{\lstinline!BrushTransition.cs!}). Verify gradients
  or image brushes blend the way you expect.
\end{itemize}

\subsection{9. Practice lab: motion
system}\label{practice-lab-motion-system}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Explicit keyframes} -- Build a reusable animation resource
  that pulses a \passthrough{\lstinline!NotificationBanner!}, then start
  it from a view model with \passthrough{\lstinline!RunAsync!}. Add
  cancellation so repeated notifications restart smoothly.
\item
  \textbf{Implicit hover transitions} -- Define a
  \passthrough{\lstinline!Transitions!} block for cards in a dashboard:
  fade elevation shadows, scale the card slightly, and update
  \passthrough{\lstinline!TranslateTransform.Y!}. Drive the transitions
  purely from pseudo-classes.
\item
  \textbf{Navigation choreography} -- Wrap your page host in a
  \passthrough{\lstinline!TransitioningContentControl!}. Combine
  \passthrough{\lstinline!PageSlide!} with
  \passthrough{\lstinline!CrossFade!}, listen for
  \passthrough{\lstinline!TransitionCompleted!}, and cancel transitions
  when the navigation stack pops quickly.
\item
  \textbf{Composition parallax} -- Build a composition child visual that
  lags behind its host using an expression animation, then snap it back
  with an implicit animation when pointer capture is lost.
\item
  \textbf{Diagnostics} -- Toggle renderer diagnostics overlays, capture
  a short trace, and confirm that the animations remain smooth when
  background tasks run.
\end{enumerate}

Document timing curves, easing choices, and any performance issues so
the team can iterate on the experience.

\subsection{10. Troubleshooting \& best
practices}\label{troubleshooting-best-practices-3}

\begin{itemize}
\tightlist
\item
  Animation not firing? Ensure the target property is styled (not
  direct) and the selector matches the control. For composition, check
  the animation \passthrough{\lstinline!Target!} matches the composition
  property name (case-sensitive).
\item
  Looped animations via \passthrough{\lstinline!RunAsync!} throw---drive
  infinite loops with \passthrough{\lstinline!Apply!} or manual
  scheduler instead.
\item
  Transitions chaining oddly? They trigger per property; animating both
  \passthrough{\lstinline!RenderTransform!} and its sub-properties
  simultaneously causes conflicts. Use a single
  \passthrough{\lstinline!TransformOperationsTransition!} to animate
  complex transforms.
\item
  Composition visuals disappear after resizing? Update
  \passthrough{\lstinline!Size!} and \passthrough{\lstinline!Offset!}
  whenever the host control's bounds change, then call
  \passthrough{\lstinline!Compositor.RequestCommitAsync()!} to flush.
\item
  Hot reload spawns multiple composition visuals? Remove the old child
  visual (\passthrough{\lstinline!Children.Remove!}) before adding a new
  one, or cache the sprite in the control instance.
\end{itemize}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-26}

\begin{itemize}
\tightlist
\item
  Animation timeline \& playback:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Animation/Animation.cs!}
\item
  Property transitions:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Animation/Transitions.cs!}
\item
  Page transitions:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Animation/PageSlide.cs!},
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Animation/CrossFade.cs!}
\item
  Composition gateway:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Rendering/Composition/Compositor.cs!},
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Rendering/Composition/CompositionTarget.cs!}
\item
  Composition effects \& materials:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Rendering/Composition/CompositionDrawListVisual.cs!},
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Rendering/Composition/CompositionExperimentalAcrylicVisual.cs!},
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Rendering/Composition/Expressions/ExpressionAnimation.cs!}
\item
  Implicit composition animations:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Rendering/Composition/CompositionObject.cs!}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-27}

\begin{itemize}
\tightlist
\item
  When would you pick a \passthrough{\lstinline!DoubleTransition!} over
  a keyframe animation, and why does that matter for layout cost?
\item
  How do \passthrough{\lstinline!IterationCount!},
  \passthrough{\lstinline!FillMode!}, and
  \passthrough{\lstinline!PlaybackDirection!} interact to determine an
  animation's resting value?
\item
  What are the risks of animating direct properties, and how does
  Avalonia guard against them?
\item
  How do you attach a composition child visual so it uses the same
  compositor as the host control?
\item
  What steps ensure a navigation animation cancels cleanly when the
  route changes mid-flight?
\end{itemize}

What's next - Next: \href{Chapter30.md}{Chapter30}

\newpage

\subsection{30. Markup, XAML compiler, and
extensibility}\label{markup-xaml-compiler-and-extensibility}

Goal - Understand how Avalonia turns \passthrough{\lstinline!.axaml!}
files into IL, resources, and runtime objects. - Choose between compiled
and runtime XAML loading, and configure each for trimming, design-time,
and diagnostics. - Extend the markup language with custom namespaces,
markup extensions, and services without breaking tooling.

Why this matters - XAML is your declarative UI language; mastering its
toolchain keeps builds fast and error messages actionable. - Compiled
XAML (XamlIl) affects startup time, binary size, trimming, and hot
reload behaviour. - Custom markup extensions, namespace maps, and
runtime loaders enable reusable component libraries and advanced
scenarios (dynamic schemas, plug-ins).

Prerequisites - Chapter 02 (project setup) for templates and build
targets. - Chapter 07 (styles and selectors) and Chapter 10 (resources)
for consuming XAML assets. - Chapter 08 (bindings) for compiled binding
references.

\subsection{1. The XAML asset pipeline}\label{the-xaml-asset-pipeline}

When you add \passthrough{\lstinline!.axaml!} files, the SDK-driven
build uses two MSBuild tasks from
\passthrough{\lstinline!Avalonia.Build.Tasks!}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{\passthrough{\lstinline!GenerateAvaloniaResources!}}
  (\passthrough{\lstinline!external/Avalonia/src/Avalonia.Build.Tasks/GenerateAvaloniaResourcesTask.cs!})

  \begin{itemize}
  \tightlist
  \item
    Runs before compilation. Packs every
    \passthrough{\lstinline!AvaloniaResource!} item into the
    \passthrough{\lstinline!*.axaml!} resource bundle
    (\passthrough{\lstinline!avares://!}).
  \item
    Parses each XAML file with
    \passthrough{\lstinline!XamlFileInfo.Parse!}, records
    \passthrough{\lstinline!x:Class!} entries, and writes
    \passthrough{\lstinline"/!AvaloniaResourceXamlInfo"} metadata so
    runtime lookups can map CLR types to resource URIs.
  \item
    Emits MSBuild diagnostics
    (\passthrough{\lstinline!BuildEngine.LogError!}) if it sees invalid
    XML or duplicate \passthrough{\lstinline!x:Class!} declarations.
  \end{itemize}
\item
  \textbf{\passthrough{\lstinline!CompileAvaloniaXaml!}}
  (\passthrough{\lstinline!external/Avalonia/src/Avalonia.Build.Tasks/CompileAvaloniaXamlTask.cs!})

  \begin{itemize}
  \tightlist
  \item
    Executes after C\# compilation. Loads the produced assembly and
    references via Mono.Cecil.
  \item
    Invokes \passthrough{\lstinline!XamlCompilerTaskExecutor.Compile!},
    which runs the XamlIl compiler over each XAML resource, generates
    partial classes, compiled bindings, and lookup stubs under the
    \passthrough{\lstinline!CompiledAvaloniaXaml!} namespace, then
    rewrites the IL in-place.
  \item
    Writes the updated assembly (and optional reference assembly) to
    \passthrough{\lstinline!$(IntermediateOutputPath)!}.
  \end{itemize}
\end{enumerate}

Key metadata: - \passthrough{\lstinline!AvaloniaResource!} item group
entries exist by default in SDK templates; make sure custom build steps
preserve the \passthrough{\lstinline!AvaloniaCompileOutput!} metadata so
incremental builds work. - Set
\passthrough{\lstinline!<VerifyXamlIl>true</VerifyXamlIl>!} to enable IL
verification after compilation; this slows builds slightly but catches
invalid IL earlier. -
\passthrough{\lstinline!<AvaloniaUseCompiledBindingsByDefault>true</AvaloniaUseCompiledBindingsByDefault>!}
opts every binding into compiled bindings unless opted out per markup
(see Chapter 08).

\subsection{2. Inside the XamlIl
compiler}\label{inside-the-xamlil-compiler}

XamlIl is Avalonia's LLVM-style pipeline built on XamlX:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Parsing} (\passthrough{\lstinline!XamlX.Parsers!}) transforms
  XAML into an AST (\passthrough{\lstinline!XamlDocument!}).
\item
  \textbf{Transform passes}
  (\passthrough{\lstinline!Avalonia.Markup.Xaml.XamlIl.CompilerExtensions!})
  rewrite the tree, resolve namespaces
  (\passthrough{\lstinline!XmlnsDefinitionAttribute!}), expand markup
  extensions, and inline templates.
\item
  \textbf{IL emission}
  (\passthrough{\lstinline!XamlCompilerTaskExecutor!}) creates classes
  such as \passthrough{\lstinline"CompiledAvaloniaXaml.!XamlLoader"},
  \passthrough{\lstinline"CompiledAvaloniaXaml.!AvaloniaResources"}, and
  compiled binding factories.
\item
  \textbf{Runtime helpers}
  (\passthrough{\lstinline!external/Avalonia/src/Markup/Avalonia.Markup.Xaml/XamlIl/Runtime/XamlIlRuntimeHelpers.cs!})
  provide services for deferred templates, parent stacks, and resource
  resolution at runtime.
\end{enumerate}

Every \passthrough{\lstinline!.axaml!} file with
\passthrough{\lstinline!x:Class="Namespace.View"!} yields: - A partial
class initializer calling
\passthrough{\lstinline!AvaloniaXamlIlRuntimeXamlLoader!}. This ensures
your code-behind \passthrough{\lstinline!InitializeComponent()!} wires
the compiled tree. - Registration in the resource map so
\passthrough{\lstinline!AvaloniaXamlLoader.Load(new Uri("avares://..."))!}
can find the compiled loader.

If you set
\passthrough{\lstinline!<SkipXamlCompilation>true</SkipXamlCompilation>!},
the compiler bypasses IL generation;
\passthrough{\lstinline!AvaloniaXamlLoader!} then falls back to runtime
parsing for each load (slower and reflection-heavy, but useful during
prototyping).

\subsection{3. Runtime loading and hot
reload}\label{runtime-loading-and-hot-reload}

\passthrough{\lstinline!AvaloniaXamlLoader!}
(\passthrough{\lstinline!external/Avalonia/src/Markup/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs!})
chooses between: - \textbf{Compiled XAML} -- looks for
\passthrough{\lstinline"CompiledAvaloniaXaml.!XamlLoader.TryLoad(string)"}
in the owning assembly and instantiates the pre-generated tree. -
\textbf{Runtime loader} -- if no compiled loader exists or when you
invoke
\passthrough{\lstinline!AvaloniaLocator.CurrentMutable.Register<IRuntimeXamlLoader>(...)!}.
This constructs a \passthrough{\lstinline!RuntimeXamlLoaderDocument!}
with your stream or string, applies
\passthrough{\lstinline!RuntimeXamlLoaderConfiguration!}, and parses
with PortableXaml + XamlIl runtime.

Runtime configuration knobs: -
\passthrough{\lstinline!UseCompiledBindingsByDefault!} toggles compiled
binding behaviour when parsing at runtime. -
\passthrough{\lstinline!DiagnosticHandler!} lets you downgrade/upgrade
runtime warnings or feed them into telemetry. -
\passthrough{\lstinline!DesignMode!} ensures design-time services
(\passthrough{\lstinline!Design.IsDesignMode!}, previews) do not execute
app logic.

Use cases for runtime loading: - Live preview / hot reload (IDE hosts
register their own \passthrough{\lstinline!IRuntimeXamlLoader!}). -
Pluggable modules that ship XAML as data (load from database, theme
packages). - Unit tests where compiling all XAML would slow loops; the
headless test adapters provide a runtime loader.

\subsection{4. Namespaces, schemas, and
lookup}\label{namespaces-schemas-and-lookup}

Avalonia uses \passthrough{\lstinline!XmlnsDefinitionAttribute!}
(\passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Metadata/XmlnsDefinitionAttribute.cs!})
to map XML namespaces to CLR namespaces. Assemblies such as
\passthrough{\lstinline!Avalonia.Markup.Xaml!} declare:

\begin{lstlisting}
[assembly: XmlnsDefinition("https://github.com/avaloniaui", "Avalonia.Markup.Xaml.MarkupExtensions")]
\end{lstlisting}

Guidelines: - Add your own
\passthrough{\lstinline![assembly: XmlnsDefinition]!} for component
libraries so users can
\passthrough{\lstinline!xmlns:controls="clr-namespace:MyApp.Controls"!}
or reuse the default Avalonia URI. - Use
\passthrough{\lstinline![assembly: XmlnsPrefix]!} (also in
\passthrough{\lstinline!Avalonia.Metadata!}) to suggest a prefix for
tooling. - Custom types must be public and reside in an assembly
referenced by the consuming project; otherwise XamlIl will emit a type
resolution error.

\passthrough{\lstinline!IXamlTypeResolver!} is available through the
service provider (\passthrough{\lstinline!Extensions.ResolveType!}).
When you write custom markup extensions, you can resolve types that
respect \passthrough{\lstinline!XmlnsDefinition!} mappings.

\subsection{5. Markup extensions and service
providers}\label{markup-extensions-and-service-providers}

All markup extensions inherit from
\passthrough{\lstinline!Avalonia.Markup.Xaml.MarkupExtension!}
(\passthrough{\lstinline!MarkupExtension.cs!}) and implement
\passthrough{\lstinline!ProvideValue(IServiceProvider serviceProvider)!}.

Avalonia supplies extensions such as
\passthrough{\lstinline!StaticResourceExtension!},
\passthrough{\lstinline!DynamicResourceExtension!},
\passthrough{\lstinline!CompiledBindingExtension!}, and
\passthrough{\lstinline!OnPlatformExtension!}
(\passthrough{\lstinline!external/Avalonia/src/Markup/Avalonia.Markup.Xaml/MarkupExtensions/*!}).
The service provider gives access to: -
\passthrough{\lstinline!INameScope!} for named elements. -
\passthrough{\lstinline!IAvaloniaXamlIlParentStackProvider!} for parent
stacks (\passthrough{\lstinline!Extensions.GetParents<T>()!}). -
\passthrough{\lstinline!IRootObjectProvider!},
\passthrough{\lstinline!IUriContext!}, and design-time services.

Custom markup extension example:

\begin{lstlisting}
public class UppercaseExtension : MarkupExtension
{
    public string? Text { get; set; }

    public override object ProvideValue(IServiceProvider serviceProvider)
    {
        var source = Text ?? serviceProvider.GetDefaultAnchor() as TextBlock;
        return source switch
        {
            string s => s.ToUpperInvariant(),
            TextBlock block => block.Text?.ToUpperInvariant() ?? string.Empty,
            _ => string.Empty
        };
    }
}
\end{lstlisting}

Usage in XAML:

\begin{lstlisting}[language=XML]
<TextBlock Text="{local:Uppercase Text=hello}"/>
\end{lstlisting}

Tips: - Always guard against null \passthrough{\lstinline!Text!}; the
extension may be instantiated at parse time without parameters. - Use
services (e.g.,
\passthrough{\lstinline!serviceProvider.GetService<IServiceProvider>!})
sparingly; they run on every instantiation. - For asynchronous or
deferred value creation, return a delegate implementing
\passthrough{\lstinline!IProvideValueTarget!} or use
\passthrough{\lstinline!XamlIlRuntimeHelpers.DeferredTransformationFactoryV2!}.

\subsection{6. Custom templates, resources, and compiled
bindings}\label{custom-templates-resources-and-compiled-bindings}

XamlIl optimises templates and bindings when you: - Declare controls
with \passthrough{\lstinline!x:Class!} so partial classes can inject
compiled fields (\passthrough{\lstinline!InitializeComponent!}). - Use
\passthrough{\lstinline!x:DataType!} on
\passthrough{\lstinline!DataTemplates!} to enable compiled bindings with
compile-time type checking. - Add
\passthrough{\lstinline!x:CompileBindings="False"!} on a scope if you
need fallback to classic binding for dynamic paths.

The compiler hoists resource dictionaries and template bodies into
factory methods, reducing runtime allocations. When you inspect
generated IL (use \passthrough{\lstinline!ilspy!}), you'll see
\passthrough{\lstinline!new Func<IServiceProvider, object>(...)!}
wrappers for control templates referencing
\passthrough{\lstinline!XamlIlRuntimeHelpers.DeferredTransformationFactoryV2!}.

\subsection{7. Debugging and
diagnostics}\label{debugging-and-diagnostics-1}

\begin{itemize}
\tightlist
\item
  Build errors referencing
  \passthrough{\lstinline!AvaloniaXamlDiagnosticCodes!} include the
  original file path; MSBuild surfaces them in IDEs with line/column.
\item
  Runtime \passthrough{\lstinline!XamlLoadException!}
  (\passthrough{\lstinline!XamlLoadException.cs!}) indicates missing
  compiled loaders or invalid markup; the message suggests ensuring
  \passthrough{\lstinline!x:Class!} and
  \passthrough{\lstinline!AvaloniaResource!} build actions.
\item
  Enable verbose compiler exceptions with
  \passthrough{\lstinline!<AvaloniaXamlIlVerboseOutput>true</AvaloniaXamlIlVerboseOutput>!}
  to print stack traces from the XamlIl pipeline.
\item
  Use \passthrough{\lstinline!avalonia-preview!} (design-time host) to
  spot issues with namespace resolution; the previewer logs originate
  from the runtime loader and respect
  \passthrough{\lstinline!RuntimeXamlLoaderConfiguration.DiagnosticHandler!}.
\end{itemize}

\subsection{8. Authoring workflow
checklist}\label{authoring-workflow-checklist}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Project file} -- confirm
  \passthrough{\lstinline!<UseCompiledBindingsByDefault>!} and
  \passthrough{\lstinline!<VerifyXamlIl>!} match your requirements.
\item
  \textbf{Namespaces} -- add
  \passthrough{\lstinline![assembly: XmlnsDefinition]!} for every
  exported namespace; document the suggested prefix.
\item
  \textbf{Resources} -- place \passthrough{\lstinline!.axaml!} under the
  project root or set \passthrough{\lstinline!Link!} metadata so
  \passthrough{\lstinline!GenerateAvaloniaResources!} records the
  intended resource URI.
\item
  \textbf{InitializeComponent} -- always call it in partial classes;
  otherwise the compiled loader is never invoked.
\item
  \textbf{Testing} -- run unit tests with
  \passthrough{\lstinline!AvaloniaHeadless!} (Chapter 21) to exercise
  runtime loader paths without the full compositor.
\end{enumerate}

\subsection{9. Practice lab: extending the markup
toolchain}\label{practice-lab-extending-the-markup-toolchain}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Inspect build output} -- build your project with
  \passthrough{\lstinline!dotnet build /bl!}. Open the MSBuild log and
  confirm \passthrough{\lstinline!GenerateAvaloniaResources!} and
  \passthrough{\lstinline!CompileAvaloniaXaml!} run with the expected
  inputs.
\item
  \textbf{Add XML namespace mappings} -- create a component library,
  decorate it with
  \passthrough{\lstinline![assembly: XmlnsDefinition("https://schemas.myapp.com/ui", "MyApp.Controls")]!},
  and consume it from a separate app.
\item
  \textbf{Create a markup extension} -- implement
  \passthrough{\lstinline!\{local:Uppercase\}!} as above, inject
  \passthrough{\lstinline!IServiceProvider!} utilities, and write tests
  that call \passthrough{\lstinline!ProvideValue!} with a fake service
  provider.
\item
  \textbf{Toggle compiled bindings} -- set
  \passthrough{\lstinline!<AvaloniaUseCompiledBindingsByDefault>false>!},
  then selectively enable compiled bindings in XAML with
  \passthrough{\lstinline!\{x:CompileBindings\}!} and observe the
  generated IL (via dotnet-monitor or ILSpy).
\item
  \textbf{Runtime loader experiment} -- register a custom
  \passthrough{\lstinline!IRuntimeXamlLoader!} in a test harness to load
  XAML from strings, flip
  \passthrough{\lstinline!UseCompiledBindingsByDefault!}, and log
  diagnostics through
  \passthrough{\lstinline!RuntimeXamlLoaderConfiguration.DiagnosticHandler!}.
\end{enumerate}

\subsection{10. Troubleshooting \& best
practices}\label{troubleshooting-best-practices-4}

\begin{itemize}
\tightlist
\item
  Build succeeds but UI is blank? Check that your
  \passthrough{\lstinline!.axaml!} file still has
  \passthrough{\lstinline!x:Class!} and
  \passthrough{\lstinline!InitializeComponent!} is called. Without it,
  the compiled loader never runs.
\item
  Duplicate \passthrough{\lstinline!x:Class!} errors: two XAML files
  declare the same CLR type; rename one or adjust the namespace. The
  compiler stops on duplicates to avoid ambiguous partial classes.
\item
  \passthrough{\lstinline!XamlTypeResolutionException!}: ensure the
  target assembly references the library exposing the type and that you
  provided an \passthrough{\lstinline!XmlnsDefinition!} mapping.
\item
  Missing resources at runtime (\passthrough{\lstinline!avares://!}
  fails): verify \passthrough{\lstinline!AvaloniaResource!} items exist
  and the resource path matches the URI (case-sensitive on Linux/macOS).
\item
  Large diff after build: compiled XAML rewrites the primary assembly;
  add \passthrough{\lstinline!obj/*.dll!} to
  \passthrough{\lstinline!.gitignore!} and avoid checking in
  intermediate outputs.
\item
  Hot reload issues: if you disable compiled XAML for faster iteration,
  remember to re-enable it before shipping to restore startup
  performance.
\end{itemize}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-27}

\begin{itemize}
\tightlist
\item
  Resource packer:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Build.Tasks/GenerateAvaloniaResourcesTask.cs!}
\item
  XamlIl compiler driver:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Build.Tasks/CompileAvaloniaXamlTask.cs!},
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Build.Tasks/XamlCompilerTaskExecutor.cs!}
\item
  Runtime loader:
  \passthrough{\lstinline!external/Avalonia/src/Markup/Avalonia.Markup.Xaml/AvaloniaXamlLoader.cs!},
  \passthrough{\lstinline!RuntimeXamlLoaderDocument.cs!}
\item
  Runtime helpers:
  \passthrough{\lstinline!external/Avalonia/src/Markup/Avalonia.Markup.Xaml/XamlIl/Runtime/XamlIlRuntimeHelpers.cs!}
\item
  Extensions \& services:
  \passthrough{\lstinline!external/Avalonia/src/Markup/Avalonia.Markup.Xaml/Extensions.cs!}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-28}

\begin{itemize}
\tightlist
\item
  What MSBuild tasks touch \passthrough{\lstinline!.axaml!} files, and
  what metadata do they emit?
\item
  How does XamlIl decide between compiled and runtime loading for a
  given URI?
\item
  Where would you place \passthrough{\lstinline![XmlnsDefinition]!}
  attributes when publishing a control library?
\item
  How do you access the root object or parent stack from inside a markup
  extension?
\item
  What steps enable you to load XAML from a raw string while still using
  compiled bindings?
\end{itemize}

What's next - Next: \href{Chapter31.md}{Chapter31}

\newpage

\subsection{31. Extended control modules and component
gallery}\label{extended-control-modules-and-component-gallery}

Goal - Master specialized Avalonia controls that sit outside the
``common controls'' set: color pickers, pull-to-refresh, notifications,
date/time inputs, split buttons, and more. - Understand how these
modules are organized, what platform behaviours they rely on, and how to
style or automate them. - Build a reusable component gallery to showcase
advanced controls with theming and accessibility baked in.

Why this matters - These controls unlock polished, production-ready
experiences (dashboards, media apps, mobile refresh gestures) without
reinventing UI plumbing. - Many live in separate namespaces such as
\passthrough{\lstinline!Avalonia.Controls.ColorPicker!} or
\passthrough{\lstinline!Avalonia.Controls.Notifications!}; knowing what
ships in the box saves time. - Styling, automation, and platform quirks
differ from core controls---you need dedicated recipes to avoid
regressions.

Prerequisites - Chapter 06 (controls tour) and Chapter 07 (styling) for
basic control usage. - Chapter 09 (input) and Chapter 15 (accessibility)
to reason about interactions. - Chapter 29 (animations) for transitional
polish.

\subsection{1. Survey of extended control
namespaces}\label{survey-of-extended-control-namespaces}

Avalonia groups advanced controls into focused namespaces:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Module
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Namespace
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Highlights
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Color editing & \passthrough{\lstinline!Avalonia.Controls.ColorPicker!}
& \passthrough{\lstinline!ColorPicker!},
\passthrough{\lstinline!ColorView!}, palette data, HSV/RGB components \\
Refresh gestures &
\passthrough{\lstinline!Avalonia.Controls.PullToRefresh!} &
\passthrough{\lstinline!RefreshContainer!},
\passthrough{\lstinline!RefreshVisualizer!},
\passthrough{\lstinline!RefreshInfoProvider!} \\
Notifications &
\passthrough{\lstinline!Avalonia.Controls.Notifications!} &
\passthrough{\lstinline!WindowNotificationManager!},
\passthrough{\lstinline!NotificationCard!},
\passthrough{\lstinline!INotification!} \\
Date \& time &
\passthrough{\lstinline!Avalonia.Controls.DateTimePickers!} &
\passthrough{\lstinline!DatePicker!},
\passthrough{\lstinline!TimePicker!}, presenters, culture support \\
Interactive navigation &
\passthrough{\lstinline!Avalonia.Controls.SplitView!},
\passthrough{\lstinline!Avalonia.Controls.SplitButton!} & Collapsible
panes, hybrid buttons \\
Document text & \passthrough{\lstinline!Avalonia.Controls.Documents!} &
Inline elements (\passthrough{\lstinline!Run!},
\passthrough{\lstinline!Bold!},
\passthrough{\lstinline!InlineUIContainer!}) \\
Misc UX &
\passthrough{\lstinline!Avalonia.Controls.TransitioningContentControl!},
\passthrough{\lstinline!Avalonia.Controls.Notifications.ReversibleStackPanel!},
\passthrough{\lstinline!Avalonia.Controls.Primitives!} helpers & \\
\end{longtable}

Each module ships styles in Fluent/Simple theme dictionaries. Include
the relevant \passthrough{\lstinline!.axaml!} resource dictionaries when
building custom themes.

\subsection{2. ColorPicker and color
workflows}\label{colorpicker-and-color-workflows}

\passthrough{\lstinline!ColorPicker!} extends
\passthrough{\lstinline!ColorView!} by providing a preview area and
flyout editing UI (\passthrough{\lstinline!ColorPicker.cs!}). Key
elements: - Preview content via
\passthrough{\lstinline!Content!}/\passthrough{\lstinline!ContentTemplate!}
(defaults to swatch + ARGB string). - Editing flyout hosts
\passthrough{\lstinline!ColorSpectrum!}, sliders, and palette pickers. -
Palettes live in \passthrough{\lstinline!ColorPalettes/*!}---you can
supply custom palettes or localize names.

Usage snippet:

\begin{lstlisting}[language=XML]
<ColorPicker SelectedColor="{Binding AccentColor, Mode=TwoWay}">
  <ColorPicker.ContentTemplate>
    <DataTemplate>
      <StackPanel Orientation="Horizontal" Spacing="8">
        <Border Width="24" Height="24" Background="{Binding}" CornerRadius="4"/>
        <TextBlock Text="{Binding Converter={StaticResource RgbFormatter}}"/>
      </StackPanel>
    </DataTemplate>
  </ColorPicker.ContentTemplate>
</ColorPicker>
\end{lstlisting}

Tips: - Set \passthrough{\lstinline!ColorPicker.FlyoutPlacement!} (via
template) to adapt for touch vs desktop usage. - Hook
\passthrough{\lstinline!ColorView.ColorChanged!} to react immediately to
slider changes (e.g., update live preview alt text). - Add automation
peers (\passthrough{\lstinline!ColorPickerAutomationPeer!}) if you
expose color selection to screen readers.

\subsection{3. Pull-to-refresh
infrastructure}\label{pull-to-refresh-infrastructure}

\passthrough{\lstinline!RefreshContainer!} wraps scrollable content and
coordinates \passthrough{\lstinline!RefreshVisualizer!} animations
(\passthrough{\lstinline!RefreshContainer.cs!}). Concepts: -
\passthrough{\lstinline!PullDirection!} (top/bottom/left/right) chooses
gesture direction. - \passthrough{\lstinline!RefreshRequested!} event
fires when the user crosses the threshold. Use
\passthrough{\lstinline!RefreshCompletionDeferral!} to await async work.
- \passthrough{\lstinline!RefreshInfoProviderAdapter!} adapts
\passthrough{\lstinline!ScrollViewer!} offsets to the visualizer; you
can replace it for custom panels.

Example:

\begin{lstlisting}[language=XML]
<ptr:RefreshContainer RefreshRequested="OnRefresh">
  <ptr:RefreshContainer.Visualizer>
    <ptr:RefreshVisualizer Orientation="TopToBottom"
                            Content="{DynamicResource PullHintTemplate}"/>
  </ptr:RefreshContainer.Visualizer>
  <ScrollViewer>
    <ItemsControl ItemsSource="{Binding FeedItems}"/>
  </ScrollViewer>
</ptr:RefreshContainer>
\end{lstlisting}

\begin{lstlisting}
private async void OnRefresh(object? sender, RefreshRequestedEventArgs e)
{
    using var deferral = e.GetDeferral();
    await ViewModel.LoadLatestAsync();
}
\end{lstlisting}

Notes: - On desktop, pull gestures require touchpad/touch screen; keep a
manual refresh fallback (button) for mouse-only setups. - Provide
localized feedback via
\passthrough{\lstinline!RefreshVisualizer.StateChanged!} (show ``Release
to refresh'' vs ``Refreshing\ldots{}''). - For virtualization, ensure
the underlying \passthrough{\lstinline!ItemsControl!} defers updates
until after refresh completes so the visualizer can retract smoothly.

\subsection{4. Notifications and toast
UIs}\label{notifications-and-toast-uis}

\passthrough{\lstinline!WindowNotificationManager!} hosts toast-like
notifications overlaying a \passthrough{\lstinline!TopLevel!}
(\passthrough{\lstinline!WindowNotificationManager.cs!}). - Set
\passthrough{\lstinline!Position!} (TopRight, BottomCenter, etc.) and
\passthrough{\lstinline!MaxItems!}. - Call
\passthrough{\lstinline!Show(INotification)!} or
\passthrough{\lstinline!Show(object)!}; the manager wraps content in a
\passthrough{\lstinline!NotificationCard!} with pseudo-classes per
\passthrough{\lstinline!NotificationType!}. - Attach
\passthrough{\lstinline!WindowNotificationManager!} to your main window
(\passthrough{\lstinline!new WindowNotificationManager(this)!} or via
XAML \passthrough{\lstinline!NotificationLayer!}).

Custom template example:

\begin{lstlisting}[language=XML]
<Style Selector="NotificationCard">
  <Setter Property="Template">
    <Setter.Value>
      <ControlTemplate TargetType="NotificationCard">
        <Border Classes="toast" CornerRadius="6" Background="{ThemeResource SurfaceBrush}">
          <StackPanel Orientation="Vertical" Margin="12">
            <TextBlock Text="{Binding Content.Title}" FontWeight="SemiBold"/>
            <TextBlock Text="{Binding Content.Message}" TextWrapping="Wrap"/>
            <Button Content="Dismiss" Classes="subtle"
                    notifications:NotificationCard.CloseOnClick="True"/>
          </StackPanel>
        </Border>
      </ControlTemplate>
    </Setter.Value>
  </Setter>
</Style>
\end{lstlisting}

Considerations: - Provide keyboard dismissal: map
\passthrough{\lstinline!Esc!} to close the newest notification. - For
MVVM, store \passthrough{\lstinline!INotificationManager!} in DI so view
models can raise toasts without referencing the view. - On future
platforms (mobile), swap to platform notification managers when
available.

\subsection{5. DatePicker/TimePicker for
forms}\label{datepickertimepicker-for-forms}

\passthrough{\lstinline!DatePicker!} and
\passthrough{\lstinline!TimePicker!} share presenters and respect
culture-specific formats (\passthrough{\lstinline!DatePicker.cs!},
\passthrough{\lstinline!TimePicker.cs!}). - Properties:
\passthrough{\lstinline!SelectedDate!},
\passthrough{\lstinline!MinYear!}, \passthrough{\lstinline!MaxYear!},
\passthrough{\lstinline!DayVisible!},
\passthrough{\lstinline!MonthFormat!},
\passthrough{\lstinline!YearFormat!}. - Template parts expose text
blocks and a popup presenter; override the template to customize layout.
- Two-way binding uses \passthrough{\lstinline!DateTimeOffset?!} (stay
mindful of time zones).

Validation strategies: - Use \passthrough{\lstinline!Binding!} with data
annotations or manual rules to block invalid ranges. - For forms, show
hint text using pseudo-class \passthrough{\lstinline!:hasnodate!} when
\passthrough{\lstinline!SelectedDate!} is null. - Provide automation
names for the button and popup to assist screen readers.

\subsubsection{Calendar control for
planners}\label{calendar-control-for-planners}

\passthrough{\lstinline!Calendar!} gives you a full month or decade view
without the flyout wrapper. - \passthrough{\lstinline!DisplayMode!}
toggles Month, Year, or Decade views---useful for date pickers embedded
in dashboards. - \passthrough{\lstinline!SelectedDates!} supports
multi-selection when \passthrough{\lstinline!SelectionMode!} is
\passthrough{\lstinline!MultipleRange!}; bind it to a collection for
booking scenarios. - Handle \passthrough{\lstinline!DisplayDateChanged!}
to lazy-load data (appointments, deadlines) as the user browses months.
- Customize the template to expose additional adorners (badges,
tooltips). Keep \passthrough{\lstinline!PART\_DaysPanel!} and related
names intact so the control keeps functioning.

When you need both \passthrough{\lstinline!Calendar!} and
\passthrough{\lstinline!DatePicker!}, reuse the same
\passthrough{\lstinline!CalendarDatePicker!} styles so typography and
spacing stay consistent.

\subsection{6. SplitView and navigation
panes}\label{splitview-and-navigation-panes}

\passthrough{\lstinline!SplitView!} builds side drawers with flexible
display modes (\passthrough{\lstinline!SplitView.cs!}). -
\passthrough{\lstinline!DisplayMode!}: Overlay, Inline, CompactOverlay,
CompactInline. - \passthrough{\lstinline!IsPaneOpen!} toggles state;
handle \passthrough{\lstinline!PaneOpening/PaneClosing!} to intercept. -
\passthrough{\lstinline!UseLightDismissOverlayMode!} enables
auto-dismiss when the user clicks outside.

Usage example:

\begin{lstlisting}[language=XML]
<SplitView IsPaneOpen="{Binding IsMenuOpen, Mode=TwoWay}"
           DisplayMode="CompactOverlay"
           PanePlacement="Left"
           CompactPaneLength="56"
           OpenPaneLength="240">
  <SplitView.Pane>
    <StackPanel>
      <Button Content="Dashboard" Command="{Binding GoHome}"/>
      <Button Content="Reports" Command="{Binding GoReports}"/>
    </StackPanel>
  </SplitView.Pane>
  <Frame Content="{Binding CurrentPage}"/>
</SplitView>
\end{lstlisting}

Tips: - On desktop, use keyboard shortcuts to toggle the pane (e.g.,
assign \passthrough{\lstinline!HotKey!} to
\passthrough{\lstinline!SplitButton!} or global command). - Manage
focus: when the pane opens via keyboard, move focus to the first
focusable element; when closing, restore focus to the toggle. - Combine
with \passthrough{\lstinline!TransitioningContentControl!} (Chapter 29)
for smooth page transitions.

\subsubsection{TransitioningContentControl for dynamic
views}\label{transitioningcontentcontrol-for-dynamic-views}

\passthrough{\lstinline!TransitioningContentControl!} wraps a content
presenter with \passthrough{\lstinline!IPageTransition!} support. -
Assign \passthrough{\lstinline!PageTransition!} in XAML (slide,
cross-fade, custom transitions) to animate view-model swaps. - Hook
\passthrough{\lstinline!TransitionCompleted!} to dispose old view models
or trigger analytics when navigation ends. - Pair with
\passthrough{\lstinline!SplitView!} or navigation shells to animate
content panes independently of the chrome.

For component galleries, use it to showcase before/after states or
responsive layouts without writing manual animation plumbing.

\subsection{7. SplitButton and
ToggleSplitButton}\label{splitbutton-and-togglesplitbutton}

\passthrough{\lstinline!SplitButton!} provides a main action plus a
secondary flyout (\passthrough{\lstinline!SplitButton.cs!}). - Primary
click raises
\passthrough{\lstinline!Click!}/\passthrough{\lstinline!Command!}; the
secondary button shows \passthrough{\lstinline!Flyout!}. -
Pseudo-classes \passthrough{\lstinline!:flyout-open!},
\passthrough{\lstinline!:pressed!}, \passthrough{\lstinline!:checked!}
(for \passthrough{\lstinline!ToggleSplitButton!}). - Works nicely with
\passthrough{\lstinline!MenuFlyout!} for command lists or settings.

Example:

\begin{lstlisting}[language=XML]
<SplitButton Content="Export"
             Command="{Binding ExportAll}">
  <SplitButton.Flyout>
    <MenuFlyout>
      <MenuItem Header="Export CSV" Command="{Binding ExportCsv}"/>
      <MenuItem Header="Export JSON" Command="{Binding ExportJson}"/>
    </MenuFlyout>
  </SplitButton.Flyout>
</SplitButton>
\end{lstlisting}

Ensure \passthrough{\lstinline!Command.CanExecute!} updates by binding
to view model state; \passthrough{\lstinline!SplitButton!} listens for
\passthrough{\lstinline!CanExecuteChanged!} and toggles
\passthrough{\lstinline!IsEnabled!} accordingly.

\subsection{8. Notifications, documents, and media
surfaces}\label{notifications-documents-and-media-surfaces}

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!Inline!}, \passthrough{\lstinline!Run!},
  \passthrough{\lstinline!Span!}, and
  \passthrough{\lstinline!InlineUIContainer!} in
  \passthrough{\lstinline!Avalonia.Controls.Documents!} let you build
  rich text with embedded controls (useful for notifications or chat
  bubbles).
\item
  Use \passthrough{\lstinline!InlineUIContainer!} sparingly; it affects
  layout performance.
\item
  Combine \passthrough{\lstinline!NotificationCard!} with document
  inlines to highlight formatted content (bold text, links).
\end{itemize}

\passthrough{\lstinline!MediaPlayerElement!} (available when you
reference the media package) embeds audio/video playback with transport
controls. - Bind \passthrough{\lstinline!Source!} to URIs or streams;
the element manages decoding via platform backends
(\passthrough{\lstinline!Windows!} uses Angle/DX,
\passthrough{\lstinline!Linux!} goes through FFmpeg when available). -
Toggle \passthrough{\lstinline!AreTransportControlsEnabled!} to show
built-in play/pause UI; for custom chrome, bind to
\passthrough{\lstinline!MediaPlayer!} and drive commands yourself. -
Handle
\passthrough{\lstinline!MediaOpened!}/\passthrough{\lstinline!MediaEnded!}
to chain playlists or update state. - On platforms without native
codecs, surface fallbacks (download prompts, external players) so the UI
stays predictable.

\subsection{9. Building a component
gallery}\label{building-a-component-gallery}

Create a \passthrough{\lstinline!ComponentGalleryWindow!} that showcases
each control with explanations and theme toggles:

\begin{lstlisting}[language=XML]
<TabControl>
  <TabItem Header="Color">
    <StackPanel Spacing="16">
      <TextBlock Text="ColorPicker" FontWeight="SemiBold"/>
      <ColorPicker SelectedColor="{Binding ThemeColor}"/>
    </StackPanel>
  </TabItem>
  <TabItem Header="Refresh">
    <ptr:RefreshContainer RefreshRequested="OnRefreshRequested">
      <ListBox ItemsSource="{Binding Items}"/>
    </ptr:RefreshContainer>
  </TabItem>
  <TabItem Header="Notifications">
    <StackPanel>
      <Button Content="Show success" Click="OnShowSuccess"/>
      <TextBlock Text="Notifications appear top-right"/>
    </StackPanel>
  </TabItem>
</TabControl>
\end{lstlisting}

Best practices: - Offer theme toggle (Fluent light/dark) to reveal
styling differences. - Surface accessibility guidance (keyboard
shortcuts, screen reader notes) alongside each sample. - Provide code
snippets via \passthrough{\lstinline!TextBlock!} or copy buttons so
teammates can reuse patterns.

\subsection{10. Practice lab: responsibility
matrix}\label{practice-lab-responsibility-matrix}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Color workflows} -- Customize
  \passthrough{\lstinline!ColorPicker!} palettes, bind to view model
  state, and expose automation peers for UI tests.
\item
  \textbf{Mobile refresh} -- Implement
  \passthrough{\lstinline!RefreshContainer!} in a list, test on
  touch-enabled hardware, and add fallback commands for desktop.
\item
  \textbf{Toast scenarios} -- Build a notification service that queues
  messages and exposes dismissal commands, then craft styles for
  different severities.
\item
  \textbf{Dashboard shell} -- Combine
  \passthrough{\lstinline!SplitView!},
  \passthrough{\lstinline!SplitButton!}, and
  \passthrough{\lstinline!TransitioningContentControl!} to create a
  responsive navigation shell with keyboard and pointer parity.
\item
  \textbf{Component gallery} -- Document each control with design notes,
  theming tweaks, and automation IDs; integrate into project
  documentation.
\end{enumerate}

\subsection{Troubleshooting \& best
practices}\label{troubleshooting-best-practices-5}

\begin{itemize}
\tightlist
\item
  Many controls rely on template parts
  (\passthrough{\lstinline!PART\_*!}). When restyling, preserve these
  names or update code-behind references.
\item
  Notification overlays run on the UI thread; throttle or batch updates
  to avoid flooding \passthrough{\lstinline!WindowNotificationManager!}
  with dozens of toasts.
\item
  \passthrough{\lstinline!RefreshContainer!} needs a
  \passthrough{\lstinline!ScrollViewer!} or adapter implementing
  \passthrough{\lstinline!IRefreshInfoProvider!}; custom panels must
  adapt to supply offset data.
\item
  Date/time pickers use \passthrough{\lstinline!DateTimeOffset!}. When
  binding to \passthrough{\lstinline!DateTime!}, convert carefully to
  retain time zones.
\item
  SplitView on compact widths: watch out for layout loops if your pane
  content uses \passthrough{\lstinline!HorizontalAlignment.Stretch!};
  consider fixed width.
\end{itemize}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-28}

\begin{itemize}
\tightlist
\item
  Color picker foundation:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls.ColorPicker/ColorPicker/ColorPicker.cs!}
\item
  Pull-to-refresh:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/PullToRefresh/RefreshContainer.cs!}
\item
  Notifications:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Notifications/WindowNotificationManager.cs!},
  \passthrough{\lstinline!NotificationCard.cs!}
\item
  Calendar \& date/time:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Calendar/Calendar.cs!},
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/DateTimePickers/DatePicker.cs!},
  \passthrough{\lstinline!TimePicker.cs!}
\item
  Split view/button:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/SplitView/SplitView.cs!},
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/SplitButton/SplitButton.cs!}
\item
  Documents:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Documents/*!}
\item
  Transitions host:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/TransitioningContentControl.cs!}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-29}

\begin{itemize}
\tightlist
\item
  Which namespace hosts \passthrough{\lstinline!RefreshContainer!}, and
  why does it need a \passthrough{\lstinline!RefreshVisualizer!}?
\item
  How does \passthrough{\lstinline!WindowNotificationManager!} limit
  concurrent notifications and close them programmatically?
\item
  What steps keep \passthrough{\lstinline!DatePicker!} in sync with
  \passthrough{\lstinline!DateTime!} view-model properties?
\item
  How do you style \passthrough{\lstinline!SplitView!} for light-dismiss
  overlay vs inline mode?
\item
  What belongs in a component gallery to help teammates reuse advanced
  controls?
\end{itemize}

What's next - Next: \href{Chapter32.md}{Chapter32}

\newpage

\subsection{32. Platform services, embedding, and native
interop}\label{platform-services-embedding-and-native-interop}

Goal - Integrate Avalonia with native hosts: Windows, macOS, X11,
browsers, mobile shells, and custom embedding scenarios. - Leverage
\passthrough{\lstinline!NativeControlHost!},
\passthrough{\lstinline!EmbeddableControlRoot!}, and platform services
(\passthrough{\lstinline!IWindowingPlatform!}, tray icons, system
dialogs) to build hybrid applications. - Understand remote protocols and
thin-client options to drive Avalonia content from external processes.

Why this matters - Many teams embed Avalonia inside existing apps
(Win32, WPF, WinForms), or host native controls inside Avalonia shells.
- Platform services expose tray icons, system navigation managers,
storage providers, and more. Using them correctly keeps UX idiomatic per
OS. - Remote rendering and embedding power tooling (previewers,
diagnostics, multi-process architectures).

Prerequisites - Chapter 12 (windows \& lifetimes) for top-level
concepts. - Chapter 18--20 (platform targets) for backend overviews. -
Chapter 32 builds on Chapter 29 (animations/composition) when
synchronizing native surfaces.

\subsection{1. Platform abstractions
overview}\label{platform-abstractions-overview}

Avalonia abstracts windowing via interfaces in
\passthrough{\lstinline!Avalonia.Controls.Platform!} and
\passthrough{\lstinline!Avalonia.Platform!}:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}
  >{\raggedright\arraybackslash}p{(\linewidth - 4\tabcolsep) * \real{0.3333}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Interface
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Location
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Purpose
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!IWindowingPlatform!} &
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Platform/IWindowingPlatform.cs!}
& Creates windows, embeddable top levels, tray icons \\
\passthrough{\lstinline!INativeControlHostImpl!} & platform backends
(Win32, macOS, iOS, Browser) & Hosts native HWND/NSView/UIViews inside
Avalonia (\passthrough{\lstinline!NativeControlHost!}) \\
\passthrough{\lstinline!ITrayIconImpl!} & backend-specific & Implements
tray icons (\passthrough{\lstinline!PlatformManager.CreateTrayIcon!}) \\
\passthrough{\lstinline!IPlatformStorageProvider!},
\passthrough{\lstinline!ILauncher!} &
\passthrough{\lstinline!Avalonia.Platform.Storage!} & File pickers,
launchers across platforms \\
\passthrough{\lstinline!IApplicationPlatformEvents!} &
\passthrough{\lstinline!Avalonia.Controls.Platform!} & System-level
events (activation, protocol handlers) \\
\end{longtable}

\passthrough{\lstinline!PlatformManager!} coordinates these services and
surfaces high-level helpers (tray icons, dialogs). Check
\passthrough{\lstinline!TopLevel.PlatformImpl!} to access
backend-specific features.

\subsection{2. Hosting native controls inside
Avalonia}\label{hosting-native-controls-inside-avalonia}

\passthrough{\lstinline!NativeControlHost!}
(\passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/NativeControlHost.cs!})
lets you wrap native views:

\begin{itemize}
\tightlist
\item
  Override
  \passthrough{\lstinline!CreateNativeControlCore(IPlatformHandle parent)!}
  to instantiate native widgets (Win32 HWND, NSView, Android View).
\item
  Avalonia attaches/detaches the native control when the host
  enters/leaves the visual tree, using
  \passthrough{\lstinline!INativeControlHostImpl!} from the current
  \passthrough{\lstinline!TopLevel!}.
\item
  \passthrough{\lstinline!TryUpdateNativeControlPosition!} translates
  Avalonia bounds into platform coordinates and resizes the native
  child.
\end{itemize}

Example (Win32 HWND):

\begin{lstlisting}
public class Win32WebViewHost : NativeControlHost
{
    protected override IPlatformHandle CreateNativeControlCore(IPlatformHandle parent)
    {
        var hwnd = Win32Interop.CreateWebView(parent.Handle);
        return new PlatformHandle(hwnd, "HWND");
    }

    protected override void DestroyNativeControlCore(IPlatformHandle control)
    {
        Win32Interop.DestroyWindow(control.Handle);
    }
}
\end{lstlisting}

Guidelines: - Ensure thread affinity: most native controls expect
creation/destruction on the UI thread. - Handle DPI changes by listening
to size changes (\passthrough{\lstinline!BoundsProperty!}) and calling
the platform API to adjust scaling. - Use
\passthrough{\lstinline!NativeControlHandleChanged!} for interop with
additional APIs (e.g., hooking message loops). - For accessibility,
expose appropriate semantics; Avalonia's
\passthrough{\lstinline!NativeControlHostAutomationPeer!} helps but you
may need custom peers.

\subsection{3. Embedding Avalonia inside native
hosts}\label{embedding-avalonia-inside-native-hosts}

\passthrough{\lstinline!EmbeddableControlRoot!}
(\passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Embedding/EmbeddableControlRoot.cs!})
wraps a \passthrough{\lstinline!TopLevel!} that can live in non-Avalonia
environments:

\begin{itemize}
\tightlist
\item
  Construct with an \passthrough{\lstinline!ITopLevelImpl!} supplied by
  platform-specific hosts
  (\passthrough{\lstinline!WinFormsAvaloniaControlHost!},
  \passthrough{\lstinline!X11 XEmbed!},
  \passthrough{\lstinline!Android AvaloniaView!},
  \passthrough{\lstinline!iOS AvaloniaView!}).
\item
  Call \passthrough{\lstinline!Prepare()!} to initialize the logical
  tree and run the initial layout pass.
\item
  Use
  \passthrough{\lstinline!StartRendering!}/\passthrough{\lstinline!StopRendering!}
  to control drawing when the host window shows/hides.
\item
  \passthrough{\lstinline!EnforceClientSize!} ensures Avalonia matches
  the host surface size; disable for custom measure logic.
\end{itemize}

Examples: - \textbf{WinForms}:
\passthrough{\lstinline!WinFormsAvaloniaControlHost!} hosts
\passthrough{\lstinline!EmbeddableControlRoot!} inside Windows Forms.
Remember to call \passthrough{\lstinline!InitAvalonia()!} before
creating controls. - \textbf{X11 embedding}:
\passthrough{\lstinline!XEmbedPlug!} uses
\passthrough{\lstinline!EmbeddableControlRoot!} to embed into foreign
X11 windows (tooling, remote previews). - \textbf{Mobile views}:
\passthrough{\lstinline!Avalonia.Android.AvaloniaView!} and
\passthrough{\lstinline!Avalonia.iOS.AvaloniaView!} wrap
\passthrough{\lstinline!EmbeddableControlRoot!} to integrate with native
UI stacks.

Interop tips: - Manage lifecycle carefully: dispose the root when the
host closes to release GPU/threads. - Expose the
\passthrough{\lstinline!Content!} property to your native layer for
dynamic view injection. - Bridge focus and input: e.g., WinForms host
sets \passthrough{\lstinline!TabStop!} and forwards focus events to the
Avalonia root.

\subsubsection{MicroCom bridges for Windows
interop}\label{microcom-bridges-for-windows-interop}

Avalonia relies on
\href{https://github.com/AvaloniaUI/MicroCom}{MicroCom} to generate
COM-compatible wrappers. When embedding on Windows (drag/drop, menus,
Win32 interop): - Use
\passthrough{\lstinline!Avalonia.MicroCom.CallbackBase!} as the base for
custom COM callbacks; it handles reference counting and error reporting.
- \passthrough{\lstinline!OleDropTarget!} and native menu exporters in
\passthrough{\lstinline!Avalonia.Win32!} demonstrate wrapping Win32
interfaces without hand-written COM glue. - When exposing Avalonia
controls to native hosts, keep MicroCom proxies alive for the lifetime
of the host window to avoid releasing underlying HWND/IDispatch too
early.

You rarely need to touch MicroCom directly, but understanding it helps
when diagnosing drag/drop or accessibility issues on Windows.

\subsection{4. Remote rendering and
previews}\label{remote-rendering-and-previews}

Avalonia's remote protocol
(\passthrough{\lstinline!external/Avalonia/src/Avalonia.Remote.Protocol!})
powers the XAML previewer and custom remoting scenarios.

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!RemoteServer!}
  (\passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Remote/RemoteServer.cs!})
  wraps an \passthrough{\lstinline!EmbeddableControlRoot!} backed by
  \passthrough{\lstinline!RemoteServerTopLevelImpl!}. It responds to
  transport messages (layout updates, pointer events) from a remote
  client.
\item
  Transports: BSON over TCP
  (\passthrough{\lstinline!BsonTcpTransport!}), streams
  (\passthrough{\lstinline!BsonStreamTransport!}), or custom
  \passthrough{\lstinline!IAvaloniaRemoteTransportConnection!}
  implementations.
\item
  Use \passthrough{\lstinline!Avalonia.DesignerSupport!} components to
  spin up preview hosts; they bind to
  \passthrough{\lstinline!IWindowingPlatform!} stubs suitable for
  design-time.
\item
  On the client side, \passthrough{\lstinline!RemoteWidget!} hosts the
  mirrored visual tree. It pairs with
  \passthrough{\lstinline!RemoteServer!} to marshal input/output.
\item
  Implement a custom \passthrough{\lstinline!ITransport!} when you need
  alternate channels (named pipes, WebSockets). The protocol is
  message-based, so you can plug in encryption or compression as needed.
\end{itemize}

Potential use cases: - Live XAML preview in IDEs (already shipped). -
Remote control panels (render UI in a service, interact via TCP). - UI
testing farms capturing frames via remote composition.

Security note: remote transports expose the UI tree---protect endpoints
if you ship this beyond trusted tooling.

\subsection{5. Tray icons, dialogs, and platform
services}\label{tray-icons-dialogs-and-platform-services}

\passthrough{\lstinline!IWindowingPlatform.CreateTrayIcon()!} supplies
backend-specific tray icon implementations. Use
\passthrough{\lstinline!PlatformManager.CreateTrayIcon()!} to
instantiate one:

\begin{lstlisting}
var trayIcon = PlatformManager.CreateTrayIcon();
trayIcon.Icon = new WindowIcon("avares://Assets/tray.ico");
trayIcon.ToolTipText = "My App";
trayIcon.Menu = new NativeMenu
{
    Items =
    {
        new NativeMenuItem("Show", (sender, args) => mainWindow.Show()),
        new NativeMenuItem("Exit", (sender, args) => app.Shutdown())
    }
};
trayIcon.IsVisible = true;
\end{lstlisting}

Other services: - \textbf{File pickers/storage}:
\passthrough{\lstinline!StorageProvider!} (Chapter 16) uses platform
storage APIs; embed scenarios must supply providers in DI. -
\textbf{System dialogs}: \passthrough{\lstinline!SystemDialog!} classes
fallback to managed dialogs when native APIs are unavailable. -
\textbf{Application platform events}:
\passthrough{\lstinline!IApplicationPlatformEvents!} handles activation
(protocol URLs, file associations). Register via
\passthrough{\lstinline!AppBuilder!} extensions. - \textbf{System
navigation}: On mobile,
\passthrough{\lstinline!SystemNavigationManager!} handles back-button
events; ensure \passthrough{\lstinline!UsePlatformDetect!} registers the
appropriate lifetime. - \textbf{Window chrome}:
\passthrough{\lstinline!Window!} exposes
\passthrough{\lstinline!SystemDecorations!},
\passthrough{\lstinline!ExtendClientAreaToDecorationsHint!},
\passthrough{\lstinline!WindowTransparencyLevel!}, and the
\passthrough{\lstinline!Chrome.WindowChrome!} helpers so you can blend
custom title bars with OS hit testing. Always provide resize grips and
fall back to system chrome when composition is disabled.

\subsection{6. Browser, Android, iOS
views}\label{browser-android-ios-views}

\begin{itemize}
\tightlist
\item
  \textbf{Browser}:
  \passthrough{\lstinline!Avalonia.Browser.AvaloniaView!} hosts
  \passthrough{\lstinline!EmbeddableControlRoot!} atop WebAssembly;
  \passthrough{\lstinline!NativeControlHost!} implementations for the
  browser route to JS interop.
\item
  \textbf{Android/iOS}: \passthrough{\lstinline!AvaloniaView!} provides
  native controls (Android View, iOS UIView) embedding Avalonia UI. Use
  \passthrough{\lstinline!SingleViewLifetime!} to tie app lifetimes to
  host platforms.
\item
  Expose Avalonia content to native navigation stacks, but run
  Avalonia's message loop
  (\passthrough{\lstinline!AppBuilder.AndroidLifecycleEvents!} /
  \passthrough{\lstinline!AppBuilder.iOS!}).
\end{itemize}

\subsection{7. Offscreen rendering and
interoperability}\label{offscreen-rendering-and-interoperability}

\passthrough{\lstinline!OffscreenTopLevel!}
(\passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Embedding/Offscreen/OffscreenTopLevel.cs!})
allows rendering to a framebuffer without showing a window---useful for:
- Server-side rendering (generate bitmaps for PDFs, emails). - Unit
tests verifying layout/visual output. - Thumbnail generation for design
tools.

Pair with \passthrough{\lstinline!RenderTargetBitmap!} to save results.

\subsection{8. Practice lab: hybrid UI
playbook}\label{practice-lab-hybrid-ui-playbook}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Embed native control} -- Host a Win32 WebView or
  platform-specific map view inside Avalonia using
  \passthrough{\lstinline!NativeControlHost!}. Ensure resize and DPI
  updates work.
\item
  \textbf{Avalonia-in-native} -- Create a WinForms or WPF shell
  embedding \passthrough{\lstinline!EmbeddableControlRoot!}. Swap
  Avalonia content dynamically and synchronize focus/keyboard.
\item
  \textbf{Tray integration} -- Add a tray icon that controls window
  visibility and displays context menus. Test on Windows and Linux
  (AppIndicator fallback).
\item
  \textbf{Remote preview} -- Spin up
  \passthrough{\lstinline!RemoteServer!} with a TCP transport and
  connect using the Avalonia preview client to render a view remotely.
\item
  \textbf{Offscreen rendering} -- Render a control to bitmap using
  \passthrough{\lstinline!OffscreenTopLevel!} +
  \passthrough{\lstinline!RenderTargetBitmap!} and compare results in a
  unit test.
\end{enumerate}

Document interop boundaries (threading, disposal, event forwarding) for
your team.

\subsection{Troubleshooting \& best
practices}\label{troubleshooting-best-practices-6}

\begin{itemize}
\tightlist
\item
  Always dispose hosts (\passthrough{\lstinline!EmbeddableControlRoot!},
  tray icons, remote transports) to release native resources.
\item
  Ensure Avalonia is initialized
  (\passthrough{\lstinline!BuildAvaloniaApp().SetupWithoutStarting()!})
  before embedding in native shells.
\item
  Watch for DPI mismatches: use
  \passthrough{\lstinline!TopLevel.PlatformImpl?.TryGetFeature<IDpiProvider>()!}
  or subscribe to scaling changes.
\item
  For \passthrough{\lstinline!NativeControlHost!}, guard against parent
  changes; detach native handles during visual tree transitions to avoid
  orphaned HWNDs.
\item
  Remote transports may drop messages under heavy load---implement
  reconnection logic and validation.
\item
  On macOS, tray icons require the app to stay alive (use
  \passthrough{\lstinline!NSApplication.ActivateIgnoringOtherApps!} when
  needed).
\end{itemize}

\subsection{Look under the hood (source
bookmarks)}\label{look-under-the-hood-source-bookmarks-29}

\begin{itemize}
\tightlist
\item
  Native hosting:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/NativeControlHost.cs!}
\item
  Embedding root:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Embedding/EmbeddableControlRoot.cs!}
\item
  Platform manager \& services:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Platform/PlatformManager.cs!}
\item
  Remote protocol:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Remote/RemoteServer.cs!},
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Remote/RemoteWidget.cs!},
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Remote.Protocol/*!}
\item
  Win32 platform:
  \passthrough{\lstinline!external/Avalonia/src/Windows/Avalonia.Win32/Win32Platform.cs!}
\item
  Browser/Android/iOS hosts:
  \passthrough{\lstinline!external/Avalonia/src/Browser/Avalonia.Browser/AvaloniaView.cs!},
  \passthrough{\lstinline!external/Avalonia/src/Android/Avalonia.Android/AvaloniaView.cs!},
  \passthrough{\lstinline!external/Avalonia/src/iOS/Avalonia.iOS/AvaloniaView.cs!}
\item
  MicroCom interop:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.MicroCom/CallbackBase.cs!},
  \passthrough{\lstinline!external/Avalonia/src/Windows/Avalonia.Win32/OleDropTarget.cs!}
\item
  Window chrome helpers:
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Chrome/WindowChrome.cs!},
  \passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Window.cs!}
\end{itemize}

\subsection{Check yourself}\label{check-yourself-30}

\begin{itemize}
\tightlist
\item
  How does \passthrough{\lstinline!NativeControlHost!} coordinate
  \passthrough{\lstinline!INativeControlHostImpl!} and what events
  trigger repositioning?
\item
  What steps are required to embed Avalonia inside an existing
  WinForms/WPF app?
\item
  Which services does \passthrough{\lstinline!IWindowingPlatform!}
  expose, and how do you use them to create tray icons or embeddable top
  levels?
\item
  How would you stream Avalonia UI to a remote client for live previews?
\item
  When rendering offscreen, which classes help you create an isolated
  top level and capture the framebuffer?
\end{itemize}

What's next - Next: \href{Chapter33.md}{Chapter33}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part VII — Code-first UI without XAML friction}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part VII — Code-first UI without XAML friction}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{33. Code-only startup and architecture
blueprint}\label{code-only-startup-and-architecture-blueprint}

Goal - Bootstrap Avalonia apps entirely from C\# so you can skip XAML
without losing features. - Structure resources, styles, and themes in
code-first projects that still feel modular. - Integrate dependency
injection, services, and lifetimes using the same primitives Avalonia's
XAML templates rely on internally.

Why this matters - Many teams prefer a single-language stack (pure C\#)
for greater refactorability, dynamic UI, or source generator workflows.
- Understanding the startup pipeline
(\passthrough{\lstinline!AppBuilder!}, lifetimes,
\passthrough{\lstinline!Application.RegisterServices!}) lets you shape
architecture to match modular backends or plug-ins. - Code-first
projects must explicitly wire themes, resources, and styles---knowing
the underlying APIs prevents surprises when copying snippets from
XAML-centric samples.

Prerequisites - Chapter 4 (startup and lifetimes) for the
\passthrough{\lstinline!AppBuilder!} pipeline. - Chapter 7 (styling) to
recognize how selectors, themes, and resources work. - Chapter 11 (MVVM)
for structuring view-models and locator patterns that code-first
projects often lean on.

\subsection{\texorpdfstring{1. Start from \texttt{Program.cs}:
configuring the builder
yourself}{1. Start from Program.cs: configuring the builder yourself}}\label{start-from-program.cs-configuring-the-builder-yourself}

Avalonia templates scaffold XAML, but the real work happens in
\passthrough{\lstinline!Program.BuildAvaloniaApp()!} (see
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Templates/!}).
Code-first apps use the same \passthrough{\lstinline!AppBuilder<TApp>!}
API.

\begin{lstlisting}
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.ReactiveUI; // optional: add once for ReactiveUI-centric apps

internal static class Program
{
    [STAThread]
    public static void Main(string[] args)
    {
        BuildAvaloniaApp()
            .StartWithClassicDesktopLifetime(args);
    }

    private static AppBuilder BuildAvaloniaApp()
        => AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .LogToTrace()
            .With(new Win32PlatformOptions
            {
                CompositionMode = new[] { Win32CompositionMode.WinUIComposition } // example tweak
            })
            .With(new X11PlatformOptions { EnableIme = true })
            .With(new AvaloniaNativePlatformOptions { UseDeferredRendering = true })
            .UseSkia();
}
\end{lstlisting}

Key points from \passthrough{\lstinline!AppBuilder.cs!}: -
\passthrough{\lstinline!Configure<App>()!} wires Avalonia's service
locator (\passthrough{\lstinline!AvaloniaLocator!}) with the type
parameter you pass. - \passthrough{\lstinline!UsePlatformDetect()!}
resolves the proper backend at runtime. Replace it with
\passthrough{\lstinline!UseWin32()!},
\passthrough{\lstinline!UseAvaloniaNative()!}, etc., to force a backend
for tests. - \passthrough{\lstinline!.UseReactiveUI()!} (from
\passthrough{\lstinline!Avalonia.ReactiveUI/AppBuilderExtensions.cs!})
registers ReactiveUI's scheduler, command binding, and view locator
glue---call it in code-first projects that rely on
\passthrough{\lstinline!ReactiveCommand!}. -
\passthrough{\lstinline!.With<TOptions>()!} registers backend-specific
option objects. Because you're not using
\passthrough{\lstinline!App.axaml!}, code is the only place to set them.

Remember you can split configuration across methods for clarity:

\begin{lstlisting}
private static AppBuilder ConfigurePlatforms(AppBuilder builder)
    => builder.UsePlatformDetect()
              .With(new Win32PlatformOptions { UseWgl = false })
              .With(new AvaloniaNativePlatformOptions { UseGpu = true });
\end{lstlisting}

Chaining explicit helper methods keeps
\passthrough{\lstinline!BuildAvaloniaApp!} readable while preserving
fluent semantics.

\subsection{\texorpdfstring{2. Crafting an \texttt{Application} subclass
without
XAML}{2. Crafting an Application subclass without XAML}}\label{crafting-an-application-subclass-without-xaml}

\passthrough{\lstinline!Application!} lives in
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Application.cs!}.
The default XAML template overrides
\passthrough{\lstinline!OnFrameworkInitializationCompleted()!} after
loading XAML. In code-first scenarios you:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Override \passthrough{\lstinline!Initialize()!} to register
  styles/resources explicitly.
\item
  (Optionally) override \passthrough{\lstinline!RegisterServices()!} to
  set up dependency injection.
\item
  Override
  \passthrough{\lstinline!OnFrameworkInitializationCompleted()!} to set
  the root visual for the selected lifetime.
\end{enumerate}

\begin{lstlisting}
using Avalonia;
using Avalonia.Controls.ApplicationLifetimes;
using Avalonia.Markup.Xaml.Styling;
using Avalonia.Themes.Fluent;

public sealed class App : Application
{
    public override void Initialize()
    {
        Styles.Clear();

        Styles.Add(new FluentTheme
        {
            Mode = FluentThemeMode.Dark
        });

        Styles.Add(new StyleInclude(new Uri("avares://App/Styles"))
        {
            Source = new Uri("avares://App/Styles/Controls.axaml") // optional: you can still load XAML fragments
        });

        Styles.Add(CreateButtonStyle());

        Resources.MergedDictionaries.Add(CreateAppResources());
    }

    protected override void RegisterServices()
    {
        // called before Initialize(). Great spot for DI container wiring.
        AvaloniaLocator.CurrentMutable.Bind<IMyService>().ToSingleton<MyService>();
    }

    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)
        {
            desktop.MainWindow = new MainWindow
            {
                DataContext = new MainWindowViewModel()
            };
        }
        else if (ApplicationLifetime is ISingleViewApplicationLifetime singleView)
        {
            singleView.MainView = new HomeView
            {
                DataContext = new HomeViewModel()
            };
        }

        base.OnFrameworkInitializationCompleted();
    }

    private static Style CreateButtonStyle()
        => new(x => x.OfType<Button>())
        {
            Setters =
            {
                new Setter(Button.CornerRadiusProperty, new CornerRadius(6)),
                new Setter(Button.PaddingProperty, new Thickness(16, 8)),
                new Setter(Button.ClassesProperty, Classes.Parse("accent"))
            }
        };

    private static ResourceDictionary CreateAppResources()
    {
        return new ResourceDictionary
        {
            ["AccentBrush"] = new SolidColorBrush(Color.Parse("#FF4F8EF7")),
            ["AccentForegroundBrush"] = Brushes.White,
            ["BorderRadiusSmall"] = new CornerRadius(4)
        };
    }
}
\end{lstlisting}

Notes from source: - \passthrough{\lstinline!Styles!} is an
\passthrough{\lstinline!IList<IStyle>!} exposed by
\passthrough{\lstinline!Application!}. Clearing it ensures you start
from a blank slate (no default theme). Add
\passthrough{\lstinline!FluentTheme!} or your own style tree. -
\passthrough{\lstinline!StyleInclude!} can still ingest axaml
fragments---code-first doesn't forbid XAML, it just avoids
\passthrough{\lstinline!Application.LoadComponent!}. -
\passthrough{\lstinline!RegisterServices()!} is invoked early in
\passthrough{\lstinline!AppBuilderBase<TApp>.Setup()!} before the app is
instantiated. It's designed for code-first registration patterns. -
Always call
\passthrough{\lstinline!base.OnFrameworkInitializationCompleted()!} to
ensure any registered
\passthrough{\lstinline!OnFrameworkInitializationCompleted!} handlers
fire.

\subsection{3. Building windows and views directly in
C}\label{building-windows-and-views-directly-in-c}

When you skip XAML, every control tree is instantiated manually. You
can: - Derive from \passthrough{\lstinline!Window!},
\passthrough{\lstinline!UserControl!}, or
\passthrough{\lstinline!ContentControl!} and compose UI in the
constructor. - Use factory methods to build complex layouts. - Compose
view-model bindings using \passthrough{\lstinline!Binding!} objects or
extension helpers.

\begin{lstlisting}
public sealed class MainWindow : Window
{
    public MainWindow()
    {
        Title = "Code-first Avalonia";
        Width = 800;
        Height = 600;

        Content = BuildLayout();
    }

    private static Control BuildLayout()
    {
        return new DockPanel
        {
            LastChildFill = true,
            Children =
            {
                CreateHeader(),
                CreateBody()
            }
        };
    }

    private static Control CreateHeader()
        => new Border
        {
            Background = (IBrush)Application.Current!.Resources["AccentBrush"],
            Padding = new Thickness(24, 16),
            Child = new TextBlock
            {
                Text = "Dashboard",
                FontSize = 22,
                Foreground = Brushes.White,
                FontWeight = FontWeight.SemiBold
            }
        }.DockTop();

    private static Control CreateBody()
        => new StackPanel
        {
            Margin = new Thickness(24),
            Spacing = 16,
            Children =
            {
                new TextBlock { Text = "Welcome!", FontSize = 18 },
                new Button
                {
                    Content = "Refresh",
                    Command = ReactiveCommand.Create(() => Debug.WriteLine("Refresh requested"))
                }
            }
        };
}
\end{lstlisting}

Helper extension methods keep layout code tidy. You can author them in a
static class:

\begin{lstlisting}
public static class DockPanelExtensions
{
    public static T DockTop<T>(this T control) where T : Control
    {
        DockPanel.SetDock(control, Dock.Top);
        return control;
    }
}
\end{lstlisting}

Because you're constructing controls in code, you can register them with
the \passthrough{\lstinline!NameScope!} for later lookup:

\begin{lstlisting}
var scope = new NameScope();
NameScope.SetNameScope(this, scope);

var statusText = new TextBlock { Text = "Idle" };
scope.Register("StatusText", statusText);
\end{lstlisting}

This matches \passthrough{\lstinline!NameScope!} behaviour from XAML
(see
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/LogicalTree/NameScope.cs!}).

\subsection{4. Binding, commands, and services without markup
extensions}\label{binding-commands-and-services-without-markup-extensions}

Code-first projects rely on the same binding engine, but you create
bindings manually or use compiled binding helpers.

\subsubsection{Creating bindings
programmatically}\label{creating-bindings-programmatically}

\begin{lstlisting}
var textBox = new TextBox();
textBox.Bind(TextBox.TextProperty, new Binding("Query")
{
    Mode = BindingMode.TwoWay,
    UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged,
    ValidatesOnDataErrors = true
});

var searchButton = new Button
{
    Content = "Search"
};
searchButton.Bind(Button.CommandProperty, new Binding("SearchCommand"));
\end{lstlisting}

\passthrough{\lstinline!Binding!} lives in
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Data/Binding.cs!}.
Anything you can express via \passthrough{\lstinline!\{Binding\}!}
markup is available as properties on this class. For compiled bindings,
use \passthrough{\lstinline!CompiledBindingFactory!} from
\passthrough{\lstinline!Avalonia.Data.Core!} directly:

\begin{lstlisting}
var factory = new CompiledBindingFactory();
var compiled = factory.Create<object, string>(
    vmGetter: static vm => ((SearchViewModel)vm).Query,
    vmSetter: static (vm, value) => ((SearchViewModel)vm).Query = value,
    name: nameof(SearchViewModel.Query),
    mode: BindingMode.TwoWay);

textBox.Bind(TextBox.TextProperty, compiled);
\end{lstlisting}

\subsubsection{Services and dependency
injection}\label{services-and-dependency-injection}

Use \passthrough{\lstinline!AvaloniaLocator.CurrentMutable!} (defined in
\passthrough{\lstinline!Application.RegisterServices!}) to register
services. For richer DI, integrate libraries like
\passthrough{\lstinline!Microsoft.Extensions.DependencyInjection!}.

\begin{lstlisting}
protected override void RegisterServices()
{
    var services = new ServiceCollection();
    services.AddSingleton<IMyService, MyService>();
    services.AddSingleton<HomeViewModel>();

    var provider = services.BuildServiceProvider();

    AvaloniaLocator.CurrentMutable.Bind<IMyService>().ToSingleton(() => provider.GetRequiredService<IMyService>());
    AvaloniaLocator.CurrentMutable.Bind<HomeViewModel>().ToTransient(() => provider.GetRequiredService<HomeViewModel>());
}
\end{lstlisting}

Later, resolve services via
\passthrough{\lstinline!AvaloniaLocator.Current.GetService<HomeViewModel>()!}
or inject them into controls. Because
\passthrough{\lstinline!RegisterServices!} runs before
\passthrough{\lstinline!Initialize!}, you can use registered services
while building resources.

\subsection{5. Theming, resources, and modular
structure}\label{theming-resources-and-modular-structure}

Code-first theming revolves around
\passthrough{\lstinline!ResourceDictionary!},
\passthrough{\lstinline!Styles!}, and
\passthrough{\lstinline!StyleInclude!}.

\subsubsection{Centralize app resources}\label{centralize-app-resources}

\begin{lstlisting}
private static ResourceDictionary CreateAppResources()
{
    return new ResourceDictionary
    {
        MergedDictionaries =
        {
            new ResourceDictionary
            {
                ["Spacing.Small"] = 4.0,
                ["Spacing.Medium"] = 12.0,
                ["Spacing.Large"] = 24.0
            }
        },
        ["AccentBrush"] = Brushes.CornflowerBlue,
        ["AccentForegroundBrush"] = Brushes.White
    };
}
\end{lstlisting}

Use namespaced keys (\passthrough{\lstinline!Spacing.Medium!}) to avoid
collisions. If you rely on resizable themes, store them in a dedicated
class:

\begin{lstlisting}
public static class AppTheme
{
    public static Styles Light { get; } = new Styles
    {
        new FluentTheme { Mode = FluentThemeMode.Light },
        CreateSharedStyles()
    };

    public static Styles Dark { get; } = new Styles
    {
        new FluentTheme { Mode = FluentThemeMode.Dark },
        CreateSharedStyles()
    };

    private static Styles CreateSharedStyles()
        => new Styles
        {
            new Style(x => x.OfType<Window>())
            {
                Setters =
                {
                    new Setter(Window.BackgroundProperty, Brushes.Transparent)
                }
            }
        };
}
\end{lstlisting}

Switch themes at runtime:

\begin{lstlisting}
public void UseDarkTheme()
{
    Application.Current!.Styles.Clear();
    foreach (var style in AppTheme.Dark)
    {
        Application.Current.Styles.Add(style);
    }
}
\end{lstlisting}

Iterate the collection when swapping
themes---\passthrough{\lstinline!Styles!} implements
\passthrough{\lstinline!IEnumerable<IStyle>!} so a simple
\passthrough{\lstinline!foreach!} keeps dependencies minimal. Remember
to freeze brushes (\passthrough{\lstinline!Brushes.Transparent!} is
already frozen) when reusing them to avoid unnecessary allocations.

\subsubsection{Organize modules by
feature}\label{organize-modules-by-feature}

A common pattern is to place each feature in its own namespace with: - A
factory method returning a \passthrough{\lstinline!Control!} (for pure
code) or a partial class if you mix \passthrough{\lstinline!.axaml!} for
templates. - A \passthrough{\lstinline!ViewModel!} class registered via
DI. - Optional
\passthrough{\lstinline!IStyle!}/\passthrough{\lstinline!ResourceDictionary!}
definitions encapsulated in static classes.

Example folder layout:

\begin{lstlisting}
src/
  Infrastructure/
    Services/
    Styles/
  Features/
    Dashboard/
      DashboardView.cs
      DashboardViewModel.cs
      DashboardStyles.cs
    Settings/
      SettingsView.cs
      SettingsViewModel.cs
\end{lstlisting}

\passthrough{\lstinline!DashboardStyles!} might expose a
\passthrough{\lstinline!Styles!} property you merge into
\passthrough{\lstinline!Application.Styles!}. Keep style/helper
definitions close to the controls they customize to maintain cohesion.

\subsection{6. Migrating from XAML to
code-first}\label{migrating-from-xaml-to-code-first}

To convert an existing XAML-based app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Copy property settings}: For each control, move attribute
  values into constructors or object initializers. Attached properties
  map to static setters
  (\passthrough{\lstinline!Grid.SetColumn(button, 1)!}).
\item
  \textbf{Convert bindings}: Replace
  \passthrough{\lstinline!\{Binding\}!} with
  \passthrough{\lstinline!control.Bind(Property, new Binding("Path"))!}.
  For \passthrough{\lstinline!ElementName!} references, call
  \passthrough{\lstinline!NameScope.Register!} and
  \passthrough{\lstinline!FindControl!}.
\item
  \textbf{Transform styles}: Use
  \passthrough{\lstinline!new Style(x => x.OfType<Button>().Class("accent"))!}
  for selectors. Set \passthrough{\lstinline!Setters!} to match
  \passthrough{\lstinline!<Setter>!} elements.
\item
  \textbf{Load templates}: Where XAML used
  \passthrough{\lstinline!<ControlTemplate>!}, build
  \passthrough{\lstinline!FuncControlTemplate!}. The constructor
  signature matches the control type and returns the template content.
\item
  \textbf{Merge resources}: Replace
  \passthrough{\lstinline!<ResourceDictionary.MergedDictionaries>!} with
  \passthrough{\lstinline!ResourceDictionary.MergedDictionaries.Add(...)!}.
\item
  \textbf{Replace markup extensions}: Many map to APIs
  (\passthrough{\lstinline!DynamicResource!} →
  \passthrough{\lstinline!DynamicResourceBindingExtensions!},
  \passthrough{\lstinline!StaticResource!} → dictionary lookup). For
  \passthrough{\lstinline!OnPlatform!} or
  \passthrough{\lstinline!OnFormFactor!}, implement custom helper
  methods that return values based on
  \passthrough{\lstinline!RuntimeInformation!}.
\end{enumerate}

Testing after each step keeps parity. Avalonia DevTools still works with
code-first UI, so inspect logical/visual trees to confirm bindings and
styles resolved correctly.

\subsection{7. Practice lab}\label{practice-lab}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{From template to C\#} -- Scaffold a standard Avalonia MVVM
  template, then delete \passthrough{\lstinline!App.axaml!} and
  \passthrough{\lstinline!MainWindow.axaml!}. Recreate them as classes
  mirroring their original layout using C\# object initializers. Verify
  styles, resources, and data bindings behave identically using
  DevTools.
\item
  \textbf{Theme switcher} -- Implement light/dark
  \passthrough{\lstinline!Styles!} groups in code. Add a toggle button
  that swaps \passthrough{\lstinline!Application.Current.Styles!} and
  persists the choice using your service layer.
\item
  \textbf{DI-first startup} -- Register services in
  \passthrough{\lstinline!RegisterServices()!} using your preferred
  container. Resolve view-models in
  \passthrough{\lstinline!OnFrameworkInitializationCompleted!} rather
  than \passthrough{\lstinline!new!}, ensuring the container owns
  lifetimes.
\item
  \textbf{Factory-based navigation} -- Build a code-first navigation
  shell where pages are created via factories
  (\passthrough{\lstinline!Func<Control>!}). Inject factories through DI
  and demonstrate a plugin module adding new pages without touching
  XAML.
\item
  \textbf{Headless smoke test} -- Pair with Chapter 38 by writing a
  headless unit test that spins up your code-first app, navigates to a
  view, and asserts control properties to guarantee the code-only tree
  is intact.
\end{enumerate}

By mastering these patterns you gain confidence that Avalonia's
internals don't require XAML. The framework's property system, theming
engine, and lifetimes remain fully accessible from C\#, letting teams
tailor architecture to their tooling and review preferences.

What's next - Next: \href{Chapter34.md}{Chapter34}

\newpage

\subsection{34. Layouts and controls authored in pure
C}\label{layouts-and-controls-authored-in-pure-c}

Goal - Compose Avalonia visual trees entirely in code using layout
containers, attached properties, and fluent helpers. - Understand how
\passthrough{\lstinline!AvaloniaObject!} APIs
(\passthrough{\lstinline!SetValue!},
\passthrough{\lstinline!SetCurrentValue!}, observers) replace attribute
syntax when you skip XAML. - Build reusable factory methods and
extension helpers that keep code-generated UI readable and testable.

Why this matters - Code-first teams still need the full power of
Avalonia's layout system: panels, attached properties, and templated
controls all live in namespaces you can reach from C\#. - Explicit
property APIs make dynamic UI safer---no magic strings or runtime
parsing, just compile-time members and analyzers. - Once you see how to
structure factories and name scopes, you can generate UI from data,
plug-ins, or source generators without sacrificing maintainability.

Prerequisites - Chapter 7 (styles) for context on how styles interact
with control trees. - Chapter 9 (input) if you plan to attach event
handlers in code-behind. - Chapter 33 (code-first startup) for
application scaffolding and DI patterns.

\subsection{\texorpdfstring{1. Layout primitives in code:
\texttt{StackPanel}, \texttt{Grid},
\texttt{DockPanel}}{1. Layout primitives in code: StackPanel, Grid, DockPanel}}\label{layout-primitives-in-code-stackpanel-grid-dockpanel}

Avalonia's panels live in
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/!}.
Construct them exactly as you would in XAML, but populate
\passthrough{\lstinline!Children!} and set properties directly.

\begin{lstlisting}
var layout = new StackPanel
{
    Orientation = Orientation.Vertical,
    Spacing = 12,
    Margin = new Thickness(24),
    Children =
    {
        new TextBlock { Text = "Customer" },
        new TextBox { Watermark = "Name" },
        new TextBox { Watermark = "Email" }
    }
};
\end{lstlisting}

\passthrough{\lstinline!StackPanel!}'s measure logic (see
\passthrough{\lstinline!StackPanel.cs!}) respects
\passthrough{\lstinline!Spacing!} and
\passthrough{\lstinline!Orientation!}. Because you're in code, you can
wrap control creation in helper methods to keep constructors clean:

\begin{lstlisting}
private static TextBox CreateLabeledInput(string label, out TextBlock caption)
{
    caption = new TextBlock { Text = label, FontWeight = FontWeight.SemiBold };
    return new TextBox { Margin = new Thickness(0, 4, 0, 16) };
}
\end{lstlisting}

\subsubsection{Grids without XAML
strings}\label{grids-without-xaml-strings}

\passthrough{\lstinline!Grid!} exposes
\passthrough{\lstinline!RowDefinitions!}/\passthrough{\lstinline!ColumnDefinitions!}
collections of
\passthrough{\lstinline!RowDefinition!}/\passthrough{\lstinline!ColumnDefinition!}.
You add definitions and set attached properties programmatically.

\begin{lstlisting}
var grid = new Grid
{
    ColumnDefinitions =
    {
        new ColumnDefinition(GridLength.Auto),
        new ColumnDefinition(GridLength.Star)
    },
    RowDefinitions =
    {
        new RowDefinition(GridLength.Auto),
        new RowDefinition(GridLength.Auto),
        new RowDefinition(GridLength.Star)
    }
};

var title = new TextBlock { Text = "Orders", FontSize = 22 }; 
Grid.SetColumnSpan(title, 2);
grid.Children.Add(title);

var filterLabel = new TextBlock { Text = "Status" };
Grid.SetRow(filterLabel, 1);
Grid.SetColumn(filterLabel, 0);
grid.Children.Add(filterLabel);

var filterBox = new ComboBox { Items = Enum.GetValues<OrderStatus>() };
Grid.SetRow(filterBox, 1);
Grid.SetColumn(filterBox, 1);
grid.Children.Add(filterBox);
\end{lstlisting}

Attached property methods (\passthrough{\lstinline!Grid.SetRow!},
\passthrough{\lstinline!Grid.SetColumnSpan!}) are static for clarity.
Because they ultimately call
\passthrough{\lstinline!AvaloniaObject.SetValue!}, you can wrap them in
fluent helpers if you prefer chaining (example later in section 3).

\subsubsection{Dock layouts and last-child
filling}\label{dock-layouts-and-last-child-filling}

\passthrough{\lstinline!DockPanel!} (source:
\passthrough{\lstinline!DockPanel.cs!}) uses the
\passthrough{\lstinline!Dock!} attached property. From code you set it
with \passthrough{\lstinline!DockPanel.SetDock(control, Dock.Left)!}.

\begin{lstlisting}
var dock = new DockPanel
{
    LastChildFill = true,
    Children =
    {
        CreateSidebar().DockLeft(),
        CreateFooter().DockBottom(),
        CreateMainRegion()
    }
};
\end{lstlisting}

Implement \passthrough{\lstinline!DockLeft()!} as an extension to keep
code terse:

\begin{lstlisting}
public static class DockExtensions
{
    public static T DockLeft<T>(this T control) where T : Control
    {
        DockPanel.SetDock(control, Dock.Left);
        return control;
    }

    public static T DockBottom<T>(this T control) where T : Control
    {
        DockPanel.SetDock(control, Dock.Bottom);
        return control;
    }
}
\end{lstlisting}

You own these helpers, so you can tailor them for your team's
conventions (dock with margins, apply classes, etc.).

\subsection{\texorpdfstring{2. Working with the property system:
\texttt{SetValue}, \texttt{SetCurrentValue},
observers}{2. Working with the property system: SetValue, SetCurrentValue, observers}}\label{working-with-the-property-system-setvalue-setcurrentvalue-observers}

Without XAML attribute syntax you interact with
\passthrough{\lstinline!AvaloniaProperty!} APIs directly. Every control
inherits from \passthrough{\lstinline!AvaloniaObject!}
(\passthrough{\lstinline!AvaloniaObject.cs!}), which exposes:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!SetValue(AvaloniaProperty property, object? value)!}
  -- sets the property locally, raising change notifications and
  affecting bindings.
\item
  \passthrough{\lstinline!SetCurrentValue(AvaloniaProperty property, object? value)!}
  -- updates the effective value but preserves existing
  bindings/animations (great for programmatic defaults).
\item
  \passthrough{\lstinline!GetObservable<T>(AvaloniaProperty<T>)!} --
  returns an \passthrough{\lstinline!IObservable<T?>!} when you need to
  react to changes.
\end{itemize}

Example: highlight focused text boxes by toggling a pseudo-class while
keeping bindings intact.

\begin{lstlisting}
var box = new TextBox();
box.GotFocus += (_, _) => box.PseudoClasses.Set(":focused", true);
box.LostFocus += (_, _) => box.PseudoClasses.Set(":focused", false);

// Provide a default width but leave bindings alone
box.SetCurrentValue(TextBox.WidthProperty, 240);
\end{lstlisting}

To wire property observers, use \passthrough{\lstinline!GetObservable!}
or \passthrough{\lstinline!GetPropertyChangedObservable!} (for any
property change):

\begin{lstlisting}
box.GetObservable(TextBox.TextProperty)
   .Subscribe(text => _logger.Information("Text changed to {Text}", text));
\end{lstlisting}

\passthrough{\lstinline!GetObservable!} is defined in
\passthrough{\lstinline!AvaloniaObject!}. Remember to dispose
subscriptions when controls leave the tree---store
\passthrough{\lstinline!IDisposable!} tokens and call
\passthrough{\lstinline!Dispose!} in your control's
\passthrough{\lstinline!DetachedFromVisualTree!} handler.

\subsubsection{Creating reusable property
helpers}\label{creating-reusable-property-helpers}

When repeating property patterns, encapsulate them:

\begin{lstlisting}
public static class ControlHelpers
{
    public static T WithMargin<T>(this T control, Thickness margin) where T : Control
    {
        control.Margin = margin;
        return control;
    }

    public static T Bind<T, TValue>(this T control, AvaloniaProperty<TValue> property, IBinding binding)
        where T : AvaloniaObject
    {
        control.Bind(property, binding);
        return control;
    }
}
\end{lstlisting}

These mirror markup extensions in code, making complex layouts more
declarative.

\subsection{3. Factories, builders, and fluent
composition}\label{factories-builders-and-fluent-composition}

Large code-first views benefit from factory methods that return
configured controls. Compose factories from smaller functions to keep
logic readable.

\begin{lstlisting}
public static class DashboardViewFactory
{
    public static Control Create(IDashboardViewModel vm)
    {
        return new Grid
        {
            ColumnDefinitions =
            {
                new ColumnDefinition(GridLength.Star),
                new ColumnDefinition(GridLength.Star)
            },
            Children =
            {
                CreateSummary(vm).WithGridPosition(0, 0),
                CreateChart(vm).WithGridPosition(0, 1)
            }
        };
    }

    private static Control CreateSummary(IDashboardViewModel vm)
        => new Border
        {
            Padding = new Thickness(24),
            Child = new TextBlock().Bind(TextBlock.TextProperty, new Binding(nameof(vm.TotalSales)))
        };
}
\end{lstlisting}

\passthrough{\lstinline!WithGridPosition!} is a fluent helper you
define:

\begin{lstlisting}
public static class GridExtensions
{
    public static T WithGridPosition<T>(this T element, int row, int column) where T : Control
    {
        Grid.SetRow(element, row);
        Grid.SetColumn(element, column);
        return element;
    }
}
\end{lstlisting}

This approach keeps UI declarations near data bindings, reducing mental
overhead for reviewers.

\subsubsection{Repeating structures via LINQ or
loops}\label{repeating-structures-via-linq-or-loops}

Because you're in C\#, generate children dynamically:

\begin{lstlisting}
var cards = vm.Notifications.Select((item, index) =>
    CreateNotificationCard(item).WithGridPosition(index / 3, index % 3));

var grid = new Grid
{
    ColumnDefinitions = { new ColumnDefinition(GridLength.Star), new ColumnDefinition(GridLength.Star), new ColumnDefinition(GridLength.Star) }
};

foreach (var card in cards)
{
    grid.Children.Add(card);
}
\end{lstlisting}

\passthrough{\lstinline!Grid!} measure logic handles dynamic counts;
just ensure \passthrough{\lstinline!RowDefinitions!} fits the generated
children (add rows as needed or rely on
\passthrough{\lstinline!GridLength.Auto!}).

\subsubsection{Sharing styles between
factories}\label{sharing-styles-between-factories}

Factories can return both controls and supporting
\passthrough{\lstinline!Styles!}:

\begin{lstlisting}
public static Styles DashboardStyles { get; } = new Styles
{
    new Style(x => x.OfType<TextBlock>().Class("section-title"))
    {
        Setters = { new Setter(TextBlock.FontSizeProperty, 18), new Setter(TextBlock.FontWeightProperty, FontWeight.SemiBold) }
    }
};
\end{lstlisting}

Merge these into \passthrough{\lstinline!Application.Current.Styles!} in
\passthrough{\lstinline!App.Initialize()!} or on demand when the feature
loads.

\subsection{\texorpdfstring{4. Managing \texttt{NameScope},
logical/visual trees, and
lookup}{4. Managing NameScope, logical/visual trees, and lookup}}\label{managing-namescope-logicalvisual-trees-and-lookup}

XAML automatically registers names in a
\passthrough{\lstinline!NameScope!}. In code-first views you create and
assign it manually when you need element lookup or
\passthrough{\lstinline!ElementName!}-like references.

\begin{lstlisting}
var scope = new NameScope();
var container = new Grid();
NameScope.SetNameScope(container, scope);

var detailPanel = new StackPanel { Orientation = Orientation.Vertical };
scope.Register("DetailPanel", detailPanel);

container.Children.Add(detailPanel);
\end{lstlisting}

Later you can resolve controls with
\passthrough{\lstinline!FindControl<T>!}:

\begin{lstlisting}
var detail = container.FindControl<StackPanel>("DetailPanel");
\end{lstlisting}

\passthrough{\lstinline!NameScope!} implementation lives in
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/LogicalTree/NameScope.cs!}.
Remember that nested scopes behave like XAML: children inherit the
nearest scope unless you assign a new one.

\subsubsection{Logical tree utilities}\label{logical-tree-utilities}

Avalonia's logical tree helpers
(\passthrough{\lstinline!LogicalTreeExtensions.cs!}) are just as useful
without XAML. Use them to inspect or traverse the tree:

\begin{lstlisting}
Control? parent = myControl.GetLogicalParent();
IEnumerable<IControl> children = myControl.GetLogicalChildren().OfType<IControl>();
\end{lstlisting}

This is handy when you dynamically add/remove controls and need to
ensure data contexts or resources flow correctly. To validate at
runtime, enable DevTools
(\passthrough{\lstinline!Avalonia.Diagnostics!}) even in code-only
views---the visual tree is identical.

\subsection{5. Advanced controls entirely from
C}\label{advanced-controls-entirely-from-c}

\subsubsection{\texorpdfstring{\texttt{TabControl} and dynamic
pages}{TabControl and dynamic pages}}\label{tabcontrol-and-dynamic-pages}

\passthrough{\lstinline!TabControl!} expects
\passthrough{\lstinline!TabItem!} children. Compose them
programmatically and bind headers/content.

\begin{lstlisting}
var tabControl = new TabControl
{
    Items = new[]
    {
        new TabItem
        {
            Header = "Overview",
            Content = new OverviewView { DataContext = vm.Overview }
        },
        new TabItem
        {
            Header = "Details",
            Content = CreateDetailsGrid(vm.Details)
        }
    }
};
\end{lstlisting}

If you prefer data-driven tabs, set \passthrough{\lstinline!Items!} to a
collection of view-models and provide
\passthrough{\lstinline!ItemTemplate!} using
\passthrough{\lstinline!FuncDataTemplate!} (see Chapter 36 for full
coverage). Even then, you create the template in code:

\begin{lstlisting}
tabControl.ItemTemplate = new FuncDataTemplate<IDetailViewModel>((context, _) =>
    new DetailView { DataContext = context },
    supportsRecycling: true);
\end{lstlisting}

\subsubsection{Lists with factories}\label{lists-with-factories}

\passthrough{\lstinline!ItemsControl!} and
\passthrough{\lstinline!ListBox!} take \passthrough{\lstinline!Items!}
plus optional panel templates. Build the items panel in code to control
layout.

\begin{lstlisting}
var list = new ListBox
{
    ItemsPanel = new FuncTemplate<Panel?>(() => new WrapPanel { ItemWidth = 160, ItemHeight = 200 }),
    Items = vm.Products.Select(p => CreateProductCard(p))
};
\end{lstlisting}

Here \passthrough{\lstinline!FuncTemplate!} comes from
\passthrough{\lstinline!Avalonia.Controls.Templates!} (source:
\passthrough{\lstinline!FuncTemplate.cs!}). It mirrors
\passthrough{\lstinline!<ItemsPanelTemplate>!}.

\subsubsection{Popups and overlays}\label{popups-and-overlays}

Controls like \passthrough{\lstinline!FlyoutBase!} or
\passthrough{\lstinline!Popup!} are fully accessible in code. Example:
attach a contextual menu.

\begin{lstlisting}
var button = new Button { Content = "Options" };
button.Flyout = new MenuFlyout
{
    Items =
    {
        new MenuItem { Header = "Refresh", Command = vm.RefreshCommand },
        new MenuItem { Header = "Export", Command = vm.ExportCommand }
    }
};
\end{lstlisting}

The object initializer syntax keeps the code close to the equivalent
XAML while exposing full IntelliSense.

\subsection{6. Diagnostics and testing for code-first
layouts}\label{diagnostics-and-testing-for-code-first-layouts}

Because no XAML compilation step validates your layout, lean on: -
\textbf{Unit tests} using \passthrough{\lstinline!Avalonia.Headless!} to
instantiate controls and assert layout bounds. - \textbf{DevTools} to
inspect the visual tree ( launch via
\passthrough{\lstinline!AttachDevTools()!} in debug builds ). -
\textbf{Logging} via property observers to catch binding mistakes early.

Example headless test snippet:

\begin{lstlisting}
[Fact]
public void Summary_panel_contains_totals()
{
    using var app = AvaloniaApp();

    var view = DashboardViewFactory.Create(new FakeDashboardVm());
    var panel = view.GetLogicalDescendants().OfType<TextBlock>()
        .First(t => t.Classes.Contains("total"));

    panel.Text.Should().Be("$42,000");
}
\end{lstlisting}

\passthrough{\lstinline!GetLogicalDescendants!} is defined in
\passthrough{\lstinline!LogicalTreeExtensions!}. Pair this with Chapter
38 for deeper testing patterns.

\subsection{7. Practice lab}\label{practice-lab-1}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{StackPanel to Grid refactor} -- Start with a simple
  \passthrough{\lstinline!StackPanel!} form built in code. Refactor it
  to a \passthrough{\lstinline!Grid!} with columns and auto-sizing rows
  using only C\# helpers. Confirm layout parity via DevTools.
\item
  \textbf{Dashboard factory} -- Implement a
  \passthrough{\lstinline!DashboardViewFactory!} that returns a
  \passthrough{\lstinline!Grid!} with cards arranged dynamically based
  on a view-model collection. Add fluent helpers for grid position,
  dock, and margin management.
\item
  \textbf{Attached property assertions} -- Write a headless unit test
  that constructs your view, retrieves a control by name, and asserts
  attached properties (\passthrough{\lstinline!Grid.GetRow!},
  \passthrough{\lstinline!DockPanel.GetDock!}) to prevent regressions.
\item
  \textbf{Dynamic modules} -- Load modules at runtime that contribute
  layout fragments via \passthrough{\lstinline!Func<Control>!}. Merge
  their
  \passthrough{\lstinline!Styles!}/\passthrough{\lstinline!ResourceDictionary!}
  contributions when modules activate and remove them when deactivated.
\item
  \textbf{Performance profiling} -- Use
  \passthrough{\lstinline!RenderTimerDiagnostics!} from DevTools to
  monitor layout passes. Compare baseline vs.~dynamic code generation to
  ensure your factories don't introduce unnecessary measure/arrange
  churn.
\end{enumerate}

Mastering these patterns means you can weave Avalonia's layout system
into any C\#-driven architecture---no XAML required, just the underlying
property system and a toolbox of fluent helpers tailored to your
project.

What's next - Next: \href{Chapter35.md}{Chapter35}

\newpage

\subsection{35. Bindings, resources, and styles with fluent
APIs}\label{bindings-resources-and-styles-with-fluent-apis}

Goal - Compose data bindings, resource lookups, and styles from C\#
using the same primitives Avalonia's XAML markup wraps. - Harness
indexer paths, compiled bindings, and validation hooks when no markup
extensions are available. - Build reusable style/resource factories that
keep code-first projects organized and themeable.

Why this matters - Binding expressions and resource dictionaries power
MVVM regardless of markup language; code-first teams need ergonomic
patterns to mirror XAML equivalents. - Explicit APIs
(\passthrough{\lstinline!Binding!},
\passthrough{\lstinline!CompiledBindingFactory!},
\passthrough{\lstinline!IResourceHost!},
\passthrough{\lstinline!Style!}) remove stringly-typed errors and enable
richer refactoring tools. - Once bindings and resources live in code,
you can conditionally compose them, share helper libraries, and unit
test your infrastructure without XML parsing.

Prerequisites - Chapter 7 (styling) and Chapter 10 (resources) to
understand the conceptual model. - Chapter 33 (code-only startup) for
service registration and theme initialization. - Chapter 34 (layout) for
structuring controls that consume bindings/styles.

\subsection{1. Binding essentials without
markup}\label{binding-essentials-without-markup}

Avalonia's binding engine is expressed via
\passthrough{\lstinline!Binding!}
(\passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Data/Binding.cs!}).
Construct bindings with property paths, modes, converters, and
validation:

\begin{lstlisting}
var binding = new Binding("Customer.Name")
{
    Mode = BindingMode.TwoWay,
    UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged,
    ValidatesOnExceptions = true
};

nameTextBox.Bind(TextBox.TextProperty, binding);
\end{lstlisting}

\passthrough{\lstinline!Bind!} is an extension method on
\passthrough{\lstinline!AvaloniaObject!} (see
\passthrough{\lstinline!BindingExtensions!}). The same API supports
command bindings:

\begin{lstlisting}
saveButton.Bind(Button.CommandProperty, new Binding("SaveCommand"));
\end{lstlisting}

For one-time assignments, use
\passthrough{\lstinline!BindingMode.OneTime!}. When you need relative
bindings (\passthrough{\lstinline!RelativeSource!} in XAML), use
\passthrough{\lstinline!RelativeSource!} objects:

\begin{lstlisting}
var binding = new Binding
{
    RelativeSource = new RelativeSource(RelativeSourceMode.FindAncestor)
    {
        AncestorType = typeof(Window)
    },
    Path = nameof(Window.Title)
};

header.Bind(TextBlock.TextProperty, binding);
\end{lstlisting}

\subsubsection{Indexer bindings from
code}\label{indexer-bindings-from-code}

Avalonia supports indexer paths (dictionary or list access) via the same
\passthrough{\lstinline!Binding.Path!} syntax used in XAML.

\begin{lstlisting}
var statusText = new TextBlock();
statusText.Bind(TextBlock.TextProperty, new Binding("Statuses[SelectedStatus]"));
\end{lstlisting}

Internally the binding engine uses \passthrough{\lstinline!IndexerNode!}
(see \passthrough{\lstinline!ExpressionNodes!}). You still get change
notifications when the indexer raises property change events
(\passthrough{\lstinline!INotifyPropertyChanged!} +
\passthrough{\lstinline!IndexerName!}). For dynamic dictionaries, call
\passthrough{\lstinline!RaisePropertyChanged("Item[]")!} on changes.

\subsubsection{\texorpdfstring{Typed bindings with
\texttt{CompiledBindingFactory}}{Typed bindings with CompiledBindingFactory}}\label{typed-bindings-with-compiledbindingfactory}

Compiled bindings avoid reflection at runtime. Create a factory and
supply strongly-typed accessors, mirroring
\passthrough{\lstinline!\{CompiledBinding\}!} usage.

\begin{lstlisting}
var factory = new CompiledBindingFactory();
var compiled = factory.Create<DashboardViewModel, string>(
    vmGetter: static vm => vm.Header,
    vmSetter: static (vm, value) => vm.Header = value,
    name: nameof(DashboardViewModel.Header),
    mode: BindingMode.TwoWay);

headerText.Bind(TextBlock.TextProperty, compiled);
\end{lstlisting}

\passthrough{\lstinline!CompiledBindingFactory!} resides in
\passthrough{\lstinline!Avalonia.Data.Core!}. Pass
\passthrough{\lstinline!BindingPriority!} if you need to align with
style triggers. Because compiled bindings capture delegates, they work
well with source generators or analyzers.

\subsubsection{Binding helpers for fluent
composition}\label{binding-helpers-for-fluent-composition}

Create extension methods to reduce boilerplate:

\begin{lstlisting}
public static class BindingHelpers
{
    public static T BindValue<T, TValue>(this T control, AvaloniaProperty<TValue> property, string path,
        BindingMode mode = BindingMode.Default) where T : AvaloniaObject
    {
        control.Bind(property, new Binding(path) { Mode = mode });
        return control;
    }
}
\end{lstlisting}

Use them when composing views:

\begin{lstlisting}
var searchBox = new TextBox()
    .BindValue(TextBox.TextProperty, nameof(SearchViewModel.Query), BindingMode.TwoWay);
\end{lstlisting}

\subsection{2. Validation, converters, and
multi-bindings}\label{validation-converters-and-multi-bindings}

\subsubsection{Validation feedback}\label{validation-feedback}

Avalonia surfaces validation errors via
\passthrough{\lstinline!BindingNotification!}. In code you set
validation options on binding instances:

\begin{lstlisting}
var amountBinding = new Binding("Amount")
{
    Mode = BindingMode.TwoWay,
    ValidatesOnDataErrors = true,
    ValidatesOnExceptions = true
};
amountTextBox.Bind(TextBox.TextProperty, amountBinding);
\end{lstlisting}

Listen for errors using \passthrough{\lstinline!BindingObserver!} or
property change notifications on
\passthrough{\lstinline!DataValidationErrors!} (see
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/DataValidationErrors.cs!}).
Example hooking into the attached property:

\begin{lstlisting}
amountTextBox.GetObservable(DataValidationErrors.HasErrorsProperty)
    .Subscribe(hasErrors => amountTextBox.Classes.Set(":invalid", hasErrors));
\end{lstlisting}

\subsubsection{Converters and converter
parameters}\label{converters-and-converter-parameters}

Instantiate converters directly and assign them to
\passthrough{\lstinline!Binding.Converter!}:

\begin{lstlisting}
var converter = new BooleanToVisibilityConverter();
var binding = new Binding("IsBusy")
{
    Converter = converter
};

spinner.Bind(IsVisibleProperty, binding);
\end{lstlisting}

For inline converters, create lambda-based converter classes
implementing \passthrough{\lstinline!IValueConverter!}. In code-first
setups you can keep converter definitions close to usage.

\subsubsection{Multi-binding
composition}\label{multi-binding-composition}

\passthrough{\lstinline!MultiBinding!} lives in
\passthrough{\lstinline!Avalonia.Base/Data/MultiBinding.cs!}. Configure
binding collection and converters directly.

\begin{lstlisting}
var multi = new MultiBinding
{
    Bindings =
    {
        new Binding("FirstName"),
        new Binding("LastName")
    },
    Converter = FullNameConverter.Instance
};

fullNameText.Bind(TextBlock.TextProperty, multi);
\end{lstlisting}

\passthrough{\lstinline!FullNameConverter!} implements
\passthrough{\lstinline!IMultiValueConverter!}. When multi-binding in
code, consider static singletons to avoid allocations.

\subsection{3. Commands and observables from
code}\label{commands-and-observables-from-code}

Avalonia command support is just binding to
\passthrough{\lstinline!ICommand!}. With code-first patterns, leverage
\passthrough{\lstinline!ReactiveCommand!} or custom commands while still
using \passthrough{\lstinline!Bind!}:

\begin{lstlisting}
refreshButton.Bind(Button.CommandProperty, new Binding("RefreshCommand"));
\end{lstlisting}

To observe property changes for reactive flows, use
\passthrough{\lstinline!GetObservable!} or
\passthrough{\lstinline!PropertyChanged!} events. Combine with
\passthrough{\lstinline!ReactiveUI!} by using
\passthrough{\lstinline!WhenAnyValue!} inside view models---code-first
views don't change this interop.

\subsection{4. Resource dictionaries and lookup
patterns}\label{resource-dictionaries-and-lookup-patterns}

\passthrough{\lstinline!ResourceDictionary!} is just a C\# collection
(see
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Controls/ResourceDictionary.cs!}).
Create dictionaries and merge them programmatically.

\begin{lstlisting}
var typographyResources = new ResourceDictionary
{
    ["Heading.FontSize"] = 24.0,
    ["Body.FontSize"] = 14.0
};

Application.Current!.Resources.MergedDictionaries.Add(typographyResources);
\end{lstlisting}

For per-control resources:

\begin{lstlisting}
var card = new Border
{
    Resources =
    {
        ["CardBackground"] = Brushes.White,
        ["CardShadow"] = new BoxShadow { Color = Colors.Black, Opacity = 0.1, Blur = 8 }
    }
};
\end{lstlisting}

\passthrough{\lstinline!Resources!} property is itself a
\passthrough{\lstinline!ResourceDictionary!}. Use strongly-typed wrapper
classes to centralize resource keys:

\begin{lstlisting}
public static class ResourceKeys
{
    public const string AccentBrush = nameof(AccentBrush);
    public const string AccentForeground = nameof(AccentForeground);
}

var accent = (IBrush)Application.Current!.Resources[ResourceKeys.AccentBrush];
\end{lstlisting}

Wrap lookups with helper methods to provide fallbacks:

\begin{lstlisting}
public static TResource GetResource<TResource>(this IResourceHost host, string key, TResource fallback)
{
    return host.TryFindResource(key, out var value) && value is TResource typed
        ? typed
        : fallback;
}
\end{lstlisting}

\passthrough{\lstinline!IResourceHost!}/\passthrough{\lstinline!IResourceProvider!}
interfaces are defined in \passthrough{\lstinline!Avalonia.Styling!}.
Controls implement them, so you can call
\passthrough{\lstinline!control.TryFindResource!} directly.

\subsection{5. Building styles fluently}\label{building-styles-fluently}

\passthrough{\lstinline!Style!} objects can be constructed with
selectors and setters. The selector API mirrors XAML but uses lambda
syntax.

\begin{lstlisting}
var buttonStyle = new Style(x => x.OfType<Button>().Class("primary"))
{
    Setters =
    {
        new Setter(Button.BackgroundProperty, Brushes.MediumPurple),
        new Setter(Button.ForegroundProperty, Brushes.White),
        new Setter(Button.PaddingProperty, new Thickness(20, 10))
    },
    Triggers =
    {
        new Trigger
        {
            Property = Button.IsPointerOverProperty,
            Value = true,
            Setters = { new Setter(Button.BackgroundProperty, Brushes.DarkMagenta) }
        }
    }
};
\end{lstlisting}

Add styles to \passthrough{\lstinline!Application.Current.Styles!} or to
a specific control's \passthrough{\lstinline!Styles!} collection.
Remember to freeze brushes (call \passthrough{\lstinline!ToImmutable()!}
or use static brushes) when reusing them widely.

\subsubsection{Style includes and theme
variants}\label{style-includes-and-theme-variants}

You can still load existing \passthrough{\lstinline!.axaml!} resources
via \passthrough{\lstinline!StyleInclude!}, or create purely code-based
ones:

\begin{lstlisting}
var theme = new Styles
{
    new StyleInclude(new Uri("avares://App/Styles"))
    {
        Source = new Uri("avares://App/Styles/Buttons.axaml")
    },
    buttonStyle
};

Application.Current!.Styles.AddRange(theme);
\end{lstlisting}

In pure C\#, \passthrough{\lstinline!Styles!} is just a list. If you
don't have \passthrough{\lstinline!AddRange!}, iterate:

\begin{lstlisting}
foreach (var style in theme)
{
    Application.Current!.Styles.Add(style);
}
\end{lstlisting}

Theme variants (\passthrough{\lstinline!ThemeVariant!}) can be set
directly on styles:

\begin{lstlisting}
buttonStyle.Resources[ThemeVariant.Light] = Brushes.Black;
buttonStyle.Resources[ThemeVariant.Dark] = Brushes.White;
\end{lstlisting}

\subsection{6. Code-first binding infrastructure
patterns}\label{code-first-binding-infrastructure-patterns}

\subsubsection{Binding factories per
view-model}\label{binding-factories-per-view-model}

Encapsulate binding creation in dedicated classes to avoid scattering
strings:

\begin{lstlisting}
public static class DashboardBindings
{
    public static Binding TotalSales => new(nameof(DashboardViewModel.TotalSales)) { Mode = BindingMode.OneWay };
    public static Binding RefreshCommand => new(nameof(DashboardViewModel.RefreshCommand));
}

salesText.Bind(TextBlock.TextProperty, DashboardBindings.TotalSales);
refreshButton.Bind(Button.CommandProperty, DashboardBindings.RefreshCommand);
\end{lstlisting}

\subsubsection{Expression-based helpers}\label{expression-based-helpers}

Use expression trees to produce path strings while maintaining
compile-time checks:

\begin{lstlisting}
public static class BindingFactory
{
    public static Binding Create<TViewModel, TValue>(Expression<Func<TViewModel, TValue>> expression,
        BindingMode mode = BindingMode.Default)
    {
        var path = ExpressionHelper.GetMemberPath(expression); // custom helper
        return new Binding(path) { Mode = mode };
    }
}
\end{lstlisting}

\passthrough{\lstinline!ExpressionHelper!} can walk the expression tree
to build \passthrough{\lstinline!Customer.Addresses[0].City!} style
paths, ensuring refactors update bindings.

\subsubsection{Declarative resource
builders}\label{declarative-resource-builders}

Provide factories for resource dictionaries similar to style factories:

\begin{lstlisting}
public static class ResourceFactory
{
    public static ResourceDictionary CreateColors() => new()
    {
        [ResourceKeys.AccentBrush] = new SolidColorBrush(Color.Parse("#4F8EF7")),
        [ResourceKeys.AccentForeground] = Brushes.White
    };
}
\end{lstlisting}

Merge them in \passthrough{\lstinline!App.Initialize()!} or feature
modules when needed.

\subsection{7. Practice lab}\label{practice-lab-2}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Binding library} -- Implement a helper class that exposes
  strongly-typed bindings for a view-model using expression trees.
  Replace string-based paths in an existing code-first view.
\item
  \textbf{Indexer dashboards} -- Build a dashboard card that binds to
  \passthrough{\lstinline!Metrics["TotalRevenue"]!} from a
  dictionary-backed view-model. Raise change notifications on dictionary
  updates and verify the UI refreshes.
\item
  \textbf{Validation styling} -- Create a reusable style that applies an
  \passthrough{\lstinline!:invalid!} pseudo-class template to controls
  with validation errors. Trigger validation via a headless test.
\item
  \textbf{Resource fallback provider} -- Write an extension method that
  locates a resource by key and throws a descriptive exception if
  missing, including current logical tree path. Use it in a headless
  test to catch missing theme registrations.
\item
  \textbf{Theme toggler} -- Compose two \passthrough{\lstinline!Styles!}
  collections (light/dark) in code, swap them at runtime, and ensure all
  bindings to theme resources update automatically. Validate behaviour
  with a headless pixel test (Chapter 40).
\end{enumerate}

With bindings, resources, and styles expressed in code, your Avalonia
app gains powerful refactorability and testability. Embrace the fluent
APIs and helper patterns to keep code-first UI as expressive as any XAML
counterpart.

What's next - Next: \href{Chapter36.md}{Chapter36}

\newpage

\subsection{36. Templates, indexers, and dynamic component
factories}\label{templates-indexers-and-dynamic-component-factories}

Goal - Compose control, data, and tree templates in pure C\# using
Avalonia's functional template APIs. - Harness indexer-driven bindings
and template bindings to build dynamic, data-driven components. -
Construct factories and selectors that swap templates at runtime without
touching XAML.

Why this matters - Templates define how controls render. In code-first
projects you still need \passthrough{\lstinline!FuncControlTemplate!},
\passthrough{\lstinline!FuncDataTemplate!}, and selectors to mirror the
flexibility of XAML. - Indexer bindings and instanced bindings power
advanced scenarios such as virtualization, item reuse, and hierarchical
data. - Dynamic factories unlock plugin architectures, runtime theme
changes, and feature toggles---all while keeping strong typing and
testability.

Prerequisites - Chapter 34 (layouts) to place templated content within
layouts. - Chapter 35 (bindings/resources) for binding syntax and helper
patterns. - Chapter 23 (custom controls) if you plan to author templated
controls that consume templates from code.

\subsection{\texorpdfstring{1. Control templates in code with
\texttt{FuncControlTemplate}}{1. Control templates in code with FuncControlTemplate}}\label{control-templates-in-code-with-funccontroltemplate}

\passthrough{\lstinline!FuncControlTemplate<T>!} (source:
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Templates/FuncControlTemplate.cs!})
produces a \passthrough{\lstinline!ControlTemplate!} that builds visuals
from code. It takes a lambda that receives the templated parent and
returns a
\passthrough{\lstinline!Control!}/\passthrough{\lstinline!IControl!}
tree.

\begin{lstlisting}
public static ControlTemplate CreateCardTemplate()
{
    return new FuncControlTemplate<ContentControl>((parent, scope) =>
    {
        var border = new Border
        {
            Background = Brushes.White,
            CornerRadius = new CornerRadius(12),
            Padding = new Thickness(16),
            Child = new ContentPresenter
            {
                Name = "PART_ContentPresenter"
            }
        };

        scope?.RegisterNamed("PART_ContentPresenter", border.Child);
        return border;
    });
}
\end{lstlisting}

Attach the template to a control:

\begin{lstlisting}
var card = new ContentControl
{
    Template = CreateCardTemplate(),
    Content = new TextBlock { Text = "Dashboard" }
};
\end{lstlisting}

Notes from the source implementation: - The second parameter
(\passthrough{\lstinline!INameScope scope!}) lets you register named
parts exactly like \passthrough{\lstinline!<ControlTemplate>!} does in
XAML. Use it to satisfy template part lookups in your control's
code-behind. - The lambda executes each time the control template is
applied, so create new control instances inside the lambda---avoid
caching across calls.

\subsubsection{\texorpdfstring{Template bindings and
\texttt{TemplatedParent}}{Template bindings and TemplatedParent}}\label{template-bindings-and-templatedparent}

Use \passthrough{\lstinline!TemplateBinding!} helpers
(\passthrough{\lstinline!TemplateBindingExtensions!}) to bind template
visual properties to the templated control.

\begin{lstlisting}
return new Border
{
    Background = Brushes.White,
    [!Border.BackgroundProperty] = parent.GetTemplateBinding(ContentControl.BackgroundProperty),
    Child = new ContentPresenter()
};
\end{lstlisting}

The \passthrough{\lstinline"[!Property]"} indexer syntax is shorthand
for creating a template binding (enabled by the
\passthrough{\lstinline!Avalonia.Markup.Declarative!} helpers). If you
prefer explicit code, use
\passthrough{\lstinline!TemplateBindingExtensions.Bind!}:

\begin{lstlisting}
var presenter = new ContentPresenter();
presenter.Bind(ContentPresenter.ContentProperty, parent.GetTemplateBinding(ContentControl.ContentProperty));
\end{lstlisting}

\passthrough{\lstinline!TemplateBindingExtensions.cs!} shows this helper
returns a lightweight binding linked to the templated parent's property
value.

\subsection{\texorpdfstring{2. Data templates with
\texttt{FuncDataTemplate}}{2. Data templates with FuncDataTemplate}}\label{data-templates-with-funcdatatemplate}

\passthrough{\lstinline!FuncDataTemplate<T>!} (source:
\passthrough{\lstinline!FuncDataTemplate.cs!}) creates visuals for data
items. Often you assign it to
\passthrough{\lstinline!ContentControl.ContentTemplate!} or
\passthrough{\lstinline!ItemsControl.ItemTemplate!}.

\begin{lstlisting}
var itemTemplate = new FuncDataTemplate<OrderItem>((item, _) =>
    new Border
    {
        Margin = new Thickness(0, 0, 0, 12),
        Child = new StackPanel
        {
            Orientation = Orientation.Horizontal,
            Spacing = 12,
            Children =
            {
                new TextBlock { Text = item.ProductName, FontWeight = FontWeight.SemiBold },
                new TextBlock { Text = item.Quantity.ToString() }
            }
        }
    }, recycle: true);
\end{lstlisting}

Pass \passthrough{\lstinline!recycle: true!} to participate in
virtualization (controls are reused). Attach to an
\passthrough{\lstinline!ItemsControl!}:

\begin{lstlisting}
itemsControl.ItemTemplate = itemTemplate;
\end{lstlisting}

\subsubsection{Binding inside data
templates}\label{binding-inside-data-templates}

Because the template receives the data item, you can access its
properties directly or create bindings relative to the template context.

\begin{lstlisting}
var template = new FuncDataTemplate<Customer>((item, scope) =>
{
    var balance = new TextBlock();
    balance.Bind(TextBlock.TextProperty, new Binding("Balance")
    {
        StringFormat = "{0:C}"
    });

    return new StackPanel
    {
        Children =
        {
            new TextBlock { Text = item.Name },
            balance
        }
    };
});
\end{lstlisting}

\passthrough{\lstinline!FuncDataTemplate!} sets the
\passthrough{\lstinline!DataContext!} to the item automatically, so
bindings with explicit paths work without additional setup.

\subsubsection{Template selectors}\label{template-selectors}

\passthrough{\lstinline!FuncDataTemplate!} supports predicates for
conditional templates. Use the overload that accepts a
\passthrough{\lstinline!Func<object?, bool>!} predicate.

\begin{lstlisting}
var positiveTemplate = new FuncDataTemplate<Transaction>((item, _) => CreateTransactionRow(item));
var negativeTemplate = new FuncDataTemplate<Transaction>((item, _) => CreateTransactionRow(item, isDebit: true));

var selector = new FuncDataTemplate<Transaction>((item, _) =>
    (item.Amount >= 0 ? positiveTemplate.Build(item) : negativeTemplate.Build(item))!,
    supportsRecycling: true);
\end{lstlisting}

For more complex selection logic, implement
\passthrough{\lstinline!IDataTemplate!} manually or use
\passthrough{\lstinline!DataTemplateSelector!} base classes from
community packages.

\subsection{\texorpdfstring{3. Hierarchical templates with
\texttt{FuncTreeDataTemplate}}{3. Hierarchical templates with FuncTreeDataTemplate}}\label{hierarchical-templates-with-functreedatatemplate}

\passthrough{\lstinline!FuncTreeDataTemplate<T>!} builds item templates
for hierarchical data such as tree views. It receives the item and a
recursion function.

\begin{lstlisting}
var treeTemplate = new FuncTreeDataTemplate<DirectoryNode>((item, _) =>
    new StackPanel
    {
        Orientation = Orientation.Horizontal,
        Children =
        {
            new TextBlock { Text = item.Name }
        }
    },
    x => x.Children,
    true);

var treeView = new TreeView
{
    Items = fileSystem.RootNodes,
    ItemTemplate = treeTemplate
};
\end{lstlisting}

The third argument is \passthrough{\lstinline!supportsRecycling!}. The
second argument is the accessor returning child items. This mirrors
XAML's
\passthrough{\lstinline!<TreeDataTemplate ItemsSource="\{Binding Children\}">!}.

\passthrough{\lstinline!FuncTreeDataTemplate!} internally wires
\passthrough{\lstinline!TreeDataTemplate!} with lambda-based factories,
so you get the same virtualization behaviour as XAML templates.

\subsection{4. Instanced bindings and indexer
tricks}\label{instanced-bindings-and-indexer-tricks}

\passthrough{\lstinline!InstancedBinding!} (source:
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Data/Core/InstancedBinding.cs!})
lets you precompute a binding for a known source. It's powerful when a
template needs to bind to an item-specific property or when you assemble
UI from graphs.

\begin{lstlisting}
var binding = new Binding("Metrics[\"Total\"]") { Mode = BindingMode.OneWay };
var instanced = InstancedBinding.OneWay(binding, metricsDictionary);

var text = new TextBlock();
text.Bind(text.TextProperty, instanced);
\end{lstlisting}

Because you supply the source
(\passthrough{\lstinline!metricsDictionary!}), the binding bypasses
\passthrough{\lstinline!DataContext!}. This is useful in templates where
you juggle multiple sources (e.g., templated parent + external service).

\subsubsection{Binding to template parts via
indexers}\label{binding-to-template-parts-via-indexers}

Within templates you can reference named parts registered through
\passthrough{\lstinline!scope.RegisterNamed!}. After applying the
template, resolve them via
\passthrough{\lstinline!TemplateAppliedEventArgs!}.

\begin{lstlisting}
protected override void OnApplyTemplate(TemplateAppliedEventArgs e)
{
    base.OnApplyTemplate(e);
    _presenter = e.NameScope.Find<ContentPresenter>("PART_ContentPresenter");
}
\end{lstlisting}

From code-first templates, ensure the name scope registration occurs
inside the template lambda as shown earlier.

\subsection{5. Swapping templates at
runtime}\label{swapping-templates-at-runtime}

Because templates are just CLR objects, you can replace them dynamically
to support different visual representations.

\begin{lstlisting}
public void UseCompactTemplates(Window window)
{
    window.Resources["CardTemplate"] = Templates.CompactCard;
    window.Resources["ListItemTemplate"] = Templates.CompactListItem;

    foreach (var presenter in window.GetVisualDescendants().OfType<ContentPresenter>())
    {
        presenter.UpdateChild(); // apply new template
    }
}
\end{lstlisting}

\passthrough{\lstinline!ContentPresenter.UpdateChild()!} forces the
presenter to re-evaluate its template.
\passthrough{\lstinline!GetVisualDescendants!} comes from
\passthrough{\lstinline!VisualTreeExtensions!}. Consider performance:
only call on affected presenters.

Use \passthrough{\lstinline!IStyle!} triggers or the view-model to
change templates automatically. Example using a binding:

\begin{lstlisting}
contentControl.Bind(ContentControl.ContentTemplateProperty, new Binding("SelectedTemplate")
{
    Mode = BindingMode.OneWay
});
\end{lstlisting}

The view-model exposes
\passthrough{\lstinline!IDataTemplate SelectedTemplate!}, and your
code-first view updates this property to switch visuals.

\subsection{6. Component factories and
virtualization}\label{component-factories-and-virtualization}

\subsubsection{Control factories}\label{control-factories}

Wrap template logic in factories that accept data and return controls,
useful for plugin systems.

\begin{lstlisting}
public interface IWidgetFactory
{
    bool CanHandle(string widgetType);
    Control Create(IWidgetContext context);
}

public sealed class ChartWidgetFactory : IWidgetFactory
{
    public bool CanHandle(string widgetType) => widgetType == "chart";

    public Control Create(IWidgetContext context)
    {
        return new Border
        {
            Child = new ChartControl { DataContext = context.Data }
        };
    }
}
\end{lstlisting}

Register factories and pick one at runtime:

\begin{lstlisting}
var widget = factories.First(f => f.CanHandle(config.Type)).Create(context);
panel.Children.Add(widget);
\end{lstlisting}

Factories can also emit data templates instead of controls. For
virtualization, return a \passthrough{\lstinline!FuncDataTemplate!} that
participates in recycling.

\subsubsection{Items panel factories}\label{items-panel-factories}

\passthrough{\lstinline!ItemsControl!} allows specifying the
\passthrough{\lstinline!ItemsPanel!} with
\passthrough{\lstinline!FuncTemplate<Panel?>!}. Build them from code to
align virtualization mode with runtime options.

\begin{lstlisting}
itemsControl.ItemsPanel = new FuncTemplate<Panel?>(() =>
    new VirtualizingStackPanel
    {
        Orientation = Orientation.Vertical,
        VirtualizationMode = ItemVirtualizationMode.Simple
    });
\end{lstlisting}

\passthrough{\lstinline!FuncTemplate<T>!} lives in
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Templates/FuncTemplate.cs!}
and returns a new panel per items presenter.

\subsubsection{\texorpdfstring{Recycling with
\texttt{RecyclingElementFactory}}{Recycling with RecyclingElementFactory}}\label{recycling-with-recyclingelementfactory}

Avalonia's element factories provide direct control over virtualization
(see
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Controls/Generators/!}).
You can use \passthrough{\lstinline!RecyclingElementFactory!} and supply
templates via \passthrough{\lstinline!IDataTemplate!} implementations
defined in code.

\begin{lstlisting}
var factory = new RecyclingElementFactory
{
    RecycleKey = "Widget",
    Template = new FuncDataTemplate<IWidgetViewModel>((item, _) => WidgetFactory.CreateControl(item))
};

var items = new ItemsRepeater { ItemTemplate = factory };
\end{lstlisting}

\passthrough{\lstinline!ItemsRepeater!} (in
\passthrough{\lstinline!Avalonia.Controls!}) mirrors WinUI's control.
Providing a factory integrates with virtualization surfaces better than
raw \passthrough{\lstinline!ItemsControl!} in performance-sensitive
scenarios.

\subsection{7. Testing templates and
factories}\label{testing-templates-and-factories}

\begin{itemize}
\tightlist
\item
  \textbf{Unit tests}: Use
  \passthrough{\lstinline!FuncDataTemplate.Build(item)!} to materialize
  the control tree in memory and assert shape/values.
\end{itemize}

\begin{lstlisting}
[Fact]
public void Order_item_template_renders_quantity()
{
    var template = Templates.OrderItem;
    var control = (Control)template.Build(new OrderItem { Quantity = 5 }, null)!;

    control.GetVisualDescendants().OfType<TextBlock>().Should().Contain(t => t.Text == "5");
}
\end{lstlisting}

\begin{itemize}
\tightlist
\item
  \textbf{Headless rendering}: Combine with Chapter 40 to capture
  template output bitmaps.
\item
  \textbf{Name scope checks}: After applying control templates, call
  \passthrough{\lstinline!TemplateAppliedEventArgs.NameScope.Find!} in
  tests to guarantee required parts exist.
\end{itemize}

\subsection{8. Practice lab}\label{practice-lab-3}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Card control template} -- Build a
  \passthrough{\lstinline!FuncControlTemplate!} for a
  \passthrough{\lstinline!CardControl!} that registers named parts, uses
  template bindings for background/content, and applies to multiple
  instances with different content.
\item
  \textbf{Conditional data templates} -- Create templates for
  \passthrough{\lstinline!IssueViewModel!} that render differently based
  on \passthrough{\lstinline!IsClosed!}. Swap templates dynamically by
  changing a property on the view-model.
\item
  \textbf{Hierarchical explorer} -- Compose a
  \passthrough{\lstinline!TreeView!} for file system data using
  \passthrough{\lstinline!FuncTreeDataTemplate!}, including icons and
  lazy loading. Ensure child collections load on demand.
\item
  \textbf{Template factory registry} -- Implement a registry of
  \passthrough{\lstinline!IDataTemplate!} factories keyed by type names.
  Resolve templates at runtime and verify virtualization with an
  \passthrough{\lstinline!ItemsRepeater!} in a headless test.
\item
  \textbf{Template swap diagnostics} -- Write a helper that re-applies
  templates when theme changes occur, logging how many presenters were
  updated. Ensure the log stays small by limiting scope to affected
  regions.
\end{enumerate}

By mastering code-based templates, indexers, and factories, you gain
full control over Avalonia's presentation layer without depending on
XAML. Combine these techniques with the binding and layout patterns from
earlier chapters to build highly dynamic, testable UI modules in pure
C\#.

What's next - Next: \href{Chapter37.md}{Chapter37}

\newpage

\subsection{37. Reactive patterns, helpers, and tooling for code-first
teams}\label{reactive-patterns-helpers-and-tooling-for-code-first-teams}

Goal - Combine Avalonia's property system with reactive libraries
(ReactiveUI, DynamicData) entirely from C\#. - Build helper extensions
for behaviours, pseudo-classes, transitions, and animation triggers
without XAML. - Integrate diagnostics and hot-reload-style tooling that
keeps developer loops tight in code-first workflows.

Why this matters - Code-first projects often favour reactive patterns to
keep UI logic composable and testable. - Avalonia exposes rich helper
APIs (\passthrough{\lstinline!Classes!},
\passthrough{\lstinline!PseudoClasses!},
\passthrough{\lstinline!Transitions!},
\passthrough{\lstinline!Interaction!}) that work perfectly in C\# once
you know where to look. - Tooling such as DevTools, live reload, and
logging remain essential even without XAML; wiring them programmatically
ensures parity with markup-heavy projects.

Prerequisites - Chapter 33--36 for code-first startup, layouts,
bindings, and templates. - Chapter 29 (animations) and Chapter 24
(DevTools) for background on transitions and diagnostics. - Working
familiarity with ReactiveUI/DynamicData if you plan to reuse those
patterns.

\subsection{1. Reactive building blocks in
Avalonia}\label{reactive-building-blocks-in-avalonia}

Avalonia's property system already supports observables.
\passthrough{\lstinline!AvaloniaObject!} exposes
\passthrough{\lstinline!GetObservable!} and
\passthrough{\lstinline!GetPropertyChangedObservable!} so you can build
reactive pipelines without XAML triggers.

\begin{lstlisting}
var textBox = new TextBox();
textBox.GetObservable(TextBox.TextProperty)
    .Throttle(TimeSpan.FromMilliseconds(250), RxApp.MainThreadScheduler)
    .DistinctUntilChanged()
    .Subscribe(text => _search.Execute(text));
\end{lstlisting}

Use \passthrough{\lstinline!ObserveOn(RxApp.MainThreadScheduler)!} to
marshal onto the UI thread when subscribing. For non-ReactiveUI
projects, use \passthrough{\lstinline!DispatcherScheduler.Current!}
(from \passthrough{\lstinline!Avalonia.Reactive!}) or
\passthrough{\lstinline!Dispatcher.UIThread.InvokeAsync!} inside the
observer.

\subsubsection{Connecting to ReactiveUI
view-models}\label{connecting-to-reactiveui-view-models}

ReactiveUI view-models usually expose
\passthrough{\lstinline!ReactiveCommand!} and
\passthrough{\lstinline!ObservableAsPropertyHelper!}. Bind them as
usual, but you can also subscribe directly:

\begin{lstlisting}
var vm = new DashboardViewModel();
vm.WhenAnyValue(x => x.IsLoading)
  .ObserveOn(RxApp.MainThreadScheduler)
  .Subscribe(isLoading => spinner.IsVisible = isLoading);
\end{lstlisting}

\passthrough{\lstinline!WhenAnyValue!} is extension from
\passthrough{\lstinline!ReactiveUI!}. For code-first views, you may
bridge them via constructor injection, ensuring the view wires
observable pipelines in its constructor or
\passthrough{\lstinline!OnAttachedToVisualTree!} lifecycle methods.

\subsubsection{DynamicData for
collections}\label{dynamicdata-for-collections}

DynamicData shines when projecting observable collections into
UI-friendly lists.

\begin{lstlisting}
var source = new SourceList<ItemViewModel>();
var bindingList = source.Connect()
    .Filter(item => item.IsEnabled)
    .Sort(SortExpressionComparer<ItemViewModel>.Descending(x => x.CreatedAt))
    .ObserveOn(RxApp.MainThreadScheduler)
    .Bind(out var items)
    .Subscribe();

listBox.Items = items;
\end{lstlisting}

Dispose the subscription when the control unloads to prevent leaks
(e.g., store \passthrough{\lstinline!IDisposable!} and dispose in
\passthrough{\lstinline!DetachedFromVisualTree!}).

\subsection{\texorpdfstring{2. Working with \texttt{Classes} and
\texttt{PseudoClasses}}{2. Working with Classes and PseudoClasses}}\label{working-with-classes-and-pseudoclasses}

\passthrough{\lstinline!Classes!} and
\passthrough{\lstinline!PseudoClasses!} collections (defined in
\passthrough{\lstinline!Avalonia.Styling!}) let you toggle CSS-like
states entirely from C\#.

\begin{lstlisting}
var panel = new Border();
panel.Classes.Add("card"); // corresponds to :class selectors in styles

panel.PseudoClasses.Set(":active", true);
\end{lstlisting}

Use helpers to line up state changes with view-model events:

\begin{lstlisting}
vm.WhenAnyValue(x => x.IsSelected)
  .Subscribe(selected => panel.Classes.Toggle("selected", selected));
\end{lstlisting}

\passthrough{\lstinline!Toggle!} is an extension you can write:

\begin{lstlisting}
public static class ClassExtensions
{
    public static void Toggle(this Classes classes, string name, bool add)
    {
        if (add)
            classes.Add(name);
        else
            classes.Remove(name);
    }
}
\end{lstlisting}

\subsubsection{\texorpdfstring{Behaviours from
\texttt{Avalonia.Interactivity}}{Behaviours from Avalonia.Interactivity}}\label{behaviours-from-avalonia.interactivity}

\passthrough{\lstinline!Interaction!} (in
\passthrough{\lstinline!external/Avalonia/src/Avalonia.Interactivity/Interaction.cs!})
provides behaviour collections similar to WPF. You can attach behaviours
programmatically via \passthrough{\lstinline!Interaction.SetBehaviors!}.

\begin{lstlisting}
Interaction.SetBehaviors(listBox, new BehaviorCollection
{
    new SelectOnPointerOverBehavior()
});
\end{lstlisting}

Behaviours are regular classes implementing
\passthrough{\lstinline!IBehavior!}. Author your own to encapsulate
complex logic like drag-to-reorder.

\subsection{3. Transitions, animations, and reactive
triggers}\label{transitions-animations-and-reactive-triggers}

\passthrough{\lstinline!Transitions!} collection (from
\passthrough{\lstinline!Avalonia.Animation!}) lives on
\passthrough{\lstinline!Control!}. Build transitions and hook them
dynamically.

\begin{lstlisting}
panel.Transitions = new Transitions
{
    new DoubleTransition
    {
        Property = Border.OpacityProperty,
        Duration = TimeSpan.FromMilliseconds(200),
        Easing = new CubicEaseOut()
    }
};
\end{lstlisting}

Activate transitions via property setters:

\begin{lstlisting}
vm.WhenAnyValue(x => x.ShowDetails)
  .Subscribe(show => panel.Opacity = show ? 1 : 0);
\end{lstlisting}

The change triggers the transition. Because transitions live on the
control, you can swap them per theme or feature by replacing the
\passthrough{\lstinline!Transitions!} collection at runtime.

\subsubsection{Animation helpers}\label{animation-helpers}

\passthrough{\lstinline!Animatable.BeginAnimation!} (from
\passthrough{\lstinline!AnimationExtensions!}) lets you trigger
storyboards without styles:

\begin{lstlisting}
panel.BeginAnimation(Border.OpacityProperty, new Animation
{
    Duration = TimeSpan.FromMilliseconds(400),
    Easing = new SineEaseInOut(),
    Children =
    {
        new KeyFrames
        {
            new KeyFrame { Cue = new Cue(0d), Setters = { new Setter(Border.OpacityProperty, 0d) } },
            new KeyFrame { Cue = new Cue(1d), Setters = { new Setter(Border.OpacityProperty, 1d) } }
        }
    }
});
\end{lstlisting}

Encapsulate animations into factory methods for reuse across views.

\subsection{4. Hot reload and state persistence
helpers}\label{hot-reload-and-state-persistence-helpers}

While Avalonia's XAML Previewer focuses on markup, code-first workflows
can approximate hot reload using: -
\textbf{\passthrough{\lstinline!DevTools!}}:
\passthrough{\lstinline!AttachDevTools()!} on the main window or
\passthrough{\lstinline!AppBuilder!} (see
\passthrough{\lstinline!ApplicationLifetimes!}). -
\textbf{\passthrough{\lstinline!Avalonia.ReactiveUI!} HotReload}
packages or community tooling for reloading compiled assemblies. -
\textbf{State persistence}: store view-model state in services to
rehydrate UI after code changes.

Enable DevTools programmatically in debug builds:

\begin{lstlisting}
if (Debugger.IsAttached)
{
    this.AttachDevTools();
}
\end{lstlisting}

For headless tests, log control trees after creation to confirm state
without UI.

\subsection{5. Diagnostics pipelines}\label{diagnostics-pipelines}

Integrate logging by observing key properties and commands.

\begin{lstlisting}
var subscription = panel.GetPropertyChangedObservable(Border.OpacityProperty)
    .Subscribe(args => _logger.Debug("Opacity changed from {Old} to {New}", args.OldValue, args.NewValue));
\end{lstlisting}

Tie into Avalonia's diagnostics overlays (Chapter 24) by enabling them
in code-first startup:

\begin{lstlisting}
if (Debugger.IsAttached)
{
    RenderOptions.ProcessRenderOperations = true;
    RendererDiagnostics.DebugOverlays = RendererDebugOverlays.Fps | RendererDebugOverlays.Layout;
}
\end{lstlisting}

\subsection{6. Putting it together: Building reusable helper
libraries}\label{putting-it-together-building-reusable-helper-libraries}

Create a shared library of helpers tailored to your code-first patterns:

\begin{lstlisting}
public static class ReactiveControlHelpers
{
    public static IDisposable BindState<TViewModel>(this TViewModel vm, Control control,
        Expression<Func<TViewModel, bool>> property, string pseudoClass)
    {
        return vm.WhenAnyValue(property)
            .ObserveOn(RxApp.MainThreadScheduler)
            .Subscribe(value => control.PseudoClasses.Set(pseudoClass, value));
    }
}
\end{lstlisting}

Use it in views:

\begin{lstlisting}
_disposables.Add(vm.BindState(this, x => x.IsActive, ":active"));
\end{lstlisting}

Maintain a \passthrough{\lstinline!CompositeDisposable!} on the view to
dispose subscriptions when the view unloads. Override
\passthrough{\lstinline!OnAttachedToVisualTree!}/\passthrough{\lstinline!OnDetachedFromVisualTree!}
to manage lifetime.

\subsection{7. Practice lab}\label{practice-lab-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Reactive state toggles} -- Implement a helper that watches
  \passthrough{\lstinline!WhenAnyValue!} on a view-model and toggles
  \passthrough{\lstinline!Classes!} on a panel. Verify with headless
  tests that pseudo-class changes propagate to styles.
\item
  \textbf{Transition kit} -- Build a factory returning
  \passthrough{\lstinline!Transitions!} configured per theme (e.g., fast
  vs.~slow). Swap collections at runtime and instrument the effect with
  property observers.
\item
  \textbf{Behavior registry} -- Create a behaviour that wires
  \passthrough{\lstinline!PointerMoved!} events into an observable
  stream. Use it to implement drag selection without code-behind
  duplication.
\item
  \textbf{Diagnostic dashboard} -- Add DevTools and renderer overlays
  programmatically. Expose a keyboard shortcut (ReactiveCommand) that
  toggles them during development.
\item
  \textbf{Hot reload simulation} -- Persist view-model state to a
  service, tear down the view, rebuild it from code, and reapply state
  to mimic live-edit workflows. Assert via unit test that state survives
  the rebuild.
\end{enumerate}

Reactive helper patterns ensure code-first Avalonia apps stay
expressive, maintainable, and observable. By leveraging observables,
behaviours, transitions, and tooling APIs directly from C\#, your team
keeps the productivity of markup-driven workflows while embracing the
flexibility of a single-language stack.

What's next - Next: \href{Chapter38.md}{Chapter38}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part VIII — Headless unit testing that gives confidence}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part VIII — Headless unit testing that gives confidence}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{38. Headless platform fundamentals and
lifetimes}\label{headless-platform-fundamentals-and-lifetimes}

Goal - Run Avalonia apps without a windowing system so tests, previews,
and automation can execute in CI. - Configure headless lifetimes,
services, and render loops to mimic production behaviour while remaining
deterministic. - Understand the knobs provided by
\passthrough{\lstinline!Avalonia.Headless!} so you can toggle Skia
rendering, timers, and focus/input handling on demand.

Why this matters - Headless execution unlocks fast feedback loops:
BDD/UI unit tests, snapshot rendering, and tooling all rely on it. - CI
agents rarely expose desktops or GPUs; the headless backend gives you a
predictable environment across Windows, macOS, and Linux. - Knowing the
lifetimes and options ensures app startup mirrors real
targets---preventing bugs that only appear when the full desktop
lifetime runs.

Prerequisites - Chapter 4 (startup and lifetimes) for the
\passthrough{\lstinline!AppBuilder!} pipeline. - Chapter 33 (code-first
startup) for wiring services/resources without XAML. - Chapter 21
(Headless and testing overview) for the bigger picture of test tooling.

\subsection{1. Meet the headless
platform}\label{meet-the-headless-platform}

The headless backend lives in
\passthrough{\lstinline!external/Avalonia/src/Headless/Avalonia.Headless!}.
You enable it by calling \passthrough{\lstinline!UseHeadless()!} on
\passthrough{\lstinline!AppBuilder!}.

\begin{lstlisting}
using Avalonia;
using Avalonia.Headless;
using Avalonia.Themes.Fluent;

public static class Program
{
    public static AppBuilder BuildAvaloniaApp(bool enableSkia = false)
        => AppBuilder.Configure<App>()
            .UseHeadless(new AvaloniaHeadlessPlatformOptions
            {
                UseHeadlessDrawing = !enableSkia,
                UseSkia = enableSkia,
                AllowEglInitialization = false,
                PreferDispatcherScheduling = true
            })
            .LogToTrace();
}
\end{lstlisting}

Key extension:
\passthrough{\lstinline!AvaloniaHeadlessAppBuilderExtensions.UseHeadless!}
registers platform services, render loop, and input plumbing. Options: -
\passthrough{\lstinline!UseHeadlessDrawing!}: if
\passthrough{\lstinline!true!}, renders to an in-memory framebuffer
without Skia. - \passthrough{\lstinline!UseSkia!}: when
\passthrough{\lstinline!true!}, create a Skia GPU context (requires
\passthrough{\lstinline!UseHeadlessDrawing = false!}). -
\passthrough{\lstinline!AllowEglInitialization!}: opt-in to EGL for
hardware acceleration when available. -
\passthrough{\lstinline!PreferDispatcherScheduling!}: ensures timers
queue work via \passthrough{\lstinline!Dispatcher!} instead of busy
loops.

Because \passthrough{\lstinline!UseHeadless()!} skips
\passthrough{\lstinline!UsePlatformDetect()!}, call it explicitly in
tests. For hybrid apps, provide a
\passthrough{\lstinline!BuildAvaloniaApp!} overload that chooses
headless vs.~desktop based on environment.

\subsection{2. Lifetimes built for
tests}\label{lifetimes-built-for-tests}

Headless apps use \passthrough{\lstinline!HeadlessLifetime!} (see
\passthrough{\lstinline!Avalonia.Headless/HeadlessLifetime.cs!}). It
mimics \passthrough{\lstinline!IClassicDesktopStyleApplicationLifetime!}
but never opens OS windows.

\begin{lstlisting}
public sealed class TestApp : Application
{
    public override void OnFrameworkInitializationCompleted()
    {
        if (ApplicationLifetime is HeadlessLifetime lifetime)
        {
            lifetime.MainView = new MainView { DataContext = new MainViewModel() };
        }

        base.OnFrameworkInitializationCompleted();
    }
}
\end{lstlisting}

\passthrough{\lstinline!HeadlessLifetime!} exposes: -
\passthrough{\lstinline!MainView!}: root visual displayed inside the
headless window implementation. - \passthrough{\lstinline!Start()!},
\passthrough{\lstinline!Stop()!}: manual control for test harnesses. -
\passthrough{\lstinline!Parameters!}: mirrors command-line args.

You can also use \passthrough{\lstinline!SingleViewLifetime!}
(\passthrough{\lstinline!Avalonia.Controls/ApplicationLifetimes/ISingleViewApplicationLifetime.cs!})
for mobile-like scenarios. Headless tests frequently wire both so code
mirrors production flows.

\subsubsection{Switching lifetimes per
environment}\label{switching-lifetimes-per-environment}

\begin{lstlisting}
var builder = Program.BuildAvaloniaApp(enableSkia: true);

if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux) && IsCiAgent)
{
    builder.SetupWithoutStarting();
    using var lifetime = new HeadlessLifetime();
    builder.Instance?.ApplicationLifetime = lifetime;
    lifetime.Start();
}
else
{
    builder.StartWithClassicDesktopLifetime(args);
}
\end{lstlisting}

\passthrough{\lstinline!SetupWithoutStarting()!} (from
\passthrough{\lstinline!AppBuilderBase!}) initializes the app without
running the run loop, allowing you to plug in custom lifetimes.

\subsection{3. Headless application sessions for test
frameworks}\label{headless-application-sessions-for-test-frameworks}

\passthrough{\lstinline!HeadlessUnitTestSession!} (source:
\passthrough{\lstinline!Avalonia.Headless/HeadlessUnitTestSession.cs!})
coordinates app startup across tests so each fixture doesn't rebuild the
runtime.

\subsubsection{NUnit integration}\label{nunit-integration}

\passthrough{\lstinline!Avalonia.Headless.NUnit!} ships attributes
(\passthrough{\lstinline![AvaloniaTest]!},
\passthrough{\lstinline![AvaloniaTheory]!}) that wrap tests in a
session. Example test fixture:

\begin{lstlisting}
[AvaloniaTest(Application = typeof(TestApp))]
public class CounterTests
{
    [Test]
    public void Clicking_increment_updates_label()
    {
        using var app = HeadlessUnitTestSession.Start<App>();
        var window = new MainWindow { DataContext = new MainViewModel() };
        window.Show();

        window.FindControl<Button>("IncrementButton")!.RaiseEvent(new RoutedEventArgs(Button.ClickEvent));

        window.FindControl<TextBlock>("CounterLabel")!.Text.Should().Be("1");
    }
}
\end{lstlisting}

\passthrough{\lstinline!HeadlessUnitTestSession.Start<TApp>()!} spins up
the shared app and dispatcher. \passthrough{\lstinline!FindControl!}
works because the visual tree exists even though no OS window renders.

\subsubsection{xUnit integration}\label{xunit-integration}

\passthrough{\lstinline!Avalonia.Headless.XUnit!} provides
\passthrough{\lstinline![AvaloniaFact]!} and
\passthrough{\lstinline![AvaloniaTheory]!} attributes. Decorate your
test class with \passthrough{\lstinline![CollectionDefinition]!} to
ensure single app instance per collection when running in parallel.

\subsection{4. Dispatcher, render loops, and
timing}\label{dispatcher-render-loops-and-timing}

Headless rendering still uses Avalonia's dispatcher and render loop.
\passthrough{\lstinline!HeadlessWindowImpl!} (source:
\passthrough{\lstinline!Avalonia.Headless/HeadlessWindowImpl.cs!})
implements \passthrough{\lstinline!IWindowImpl!} with an in-memory
framebuffer. Understanding its behaviour is crucial for deterministic
tests.

\subsubsection{Forcing layout/render
ticks}\label{forcing-layoutrender-ticks}

Headless tests don't run an infinite loop unless you start it. Use
\passthrough{\lstinline!AvaloniaHeadlessPlatform.ForceRenderTimerTick()!}
to advance timers manually.

\begin{lstlisting}
public static void RenderFrame(TopLevel topLevel)
{
    AvaloniaHeadlessPlatform.ForceRenderTimerTick();
    topLevel.RunJobsOnMainThread();
}
\end{lstlisting}

\passthrough{\lstinline!RunJobsOnMainThread()!} is a helper extension
defined in \passthrough{\lstinline!HeadlessWindowExtensions!}. It drains
pending dispatcher work and ensures layout/render happens before
assertions.

\subsubsection{Simulating async work}\label{simulating-async-work}

Combine \passthrough{\lstinline!Dispatcher.UIThread.InvokeAsync!} with
\passthrough{\lstinline!ForceRenderTimerTick!} to await UI updates:

\begin{lstlisting}
await Dispatcher.UIThread.InvokeAsync(() => viewModel.LoadAsync());
AvaloniaHeadlessPlatform.ForceRenderTimerTick();
\end{lstlisting}

In tests, call \passthrough{\lstinline!Dispatcher.UIThread.RunJobs()!}
to flush pending tasks (extension in
\passthrough{\lstinline!Avalonia.Headless!} as well).

\subsection{5. Input, focus, and window
services}\label{input-focus-and-window-services}

\passthrough{\lstinline!HeadlessWindowImpl!} implements
\passthrough{\lstinline!IHeadlessWindow!}, exposing methods to simulate
input:

\begin{lstlisting}
var topLevel = new Window();
var headless = (IHeadlessWindow)topLevel.PlatformImpl!;

headless.MouseMove(new Point(50, 30), RawInputModifiers.None);
headless.MouseDown(new Point(50, 30), MouseButton.Left, RawInputModifiers.LeftMouseButton);
headless.MouseUp(new Point(50, 30), MouseButton.Left, RawInputModifiers.LeftMouseButton);
\end{lstlisting}

Use extension methods from
\passthrough{\lstinline!HeadlessWindowExtensions!} (e.g.,
\passthrough{\lstinline!Click(Point)!}) to simplify. Focus management
works: call \passthrough{\lstinline!topLevel.Focus()!} or
\passthrough{\lstinline!KeyboardDevice.Instance.SetFocusedElement!}.

Services like storage providers or dialogs aren't available by default.
If your app depends on them, register test doubles in
\passthrough{\lstinline!Application.RegisterServices()!}:

\begin{lstlisting}
protected override void RegisterServices()
{
    var services = AvaloniaLocator.CurrentMutable;
    services.Bind<IPlatformLifetimeEvents>().ToConstant(new TestLifetimeEvents());
    services.Bind<IClipboard>().ToSingleton<HeadlessClipboard>();
}
\end{lstlisting}

\passthrough{\lstinline!Avalonia.Headless!} already provides
\passthrough{\lstinline!HeadlessClipboard!},
\passthrough{\lstinline!HeadlessCursorFactory!}, and other minimal
implementations; inspect \passthrough{\lstinline!Avalonia.Headless!}
folder for available services before writing your own.

\subsection{6. Rendering options and Skia
integration}\label{rendering-options-and-skia-integration}

By default headless renders via CPU copy. To generate bitmaps (Chapter
40), enable Skia:

\begin{lstlisting}
var builder = Program.BuildAvaloniaApp(enableSkia: true);
var options = AvaloniaLocator.Current.GetService<AvaloniaHeadlessPlatformOptions>();
\end{lstlisting}

When \passthrough{\lstinline!UseSkia!} is true, the backend creates a
Skia surface per frame. Ensure the CI environment has the necessary
native dependencies (\passthrough{\lstinline!libSkiaSharp!}). If you
stick with \passthrough{\lstinline!UseHeadlessDrawing = true!},
\passthrough{\lstinline!RenderTargetBitmap!} still works but without GPU
acceleration.

\passthrough{\lstinline!HeadlessWindowExtensions.CaptureRenderedFrame(topLevel)!}
captures an \passthrough{\lstinline!IBitmap!} of the latest frame---use
it for snapshot tests.

\subsection{7. Troubleshooting common
issues}\label{troubleshooting-common-issues}

\begin{itemize}
\tightlist
\item
  \textbf{App not initialized}: Ensure
  \passthrough{\lstinline!AppBuilder.Configure<App>()!} runs before
  calling \passthrough{\lstinline!HeadlessUnitTestSession.Start!}.
  Missing static constructor often stems from trimming or linking; mark
  entry point classes with
  \passthrough{\lstinline![assembly: RequiresUnreferencedCode]!} if
  needed.
\item
  \textbf{Dispatcher deadlocks}: Always schedule UI work via
  \passthrough{\lstinline!Dispatcher.UIThread!}. If a test blocks the UI
  thread, there's no OS event loop to bail you out.
\item
  \textbf{Missing services}: Headless backend only registers core
  services. Provide mocks for file dialogs, storage, or notifications.
\item
  \textbf{Time-dependent tests}: When using timers, call
  \passthrough{\lstinline!ForceRenderTimerTick!} repeatedly or provide
  deterministic scheduler wrappers.
\item
  \textbf{Memory leaks}: Dispose windows
  (\passthrough{\lstinline!window.Close()!}) and subscriptions
  (\passthrough{\lstinline!CompositeDisposable!}) after each
  test---headless sessions persist across multiple tests by default.
\end{itemize}

\subsection{8. Practice lab}\label{practice-lab-5}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Headless bootstrap} -- Build a reusable
  \passthrough{\lstinline!HeadlessTestApplication!} that mirrors your
  production \passthrough{\lstinline!App!} styles/resources. Verify
  service registration via unit tests that resolve dependencies from
  \passthrough{\lstinline!AvaloniaLocator!}.
\item
  \textbf{Lifetime switcher} -- Write a helper that starts your app with
  \passthrough{\lstinline!HeadlessLifetime!} when
  \passthrough{\lstinline!DOTNET\_RUNNING\_IN\_CONTAINER!} is set.
  Assert via tests that both classic desktop and headless lifetimes
  share the same
  \passthrough{\lstinline!OnFrameworkInitializationCompleted!} flow.
\item
  \textbf{Deterministic render loop} -- Create a headless fixture that
  mounts a view, updates the view-model, calls
  \passthrough{\lstinline!ForceRenderTimerTick!}, and asserts
  layout/visual changes with zero sleeps.
\item
  \textbf{Input harness} -- Implement extensions wrapping
  \passthrough{\lstinline!IHeadlessWindow!} for click, drag, and
  keyboard simulation. Use them to test complex interactions
  (drag-to-reorder list) without real input devices.
\item
  \textbf{Service fallback} -- Provide headless implementations for
  storage provider and clipboard, inject them in
  \passthrough{\lstinline!RegisterServices!}, and write tests asserting
  your UI handles success/failure cases.
\end{enumerate}

Mastering the headless platform ensures Avalonia apps stay testable,
portable, and CI-friendly. With lifetimes, options, and input surfaces
under your control, you can script rich UI scenarios without ever
opening an OS window.

What's next - Next: \href{Chapter39.md}{Chapter39}

\newpage

\subsection{39. Unit testing view-models and controls
headlessly}\label{unit-testing-view-models-and-controls-headlessly}

Goal - Exercise your UI and view-model logic inside real
\passthrough{\lstinline!Dispatcher!} loops without opening desktop
windows. - Share fixtures and app configuration across xUnit and NUnit
by wiring \passthrough{\lstinline!AvaloniaHeadless!} runners correctly.
- Simulate input, state changes, and async updates deterministically so
assertions stay reliable in CI.

Why this matters - Headless UI tests catch regressions that unit tests
miss while remaining fast enough for continuous builds. - Avalonia's
dispatcher and property system require a running application
instance---adapters handle that for you. - Framework-provided attributes
eliminate flaky cross-thread failures and keep tests close to production
startup paths.

Prerequisites - Chapter 4 for lifetime selection and
\passthrough{\lstinline!AppBuilder!} basics. - Chapter 21 for the
bird's-eye view of headless testing capabilities. - Chapter 38 for
platform options, dispatcher control, and input helpers.

\subsection{1. Pick the headless
harness}\label{pick-the-headless-harness}

Avalonia ships runner glue for xUnit and NUnit so your test bodies
always execute on the UI dispatcher.

\subsubsection{xUnit: opt into the Avalonia test
framework}\label{xunit-opt-into-the-avalonia-test-framework}

Add the assembly-level attribute once and then decorate tests with
\passthrough{\lstinline![AvaloniaFact]!}/\passthrough{\lstinline![AvaloniaTheory]!}.

\begin{lstlisting}
// AssemblyInfo.cs
using Avalonia.Headless;
using Avalonia.Headless.XUnit;

[assembly: AvaloniaTestApplication(typeof(TestApp))]
[assembly: AvaloniaTestFramework]
\end{lstlisting}

\passthrough{\lstinline!AvaloniaTestFramework!} (see
\passthrough{\lstinline!external/Avalonia/src/Headless/Avalonia.Headless.XUnit/AvaloniaTestFramework.cs!})
installs a custom executor that spawns a
\passthrough{\lstinline!HeadlessUnitTestSession!} for the assembly. Each
\passthrough{\lstinline![AvaloniaFact]!} routes through
\passthrough{\lstinline!AvaloniaTestCaseRunner!}, ensuring awaited
continuations re-enter the dispatcher thread.

\subsubsection{\texorpdfstring{NUnit: wrap commands via
\texttt{{[}AvaloniaTest{]}}}{NUnit: wrap commands via {[}AvaloniaTest{]}}}\label{nunit-wrap-commands-via-avaloniatest}

\begin{lstlisting}
using Avalonia.Headless;
using Avalonia.Headless.NUnit;

[assembly: AvaloniaTestApplication(typeof(TestApp))]

public class ButtonSpecs
{
    [SetUp]
    public void OpenApp() => Dispatcher.UIThread.VerifyAccess();

    [AvaloniaTest, Timeout(10000)]
    public void Click_updates_counter()
    {
        var window = new Window();
        // ...
    }
}
\end{lstlisting}

\passthrough{\lstinline!AvaloniaTestAttribute!} swaps NUnit's command
pipeline with \passthrough{\lstinline!AvaloniaTestMethodCommand!}
(\passthrough{\lstinline!external/Avalonia/src/Headless/Avalonia.Headless.NUnit/AvaloniaTestMethodCommand.cs!}),
capturing
\passthrough{\lstinline!SetUp!}/\passthrough{\lstinline!TearDown!}
delegates and executing them inside the shared dispatcher.

\subsection{2. Bootstrap the application under
test}\label{bootstrap-the-application-under-test}

The harness needs an entry point that mirrors production startup. Reuse
your \passthrough{\lstinline!BuildAvaloniaApp!} method or author a
lightweight test shell.

\begin{lstlisting}
public class TestApp : Application
{
    public override void OnFrameworkInitializationCompleted()
    {
        Styles.Add(new SimpleTheme());
        base.OnFrameworkInitializationCompleted();
    }

    public static AppBuilder BuildAvaloniaApp() =>
        AppBuilder.Configure<TestApp>()
            .UseSkia()
            .UseHeadless(new AvaloniaHeadlessPlatformOptions
            {
                UseHeadlessDrawing = false, // enable Skia-backed surfaces for rendering checks
                PreferDispatcherScheduling = true
            });
}
\end{lstlisting}

This pattern matches Avalonia's own tests
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.Headless.UnitTests/TestApplication.cs!}).
When the runner detects \passthrough{\lstinline!BuildAvaloniaApp!}, it
invokes it before each dispatch, so your services, themes, and
dependency injection mirror the real app. If your production bootstrap
already includes \passthrough{\lstinline!UseHeadless!}, the harness
respects it; otherwise
\passthrough{\lstinline!HeadlessUnitTestSession.StartNew!} injects
defaults.

\subsection{3. Understand session lifetime and dispatcher
flow}\label{understand-session-lifetime-and-dispatcher-flow}

\passthrough{\lstinline!HeadlessUnitTestSession!}
(\passthrough{\lstinline!external/Avalonia/src/Headless/Avalonia.Headless/HeadlessUnitTestSession.cs!})
is the engine behind both harnesses. Highlights:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!GetOrStartForAssembly!} caches a session per
  test assembly, honoring
  \passthrough{\lstinline![AvaloniaTestApplication]!}.
\item
  \passthrough{\lstinline!Dispatch!}/\passthrough{\lstinline!Dispatch<TResult>!}
  queue work onto the UI thread while keeping NUnit/xUnit's thread
  blocked until completion.
\item
  \passthrough{\lstinline!EnsureApplication()!} recreates the
  \passthrough{\lstinline!AppBuilder!} scope for every dispatched
  action, resetting \passthrough{\lstinline!Dispatcher!} state so tests
  remain isolated.
\end{itemize}

You can opt into manual session control when writing custom runners or
diagnostics:

\begin{lstlisting}
using var session = HeadlessUnitTestSession.StartNew(typeof(TestApp));
await session.Dispatch(async () =>
{
    var window = new Window();
    window.Show();
    await Dispatcher.UIThread.InvokeAsync(() => window.Close());
}, CancellationToken.None);
\end{lstlisting}

Dispose the session at the end of a run to stop the dispatcher loop and
release the blocking queue.

\subsection{4. Mount controls and bind
view-models}\label{mount-controls-and-bind-view-models}

With the dispatcher in place, tests can instantiate real controls,
establish bindings, and observe Avalonia's property system.

\begin{lstlisting}
public class CounterTests
{
    [AvaloniaFact]
    public void Button_click_updates_label()
    {
        var vm = new CounterViewModel();
        var window = new Window
        {
            DataContext = vm,
            Content = new StackPanel
            {
                Children =
                {
                    new Button { Name = "IncrementButton", Command = vm.IncrementCommand },
                    new TextBlock { Name = "CounterLabel", [!TextBlock.TextProperty] = vm.CounterBinding }
                }
            }
        };

        window.Show();
        window.MouseDown(new Point(20, 20), MouseButton.Left);
        window.MouseUp(new Point(20, 20), MouseButton.Left);

        window.FindControl<TextBlock>("CounterLabel")!.Text.Should().Be("1");
        window.Close();
    }
}
\end{lstlisting}

The mouse helpers come from
\passthrough{\lstinline!HeadlessWindowExtensions!}
(\passthrough{\lstinline!external/Avalonia/src/Headless/Avalonia.Headless/HeadlessWindowExtensions.cs!}).
They flush pending dispatcher work before delivering input, then run
jobs again afterward so bindings update before the assertion. Always
\passthrough{\lstinline!Close()!} windows when you finish to keep the
session clean.

\subsection{5. Share fixtures with setup/teardown
hooks}\label{share-fixtures-with-setupteardown-hooks}

Both frameworks let you prepare windows or services per test while
staying on the UI thread.

\begin{lstlisting}
public class InputHarness
#if XUNIT
    : IDisposable
#endif
{
    private readonly Window _window;

#if NUNIT
    [SetUp]
    public void SetUp()
#elif XUNIT
    public InputHarness()
#endif
    {
        Dispatcher.UIThread.VerifyAccess();
        _window = new Window { Width = 100, Height = 100 };
    }

#if NUNIT
    [AvaloniaTest]
#elif XUNIT
    [AvaloniaFact]
#endif
    public void Drag_updates_position()
    {
        _window.Show();
        _window.MouseDown(new Point(10, 10), MouseButton.Left);
        _window.MouseMove(new Point(60, 40));
        _window.MouseUp(new Point(60, 40), MouseButton.Left);
        _window.Position.Should().Be(new PixelPoint(0, 0)); // headless doesn’t move windows automatically
    }

#if NUNIT
    [TearDown]
    public void TearDown()
#elif XUNIT
    public void Dispose()
#endif
    {
        Dispatcher.UIThread.VerifyAccess();
        _window.Close();
    }
}
\end{lstlisting}

The sample mirrors Avalonia's own \passthrough{\lstinline!InputTests!}
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.Headless.UnitTests/InputTests.cs!}).
Use preprocessor guards if you cross-compile the same tests between
xUnit and NUnit packages.

\subsection{6. Keep async work
deterministic}\label{keep-async-work-deterministic}

Headless tests still depend on Avalonia's dispatcher and timers. Prefer
structured helpers over \passthrough{\lstinline!Task.Delay!}.

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!Dispatcher.UIThread.RunJobs()!} drains queued
  operations immediately.
\item
  \passthrough{\lstinline!AvaloniaHeadlessPlatform.ForceRenderTimerTick()!}
  advances layout and render timers---pair it with
  \passthrough{\lstinline!RunJobs()!} when you expect visuals to update.
\item
  \passthrough{\lstinline!DispatcherTimer.RunOnce!} works inside tests;
  the runner ensures the callback fires on the same thread, as shown in
  \passthrough{\lstinline!ThreadingTests!}
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.Headless.UnitTests/ThreadingTests.cs!}).
\end{itemize}

\begin{lstlisting}
[AvaloniaFact]
public async Task Loader_raises_progress()
{
    var progress = 0;
    var loader = new AsyncLoader();

    await Dispatcher.UIThread.InvokeAsync(() => loader.Start());

    while (progress < 100)
    {
        AvaloniaHeadlessPlatform.ForceRenderTimerTick();
        Dispatcher.UIThread.RunJobs();
        progress = loader.Progress;
    }

    progress.Should().Be(100);
}
\end{lstlisting}

If your view-model uses \passthrough{\lstinline!DispatcherTimer!},
expose a hook that ticks manually so tests avoid clock-based flakiness.

\subsection{7. Theories, collections, and
parallelism}\label{theories-collections-and-parallelism}

\passthrough{\lstinline![AvaloniaTheory]!} supports data-driven tests
while staying on the dispatcher. For xUnit, decorate a collection
definition to run related fixtures sequentially:

\begin{lstlisting}
[AvaloniaCollection] // custom marker
public class DialogTests
{
    [AvaloniaTheory]
    [InlineData(false)]
    [InlineData(true)]
    public void Dialog_lifecycle(bool useAsync)
    {
        // ...
    }
}

[CollectionDefinition("AvaloniaCollection", DisableParallelization = true)]
public class AvaloniaCollection : ICollectionFixture<HeadlessFixture> { }
\end{lstlisting}

The custom fixture can preload services or share the
\passthrough{\lstinline!MainView!}. NUnit users can rely on
\passthrough{\lstinline![Apartment(ApartmentState.STA)]!} plus
\passthrough{\lstinline![AvaloniaTest]!} when mixing with other UI
frameworks, but remember Avalonia already enforces a single dispatcher
thread.

\subsection{8. Troubleshooting failures}\label{troubleshooting-failures}

\begin{itemize}
\tightlist
\item
  \textbf{Test never finishes} -- ensure you awaited async work through
  \passthrough{\lstinline!Dispatcher.UIThread!} or
  \passthrough{\lstinline!HeadlessUnitTestSession.Dispatch!}. Background
  tasks without dispatcher access will hang because the harness blocks
  the originating test thread.
\item
  \textbf{Missing services} -- register substitutes in
  \passthrough{\lstinline!Application.RegisterServices()!} before
  calling base initialization. Clipboard, dialogs, or storage require
  headless-friendly implementations (see Chapter 38).
\item
  \textbf{State bleed between tests} -- close all
  \passthrough{\lstinline!TopLevel!}s, dispose
  \passthrough{\lstinline!CompositeDisposable!}s, and avoid static
  view-model singletons. Each dispatched action gets a fresh
  \passthrough{\lstinline!Application!} scope, but stray static caches
  persist.
\item
  \textbf{Random
  \passthrough{\lstinline!InvalidOperationException: VerifyAccess!}} --
  a test ran code on a thread pool thread. Wrap the block in
  \passthrough{\lstinline!Dispatcher.UIThread.InvokeAsync!} or use
  \passthrough{\lstinline!await session.Dispatch(...)!} in custom
  helpers.
\item
  \textbf{Parallel collection deadlocks} -- turn off test parallelism
  when fixtures share windows. xUnit:
  \passthrough{\lstinline![assembly: CollectionBehavior(DisableTestParallelization = true)]!};
  NUnit: \passthrough{\lstinline!--workers=1!} or
  \passthrough{\lstinline![NonParallelizable]!} per fixture.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-6}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Session helper} -- Write a reusable
  \passthrough{\lstinline!HeadlessTestSessionFixture!} exposing
  \passthrough{\lstinline!Dispatch(Func<Task>)!} so plain unit tests can
  invoke dispatcher-bound code without attributes.
\item
  \textbf{View-model assertions} -- Mount a form with compiled bindings,
  trigger \passthrough{\lstinline!BindingOperations!} updates, and
  assert validation errors surface via
  \passthrough{\lstinline!DataValidationErrors.GetErrors!}.
\item
  \textbf{Keyboard automation} -- Use
  \passthrough{\lstinline!HeadlessWindowExtensions.KeyPressQwerty!} to
  simulate typing into a \passthrough{\lstinline!TextBox!}, verify
  selection state, then assert command execution when pressing Enter.
\item
  \textbf{Timer-driven UI} -- Create a progress dialog using
  \passthrough{\lstinline!DispatcherTimer!}. In tests, tick the timer
  manually and assert the dialog closes itself at 100\% without
  sleeping.
\item
  \textbf{Theory matrix} -- Build a
  \passthrough{\lstinline![AvaloniaTheory]!} test that runs the same
  control suite using Classic Desktop vs.~Single View lifetimes by
  swapping \passthrough{\lstinline!HeadlessLifetime.MainView!}. Confirm
  both paths render identical text through
  \passthrough{\lstinline!GetLastRenderedFrame()!}.
\end{enumerate}

What's next - Next: \href{Chapter40.md}{Chapter40}

\newpage

\subsection{40. Rendering verification and pixel
assertions}\label{rendering-verification-and-pixel-assertions}

Goal - Capture deterministic frames from controls and windows so UI
regressions show up as image diffs. - Re-render visuals off-screen with
\passthrough{\lstinline!RenderTargetBitmap!} for pipeline-level
validation without a running window. - Build comparison utilities that
tolerate minor noise while still failing on real regressions.

Why this matters - Visual bugs rarely surface through property
assertions alone; pixel diffs make style and layout drift obvious. - CI
agents run headless---leveraging Avalonia's off-screen renderers keeps
comparison workflows portable. - Consistent capture pipelines simplify
storing baselines, reviewing diffs, and onboarding QA to UI automation.

Prerequisites - Chapter 21 for the overview of headless testing options.
- Chapter 38 for dispatcher control and headless render ticks. - Chapter
39 for running xUnit/NUnit fixtures on the Avalonia dispatcher.

\subsection{1. Capture frames from headless top
levels}\label{capture-frames-from-headless-top-levels}

\passthrough{\lstinline!HeadlessWindowExtensions.CaptureRenderedFrame!}
(\passthrough{\lstinline!external/Avalonia/src/Headless/Avalonia.Headless/HeadlessWindowExtensions.cs:20!})
flushes the dispatcher, ticks the headless timer, and returns a
\passthrough{\lstinline!WriteableBitmap!} of the latest frame. The
helper delegates to \passthrough{\lstinline!GetLastRenderedFrame!},
which requires Skia-backed rendering---set
\passthrough{\lstinline!UseHeadlessDrawing = false!} and
\passthrough{\lstinline!UseSkia = true!} in your test app:

\begin{lstlisting}
public static AppBuilder BuildAvaloniaApp() =>
    AppBuilder.Configure<TestApp>()
        .UseHeadless(new AvaloniaHeadlessPlatformOptions
        {
            UseHeadlessDrawing = false,
            UseSkia = true,
            PreferDispatcherScheduling = true
        });
\end{lstlisting}

Once configured, capture snapshots straight from a headless window:

\begin{lstlisting}
var window = new Window
{
    Content = new ControlCatalogPage(),
    SizeToContent = SizeToContent.WidthAndHeight
};

window.Show();
var frame = window.CaptureRenderedFrame();
Assert.NotNull(frame);
\end{lstlisting}

Avalonia's own regression tests follow this pattern
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.Headless.UnitTests/RenderingTests.cs:18!}).
Use \passthrough{\lstinline!CaptureRenderedFrame!} when you want the
helper to tick timers for you; call
\passthrough{\lstinline!GetLastRenderedFrame!} if you have already
driven the dispatcher manually.

\subsection{\texorpdfstring{2. Render visuals off-screen with
\texttt{RenderTargetBitmap}}{2. Render visuals off-screen with RenderTargetBitmap}}\label{render-visuals-off-screen-with-rendertargetbitmap}

To avoid constructing full windows, target the visual tree directly.
\passthrough{\lstinline!RenderTargetBitmap!} uses
\passthrough{\lstinline!ImmediateRenderer.Render!} under the hood
(\passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Media/Imaging/RenderTargetBitmap.cs:33!}).

\begin{lstlisting}
var root = new Border
{
    Width = 200,
    Height = 120,
    Background = Brushes.CornflowerBlue,
    Child = new TextBlock
    {
        Text = "Hello Avalonia",
        FontSize = 24,
        HorizontalAlignment = HorizontalAlignment.Center,
        VerticalAlignment = VerticalAlignment.Center
    }
};

await Dispatcher.UIThread.InvokeAsync(() => root.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity)));
root.Arrange(new Rect(root.DesiredSize));

using var rtb = new RenderTargetBitmap(new PixelSize(200, 120));
rtb.Render(root);
\end{lstlisting}

The bitmap implements \passthrough{\lstinline!IBitmap!}, so you can save
it, compare pixels, or embed it in diagnostics emails. For complex
compositions, grab a \passthrough{\lstinline!DrawingContext!} from
\passthrough{\lstinline!RenderTargetBitmap.CreateDrawingContext!} to
draw primitive overlays before comparison.

\subsection{3. Compare pixels with configurable
tolerances}\label{compare-pixels-with-configurable-tolerances}

Whether you use \passthrough{\lstinline!CaptureRenderedFrame!} or
\passthrough{\lstinline!RenderTargetBitmap!}, lock the frame buffer to
access raw bytes. \passthrough{\lstinline!WriteableBitmap.Lock()!}
exposes an \passthrough{\lstinline!ILockedFramebuffer!} with stride,
format, and a pointer into the pixel buffer
(\passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Media/Imaging/WriteableBitmap.cs:59!}).

\begin{lstlisting}
public static PixelDiffResult CompareBitmaps(IBitmap expected, IBitmap actual, byte tolerance = 2)
{
    using var left = expected.Lock();
    using var right = actual.Lock();

    if (left.Size != right.Size)
        return PixelDiffResult.SizeMismatch(left.Size, right.Size);

    var failures = new List<PixelDiff>();

    unsafe
    {
        for (var y = 0; y < left.Size.Height; y++)
        {
            var pLeft = (byte*)left.Address + y * left.RowBytes;
            var pRight = (byte*)right.Address + y * right.RowBytes;

            for (var x = 0; x < left.Size.Width; x++)
            {
                var idx = x * 4; // BGRA
                var delta = Math.Max(
                    Math.Abs(pLeft[idx] - pRight[idx]),
                    Math.Max(Math.Abs(pLeft[idx + 1] - pRight[idx + 1]),
                             Math.Abs(pLeft[idx + 2] - pRight[idx + 2])));

                if (delta > tolerance)
                    failures.Add(new PixelDiff(x, y, delta));
            }
        }
    }

    return PixelDiffResult.FromList(failures);
}
\end{lstlisting}

Tune the tolerance to absorb small antialiasing differences. Consider
summing absolute channel differences or using the Delta-E metric when
gradients highlight sub-pixel drift.

\subsubsection{Produce diagnostic
overlays}\label{produce-diagnostic-overlays}

When differences occur, create an error bitmap that highlights only
changed pixels:

\begin{lstlisting}
public static WriteableBitmap CreateDiffMask(IBitmap baseline, PixelDiffResult result)
{
    var size = baseline.PixelSize;
    var diff = new WriteableBitmap(size, baseline.Dpi); // default BGRA32

    using var target = diff.Lock();
    var buffer = new Span<byte>((void*)target.Address, target.RowBytes * size.Height);
    buffer.Clear();

    foreach (var pixel in result.Failures)
    {
        var idx = pixel.Y * target.RowBytes + pixel.X * 4;
        buffer[idx + 0] = 0;          // B
        buffer[idx + 1] = 0;          // G
        buffer[idx + 2] = 255;        // R highlights
        buffer[idx + 3] = 255;        // A
    }

    return diff;
}
\end{lstlisting}

Attach the original frame, baseline, and diff mask to CI artifacts so
reviewers can inspect regressions quickly.

\subsection{4. Manage baselines and golden
images}\label{manage-baselines-and-golden-images}

Golden images can live alongside tests as embedded resources. Load them
via \passthrough{\lstinline!WriteableBitmap.Decode!} and normalize
configuration before comparison:

\begin{lstlisting}
await using var stream = manifestAssembly.GetManifestResourceStream("Tests.Baselines.Dialog.png");
var baseline = WriteableBitmap.Decode(stream!);
\end{lstlisting}

When baselines must be refreshed, capture a new frame and save it to
disk using \passthrough{\lstinline!frame.Save(fileStream)!}. Normalize
DPI and render scaling so new baselines remain cross-platform:

\begin{lstlisting}
var normalized = new RenderTargetBitmap(new PixelSize(800, 600), new Vector(96, 96));
normalized.Render(window);
await using var file = File.Create("Baselines/Dialog.png");
normalized.Save(file);
\end{lstlisting}

\passthrough{\lstinline!RenderTargetBitmapImpl!} uses Skia surfaces
(\passthrough{\lstinline!external/Avalonia/src/Skia/Avalonia.Skia/RenderTargetBitmapImpl.cs:8!}),
so CI agents must have the Skia native bundle available. If you target
platforms without GPU support, stick to headless captures with
\passthrough{\lstinline!UseHeadlessDrawing = true!} and fall back to
\passthrough{\lstinline!WriteableBitmap!} comparisons.

\subsection{5. Handle DPI, alpha, and layout
variability}\label{handle-dpi-alpha-and-layout-variability}

Visual tests are sensitive to device-independent rounding. Lock down
inputs:

\begin{itemize}
\tightlist
\item
  Set explicit window sizes and call
  \passthrough{\lstinline!SizeToContent = WidthAndHeight!} to avoid
  layout fluctuations.
\item
  Fix \passthrough{\lstinline!RenderScaling!} by pinning
  \passthrough{\lstinline!UseHeadlessDrawing!} and Skia DPI to 96.
\item
  Strip alpha when comparing controls that rely on transparency to avoid
  background differences. Copy pixels into a new bitmap with an opaque
  fill before diffing.
\end{itemize}

For dynamic content (animations, timers), tick the dispatcher
deterministically: call
\passthrough{\lstinline!AvaloniaHeadlessPlatform.ForceRenderTimerTick()!}
between each capture, and pause transitions via
\passthrough{\lstinline!IClock!} injection so frames stay stable.

Leverage composition snapshots when you need sub-tree captures:
\passthrough{\lstinline!Compositor.CreateCompositionVisualSnapshot!}
returns a GPU-rendered image of any \passthrough{\lstinline!Visual!}
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.Headless.UnitTests/RenderingTests.cs:118!}).
Convert the snapshot to \passthrough{\lstinline!WriteableBitmap!} for
comparisons if you want to isolate specific effects layers.

\subsection{6. Troubleshooting}\label{troubleshooting-4}

\begin{itemize}
\tightlist
\item
  \textbf{\passthrough{\lstinline!GetLastRenderedFrame!} throws} --
  ensure Skia is active; the helper checks for
  \passthrough{\lstinline!HeadlessPlatformRenderInterface!} and fails
  when only headless drawing is enabled.
\item
  \textbf{Alpha mismatches} -- multiply against a known background
  before diffing. Render your control inside a
  \passthrough{\lstinline!Border!} with a solid color or premultiply the
  buffer before comparison.
\item
  \textbf{Different stride values} -- always use
  \passthrough{\lstinline!ILockedFramebuffer.RowBytes!} instead of
  assuming width × 4 bytes.
\item
  \textbf{Platform font differences} -- embed test fonts or ship them
  with the test harness so text metrics remain identical across agents.
\item
  \textbf{Large golden files} -- compress PNGs with
  \passthrough{\lstinline!optipng!} or generate vector baselines by
  storing the render input (XAML/data) alongside the image for easier
  review.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-7}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Snapshot harness} -- Build a
  \passthrough{\lstinline!PixelAssert.Capture(window)!} helper that
  returns baseline, actual, and diff images, then integrates them with
  your test framework's logging.
\item
  \textbf{Tolerance sweeper} -- Write a diagnostic that runs the same
  render with multiple tolerances, reporting how many pixels fail each
  threshold to help pick a sensible default.
\item
  \textbf{Golden management} -- Implement a CLI command that regenerates
  baselines from the latest controls, writes them to disk, and updates a
  manifest listing checksum + control name.
\item
  \textbf{Alpha neutralization} -- Add a utility that composites
  captured frames over a configurable background color before
  comparison, and verify it fixes regressions caused by transparent
  overlays.
\item
  \textbf{Snapshot localization} -- Capture the same view under
  different resource cultures and ensure your comparison harness accepts
  localized text while still flagging layout drift.
\end{enumerate}

What's next - Next: \href{Chapter41.md}{Chapter41}

\newpage

\subsection{41. Simulating input and automation in headless
runs}\label{simulating-input-and-automation-in-headless-runs}

Goal - Drive Avalonia UI interactions programmatically inside headless
tests, mirroring real user gestures. - Coordinate keyboard, pointer, and
text input events through
\passthrough{\lstinline!HeadlessWindowExtensions!} so focus and routing
behave exactly as on desktop. - Assert downstream automation
effects---commands, behaviors, drag/drop---without launching OS-level
windows.

Why this matters - Interactive flows (menus, drag handles, keyboard
shortcuts) break easily if you only test bindings or view-models;
simulated input keeps coverage honest. - CI agents lack real hardware.
The headless platform proxies devices so you can rehearse full user
journeys deterministically. - Automation/UIP frameworks often rely on
routed events and focus transitions; reproducing them in tests prevents
last-minute surprises.

Prerequisites - Chapter 38 for headless dispatcher control and platform
options. - Chapter 39 for integrating Avalonia's headless test
attributes in xUnit or NUnit. - Chapter 40 if you plan to pair input
simulation with pixel verification.

\subsection{1. Meet the headless input
surface}\label{meet-the-headless-input-surface}

Every headless \passthrough{\lstinline!TopLevel!} implements
\passthrough{\lstinline!IHeadlessWindow!}
(\passthrough{\lstinline!external/Avalonia/src/Headless/Avalonia.Headless/IHeadlessWindow.cs:7!}),
exposing methods for keyboard, pointer, wheel, and drag/drop events.
\passthrough{\lstinline!HeadlessWindowExtensions!}
(\passthrough{\lstinline!external/Avalonia/src/Headless/Avalonia.Headless/HeadlessWindowExtensions.cs:20!})
wraps those APIs, handling dispatcher ticks before and after each
gesture so routed events fire on time.

\begin{lstlisting}
var window = new Window { Content = new Button { Content = "Click me" } };
window.Show();

window.MouseMove(new Point(20, 20));
window.MouseDown(new Point(20, 20), MouseButton.Left);
window.MouseUp(new Point(20, 20), MouseButton.Left);
\end{lstlisting}

Under the hood the extension flushes outstanding work
(\passthrough{\lstinline!Dispatcher.UIThread.RunJobs()!}), triggers the
render timer
(\passthrough{\lstinline!AvaloniaHeadlessPlatform.ForceRenderTimerTick()!}),
invokes the requested gesture on the
\passthrough{\lstinline!IHeadlessWindow!}, and drains the dispatcher
again. This ensures property changes, focus updates, and automation
events complete before your assertions run.

\subsection{2. Keyboard and text input}\label{keyboard-and-text-input}

\passthrough{\lstinline!HeadlessWindowExtensions!} provides multiple
helpers for synthesizing key strokes:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!KeyPress!}/\passthrough{\lstinline!KeyRelease!}
  accept logical \passthrough{\lstinline!Key!} values plus
  \passthrough{\lstinline!RawInputModifiers!}.
\item
  \passthrough{\lstinline!KeyPressQwerty!}/\passthrough{\lstinline!KeyReleaseQwerty!}
  map physical scan codes to logical keys using a QWERTY layout.
\item
  \passthrough{\lstinline!KeyTextInput!} sends text composition events
  directly to controls that listen for
  \passthrough{\lstinline!TextInput!}.
\end{itemize}

\begin{lstlisting}
var textBox = new TextBox { AcceptsReturn = true };
var window = new Window { Content = textBox };
window.Show();
textBox.Focus();

window.KeyPressQwerty(PhysicalKey.KeyH, RawInputModifiers.Shift);
window.KeyPressQwerty(PhysicalKey.KeyI, RawInputModifiers.None);
window.KeyReleaseQwerty(PhysicalKey.Enter, RawInputModifiers.None);
window.KeyTextInput("!");

textBox.Text.Should().Be("Hi!\n");
\end{lstlisting}

Avalonia routes the events through
\passthrough{\lstinline!KeyboardDevice!} so controls experience the same
bubbling/tunneling as in production. Remember to set focus explicitly
(\passthrough{\lstinline!textBox.Focus()!} or
\passthrough{\lstinline!KeyboardDevice.Instance.SetFocusedElement!})
before typing---headless windows do not auto-focus when shown.

\subsection{3. Pointer gestures and
drag/drop}\label{pointer-gestures-and-dragdrop}

Mouse helpers cover move, button transitions, wheel scrolling, and
drag/drop scenarios. The headless platform maintains a single virtual
pointer (\passthrough{\lstinline!HeadlessWindowImpl!} uses
\passthrough{\lstinline!PointerDevice!}, see
\passthrough{\lstinline!external/Avalonia/src/Headless/Avalonia.Headless/HeadlessWindowImpl.cs:34!}).

\begin{lstlisting}
var listBox = new ListBox
{
    ItemsSource = new[] { "Alpha", "Beta", "Gamma" }
};
var window = new Window { Content = listBox };
window.Show();

// Click first item
window.MouseMove(new Point(10, 20));
window.MouseDown(new Point(10, 20), MouseButton.Left);
window.MouseUp(new Point(10, 20), MouseButton.Left);
listBox.SelectedIndex.Should().Be(0);

// Scroll down
window.MouseWheel(new Point(10, 20), new Vector(0, -120));
\end{lstlisting}

For drag/drop, build a \passthrough{\lstinline!DataObject!} and send a
sequence of drag events:

\begin{lstlisting}
var data = new DataObject();
data.Set(DataFormats.Text, "payload");
window.DragDrop(new Point(10, 20), RawDragEventType.DragEnter, data, DragDropEffects.Copy);
window.DragDrop(new Point(80, 40), RawDragEventType.DragOver, data, DragDropEffects.Copy);
window.DragDrop(new Point(80, 40), RawDragEventType.Drop, data, DragDropEffects.Copy);
\end{lstlisting}

Your controls will receive \passthrough{\lstinline!DragEventArgs!},
invoke drop handlers, and update view-models just as they would with
real user input.

\subsection{4. Focus, capture, and multi-step
workflows}\label{focus-capture-and-multi-step-workflows}

Headless tests still rely on Avalonia's focus and capture services:

\begin{itemize}
\tightlist
\item
  Call \passthrough{\lstinline!control.Focus()!} or
  \passthrough{\lstinline!FocusManager.Instance.Focus(control)!} before
  keyboard entry.
\item
  Pointer capture happens automatically when a control handles
  \passthrough{\lstinline!PointerPressed!} and calls
  \passthrough{\lstinline!e.Pointer.Capture(control)!}. To assert
  capture, inspect \passthrough{\lstinline!Pointer.Captured!} inside
  your test after dispatching input.
\item
  Release capture manually with
  \passthrough{\lstinline!pointer.Capture(null)!} when simulating
  complex gestures to avoid stale state.
\end{itemize}

Example: testing a custom drag handle that requires capture and modifier
keys.

\begin{lstlisting}
[AvaloniaFact]
public void DragHandle_updates_offset()
{
    var handle = new DragHandleControl();
    var window = new Window { Content = handle };
    window.Show();

    window.MouseMove(new Point(5, 5));
    window.MouseDown(new Point(5, 5), MouseButton.Left, RawInputModifiers.LeftMouseButton);
    handle.PointerIsCaptured.Should().BeTrue();

    window.MouseMove(new Point(45, 5), RawInputModifiers.LeftMouseButton | RawInputModifiers.Shift);
    window.MouseUp(new Point(45, 5), MouseButton.Left);

    handle.Offset.Should().BeGreaterThan(0);
}
\end{lstlisting}

Because \passthrough{\lstinline!HeadlessWindowExtensions!} executes all
gestures on the UI thread, your control can update dependency
properties, trigger animations, and publish events synchronously within
the test.

\subsection{5. Compose higher-level automation
helpers}\label{compose-higher-level-automation-helpers}

Most suites wrap common interaction patterns in reusable functions to
keep tests declarative:

\begin{lstlisting}
public sealed class HeadlessUser
{
    private readonly Window _window;
    public HeadlessUser(Window window) => _window = window;

    public void Click(Control control)
    {
        var point = control.TranslatePoint(new Point(control.Bounds.Width / 2, control.Bounds.Height / 2), _window) ?? default;
        _window.MouseMove(point);
        _window.MouseDown(point, MouseButton.Left);
        _window.MouseUp(point, MouseButton.Left);
    }

    public void Type(string text)
    {
        foreach (var ch in text)
            _window.KeyTextInput(ch.ToString());
    }
}
\end{lstlisting}

Pair these helpers with assertions against
\passthrough{\lstinline!AutomationProperties!} to verify accessibility
metadata as you drive the UI. Tests in
\passthrough{\lstinline!external/Avalonia/tests/Avalonia.Headless.UnitTests/InputTests.cs:29!}
demonstrate structuring fixtures that open a window in
\passthrough{\lstinline![SetUp]!}/constructor, execute gestures, and
dispose deterministically.

\subsection{6. Raw input modifiers and multiple
devices}\label{raw-input-modifiers-and-multiple-devices}

\passthrough{\lstinline!RawInputModifiers!} combines buttons, keyboard
modifiers, and touch states into a single bit field. Use it to emulate
complex shortcuts:

\begin{lstlisting}
window.MouseDown(point, MouseButton.Left, RawInputModifiers.LeftMouseButton | RawInputModifiers.Control);
window.KeyPress(Key.S, RawInputModifiers.Control, PhysicalKey.KeyS, "s");
\end{lstlisting}

Headless currently exposes a single mouse pointer and keyboard. To
simulate multi-pointer scenarios (e.g., pinch gestures), create custom
\passthrough{\lstinline!RawPointerEventArgs!} and push them through
\passthrough{\lstinline!InputManager.Instance.ProcessInput!}. That
advanced path uses \passthrough{\lstinline!IInputRoot.Input!} (hook
available via \passthrough{\lstinline!HeadlessWindowImpl.Input!}),
giving you full control when default helpers are insufficient.

\subsection{7. Troubleshooting}\label{troubleshooting-5}

\begin{itemize}
\tightlist
\item
  \textbf{No events firing} -- confirm you called
  \passthrough{\lstinline!window.Show()!} and that the target control is
  in the visual tree. Without showing, the platform impl doesn't attach
  an \passthrough{\lstinline!InputRoot!}.
\item
  \textbf{Focus lost between gestures} -- check whether your control
  closes popups or dialogs. Re-focus before continuing or assert against
  \passthrough{\lstinline!FocusManager.Instance.Current!}.
\item
  \textbf{Pointer coordinates off} -- convert control-relative
  coordinates to window coordinates
  (\passthrough{\lstinline!TranslatePoint!}) and double-check logical
  vs.~visual point units (headless always uses logical units, scaling =
  1 unless you override).
\item
  \textbf{Keyboard text missing} -- some controls ignore
  \passthrough{\lstinline!KeyTextInput!} without focus or when
  \passthrough{\lstinline!AcceptsReturn!} is false. Set the right
  properties or use \passthrough{\lstinline!TextInputOptions!} when
  testing IME handling
  (\passthrough{\lstinline!external/Avalonia/src/Avalonia.Base/Input/TextInput/TextInputOptions.cs!}).
\item
  \textbf{Drag/drop crashes} -- make sure Skia is enabled for
  capture-heavy tests and that you dispose
  \passthrough{\lstinline!DataObject!} content streams after the drop
  completes.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-8}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{User DSL} -- Build a \passthrough{\lstinline!HeadlessUser!}
  helper that supports click, double-click, context menu, typing, and
  modifier-aware shortcuts. Use it to script multi-page navigation
  flows.
\item
  \textbf{Pointer capture assertions} -- Write a test that verifies a
  custom canvas captures the pointer during drawing and releases it when
  \passthrough{\lstinline!PointerReleased!} fires, asserting against
  \passthrough{\lstinline!Pointer.Captured!}.
\item
  \textbf{Keyboard navigation} -- Simulate
  \passthrough{\lstinline!Tab!}/\passthrough{\lstinline!Shift+Tab!}
  sequences across a dialog and assert
  \passthrough{\lstinline!FocusManager.Instance.Current!} to ensure
  accessibility order is correct.
\item
  \textbf{Drag/drop harness} -- Create reusable helpers for
  \passthrough{\lstinline!DragEnter!}/\passthrough{\lstinline!DragOver!}/\passthrough{\lstinline!Drop!}
  with specific \passthrough{\lstinline!IDataObject!} payloads. Verify
  your view-model receives the right data and that effects
  (\passthrough{\lstinline!DragDropEffects!}) match expectations.
\item
  \textbf{IME/text services} -- Toggle
  \passthrough{\lstinline!TextInputOptions!} on a
  \passthrough{\lstinline!TextBox!}, send mixed
  \passthrough{\lstinline!KeyPress!} and
  \passthrough{\lstinline!KeyTextInput!} events, and confirm composition
  events surface in your view-model for languages requiring IME support.
\end{enumerate}

What's next - Next: \href{Chapter42.md}{Chapter42}

\newpage

\subsection{42. CI pipelines, diagnostics, and
troubleshooting}\label{ci-pipelines-diagnostics-and-troubleshooting}

Goal - Run Avalonia headless and automation suites reliably in CI across
Windows, macOS, and Linux agents. - Capture logs, screenshots, and
diagnostics artifacts so UI regressions are easy to triage. - Detect
hangs or ordering issues proactively and keep runs deterministic even
under heavy concurrency.

Why this matters - UI regressions usually surface first in
automation---if the pipeline flakes, the team stops trusting the signal.
- Headless tests rely on the dispatcher and render loop; CI environments
with limited GPUs or desktops need deliberate setup. - Rich artifacts
(logs, videos, dumps) turn red builds into actionable bug reports
instead of mystery failures.

Prerequisites - Chapter 38 for configuring
\passthrough{\lstinline!UseHeadless!} and driving the dispatcher. -
Chapter 39 for integrating the headless test session into xUnit or
NUnit. - Chapter 41 for scripting complex input sequences that your
pipeline will exercise.

\subsection{1. Pick a CI host and bootstrap
prerequisites}\label{pick-a-ci-host-and-bootstrap-prerequisites}

Avalonia's own integration pipeline (see
\passthrough{\lstinline!external/Avalonia/azure-pipelines-integrationtests.yml:1!})
demonstrates the moving parts for Appium + headless test runs:

\begin{itemize}
\tightlist
\item
  Install the correct .NET runtimes/SDKs via
  \passthrough{\lstinline!UseDotNet@2!}.
\item
  Prepare platform dependencies (e.g., select Xcode, kill stray
  \passthrough{\lstinline!node!} processes, start Appium on macOS; start
  WinAppDriver on Windows).
\item
  Build the test app and run \passthrough{\lstinline!dotnet test!}
  against
  \passthrough{\lstinline!Avalonia.IntegrationTests.Appium.csproj!}.
\item
  Publish artifacts---\passthrough{\lstinline!appium.out!} on failure
  and TRX results on all outcomes.
\end{itemize}

For GitHub Actions, mirror that setup with runner-specific steps:

\begin{lstlisting}
jobs:
  ui-tests:
    strategy:
      matrix:
        os: [windows-latest, macos-13]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v3
        with:
          global-json-file: global.json
      - name: Start WinAppDriver
        if: runner.os == 'Windows'
        run: Start-Process -FilePath 'C:\\Program Files (x86)\\Windows Application Driver\\WinAppDriver.exe'
      - name: Restore
        run: dotnet restore tests/Avalonia.Headless.UnitTests
      - name: Test headless suite
        run: dotnet test tests/Avalonia.Headless.UnitTests --logger "trx;LogFileName=headless.trx" --blame-hang-timeout 5m
      - name: Publish results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: headless-results
          path: '**/*.trx'
\end{lstlisting}

Adjust the matrix for Linux when you only need headless tests (no
Appium). Use the same \passthrough{\lstinline!dotnet test!} command
locally to validate pipeline scripts.

\subsection{2. Configure deterministic test
execution}\label{configure-deterministic-test-execution}

Headless suites should run with parallelism disabled unless every
fixture is isolation-safe. xUnit supports assembly-level configuration:

\begin{lstlisting}
// AssemblyInfo.cs
[assembly: CollectionBehavior(DisableTestParallelization = true)]
[assembly: AvaloniaTestFramework]
\end{lstlisting}

Pair the attribute with
\passthrough{\lstinline!AvaloniaTestApplication!} so a single
\passthrough{\lstinline!HeadlessUnitTestSession!} drives the whole
assembly. For NUnit, launch the test runner with
\passthrough{\lstinline!--workers=1!} or mark fixtures
\passthrough{\lstinline![NonParallelizable]!}. This avoids fighting over
the singleton dispatcher and ensures actions happen in the same order on
developer machines and CI bots.

Within tests, drain work deterministically.
\passthrough{\lstinline!HeadlessWindowExtensions!} already wraps each
gesture with \passthrough{\lstinline!Dispatcher.UIThread.RunJobs()!} and
\passthrough{\lstinline!AvaloniaHeadlessPlatform.ForceRenderTimerTick()!};
call those directly from helpers when you schedule background tasks
outside the provided wrappers.

\subsection{3. Capture logs, screenshots, and
videos}\label{capture-logs-screenshots-and-videos}

Collect evidence automatically so failing builds are actionable:

\begin{itemize}
\tightlist
\item
  Turn on Avalonia's trace logging by chaining
  \passthrough{\lstinline!.LogToTrace()!} in your
  \passthrough{\lstinline!AppBuilder!}. Redirect stderr to a file in CI
  (\passthrough{\lstinline!dotnet test … 2> headless.log!}) and upload
  it as an artifact.
\item
  Use \passthrough{\lstinline!CaptureRenderedFrame!} (Chapter 40) to
  grab before/after bitmaps on failure. Save them with a timestamp
  inside
  \passthrough{\lstinline!TestContext.CurrentContext.WorkDirectory!}
  (NUnit) or \passthrough{\lstinline!ITestOutputHelper!} attachments
  (xUnit).
\item
  On Windows, record screen captures with MSTest data collectors.
  Avalonia ships \passthrough{\lstinline!record-video.runsettings!}
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/record-video.runsettings:1!})
  to capture Appium sessions; reuse it by passing
  \passthrough{\lstinline!/Settings:record-video.runsettings!} to VSTest
  or \passthrough{\lstinline!--settings!} to
  \passthrough{\lstinline!dotnet test!}.
\item
  For Appium runs, write driver logs to disk. The macOS pipeline
  publishes \passthrough{\lstinline!appium.out!} when a job fails
  (\passthrough{\lstinline!external/Avalonia/azure-pipelines-integrationtests.yml:27!}).
\end{itemize}

\subsection{4. Diagnose hangs and
deadlocks}\label{diagnose-hangs-and-deadlocks}

UI tests occasionally hang because outstanding work blocks the
dispatcher. Harden your pipeline with diagnosis options:

\begin{itemize}
\tightlist
\item
  Use
  \passthrough{\lstinline!dotnet test --blame-hang-timeout 5m --blame-hang-dump-type full!}
  to trigger crash dumps when a test exceeds the timeout.
\item
  Wrap long-running awaits inside
  \passthrough{\lstinline!HeadlessUnitTestSession.Dispatch!} so the
  framework can pump the dispatcher
  (\passthrough{\lstinline!external/Avalonia/src/Headless/Avalonia.Headless/HeadlessUnitTestSession.cs:54!}).
\item
  Expose a helper that runs
  \passthrough{\lstinline!Dispatcher.UIThread.RunJobs()!} and
  \passthrough{\lstinline!AvaloniaHeadlessPlatform.ForceRenderTimerTick()!}
  in a loop until a condition is met. Fail the test if the condition
  never becomes true to avoid infinite waits.
\item
  When debugging locally, attach a logger to
  \passthrough{\lstinline!DispatcherTimer!} callbacks or set
  \passthrough{\lstinline!DispatcherTimer.Tag!} to identify timers
  causing hangs; the headless render timer is labeled
  \passthrough{\lstinline!HeadlessRenderTimer!}
  (\passthrough{\lstinline!external/Avalonia/src/Headless/Avalonia.Headless/AvaloniaHeadlessPlatform.cs:21!}).
\end{itemize}

Analyze captured dumps with
\passthrough{\lstinline!dotnet-dump analyze!} to inspect managed thread
stacks and spot blocked tasks.

\subsection{5. Environment hygiene on shared
agents}\label{environment-hygiene-on-shared-agents}

CI agents often reuse workspaces. Add cleanup steps before running UI
automation:

\begin{itemize}
\tightlist
\item
  Kill straggling processes
  (\passthrough{\lstinline!pkill IntegrationTestApp!},
  \passthrough{\lstinline!pkill node!}) as the macOS pipeline does
  (\passthrough{\lstinline!external/Avalonia/azure-pipelines-integrationtests.yml:21!}).
\item
  Remove stale app bundles or temporary data to guarantee a clean run.
\item
  Reset environment variables that influence Avalonia behavior (e.g.,
  \passthrough{\lstinline!AVALONIA\_RENDERER!} overrides). Keep your
  scripts explicit to avoid surprises when infra engineers tweak images.
\end{itemize}

For cross-platform Appium tests, encapsulate capability setup in
fixtures. \passthrough{\lstinline!DefaultAppFixture!}
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/DefaultAppFixture.cs:9!})
configures Windows and macOS sessions differently while exposing a
consistent driver to tests.

\subsection{6. Build health dashboards and
alerts}\label{build-health-dashboards-and-alerts}

Publish TRX or NUnit XML outputs to your CI system so failures appear in
dashboards. Azure Pipelines uses
\passthrough{\lstinline!PublishTestResults@2!} to ingest xUnit results
even when the job succeeds with warnings
(\passthrough{\lstinline!external/Avalonia/azure-pipelines-integrationtests.yml:67!}).
GitHub Actions can read TRX via
\passthrough{\lstinline!dorny/test-reporter!} or similar actions.

Send critical logs to observability tools if your team maintains
telemetry infrastructure. A simple approach is to push structured log
lines to stdout in JSON---CI services preserve the console by default.

\subsection{7. Troubleshooting
checklist}\label{troubleshooting-checklist-1}

\begin{itemize}
\tightlist
\item
  \textbf{Tests fail only on CI} -- compare fonts, localization, and
  DPI. Ensure custom fonts are deployed with the test app and
  \passthrough{\lstinline!CultureInfo.DefaultThreadCurrentUICulture!} is
  set for deterministic layouts.
\item
  \textbf{Intermittent hangs} -- add \passthrough{\lstinline!--blame!}
  dumps, then review stuck threads. Often a test awaited
  \passthrough{\lstinline!Task.Delay!} without advancing the render
  timer; replace with deterministic loops.
\item
  \textbf{Missing screenshots} -- confirm Skia is enabled
  (\passthrough{\lstinline!UseHeadlessDrawing = false!}) so
  \passthrough{\lstinline!CaptureRenderedFrame!} works in pipelines.
\item
  \textbf{Appium session errors} -- verify the automation server is
  running (WinAppDriver/Appium) before tests start, and stop it in a
  final step to avoid port conflicts next run.
\item
  \textbf{Resource leaks across tests} -- always close windows
  (\passthrough{\lstinline!window.Close()!}), dispose
  \passthrough{\lstinline!CompositeDisposable!}, and tear down Appium
  sessions in \passthrough{\lstinline!Dispose!}. Lingering windows keep
  the dispatcher alive and can cause later tests to inherit state.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-9}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Pipeline parity} -- Create a local script that mirrors your CI
  job (\passthrough{\lstinline!dotnet restore!},
  \passthrough{\lstinline!dotnet test!}, artifact copy). Run it before
  pushing so pipeline failures never surprise you.
\item
  \textbf{Hang detector} -- Wire
  \passthrough{\lstinline!dotnet test --blame!} into your CI job and
  practice analyzing the generated dumps for a deliberately hung test.
\item
  \textbf{Artifact triage} -- Extend your test harness to save headless
  screenshots and logs into an output directory, then configure your
  pipeline to upload them on failure.
\item
  \textbf{Parallelism audit} -- Temporarily enable test parallelization
  to identify fixtures that rely on global state. Fix the offenders or
  permanently disable parallel runs via assembly attributes.
\item
  \textbf{Cross-platform dry run} -- Use a GitHub Actions matrix or
  Azure multi-job pipeline to run headless tests on Windows and Linux
  simultaneously, comparing logs for environment-specific quirks.
\end{enumerate}

What's next - Next: \href{Chapter43.md}{Chapter43}

\clearpage
\phantomsection
\addcontentsline{toc}{section}{Part IX — Appium automation done right}
\thispagestyle{empty}
\vspace*{\fill}
\begin{center}
{\Huge\bfseries Part IX — Appium automation done right}
\end{center}
\vspace*{\fill}
\clearpage

\newpage

\subsection{43. Appium fundamentals for Avalonia
apps}\label{appium-fundamentals-for-avalonia-apps}

Goal - Stand up Appium-based UI tests that drive Avalonia desktop apps
on Windows and macOS. - Reuse the built-in integration harness
(\passthrough{\lstinline!Avalonia.IntegrationTests.Appium!}) to spin
sessions, navigate the sample app, and locate controls reliably. -
Understand the accessibility surface Avalonia exposes so selectors stay
stable across platforms and Appium versions.

Why this matters - End-to-end coverage validates window chrome, dialogs,
and platform behaviors that headless tests can't touch. - Appium works
with the same accessibility tree users rely on---tests that pass here
give confidence in automation readiness. - A disciplined harness keeps
session setup, synchronization, and cleanup consistent across operating
systems.

Prerequisites - Chapter 12 for windowing concepts referenced by Appium
tests. - Chapter 13 for menus/dialogs---the automation harness exercises
them heavily. - Chapter 42 for CI orchestration once your Appium suite
is green locally.

\subsection{1. Anatomy of the Avalonia Appium
harness}\label{anatomy-of-the-avalonia-appium-harness}

Avalonia ships an Appium test suite in
\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium!}.
Key parts:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!DefaultAppFixture!} builds and launches the
  sample \passthrough{\lstinline!IntegrationTestApp!}, creating an
  \passthrough{\lstinline!AppiumDriver!} for Windows or macOS sessions
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/DefaultAppFixture.cs:9!}).
\item
  \passthrough{\lstinline!TestBase!} accepts the fixture and navigates
  the ControlCatalog-style pager. It retries the navigation click to
  absorb macOS animations
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TestBase.cs:6!}).
\item
  \passthrough{\lstinline!CollectionDefinitions!} wires fixtures into
  xUnit collections so sessions are shared per test class
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/CollectionDefinitions.cs:4!}).
\end{itemize}

Reuse this structure in your own project: create a fixture that launches
your app (packaged exe/bundle), expose the
\passthrough{\lstinline!AppiumDriver!}, and derive page-specific test
classes from a \passthrough{\lstinline!TestBase!} that performs
navigation.

\subsection{2. Configure sessions per
platform}\label{configure-sessions-per-platform}

\passthrough{\lstinline!DefaultAppFixture!} populates capability sets
tailored to each OS:

\begin{lstlisting}
var options = new AppiumOptions();
if (OperatingSystem.IsWindows())
{
    options.AddAdditionalCapability(MobileCapabilityType.App, TestAppPath);
    options.AddAdditionalCapability(MobileCapabilityType.PlatformName, MobilePlatform.Windows);
    options.AddAdditionalCapability(MobileCapabilityType.DeviceName, "WindowsPC");
    Session = new WindowsDriver(new Uri("http://127.0.0.1:4723"), options);
}
else if (OperatingSystem.IsMacOS())
{
    options.AddAdditionalCapability("appium:bundleId", "net.avaloniaui.avalonia.integrationtestapp");
    options.AddAdditionalCapability(MobileCapabilityType.PlatformName, MobilePlatform.MacOS);
    options.AddAdditionalCapability(MobileCapabilityType.AutomationName, "mac2");
    Session = new MacDriver(new Uri("http://127.0.0.1:4723/wd/hub"), options);
}
\end{lstlisting}

The fixture also foregrounds the window on Windows via
\passthrough{\lstinline!SetForegroundWindow!} to avoid focus issues.
Always close the session in \passthrough{\lstinline!Dispose!} even if
Appium errors---macOS' \passthrough{\lstinline!mac2!} driver may throw
on shutdown, so wrap in try/catch like the sample.

TIP: keep Appium/WAD endpoints configurable via environment variables so
your CI scripts can point to remote device clouds.

\subsection{3. Navigating the sample
app}\label{navigating-the-sample-app}

\passthrough{\lstinline!TestBase!} selects a page by finding the pager
control and clicking the relevant button. The same pattern applies to
your app:

\begin{lstlisting}
public class WindowTests : TestBase
{
    public WindowTests(DefaultAppFixture fixture) : base(fixture, "Window") { }

    [Fact]
    public void Can_toggle_window_state()
    {
        var windowStateCombo = Session.FindElementByAccessibilityId("CurrentWindowState");
        windowStateCombo.Click();
        Session.FindElementByAccessibilityId("WindowStateMaximized").SendClick();
        Assert.Equal("Maximized", windowStateCombo.GetComboBoxValue());
    }
}
\end{lstlisting}

The \passthrough{\lstinline!pageName!} passed to
\passthrough{\lstinline!TestBase!} must match the accessible name
exposed by the pager button. Avalonia's sample ControlCatalog sets these
via \passthrough{\lstinline!AutomationProperties.Name!}, so always
annotate navigation controls in your app for consistent selectors.

\subsection{4. Element discovery and helper
APIs}\label{element-discovery-and-helper-apis}

Selectors vary subtly across platforms. Avalonia's helpers hide those
differences:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!AppiumDriverEx!} defines
  \passthrough{\lstinline!FindElementByAccessibilityId!},
  \passthrough{\lstinline!FindElementByName!}, and other convenience
  methods to work with both Appium 1 and 2
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/AppiumDriverEx.cs:1!}).
\item
  \passthrough{\lstinline!ElementExtensions!} centralizes common queries
  such as chrome buttons and combo box value extraction. For example,
  \passthrough{\lstinline!GetComboBoxValue!} uses
  \passthrough{\lstinline!Text!} on Windows and
  \passthrough{\lstinline!value!} attributes elsewhere
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:34!}).
\item
  \passthrough{\lstinline!GetCurrentSingleWindow!} hides the extra
  wrapper window present in macOS accessibility trees
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:60!}).
\end{itemize}

When building your suite, add similar extension methods instead of
hard-coding XPath per test. Keep selectors rooted in
\passthrough{\lstinline!AutomationId!} or names you control via
\passthrough{\lstinline!AutomationProperties.AutomationId!} and
\passthrough{\lstinline!Name!} to minimize brittleness.

\subsection{5. Synchronization and
retries}\label{synchronization-and-retries}

Appium commands are asynchronous relative to the app. Avalonia tests mix
explicit waits, retries, and timeouts:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!TestBase!} retries page navigation three times
  with a 1s delay to survive macOS transitions.
\item
  \passthrough{\lstinline!ElementExtensions.OpenWindowWithClick!} polls
  for either a new window handle or child window to appear, retrying up
  to ten times
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:86!}).
\item
  For transitions with animations (e.g., exiting full screen), tests
  call \passthrough{\lstinline!Thread.Sleep!} after sending
  commands---note the cleanup block in
  \passthrough{\lstinline!WindowTests!} that waits 1 second on macOS
  before asserting
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/WindowTests.cs:53!}).
\end{itemize}

Wrap these patterns in helper methods so timing tweaks stay centralized.
For more resilient waits, use Appium's
\passthrough{\lstinline!WebDriverWait!} with conditions such as
\passthrough{\lstinline!driver.FindElementByAccessibilityId(...)!} or
\passthrough{\lstinline!element.Displayed!}.

\subsection{6. Cross-platform control with attributes and
collections}\label{cross-platform-control-with-attributes-and-collections}

Automation suites often need OS-specific assertions. Avalonia uses:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline![PlatformFact]!}/\passthrough{\lstinline![PlatformTheory]!}
  to skip tests on unsupported OSes
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PlatformFactAttribute.cs:7!}).
\item
  Collection definitions to isolate fixtures for specialized apps (e.g.,
  overlay popups vs.~default ControlCatalog)
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/CollectionDefinitions.cs:10!}).
\end{itemize}

Follow suit by tagging tests with custom attributes that read
environment variables or capability flags. This keeps your suite from
failing on agents lacking certain features (e.g., Win32-only APIs).

\subsection{7. Exposing automation IDs in
Avalonia}\label{exposing-automation-ids-in-avalonia}

Appium relies on the accessibility tree. Avalonia maps these properties
as follows:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!AutomationProperties.AutomationId!} and
  control \passthrough{\lstinline!Name!} become accessibility IDs
  (\passthrough{\lstinline!AutomationTests.AutomationId!},
  \passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/AutomationTests.cs:12!}).
\item
  \passthrough{\lstinline!AutomationProperties.Name!} populates the
  element name in both Windows UIA and macOS accessibility APIs.
\item
  \passthrough{\lstinline!AutomationProperties.LabeledBy!} and other
  metadata surface via Appium attributes so you can assert associations
  (\passthrough{\lstinline!AutomationTests.LabeledBy!}).
\end{itemize}

Ensure the controls you interact with set both
\passthrough{\lstinline!AutomationId!} and
\passthrough{\lstinline!Name!}; for templated controls expose IDs
through \passthrough{\lstinline!x:Name!} or
\passthrough{\lstinline!Automation.Id!}. Without these properties,
selectors fall back to fragile XPath queries.

\subsection{8. Running the suite}\label{running-the-suite}

\subsubsection{Windows}\label{windows-3}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Install WinAppDriver (ships with Visual Studio workloads) and start it
  on port 4723.
\item
  Build your Avalonia app for \passthrough{\lstinline!net8.0-windows!}
  with \passthrough{\lstinline!UseWindowsForms!} disabled (the sample
  uses \passthrough{\lstinline!IntegrationTestApp!}).
\item
  Launch Appium tests:
  \passthrough{\lstinline!dotnet test tests/Avalonia.IntegrationTests.Appium --logger "trx;LogFileName=appium.trx"!}.
\end{enumerate}

\subsubsection{macOS}\label{macos-3}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Install Appium 2 with the \passthrough{\lstinline!mac2!} driver and
  run \passthrough{\lstinline!appium --base-path /wd/hub!}.
\item
  Ensure the test runner has accessibility permissions; the pipeline
  script resets them via \passthrough{\lstinline!pkill!} and
  \passthrough{\lstinline!osascript!}
  (\passthrough{\lstinline!external/Avalonia/azure-pipelines-integrationtests.yml:17!}).
\item
  Bundle the app
  (\passthrough{\lstinline!samples/IntegrationTestApp/bundle.sh!}) so
  Appium can reference it by bundle ID.
\end{enumerate}

Use the provided \passthrough{\lstinline!macos-clean-build-test.sh!} as
a reference for orchestrating builds locally or in CI.

\subsection{9. Troubleshooting}\label{troubleshooting-6}

\begin{itemize}
\tightlist
\item
  \textbf{Session fails to start} -- Verify the Appium server is running
  and that the path/bundle ID is correct. On Windows, ensure the test
  app exists relative to the test project
  (\passthrough{\lstinline!DefaultAppFixture.TestAppPath!}).
\item
  \textbf{Elements not found} -- Inspect the accessibility tree with
  tools such as Windows Inspect or macOS Accessibility Inspector. Add
  missing \passthrough{\lstinline!AutomationId!} values to the Avalonia
  XAML.
\item
  \textbf{Focus issues after fullscreen} -- Mirror Avalonia's retry
  \passthrough{\lstinline!Thread.Sleep!} or use explicit waits; macOS
  may animate transitions for up to a second.
\item
  \textbf{Multiple windows} -- Use
  \passthrough{\lstinline!OpenWindowWithClick!} helper to track handles.
  Remember to dispose the returned \passthrough{\lstinline!IDisposable!}
  so the new window closes after the test.
\item
  \textbf{Driver shutdown crashes} -- Wrap
  \passthrough{\lstinline!Session.Close()!} in try/catch like
  \passthrough{\lstinline!DefaultAppFixture.Dispose!} to shield flaky
  platform drivers.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-10}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Custom fixture} -- Implement a fixture that launches your app
  under test, parameterized by environment variables for executable path
  and Appium endpoint.
\item
  \textbf{Navigation helper} -- Create a
  \passthrough{\lstinline!TestBase!} that navigates your shell's
  menu/pager via automation IDs, then write a smoke test asserting
  window title, version label, or status bar text.
\item
  \textbf{Selector audit} -- Add \passthrough{\lstinline!AutomationId!}
  attributes to controls in a sample page, write tests that locate them
  by accessibility ID, and verify they remain stable after theme
  changes.
\item
  \textbf{Cross-platform skip logic} -- Introduce
  \passthrough{\lstinline![PlatformFact]!}-style attributes that read
  from \passthrough{\lstinline!RuntimeInformation!} and feature flags
  (e.g., skip tray icon tests on macOS), then apply them to OS-specific
  suites.
\item
  \textbf{Wait strategy} -- Replace any
  \passthrough{\lstinline!Thread.Sleep!} in your tests with a reusable
  wait helper that polls for element state using Appium's
  \passthrough{\lstinline!WebDriverWait!}, ensuring the helper raises
  descriptive timeout errors.
\end{enumerate}

What's next - Next: \href{Chapter44.md}{Chapter44}

\newpage

\subsection{44. Environment setup, drivers, and device
clouds}\label{environment-setup-drivers-and-device-clouds}

Goal - Stand up reliable Appium infrastructure for Avalonia desktop
automation on Windows and macOS. - Package and register test apps so
automation servers can launch them locally or on remote device clouds. -
Script build/start/stop flows that keep CI agents clean while preserving
diagnostics.

Why this matters - Incorrect driver versions or unregistered bundles are
the top causes of flaky Appium runs. - Avalonia apps often ship custom
arguments (overlay popups, experimental features); tests need a
repeatable way to pass them to the harness. - Device-cloud execution
magnifies small misconfigurations---locking your setup locally prevents
expensive remote reruns.

Prerequisites - Chapter 43 for the fundamentals of Avalonia's Appium
test harness. - Chapter 42 for CI orchestration patterns and artifact
capture. - Base familiarity with platform build tooling (PowerShell,
bash, Xcode command-line tools).

\subsection{1. Install automation servers and
drivers}\label{install-automation-servers-and-drivers}

\subsubsection{Windows}\label{windows-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Install \textbf{WinAppDriver}
  (https://github.com/microsoft/WinAppDriver). It registers itself in
  the Start menu and listens on
  \passthrough{\lstinline!http://127.0.0.1:4723!}.
\item
  Ensure the machine is running in \textbf{desktop interactive}
  mode---WinAppDriver cannot interact with headless Windows Server
  sessions.
\item
  Optional: pin the service to auto-start via
  \passthrough{\lstinline!schtasks!} or a Windows Service wrapper so CI
  agents bring it up automatically.
\end{enumerate}

\subsubsection{macOS}\label{macos-4}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Install \textbf{Appium}
  (\passthrough{\lstinline!npm install -g appium!}). For Appium 1, the
  built-in mac driver is sufficient; for Appium 2 install the
  \passthrough{\lstinline!mac2!} driver
  (\passthrough{\lstinline!appium driver install mac2!}).
\item
  Grant Xcode helper the accessibility permissions required to drive UI
  (see harness readme at
  \passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/readme.md!}).
\item
  Register your Avalonia app bundle so Appium can launch it by bundle
  ID. Avalonia's script
  \passthrough{\lstinline!samples/IntegrationTestApp/bundle.sh!} builds
  and publishes the bundle.
\item
  Start Appium. For Appium 2 use a base path to maintain compatibility
  with existing clients:
  \passthrough{\lstinline!appium --base-path=/wd/hub!}.
\end{enumerate}

The harness toggles between Appium 1 and 2 using the
\passthrough{\lstinline!IsRunningAppium2!} property
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/Avalonia.IntegrationTests.Appium.csproj:5!}).
Set the property to \passthrough{\lstinline!true!} in
\passthrough{\lstinline!Directory.Build.props!} or via
\passthrough{\lstinline!dotnet test -p:IsRunningAppium2=true!} when
running against Appium 2.

\subsection{2. Package and register the test
app}\label{package-and-register-the-test-app}

Appium launches desktop apps by path (Windows) or bundle identifier
(macOS). The Avalonia sample uses
\passthrough{\lstinline!IntegrationTestApp!} and rebuilds it before each
run:

\begin{itemize}
\tightlist
\item
  macOS pipeline script
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/macos-clean-build-test.sh:1!})
  cleans the repo, compiles native dependencies, bundles the app, and
  opens it once to register Launch Services.
\item
  Windows pipeline
  (\passthrough{\lstinline!external/Avalonia/azure-pipelines-integrationtests.yml:42!})
  builds \passthrough{\lstinline!IntegrationTestApp!} and the test
  project before running \passthrough{\lstinline!dotnet test!}.
\end{itemize}

When testing your own app:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Provide a CLI or script (PowerShell/bbash) that packs the app and
  exposes the absolute path or bundle ID through environment variables
  (\passthrough{\lstinline!TEST\_APP\_PATH!},
  \passthrough{\lstinline!TEST\_APP\_BUNDLE!}).
\item
  Inherit from \passthrough{\lstinline!DefaultAppFixture!} and override
  \passthrough{\lstinline!ConfigureWin32Options!} /
  \passthrough{\lstinline!ConfigureMacOptions!} to use those values.
  Example:
\end{enumerate}

\begin{lstlisting}
protected override void ConfigureWin32Options(AppiumOptions options, string? app = null)
{
    base.ConfigureWin32Options(options, Environment.GetEnvironmentVariable("TEST_APP_PATH"));
}

protected override void ConfigureMacOptions(AppiumOptions options, string? app = null)
{
    base.ConfigureMacOptions(options, Environment.GetEnvironmentVariable("TEST_APP_BUNDLE"));
}
\end{lstlisting}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  For variants (e.g., overlay popups), add command-line arguments via
  capabilities. \passthrough{\lstinline!OverlayPopupsAppFixture!} adds
  \passthrough{\lstinline!--overlayPopups!} on both platforms
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/OverlayPopupsAppFixture.cs:4!}).
\end{enumerate}

\subsection{3. Start/stop lifecycle
scripts}\label{startstop-lifecycle-scripts}

Automation servers must be running when tests start and shut down
afterward. Avalonia's pipelines demonstrate the sequence:

\begin{itemize}
\tightlist
\item
  \textbf{macOS job} kills stray processes
  (\passthrough{\lstinline!pkill node!},
  \passthrough{\lstinline!pkill IntegrationTestApp!}), starts Appium in
  the background, bundles the app, launches it, runs
  \passthrough{\lstinline!dotnet test!}, then terminates Appium and the
  app again
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/macos-clean-build-test.sh:6!}).
\item
  \textbf{Windows job} uses Azure DevOps tasks to start/stop
  WinAppDriver
  (\passthrough{\lstinline!external/Avalonia/azure-pipelines-integrationtests.yml:32!}).
  When scripting locally, run
  \passthrough{\lstinline!Start-Process "WinAppDriver.exe"!} before
  tests and \passthrough{\lstinline!Stop-Process -Name WinAppDriver!}
  afterward.
\end{itemize}

General guidelines:

\begin{itemize}
\tightlist
\item
  Always clean up (\passthrough{\lstinline!pkill!},
  \passthrough{\lstinline!Stop-Process!}) on both success and failure to
  keep subsequent runs deterministic.
\item
  Redirect server logs to files
  (\passthrough{\lstinline!appium > appium.out \&!}). Publish them when
  the job fails for easier triage (see pipeline's
  \passthrough{\lstinline!publish appium.out!} step).
\end{itemize}

\subsection{4. Device cloud
configuration}\label{device-cloud-configuration}

Device clouds (BrowserStack App Automate, Sauce Labs, Azure-hosted
desktops) require the same capabilities plus authentication tokens:

\begin{lstlisting}
options.AddAdditionalCapability("browserstack.user", Environment.GetEnvironmentVariable("BS_USER"));
options.AddAdditionalCapability("browserstack.key", Environment.GetEnvironmentVariable("BS_KEY"));
options.AddAdditionalCapability("appium:options", new Dictionary<string, object>
{
    ["osVersion"] = "11",
    ["deviceName"] = "Windows 11",
    ["appium:app"] = "bs://<uploaded-app-id>"
});
\end{lstlisting}

Upload your Avalonia app (packaged exe zipped, or macOS
\passthrough{\lstinline!.app!} bundle) via the vendor's CLI before tests
run. On hosted Windows machines, ensure the automation provider exposes
UI Automation trees---some locked-down images disable it.

When targeting clouds, keep these adjustments in fixtures:

\begin{lstlisting}
protected override void ConfigureWin32Options(AppiumOptions options, string? app = null)
{
    if (UseCloud)
    {
        options.AddAdditionalCapability("app", CloudAppId);
        options.AddAdditionalCapability("bstack:options", new { osVersion = "11", sessionName = TestContext.CurrentContext.Test.Name });
    }
    else
    {
        base.ConfigureWin32Options(options, app);
    }
}
\end{lstlisting}

Guard cloud-specific behavior using environment variables so local runs
stay unchanged.

\subsection{5. Managing driver
compatibility}\label{managing-driver-compatibility}

The harness conditionally compiles for Appium 1 vs.~2 via
\passthrough{\lstinline!APPIUM1!}/\passthrough{\lstinline!APPIUM2!}
constants (\passthrough{\lstinline!AppiumDriverEx.cs!}). Checklist:

\begin{itemize}
\tightlist
\item
  Run \passthrough{\lstinline!dotnet test -p:IsRunningAppium2=true!}
  when hitting Appium 2 endpoints. This updates
  \passthrough{\lstinline!DefineConstants!} and switches to the newer
  \passthrough{\lstinline!Appium.WebDriver 5.x!} client.
\item
  Ensure the Appium server version matches the driver: Appium 2 + mac2
  driver expect W3C protocol only.
\item
  WinAppDriver currently supports only Appium 1, so keep a separate
  pipeline lane for Windows if you standardize on Appium 2 for macOS.
\end{itemize}

If you see protocol errors, print the server log
(\passthrough{\lstinline!appium.out!}) and compare capability names.
Appium 2 requires \passthrough{\lstinline!appium:!} prefixes for
vendor-specific entries (already shown in
\passthrough{\lstinline!DefaultAppFixture.ConfigureMacOptions!}).

\subsection{6. Permissions and security
prompts}\label{permissions-and-security-prompts}

Desktop automation breaks when the app lacks accessibility permissions:

\begin{itemize}
\tightlist
\item
  macOS: add the Appium binary, the terminal/agent, and Xcode helper to
  \passthrough{\lstinline!System Settings → Privacy \& Security → Accessibility!}.
  The readme covers the exact steps.
\item
  Windows: disable UAC prompts or run the agent as administrator. If UAC
  prompts appear, automation cannot interact with the foreground until
  dismissed.
\item
  Device clouds: follow provider docs to grant persistent accessibility
  or run under pre-approved automation accounts.
\end{itemize}

Automate these steps where possible---on macOS you can pre-provision a
profile or run a script to enable permissions via
\passthrough{\lstinline!tccutil!}. For Windows, prefer an image with
WinAppDriver pre-installed.

\subsection{7. Logging and diagnostics}\label{logging-and-diagnostics}

Augment your harness to collect evidence:

\begin{itemize}
\tightlist
\item
  Use \passthrough{\lstinline!appium --log-level info --log appium.log!}
  to write structured JSON logs.
\item
  Forward driver logs to test output:
  \passthrough{\lstinline!Session.Manage().Logs.GetLog("driver");!}
  after a failure.
\item
  For WinAppDriver, enable verbose logs via registry
  (\passthrough{\lstinline!HKEY\_LOCAL\_MACHINE\\SOFTWARE\\Microsoft\\WinAppDriver\\ConsoleLogging = 1!}).
\item
  Record video on Windows using the supplied
  \passthrough{\lstinline!record-video.runsettings!} file when executing
  through VSTest (Chapter 42).
\end{itemize}

\subsection{8. Troubleshooting}\label{troubleshooting-7}

\begin{itemize}
\tightlist
\item
  \textbf{\passthrough{\lstinline!SessionNotCreatedException!}} -- Check
  that the app path/bundle exists and the process isn't already running.
  On macOS, run \passthrough{\lstinline!osascript!} cleanup like the
  sample script to delete stale bundles.
\item
  \textbf{\passthrough{\lstinline!Could not find app!}} -- Re-run your
  packaging script; the bundle path changes when switching architectures
  (\passthrough{\lstinline!osx-arm64!}
  vs.~\passthrough{\lstinline!osx-x64!}).
\item
  \textbf{Authentication failures on clouds} -- Ensure credentials are
  injected securely via pipeline secrets; log obfuscated values for
  debugging but never commit them to source.
\item
  \textbf{Driver mismatch} -- Align
  \passthrough{\lstinline!IsRunningAppium2!} with the server version.
  Appium 2 rejects legacy capability names like
  \passthrough{\lstinline!bundleId!} without the
  \passthrough{\lstinline!appium:!} prefix.
\item
  \textbf{Resource leaks} -- Always dispose fixtures, even in skipped
  tests. Wrap \passthrough{\lstinline!Session!} accesses in
  \passthrough{\lstinline!try/finally!} or use
  \passthrough{\lstinline!IAsyncLifetime!} to guarantee cleanup after
  each class.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-11}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Bootstrap script} -- Create cross-platform scripts
  (\passthrough{\lstinline!scripts/run-appium-tests.ps1!} and
  \passthrough{\lstinline!.sh!}) that build your app, start/stop
  automation servers, and invoke \passthrough{\lstinline!dotnet test!}.
  Validate they leave no background processes.
\item
  \textbf{Configurable fixture} -- Extend
  \passthrough{\lstinline!DefaultAppFixture!} to read capabilities from
  JSON (local vs.~cloud). Add tests that assert the chosen configuration
  by inspecting \passthrough{\lstinline!Session.Capabilities!}.
\item
  \textbf{Permission audit} -- Write a checklist or automated probe that
  verifies accessibility permissions before starting tests (e.g.,
  attempt to focus a dummy window and fail fast with instructions).
\item
  \textbf{Driver matrix} -- Run the same smoke suite against Appium 1
  (WinAppDriver) and Appium 2 (mac2) by toggling
  \passthrough{\lstinline!IsRunningAppium2!}. Capture and compare server
  logs to understand protocol differences.
\item
  \textbf{CI integration} -- Add jobs to your pipeline that call your
  bootstrap script on Windows and macOS runners. Upload Appium logs and
  test TRX files as artifacts, confirming cleanup occurs even when tests
  fail.
\end{enumerate}

What's next - Next: \href{Chapter45.md}{Chapter45}

\newpage

\subsection{45. Element discovery, selectors, and
PageObjects}\label{element-discovery-selectors-and-pageobjects}

Goal - Locate Avalonia controls reliably through Appium's accessibility
surface, even when templates or virtualization hide elements. -
Encapsulate selectors and interactions in reusable PageObjects so suites
stay maintainable as the UI grows. - Combine waits, retries, and
platform-aware helpers to avoid brittle tests across Windows, macOS, and
remote hosts.

Why this matters - Avalonia templates can reshape automation trees;
hard-coded XPath falls apart when themes change. - Virtualized lists
only materialize visible items---selectors must cope with dynamic
children. - Cross-platform automation surfaces expose different
attributes; centralizing logic keeps suites portable.

Prerequisites - Chapter 43 for harness fundamentals. - Chapter 44 for
environment setup and driver configuration. - Familiarity with Avalonia
accessibility APIs (\passthrough{\lstinline!AutomationProperties!}).

\subsection{1. Build selectors on accessibility IDs
first}\label{build-selectors-on-accessibility-ids-first}

Avalonia maps
\passthrough{\lstinline!AutomationProperties.AutomationId!} and control
\passthrough{\lstinline!Name!} directly into Appium selectors. Tests
such as \passthrough{\lstinline!AutomationTests.AutomationId!} rely on
\passthrough{\lstinline!FindElementByAccessibilityId!}
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/AutomationTests.cs:12!}).
Adopt this priority order:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \passthrough{\lstinline!FindElementByAccessibilityId!} for IDs you
  own.
\item
  \passthrough{\lstinline!FindElementByName!} for localized labels
  (\passthrough{\lstinline!ElementExtensions.GetName!}) or menu items.
\item
  \passthrough{\lstinline!FindElementByXPath!} as a last resort for
  structure-dependent lookups (e.g., tray icons on Windows).
\end{enumerate}

Annotate controls in XAML with both \passthrough{\lstinline!x:Name!} and
\passthrough{\lstinline!AutomationProperties.AutomationId!} to keep
selectors stable. For templated controls, expose IDs through template
parts so they enter the automation tree.

\subsection{2. Reuse PageObject-style
wrappers}\label{reuse-pageobject-style-wrappers}

Avalonia's Appium harness centralizes navigation in
\passthrough{\lstinline!TestBase!}. Each test class inherits and passes
the page name, letting \passthrough{\lstinline!TestBase!} click through
the pager with retries
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TestBase.cs:6!}).
Mirror this structure:

\begin{lstlisting}
public abstract class CatalogPage : TestBase
{
    protected CatalogPage(DefaultAppFixture fixture, string pageName)
        : base(fixture, pageName) { }

    protected AppiumWebElement Control(string automationId)
        => Session.FindElementByAccessibilityId(automationId);
}

public sealed class WindowPage : CatalogPage
{
    public WindowPage(DefaultAppFixture fixture) : base(fixture, "Window") { }

    public AppiumWebElement WindowState => Control("CurrentWindowState");
    public void SelectState(string id) => Control(id).SendClick();
}
\end{lstlisting}

Wrap gestures (click, double-click, modifier shortcuts) in extension
methods rather than duplicating \passthrough{\lstinline!Actions!}
blocks. Avalonia's \passthrough{\lstinline!ElementExtensions.SendClick!}
simulates physical clicks to accommodate controls that resist
\passthrough{\lstinline!element.Click()!}
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:235!}).

\subsection{3. Handle virtualization and dynamic
children}\label{handle-virtualization-and-dynamic-children}

Virtualized lists only generate visible items.
\passthrough{\lstinline!ListBoxTests.Is\_Virtualized!} counts visual
children returned by \passthrough{\lstinline!GetChildren!} to prove
virtualization is active
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ListBoxTests.cs:52!}).

Techniques: - Scroll or page through lists via keyboard
(\passthrough{\lstinline!Keys.PageDown!}) or pointer wheel to
materialize items lazily. - Query container children each time rather
than caching stale \passthrough{\lstinline!AppiumWebElement!}
references. - Use sentinel elements (e.g., ``Loading\ldots'' items) to
detect asynchronous population and wait before asserting.

\begin{lstlisting}
public IReadOnlyList<AppiumWebElement> VisibleRows()
    => Session.FindElementByAccessibilityId("BasicListBox").GetChildren();
\end{lstlisting}

Combine with helper waits to poll until a desired item appears instead
of assuming immediate materialization.

\subsection{4. Account for platform differences in
selectors}\label{account-for-platform-differences-in-selectors}

Avalonia ships cross-platform helpers that encapsulate OS-specific
attribute quirks:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!ElementExtensions.GetComboBoxValue!} chooses
  \passthrough{\lstinline!Text!} on Windows and
  \passthrough{\lstinline!value!} on macOS
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:34!}).
\item
  \passthrough{\lstinline!GetCurrentSingleWindow!} navigates macOS's
  duplicated window hierarchy by using a parent XPath
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:60!}).
\item
  \passthrough{\lstinline!TrayIconTests!} opens nested sessions to
  access Windows taskbar automation IDs, while macOS uses generic status
  item XPath
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TrayIconTests.cs:13!}).
\end{itemize}

Keep such logic in dedicated helpers; PageObjects should consume a
single API regardless of platform. Provide capabilities (e.g.,
\passthrough{\lstinline!UseOverlayPopups!}) through fixtures so tests
stay declarative
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/OverlayPopupsAppFixture.cs:4!}).

\subsection{5. Synchronize with the UI
deliberately}\label{synchronize-with-the-ui-deliberately}

Animations and popups require waits. The harness uses:

\begin{itemize}
\tightlist
\item
  Retries in \passthrough{\lstinline!TestBase!} navigation with
  \passthrough{\lstinline!Thread.Sleep(1000)!} between attempts to allow
  fullscreen transitions
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TestBase.cs:12!}).
\item
  Looped polling in
  \passthrough{\lstinline!ElementExtensions.OpenWindowWithClick!} to
  detect new window handles or child windows, retrying up to ten times
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:86!}).
\item
  Explicit sleeps after context menu or tray interactions when platform
  APIs lag
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TrayIconTests.cs:33!}).
\end{itemize}

Upgrade these patterns using \passthrough{\lstinline!WebDriverWait!} to
poll until predicates succeed:

\begin{lstlisting}
public static AppiumWebElement WaitForElement(AppiumDriver session, By by, TimeSpan timeout)
{
    return new WebDriverWait(session, timeout).Until(driver =>
    {
        var element = driver.FindElement(by);
        return element.Displayed ? element : null;
    });
}
\end{lstlisting}

Centralize waits so adjustments (timeouts, polling intervals) propagate
across the suite.

\subsection{6. Model complex selectors as
queries}\label{model-complex-selectors-as-queries}

Large UIs often require multi-step discovery:

\begin{itemize}
\tightlist
\item
  Menus: \passthrough{\lstinline!MenuTests!} clicks through root, child,
  and grandchild items using accessibility IDs and names
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/MenuTests.cs:25!}).
  Wrap this into helper methods like
  \passthrough{\lstinline!OpenMenu("Root", "Child", "Grandchild")!}.
\item
  Tray icons: \passthrough{\lstinline!GetTrayIconButton!} first attempts
  to find the icon, then expands the overflow flyout if absent, handling
  whitespace quirks in names
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TrayIconTests.cs:62!}).
\item
  Windows: \passthrough{\lstinline!OpenWindowWithClick!} tracks new
  handles or titles, accommodating macOS fullscreen behavior by ignoring
  untitled intermediate nodes
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:200!}).
\end{itemize}

Treat these as queries, not static selectors. Accept parameters (icon
name, menu path) and apply consistent error messaging when assertions
fail.

\subsection{7. Use test attributes to scope
runs}\label{use-test-attributes-to-scope-runs}

Selectors often depend on platform capabilities. Decorate tests with
\passthrough{\lstinline![PlatformFact]!} /
\passthrough{\lstinline![PlatformTheory]!} to skip unsupported scenarios
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PlatformFactAttribute.cs:7!}).
This prevents PageObjects from needing conditionals inside every method
and ensures pipelines stay green when features diverge.

Group tests requiring special fixtures (e.g., overlay popups) via xUnit
collections
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/CollectionDefinitions.cs:4!}).
PageObjects then request the appropriate fixture type through
constructor injection.

\subsection{8. Troubleshooting
selectors}\label{troubleshooting-selectors}

\begin{itemize}
\tightlist
\item
  \textbf{Elements disappear mid-test} -- virtualization recycled them;
  retrieve fresh references after scrolling.
\item
  \textbf{Click no-ops} -- switch to \passthrough{\lstinline!SendClick!}
  actions; some controls ignore
  \passthrough{\lstinline!element.Click()!} on macOS.
\item
  \textbf{Wrong element chosen} -- qualify by automation ID before
  falling back to names. Names may change with localization.
\item
  \textbf{Popups not found} -- ensure you expanded parent menus or
  overflow trays first. Add logging describing the hierarchy you
  traversed for easier debugging.
\item
  \textbf{Timeouts} -- adopt structured waits instead of arbitrary
  sleeps; log the search strategy (selector type, fallback attempts) on
  failure.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-12}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{PageObject refactor} -- Extract a PageObject for a complex
  page (e.g., ComboBox) that exposes strongly-typed actions and returns
  typed results (\passthrough{\lstinline!GetSelectedValue!}). Replace
  direct selector usage in tests.
\item
  \textbf{Selector fallback} -- Implement a helper that tries
  \passthrough{\lstinline!AutomationId!}, then
  \passthrough{\lstinline!Name!}, then a custom XPath, logging each
  attempt. Use it to locate menu items with localized labels.
\item
  \textbf{Virtualized scrolling} -- Write a test that scrolls through a
  long \passthrough{\lstinline!ListBox!}, verifying virtualization by
  checking \passthrough{\lstinline!GetChildren().Count!} stays below a
  threshold while confirming a distant item becomes Selected.
\item
  \textbf{Wait utility} -- Replace
  \passthrough{\lstinline!Thread.Sleep!} in one test with a reusable
  \passthrough{\lstinline!WaitFor!} method leveraging
  \passthrough{\lstinline!WebDriverWait!}. Confirm the test still passes
  under slower animations by injecting artificial delays.
\item
  \textbf{Cross-platform assertions} -- Add assertions that rely on
  windows or tray icons, guarding them with
  \passthrough{\lstinline![PlatformFact]!}. Implement helper methods
  that throw informative exceptions when run on unsupported platforms.
\end{enumerate}

What's next - Next: \href{Chapter46.md}{Chapter46}

\newpage

\subsection{46. Cross-platform scenarios and advanced
gestures}\label{cross-platform-scenarios-and-advanced-gestures}

Goal - Exercise Avalonia apps under platform-specific shells---window
chrome, tray icons, menus---without duplicating logic per OS. - Drive
complex pointer and keyboard gestures (drag, multi-click, context tap)
using Appium actions that map correctly on Windows and macOS. - Validate
multi-monitor layouts, fullscreen transitions, and system integrations
while keeping selectors and waits resilient.

Why this matters - Desktop affordances behave differently across Win32
and macOS accessibility stacks; tests must adapt or risk false
negatives. - Advanced gestures rely on low-level pointer semantics that
Appium exposes inconsistently across drivers. - Cross-platform
consistency is a core Avalonia selling point---automated verification
keeps regressions from sneaking in.

Prerequisites - Chapter 43 for the foundational Appium harness. -
Chapter 45 for selector patterns and PageObject design. - Familiarity
with Avalonia windowing APIs (Chapters 12 and 18).

\subsection{1. Split platform-specific coverage with fixtures and
attributes}\label{split-platform-specific-coverage-with-fixtures-and-attributes}

\passthrough{\lstinline!PlatformFactAttribute!} and
\passthrough{\lstinline!PlatformTheoryAttribute!} skip tests on
unsupported OSes
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PlatformFactAttribute.cs:7!}).
Use them to branch behavior cleanly:

\begin{lstlisting}
[PlatformFact(TestPlatforms.MacOS)]
public void ThickTitleBar_Drag_Reports_Moves() { ... }
\end{lstlisting}

Group tests into collections bound to fixtures that configure
capabilities. For example, \passthrough{\lstinline!DefaultAppFixture!}
launches the stock ControlCatalog, while
\passthrough{\lstinline!OverlayPopupsAppFixture!} adds
\passthrough{\lstinline!--overlayPopups!} arguments to highlight overlay
behavior
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/OverlayPopupsAppFixture.cs:4!}).

\subsection{2. Window management across
platforms}\label{window-management-across-platforms}

\subsubsection{Windows}\label{windows-5}

\passthrough{\lstinline!WindowTests!} (see
\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/WindowTests.cs!})
verifies state transitions (Normal, Maximized, FullScreen), docked
windows, and mode toggles. It uses \passthrough{\lstinline!SendClick!}
on combo entries because native \passthrough{\lstinline!Click()!} is
unreliable on certain automation peers
(\passthrough{\lstinline!ElementExtensions.SendClick!},
\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:235!}).

\subsubsection{macOS}\label{macos-5}

\passthrough{\lstinline!WindowTests\_MacOS!} covers thick title bars,
system chrome toggles, and fullscreen animations
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/WindowTests\_MacOS.cs:19!}).
Tests depend on applying window decoration parameters via checkboxes
exposed in the demo app.

\textbf{Tips} - Normalize state by calling the same helper at test end;
\passthrough{\lstinline!PointerTests\_MacOS.Dispose!} resets window
parameters before exiting
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PointerTests\_MacOS.cs:119!}).
- When switching states that trigger animations, add intentional waits
or \passthrough{\lstinline!WebDriverWait!} polling before grabbing the
next snapshot.

\subsection{3. Multi-window flows and
dialogs}\label{multi-window-flows-and-dialogs}

Use \passthrough{\lstinline!ElementExtensions.OpenWindowWithClick!} to
encapsulate the logic of detecting new windows. It differentiates
between top-level handles (Windows) and child windows (macOS) and
returns an \passthrough{\lstinline!IDisposable!} that closes the window
on teardown
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ElementExtensions.cs:86!}).

\begin{lstlisting}
using (Control("OpenModal").OpenWindowWithClick())
{
    // Assert modal state
}
\end{lstlisting}

\passthrough{\lstinline!PointerTests.Pointer\_Capture\_Is\_Released\_When\_Showing\_Dialog!}
relies on this helper to ensure capture is cleared when a dialog opens
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PointerTests.cs:13!}).

\subsection{4. Tray icons and system
menus}\label{tray-icons-and-system-menus}

System integration differs dramatically:

\begin{itemize}
\tightlist
\item
  \textbf{Windows}: \passthrough{\lstinline!TrayIconTests!} locates the
  shell tray window, handles overflow flyouts, and accounts for
  whitespace-prefixed icon names
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TrayIconTests.cs:62!}).
  It also opens a secondary ``Root'' session that targets the desktop to
  access the taskbar.
\item
  \textbf{macOS}: tray icons appear as
  \passthrough{\lstinline!XCUIElementTypeStatusItem!} elements and menus
  are retrieved via
  \passthrough{\lstinline!//XCUIElementTypeStatusItem/XCUIElementTypeMenu!}.
\end{itemize}

Wrap this logic in helper methods and hide it behind PageObjects so
tests merely call \passthrough{\lstinline!TrayIcon().ShowMenu()!} and
assert resulting automation flags.

\subsection{5. Advanced pointer
gestures}\label{advanced-pointer-gestures}

\subsubsection{Gesture taxonomy}\label{gesture-taxonomy}

\passthrough{\lstinline!GestureTests!} demonstrates how to script taps,
double-taps, drags, and right-clicks using Actions API
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/GestureTests.cs:16!}).
Examples:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!new Actions(Session).DoubleClick(element).Perform();!}
\item
  Multi-step pointer sequences using
  \passthrough{\lstinline!PointerInputDevice!} for macOS-specific
  right-tap semantics
  (\passthrough{\lstinline!GestureTests.RightTapped\_Is\_Raised\_2!},
  line 139).
\end{itemize}

\subsubsection{Title bar drags on macOS}\label{title-bar-drags-on-macos}

\passthrough{\lstinline!PointerTests\_MacOS.OSXThickTitleBar\_Pointer\_Events\_Continue\_Outside\_Window\_During\_Drag!}
verifies pointer capture beyond window bounds while dragging the title
bar
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PointerTests\_MacOS.cs:17!}).
It uses \passthrough{\lstinline!DragAndDropToOffset!} and reads
automation counters from the secondary window.

\textbf{Practice} - Always move the pointer onto the target before
pressing:
\passthrough{\lstinline!new Actions(Session).MoveToElement(titleAreaControl).Perform();!}
- After custom pointer sequences, release buttons even when assertions
fail to leave the driver in a consistent state
(\passthrough{\lstinline!GestureTests.DoubleTapped\_Is\_Raised\_2!},
line 70).

\subsection{6. Keyboard modifiers and selection
semantics}\label{keyboard-modifiers-and-selection-semantics}

\passthrough{\lstinline!ListBoxTests!} executes Shift-range selection
and marks Ctrl-click tests as skipped due to driver limitations
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ListBoxTests.cs:36!}).
Document such constraints in your suite and apply
\passthrough{\lstinline![Fact(Skip=...)]!} with explanations for future
debugging.

\passthrough{\lstinline!ComboBoxTests!} rely on keyboard shortcuts
(\passthrough{\lstinline!Keys.LeftAlt + Keys.ArrowDown!}) and ensure
wrapping behavior toggles via checkboxes before assertion
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ComboBoxTests.cs:41!}).
Keep these interactions in PageObjects so tests remain expressive
(\passthrough{\lstinline!ComboBoxPage.OpenDropdown()!} vs.~inline key
sequences).

\subsection{7. Multi-monitor and screen
awareness}\label{multi-monitor-and-screen-awareness}

\passthrough{\lstinline!ScreenTests!} pulls current monitor data and
asserts invariants around bounds, work area, and scaling
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ScreenTests.cs:12!}).
Use similar verifications when you need to assert window placement on
multi-monitor setups.

For drag-to-monitor flows, record starting and ending positions via text
fields surfaced in the app, then compare after applying pointer moves.
Ensure tests reset state (move window back) when done to avoid cascading
failures.

\subsection{8. Troubleshooting cross-platform
gestures}\label{troubleshooting-cross-platform-gestures}

\begin{itemize}
\tightlist
\item
  \textbf{Stuck pointer buttons} -- Ensure
  \passthrough{\lstinline!PointerInputDevice!} sequences end with
  \passthrough{\lstinline!PointerUp!}. If a test fails mid-action, add
  \passthrough{\lstinline!try/finally!} to release buttons.
\item
  \textbf{Unexpected double-taps} -- As shown in
  \passthrough{\lstinline!PointerTests\_MacOS.OSXThickTitleBar\_Single\_Click\_Does\_Not\_Generate\_DoubleTapped\_Event!},
  add counters to your app to observe actual events and assert on them
  instead of stateful UI side effects.
\item
  \textbf{Tray icon discovery failures} -- Expand overflow menus
  explicitly on Windows; on macOS, allow for menu creation delays by
  polling after clicking the status item.
\item
  \textbf{Localization differences} -- Names of system menu items vary;
  rely on automation IDs when possible or provide fallback selectors.
\item
  \textbf{Driver limitations} -- Document known issues (e.g.,
  WinAppDriver ctrl-click) with skip reasons so team members know why
  coverage is missing.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-13}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Window choreography} -- Script a test that opens a secondary
  window, drags it to a new position, toggles fullscreen, and returns to
  normal. Assert pointer capture counts using automation counters
  exposed in the sample.
\item
  \textbf{Tray icon helper} -- Build a PageObject with
  \passthrough{\lstinline!ShowMenu()!} and
  \passthrough{\lstinline!ClickMenuItem(string text)!} methods that
  handle Windows overflow and macOS status items automatically. Use it
  to verify a menu command toggles a checkbox in the main window.
\item
  \textbf{Gesture pipeline} -- Implement a helper that performs a
  parameterized pointer gesture
  (\passthrough{\lstinline!PointerSequence!} builder). Use it to test
  tap, double-tap, drag, and right-tap on the same control, asserting
  the logged gesture text each time.
\item
  \textbf{Multi-monitor regression} -- Extend the sample app to surface
  target screen IDs. Write a test that moves a window across monitors
  and verifies the reported screen changes, resetting to the primary
  display afterward.
\item
  \textbf{Platform matrix} -- Create a theory that runs the same smoke
  scenario across Windows/Mac fixtures using
  \passthrough{\lstinline![PlatformTheory]!}. Capture driver logs on
  failure and assert the test records which platform executed for easier
  triage.
\end{enumerate}

What's next - Next: \href{Chapter47.md}{Chapter47}

\newpage

\subsection{47. Stabilizing suites, reporting, and best
practices}\label{stabilizing-suites-reporting-and-best-practices}

Goal - Keep Appium-based Avalonia suites reliable on developer machines
and CI by isolating flakiness causes. - Capture meaningful diagnostics
(logs, videos, artifacts) that accelerate investigation when tests fail.
- Scale coverage with retry, quarantine, and reporting strategies that
protect signal quality.

Why this matters - Cross-platform automation is sensitive to timing,
focus, and OS updates---without discipline the suite becomes noisy. -
Fast feedback requires structured artifacts; otherwise failures devolve
into manual repro marathons. - Stakeholders need trend visibility: which
areas flake, which platforms lag, and where to invest engineering
effort.

Prerequisites - Chapter 43--46 for harness setup, selectors, and
advanced scenarios. - Chapter 42 for CI pipeline integration basics.

\subsection{1. Triage flakiness with
classification}\label{triage-flakiness-with-classification}

Begin every investigation by tagging failures: - \textbf{Timing}
(animations, virtualization) -- resolved with better waits
(\passthrough{\lstinline!WebDriverWait!}, dispatcher polling). -
\textbf{Environment} (permissions, display scaling) -- addressed by
setup scripts or platform skips. - \textbf{Driver quirks} (WinAppDriver
Ctrl-click) -- documented with
\passthrough{\lstinline![Fact(Skip="...")]!} like
\passthrough{\lstinline!ListBoxTests.Can\_Select\_Items\_By\_Ctrl\_Clicking!}
(\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/ListBoxTests.cs:36!}).
- \textbf{App bugs} -- file issues with automation evidence attached.

Maintain a living flake log referencing test name, platform, root cause,
and remediation. Automate updates by pushing annotations into test
reporters (Azure Pipelines, GitHub Actions).

\subsection{2. Quarantine and retries without hiding real
bugs}\label{quarantine-and-retries-without-hiding-real-bugs}

Retries buy time but can mask regressions. Strategies:

\begin{itemize}
\tightlist
\item
  Implement targeted retries via xUnit ordering or
  \passthrough{\lstinline![RetryFact]!} equivalents. Avalonia currently
  handles retries manually by skipping unstable tests with reason
  strings (e.g.,
  \passthrough{\lstinline!TrayIconTests.Should\_Handle\_Left\_Click!} is
  marked
  \passthrough{\lstinline![PlatformFact(..., Skip = "Flaky test")]!},
  \passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/TrayIconTests.cs:29!}).
\item
  Prefer \textbf{automatic quarantine}: tag flaky tests and run them in
  a separate lane, keeping main suites failure-free. Example: use xUnit
  traits or custom attributes to filter
  (\passthrough{\lstinline'dotnet test --filter "TestCategory!=Quarantine"'}).
\item
  Combine retries with diagnostics: on the last retry failure, dump
  Appium logs and take screenshots before failing.
\end{itemize}

\subsection{3. Capture rich diagnostics}\label{capture-rich-diagnostics}

For every critical failure, collect:

\begin{itemize}
\tightlist
\item
  \textbf{Appium server logs} (\passthrough{\lstinline!appium.out!} in
  the macOS script) and publish them via CI artifacts
  (\passthrough{\lstinline!external/Avalonia/azure-pipelines-integrationtests.yml:27!}).
\item
  \textbf{Driver logs}:
  \passthrough{\lstinline!Session.Manage().Logs.GetLog("driver")!} after
  catch blocks to capture protocol exchanges.
\item
  \textbf{Screenshots}: call
  \passthrough{\lstinline!Session.GetScreenshot().SaveAsFile(...)!} on
  failure; stash path in test output.
\item
  \textbf{Videos}: on Windows, VSTest runsettings
  \passthrough{\lstinline!record-video.runsettings!} records screen
  output
  (\passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/record-video.runsettings!}).
\item
  \textbf{Headless imagery}: pair Appium runs with headless captures
  (Chapter 40) to highlight visual state at failure.
\end{itemize}

Build helper methods so tests simply call
\passthrough{\lstinline!ArtifactCollector.Capture(context);!}. Ensure
cleanup occurs even when assertions throw (use
\passthrough{\lstinline!try/finally!}).

\subsection{4. Standardize waiting and polling
policies}\label{standardize-waiting-and-polling-policies}

Enforce consistent defaults:

\begin{itemize}
\tightlist
\item
  Set a global implicit wait (short, e.g., 1s) and rely on explicit
  waits for complex states. Too-long implicit waits slow down failure
  discovery.
\item
  Provide \passthrough{\lstinline!WaitForElement!} and
  \passthrough{\lstinline!WaitForCondition!} helpers with logging. Use
  them instead of ad-hoc \passthrough{\lstinline!Thread.Sleep!}.
\item
  For dispatcher-driven state, expose instrumentation in the app (text
  fields reporting counters like \passthrough{\lstinline!GetMoveCount!}
  in \passthrough{\lstinline!PointerTests\_MacOS!},
  \passthrough{\lstinline!external/Avalonia/tests/Avalonia.IntegrationTests.Appium/PointerTests\_MacOS.cs:86!}).
  Poll those values to assert behavior deterministically.
\end{itemize}

Document wait policies in CONTRIBUTING guidelines to onboard new
contributors.

\subsection{5. Structure reports for quick
scanning}\label{structure-reports-for-quick-scanning}

\subsubsection{Azure Pipelines / GitHub
Actions}\label{azure-pipelines-github-actions}

\begin{itemize}
\tightlist
\item
  Publish TRX results with names that encode platform, driver, and suite
  (e.g., \passthrough{\lstinline!Appium-macOS-Appium2.trx!}).
\item
  Upload log bundles (\passthrough{\lstinline!logs/appium.log!},
  \passthrough{\lstinline!screenshots/*.png!}). Provide clickable links
  in summary markdown.
\item
  Add summary steps that print failing test names grouped by category
  (flaky, new regression, quarantined).
\end{itemize}

\subsubsection{Local development}\label{local-development}

\begin{itemize}
\tightlist
\item
  Provide a script (Chapter 44) that mirrors CI output directories so
  developers can inspect logs locally.
\item
  Encourage use of
  \passthrough{\lstinline!dotnet test --logger "trx;LogFileName=local.trx"!}
  + \passthrough{\lstinline!reportgenerator!} for HTML summaries.
\end{itemize}

\subsection{6. Enforce coding standards in
tests}\label{enforce-coding-standards-in-tests}

\begin{itemize}
\tightlist
\item
  \textbf{Selectors}: centralize in PageObjects. No raw XPath in tests.
\item
  \textbf{Waits}: ban \passthrough{\lstinline!Thread.Sleep!} in code
  review; insist on helper usage.
\item
  \textbf{Cleanup}: always dispose windows/sessions
  (\passthrough{\lstinline!using!} pattern with
  \passthrough{\lstinline!OpenWindowWithClick!}). Review tests that skip
  cleanup (they often cause downstream failures).
\item
  \textbf{Platform gating}: pair every platform-specific assertion with
  \passthrough{\lstinline![PlatformFact]!}/\passthrough{\lstinline![PlatformTheory]!}
  to avoid accidental runs on unsupported OSes.
\end{itemize}

Add lint tooling (Roslyn analyzers or custom scripts) to scan for banned
patterns (e.g., \passthrough{\lstinline!Thread.Sleep(!}) in test
projects.

\subsection{7. Monitor and alert on
trends}\label{monitor-and-alert-on-trends}

\begin{itemize}
\tightlist
\item
  Track success rate per platform, per suite. Configure dashboards
  (Azure Analytics, GitHub Insights) to display pass percentages over
  time.
\item
  Emit custom metrics (e.g., number of retries) to a time-series store.
  If retries spike, alert engineers before builds start failing.
\item
  Rotate flake triage duty; publish weekly summaries identifying top
  offenders and assigned owners.
\end{itemize}

\subsection{8. Troubleshooting
checklist}\label{troubleshooting-checklist-2}

\begin{itemize}
\tightlist
\item
  \textbf{Frequent timeouts} -- confirm Appium server stability, check
  CPU usage on agents, review wait durations.
\item
  \textbf{Intermittent focus issues} -- ensure tests foreground windows
  (\passthrough{\lstinline!SetForegroundWindow!} on Windows) or click
  background-free zones before interacting.
\item
  \textbf{Driver crashes} -- update Appium/WinAppDriver, capture crash
  dumps, and reference known issues (e.g., mac2 driver close-session
  crash handled in \passthrough{\lstinline!DefaultAppFixture.Dispose!}).
\item
  \textbf{Artifacts missing} -- verify CI scripts always run artifact
  upload steps with \passthrough{\lstinline!condition: always()!}.
\item
  \textbf{Quarantine drift} -- periodic reviews to reinstate fixed
  tests; failing to do so erodes coverage.
\end{itemize}

\subsection{Practice lab}\label{practice-lab-14}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Artifact collector} -- Implement a helper that captures Appium
  logs, driver logs, screenshots, and optional videos when a test fails.
  Wire it into an xUnit \passthrough{\lstinline!IAsyncLifetime!} fixture
  so it runs automatically.
\item
  \textbf{Wait audit} -- Write an analyzer or script that flags
  \passthrough{\lstinline!Thread.Sleep!} usages in the Appium test
  project. Replace them with explicit waits and document the change.
\item
  \textbf{Quarantine lane} -- Configure your CI pipeline with two jobs:
  stable and quarantine
  (\passthrough{\lstinline'dotnet test --filter "Category!=Quarantine"'}
  vs.~\passthrough{\lstinline!Category=Quarantine!}). Move a flaky test
  into the quarantine lane and verify reporting highlights it
  separately.
\item
  \textbf{Trend dashboard} -- Export TRX results for the past week and
  build a simple dashboard (Power BI, Grafana) showing pass/fail counts
  per platform. Identify top flaky tests.
\item
  \textbf{Regression template} -- Create an issue template that captures
  test name, platform, driver version, app commit, and links to
  artifacts. Use it when logging Appium regressions to standardize
  triage information.
\end{enumerate}

What's next - Return to \href{../Index.md}{Index} for appendices,
publishing checklists, or future updates.
